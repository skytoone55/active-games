This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules, .next, .git, package-lock.json, yarn.lock, backups, *.tsbuildinfo, *.sql, *.log, scripts, documents, src/i18n/locales/fr.json, src/i18n/locales/he.json, src/lib/supabase/types.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    backup.yml
public/
  images/
    games/
      arena-popup.jpg
      arena-thumb.jpg
      basketball-popup.jpg
      basketball-thumb.jpg
      climbing-popup.jpg
      climbing-thumb.jpg
      control-popup.png
      control-thumb.png
      flash-popup.jpg
      flash-thumb.jpg
      grid-popup.jpg
      grid-thumb.jpg
      hide-popup.jpg
      hide-thumb.png
      laser-popup.jpg
      laser-thumb.jpg
      push-popup.jpg
      push-thumb.jpg
    contact-image.png
    logo_laser_city.png
    logo-activegames.png
    logo.png
  videos/
    arena.mp4
    basketball.mp4
    climb.mp4
    climbing.mp4
    control.mp4
    flash.mp4
    grid.mp4
    Grille-active-games.mp4
    hide.mp4
    laser.mp4
    push.mp4
    Video-sans-titre-‐-Realisee-avec-Clipchamp-2.mp4
    Video-sans-titre-‐-Realisee-avec-Clipchamp.mp4
src/
  app/
    admin/
      clara/
        settings/
          page.tsx
      clients/
        components/
          ClientModal.tsx
          MergeContactsModal.tsx
        page.tsx
      components/
        AccountingModal.tsx
        AdminHeader.tsx
        AgendaSearch.tsx
        AgendaStats.tsx
        BookingModal.tsx
        BranchSelector.tsx
        ClientOnly.tsx
        ConfirmationModal.tsx
        ContactDetailsModal.tsx
        ContactFieldAutocomplete.tsx
        ContactSearch.tsx
        CustomSelect.tsx
        DateNavigation.tsx
        GridSettingsPopup.tsx
        index.ts
        OrderDetailModalWrapper.tsx
        PaymentModal.tsx
        PermissionToast.tsx
        SettingsModal.tsx
      data-management/
        page.tsx
      emails/
        components/
          EmailsTable.tsx
        page.tsx
      login/
        page.tsx
      logs/
        components/
          LogsTable.tsx
        page.tsx
      orders/
        components/
          OrderDetailModal.tsx
          OrdersTable.tsx
        page.tsx
      permissions/
        components/
          PermissionsTable.tsx
        page.tsx
      roles/
        components/
          RoleModal.tsx
          RolesTable.tsx
        page.tsx
      settings/
        components/
          CredentialsSection.tsx
          EmailTemplatesSection.tsx
          ICountCatalogSection.tsx
          MaintenanceSection.tsx
          TemplatesSection.tsx
          TermsConditionsSection.tsx
        page.tsx
      statistics/
        page.tsx
      users/
        components/
          CreateUserModal.tsx
          EditSelfModal.tsx
          EditUserModal.tsx
          UsersTable.tsx
        page.tsx
      layout.tsx
      page.tsx
    api/
      admin/
        backfill-totals/
          route.ts
        clara/
          conversations/
            route.ts
        data-management/
          counts/
            route.ts
          delete/
            route.ts
        statistics/
          ask/
            route.ts
          route.ts
        users/
          [id]/
            route.ts
          route.ts
      auth/
        log/
          route.ts
      bookings/
        [id]/
          route.ts
        route.ts
      branches/
        route.ts
      cgv/
        [token]/
          route.ts
      contact/
        route.ts
      contacts/
        [id]/
          bookings/
            route.ts
          stats/
            route.ts
          route.ts
        route.ts
      cron/
        backup/
          route.ts
        cgv-reminders/
          route.ts
        check-email-status/
          route.ts
      debug/
        settings/
          route.ts
      email-templates/
        [id]/
          route.ts
        route.ts
      emails/
        [id]/
          route.ts
        route.ts
      icount-event-formulas/
        [id]/
          route.ts
        route.ts
      icount-formulas/
        [id]/
          route.ts
        route.ts
      icount-products/
        [id]/
          route.ts
        sync/
          route.ts
        route.ts
      icount-rooms/
        [id]/
          route.ts
        route.ts
      logs/
        route.ts
      orders/
        [id]/
          authorize-card/
            route.ts
          close/
            route.ts
          payment/
            route.ts
          preauth/
            route.ts
          refund/
            route.ts
          resend-cgv/
            route.ts
          resend-email/
            route.ts
          send-invoice/
            route.ts
          route.ts
        route.ts
      payment-credentials/
        test/
          route.ts
        route.ts
      payments/
        test-connection/
          route.ts
      permissions/
        route.ts
      public/
        calculate-deposit/
          route.ts
        pay-deposit/
          route.ts
      roles/
        [id]/
          route.ts
        route.ts
      terms/
        route.ts
      webhooks/
        brevo/
          route.ts
    cgv/
      [token]/
        page.tsx
    reservation/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    Clara/
      ClaraAssistant.tsx
      ClaraButton.tsx
      ClaraProvider.tsx
      index.ts
    BranchesSection.tsx
    ConceptSection.tsx
    ContactSection.tsx
    ErrorBoundary.tsx
    ErrorBoundaryWrapper.tsx
    Footer.tsx
    FranchiseSection.tsx
    GamesSection.tsx
    Header.tsx
    HeroSection.tsx
    index.ts
    PricingSection.tsx
    WhatsAppButton.tsx
    WhyChooseUsSection.tsx
  contexts/
    LanguageContext.tsx
  hooks/
    index.ts
    useAuth.ts
    useBookings.ts
    useBranches.ts
    useContacts.ts
    useEmails.ts
    useEmailTemplates.ts
    useInactivityTimeout.ts
    useLaserRooms.ts
    useLogs.ts
    useOrders.ts
    usePermissions.ts
    usePricingData.ts
    useRealtimeSubscription.ts
    useRoles.ts
    useSessionPersistence.ts
    useUserPermissions.ts
    useUsers.ts
  i18n/
    locales/
      en.json
    index.ts
  lib/
    clara/
      supabase-schema.ts
    payment-provider/
      icount/
        client.ts
        clients.ts
        credit-card.ts
        documents.ts
        index.ts
        items.ts
      index.ts
      types.ts
    supabase/
      client.ts
      index.ts
      server.ts
      service-role.ts
    activity-logger.ts
    booking-validation.ts
    cache.ts
    dates.ts
    email-sender.ts
    icount-documents.ts
    icount-sync.ts
    laser-allocation.ts
    permissions.ts
    price-calculator.ts
    reservations.ts
    session-builder.ts
    validation.ts
supabase/
  .temp/
    cli-latest
    gotrue-version
    pooler-url
    postgres-version
    project-ref
    rest-version
    storage-migration
    storage-version
.env.example
.gitignore
conditions.txt
next-env.d.ts
next.config.ts
package.json
postcss.config.mjs
RAPPORT_SAUVEGARDE_SIMPLE.md
RAPPORT_SAUVEGARDE.md
README.md
tailwind.config.ts
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/admin/clients/components/MergeContactsModal.tsx">
'use client'

import { useState } from 'react'
import { X, Loader2, User, Phone, Mail, AlertTriangle, Check } from 'lucide-react'
import { useContacts, type UpdateContactData } from '@/hooks/useContacts'
import type { Contact, BookingContactUpdate } from '@/lib/supabase/types'

type ContactField = 'first_name' | 'last_name' | 'phone' | 'email' | 'notes_client'
import { getClient } from '@/lib/supabase/client'

interface MergeContactsModalProps {
  isOpen: boolean
  onClose: () => void
  contacts: Contact[]
  onMergeComplete: () => void
  branchId: string
  isDark: boolean
}

export function MergeContactsModal({
  isOpen,
  onClose,
  contacts,
  onMergeComplete,
  branchId,
  isDark,
}: MergeContactsModalProps) {
  const { updateContact, archiveContact } = useContacts(branchId)
  const [selectedFields, setSelectedFields] = useState<Record<string, string>>({})
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  if (!isOpen || contacts.length < 2) return null

  // Le premier contact sera le contact principal (celui qui sera conservé)
  const primaryContact = contacts[0]
  const duplicateContacts = contacts.slice(1)

  // Initialiser les champs sélectionnés avec les valeurs du contact principal
  const initializeFields = () => {
    const fields: Record<string, string> = {}
    fields.first_name = primaryContact.id
    fields.last_name = primaryContact.id
    fields.phone = primaryContact.id
    fields.email = primaryContact.email ? primaryContact.id : (duplicateContacts.find(c => c.email)?.id || primaryContact.id)
    fields.notes_client = primaryContact.notes_client ? primaryContact.id : (duplicateContacts.find(c => c.notes_client)?.id || primaryContact.id)
    setSelectedFields(fields)
  }

  if (Object.keys(selectedFields).length === 0) {
    initializeFields()
  }

  const handleFieldSelect = (field: string, contactId: string) => {
    setSelectedFields(prev => ({ ...prev, [field]: contactId }))
  }

  const handleMerge = async () => {
    setLoading(true)
    setError(null)

    try {
      const supabase = getClient()

      // Récupérer les valeurs sélectionnées
      const allContacts = [primaryContact, ...duplicateContacts]
      const mergedData: UpdateContactData = {}

      Object.entries(selectedFields).forEach(([field, contactId]) => {
        const selectedContact = allContacts.find(c => c.id === contactId)
        if (selectedContact) {
          const value = selectedContact[field as ContactField]
          if (field === 'first_name' && value) {
            mergedData.first_name = value
          } else if (field === 'last_name') {
            mergedData.last_name = value
          } else if (field === 'phone' && value) {
            mergedData.phone = value
          } else if (field === 'email') {
            mergedData.email = value
          } else if (field === 'notes_client') {
            mergedData.notes_client = value
          }
        }
      })

      // Fusionner les notes (concaténer)
      const allNotes = allContacts
        .map(c => c.notes_client)
        .filter(Boolean)
        .join('\n---\n')
      if (allNotes) {
        mergedData.notes_client = allNotes
      }

      // Mettre à jour le contact principal avec les données fusionnées
      await updateContact(primaryContact.id, mergedData)

      // Transférer les réservations des contacts dupliqués vers le contact principal
      for (const duplicate of duplicateContacts) {
        // Récupérer les réservations liées
        const { data: bookingContacts } = await supabase
          .from('booking_contacts')
          .select('booking_id, contact_id')
          .eq('contact_id', duplicate.id)
          .returns<Array<{ booking_id: string; contact_id: string }>>()

        if (bookingContacts && bookingContacts.length > 0) {
          // Pour chaque réservation, vérifier si le contact principal est déjà lié
          for (const bc of bookingContacts) {
            const bookingId = bc.booking_id
            const { data: existing } = await supabase
              .from('booking_contacts')
              .select('id')
              .eq('booking_id', bookingId)
              .eq('contact_id', primaryContact.id)
              .single()

            if (!existing) {
              // Transférer la liaison - mettre à jour contact_id
              const updateData: BookingContactUpdate = { contact_id: primaryContact.id }
              await supabase
                .from('booking_contacts')
                // @ts-expect-error - Supabase type inference limitation with update
                .update(updateData)
                .eq('booking_id', bookingId)
                .eq('contact_id', duplicate.id)
            } else {
              // Supprimer la liaison dupliquée
              await supabase
                .from('booking_contacts')
                .delete()
                .eq('booking_id', bookingId)
                .eq('contact_id', duplicate.id)
            }
          }
        }

        // Archiver les contacts dupliqués avec raison
        await archiveContact(duplicate.id)
        await updateContact(duplicate.id, {
          archived_reason: `Fusionné avec ${primaryContact.first_name} ${primaryContact.last_name || ''} (ID: ${primaryContact.id})`,
        })
      }

      onMergeComplete()
      onClose()
    } catch (err) {
      console.error('Error merging contacts:', err)
      setError('Erreur lors de la fusion des contacts')
    } finally {
      setLoading(false)
    }
  }

  const getContactValue = (contact: Contact, field: ContactField): string => {
    return contact[field] || '-'
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
      <div
        className={`relative w-full max-w-4xl mx-4 rounded-2xl shadow-2xl max-h-[90vh] overflow-y-auto ${
          isDark ? 'bg-gray-800' : 'bg-white'
        }`}
      >
        {/* Header */}
        <div className={`flex items-center justify-between p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <div className="flex items-center gap-3">
            <AlertTriangle className={`w-6 h-6 ${isDark ? 'text-yellow-400' : 'text-yellow-600'}`} />
            <h2 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
              Fusionner les contacts
            </h2>
          </div>
          <button
            onClick={onClose}
            disabled={loading}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'hover:bg-gray-700 text-gray-400 hover:text-white'
                : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
            } disabled:opacity-50`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Content */}
        <div className="p-6 space-y-6">
          {/* Warning */}
          <div className={`p-4 rounded-lg border ${
            isDark
              ? 'bg-yellow-500/10 border-yellow-500/50 text-yellow-400'
              : 'bg-yellow-50 border-yellow-200 text-yellow-700'
          }`}>
            <p className="text-sm">
              <strong>Attention:</strong> Cette action fusionnera {duplicateContacts.length} contact(s) avec le contact principal. 
              Les contacts dupliqués seront archivés et leurs réservations transférées vers le contact principal.
            </p>
          </div>

          {/* Erreur */}
          {error && (
            <div className={`p-4 rounded-lg border ${
              isDark
                ? 'bg-red-500/10 border-red-500/50 text-red-400'
                : 'bg-red-50 border-red-200 text-red-600'
            }`}>
              {error}
            </div>
          )}

          {/* Table de sélection */}
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className={isDark ? 'bg-gray-700/50' : 'bg-gray-100'}>
                <tr>
                  <th className={`px-4 py-3 text-left text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    Champ
                  </th>
                  <th className={`px-4 py-3 text-center text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    Contact principal (à conserver)
                  </th>
                  {duplicateContacts.map((contact, idx) => (
                    <th key={contact.id} className={`px-4 py-3 text-center text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      Doublon {idx + 1}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody className={isDark ? 'divide-y divide-gray-700' : 'divide-y divide-gray-200'}>
                {(['first_name', 'last_name', 'phone', 'email', 'notes_client'] as ContactField[]).map((field) => (
                  <tr key={field}>
                    <td className={`px-4 py-3 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      {field === 'first_name' ? 'Prénom' :
                       field === 'last_name' ? 'Nom' :
                       field === 'phone' ? 'Téléphone' :
                       field === 'email' ? 'Email' :
                       'Notes'}
                    </td>
                    <td className="px-4 py-3">
                      <label className="flex items-center justify-center cursor-pointer">
                        <input
                          type="radio"
                          name={`field_${field}`}
                          checked={selectedFields[field] === primaryContact.id}
                          onChange={() => handleFieldSelect(field, primaryContact.id)}
                          className="mr-2"
                        />
                        <span className={isDark ? 'text-white' : 'text-gray-900'}>
                          {getContactValue(primaryContact, field)}
                        </span>
                      </label>
                    </td>
                    {duplicateContacts.map((contact) => (
                      <td key={contact.id} className="px-4 py-3">
                        <label className="flex items-center justify-center cursor-pointer">
                          <input
                            type="radio"
                            name={`field_${field}`}
                            checked={selectedFields[field] === contact.id}
                            onChange={() => handleFieldSelect(field, contact.id)}
                            className="mr-2"
                          />
                          <span className={isDark ? 'text-gray-300' : 'text-gray-700'}>
                            {getContactValue(contact, field)}
                          </span>
                        </label>
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Footer */}
          <div className={`flex items-center justify-end gap-3 pt-4 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className={`px-4 py-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              } disabled:opacity-50`}
            >
              Annuler
            </button>
            <button
              onClick={handleMerge}
              disabled={loading}
              className="px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Fusion en cours...
                </>
              ) : (
                <>
                  <Check className="w-4 h-4" />
                  Fusionner les contacts
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/components/BranchSelector.tsx">
'use client'

import { ChevronDown, Building2 } from 'lucide-react'
import { useState, useRef, useEffect } from 'react'
import type { Branch } from '@/lib/supabase/types'

interface BranchSelectorProps {
  branches: Branch[]
  selectedBranch: Branch | null
  onSelect: (branchId: string) => void
  disabled?: boolean
  theme?: 'light' | 'dark'
}

export function BranchSelector({
  branches,
  selectedBranch,
  onSelect,
  disabled = false,
  theme = 'dark',
}: BranchSelectorProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [mounted, setMounted] = useState(false)
  const dropdownRef = useRef<HTMLDivElement>(null)

  // Éviter les problèmes d'hydratation
  useEffect(() => {
    setMounted(true)
  }, [])

  // Fermer le dropdown quand on clique ailleurs
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside)
    }
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [isOpen])

  const isDark = theme === 'dark'

  if (branches.length === 0) {
    return (
      <div className={`flex items-center gap-2 px-4 py-2 rounded-lg ${
        isDark
          ? 'bg-gray-800 text-gray-400'
          : 'bg-gray-100 text-gray-600'
      }`}>
        <Building2 className="w-5 h-5" />
        <span>Aucune agence disponible</span>
      </div>
    )
  }

  if (branches.length === 1) {
    return (
      <div className={`flex items-center gap-2 px-4 py-2 rounded-lg ${
        isDark
          ? 'bg-gray-800 text-white'
          : 'bg-gray-100 text-gray-900'
      }`}>
        <Building2 className={`w-5 h-5 ${
          isDark ? 'text-blue-400' : 'text-blue-600'
        }`} />
        <span>{selectedBranch?.name || branches[0].name}</span>
      </div>
    )
  }

  return (
    <div ref={dropdownRef} className="relative">
      <button
        onClick={() => !disabled && setIsOpen(!isOpen)}
        disabled={disabled}
        className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-colors ${
          isDark
            ? 'bg-gray-800 hover:bg-gray-700 text-white'
            : 'bg-gray-100 hover:bg-gray-200 text-gray-900'
        } ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
      >
        <Building2 className={`w-5 h-5 ${
          isDark ? 'text-blue-400' : 'text-blue-600'
        }`} />
        <span>{selectedBranch?.name || 'Sélectionner une agence'}</span>
        <ChevronDown className={`w-4 h-4 transition-transform ${
          isDark ? 'text-gray-400' : 'text-gray-600'
        } ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {mounted && isOpen && (
        <div className={`absolute top-full left-0 mt-2 w-64 rounded-lg shadow-xl z-50 overflow-hidden ${
          isDark
            ? 'bg-gray-800 border border-gray-700'
            : 'bg-white border border-gray-200'
        }`}>
          {branches.map((branch) => (
            <button
              key={branch.id}
              onClick={() => {
                onSelect(branch.id)
                setIsOpen(false)
              }}
              className={`w-full px-4 py-3 text-left transition-colors ${
                selectedBranch?.id === branch.id
                  ? isDark
                    ? 'bg-blue-600/20 text-blue-400'
                    : 'bg-blue-100 text-blue-700'
                  : isDark
                  ? 'text-white hover:bg-gray-700'
                  : 'text-gray-900 hover:bg-gray-100'
              }`}
            >
              <div className="font-medium">{branch.name}</div>
              {branch.name_en && branch.name_en !== branch.name && (
                <div className={`text-sm ${
                  isDark ? 'text-gray-400' : 'text-gray-600'
                }`}>{branch.name_en}</div>
              )}
            </button>
          ))}
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/components/ClientOnly.tsx">
'use client'

import { useState, useEffect, type ReactNode } from 'react'

interface ClientOnlyProps {
  children: ReactNode
  fallback?: ReactNode
}

export function ClientOnly({ children, fallback = null }: ClientOnlyProps) {
  const [hasMounted, setHasMounted] = useState(false)

  useEffect(() => {
    setHasMounted(true)
  }, [])

  if (!hasMounted) {
    return fallback
  }

  return <>{children}</>
}
</file>

<file path="src/app/admin/components/ContactFieldAutocomplete.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { User, Phone, Mail, Loader2 } from 'lucide-react'
import { useContacts } from '@/hooks/useContacts'
import type { Contact } from '@/lib/supabase/types'

interface ContactFieldAutocompleteProps {
  branchId: string
  value: string
  onChange: (value: string) => void
  onSelectContact: (contact: Contact) => void
  fieldType: 'firstName' | 'lastName' | 'email' | 'phone'
  placeholder?: string
  required?: boolean
  isDark: boolean
  inputType?: 'text' | 'tel' | 'email'
  disabled?: boolean // Désactive la recherche et rend le champ readonly
  isFocused?: boolean // Indique si ce champ a le focus (pour ne lancer la recherche que sur le champ actif)
  onEnterKey?: () => void // Handler pour la touche Entrée
}

export function ContactFieldAutocomplete({
  branchId,
  value,
  onChange,
  onSelectContact,
  fieldType,
  placeholder,
  required = false,
  isDark,
  inputType = 'text',
  disabled = false,
  isFocused = false,
  onEnterKey,
}: ContactFieldAutocompleteProps) {
  const [showResults, setShowResults] = useState(false)
  const [searchResults, setSearchResults] = useState<Contact[]>([])
  const [isSearching, setIsSearching] = useState(false)
  const [hasFocus, setHasFocus] = useState(false)
  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const { searchContacts } = useContacts(branchId)

  // Recherche avec debounce - SEULEMENT si le champ a le focus ET n'est pas désactivé
  useEffect(() => {
    // Ne pas lancer de recherche si :
    // - Le champ est désactivé
    // - Le champ n'a pas le focus
    // - Pas de branchId
    if (disabled || !hasFocus || !branchId) {
      setSearchResults([])
      setShowResults(false)
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current)
      }
      return
    }

    // Nettoyer le timeout précédent
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current)
    }

    // Si la recherche est vide, réinitialiser
    if (!value.trim()) {
      setSearchResults([])
      setShowResults(false)
      return
    }

    // Debounce de 300ms
    setIsSearching(true)
    searchTimeoutRef.current = setTimeout(async () => {
      try {
        const result = await searchContacts({
          query: value.trim(),
          branchId,
          includeArchived: false,
          page: 1,
          pageSize: 10, // Limiter à 10 résultats pour l'autocomplete
        })

        setSearchResults(result.contacts)
        setShowResults(true)
      } catch (error) {
        console.error('Error searching contacts:', error)
        setSearchResults([])
      } finally {
        setIsSearching(false)
      }
    }, 300)

    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current)
      }
    }
  }, [value, branchId, searchContacts, disabled, hasFocus])

  // Fermer les résultats si on clique en dehors
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setShowResults(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Sélectionner un contact
  const handleSelectContact = (contact: Contact) => {
    onSelectContact(contact)
    setShowResults(false)
  }

  // Formater le nom complet
  const getDisplayName = (contact: Contact): string => {
    const parts = [contact.first_name, contact.last_name].filter(Boolean)
    return parts.length > 0 ? parts.join(' ') : contact.phone || 'Contact'
  }

  // Déterminer la position du dropdown selon le champ
  // Prénom et Téléphone : colonne gauche → dropdown aligné à gauche
  // Nom et Email : colonne droite → dropdown aligné à droite pour éviter de sortir
  const isLeftColumn = fieldType === 'firstName' || fieldType === 'phone'

  return (
    <div ref={containerRef} className="relative">
      {/* Input avec autocomplete */}
      <div className="relative">
        <input
          type={inputType}
          value={value}
          onChange={(e) => {
            if (!disabled) {
              onChange(e.target.value)
            }
          }}
          onKeyDown={(e) => {
            // Si Entrée est pressée
            if (e.key === 'Enter') {
              // Si des résultats sont affichés avec des résultats disponibles, laisser naviguer (Tab/Entrée pour sélectionner)
              if (showResults && searchResults.length > 0) {
                // Laisser le comportement par défaut du navigateur
                return
              }
              
              // Sinon, soumettre le formulaire si le handler est fourni
              if (onEnterKey) {
                e.preventDefault()
                e.stopPropagation()
                // Appeler le handler directement
                onEnterKey()
              }
            }
          }}
          onFocus={() => {
            if (!disabled) {
              setHasFocus(true)
              if (value.trim() && searchResults.length > 0) {
                setShowResults(true)
              }
            }
          }}
          onBlur={() => {
            // Ne pas fermer immédiatement pour permettre le clic sur un résultat
            setTimeout(() => {
              setHasFocus(false)
            }, 200)
          }}
          required={required}
          placeholder={placeholder}
          disabled={disabled}
          readOnly={disabled}
          className={`w-full px-3 py-2 rounded-lg border ${
            disabled
              ? isDark
                ? 'bg-gray-800 border-gray-700 text-gray-500 cursor-not-allowed'
                : 'bg-gray-100 border-gray-300 text-gray-500 cursor-not-allowed'
              : isDark
                ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
          } focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
        />
        {isSearching && (
          <Loader2 className={`absolute right-3 top-1/2 -translate-y-1/2 w-5 h-5 animate-spin ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
        )}
      </div>

      {/* Résultats de recherche */}
      {showResults && searchResults.length > 0 && (
        <div
          className={`absolute z-50 ${isLeftColumn ? 'left-0' : 'right-0'} mt-1 min-w-full w-max rounded-lg border shadow-lg max-h-64 overflow-y-auto ${
            isDark
              ? 'bg-gray-800 border-gray-700'
              : 'bg-white border-gray-300'
          }`}
          style={{
            maxWidth: 'min(calc(100vw - 2rem), 600px)',
          }}
        >
          {searchResults.map((contact) => (
            <button
              key={contact.id}
              type="button"
              onClick={() => handleSelectContact(contact)}
              className={`w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors border-b whitespace-nowrap ${
                isDark
                  ? 'border-gray-700 text-gray-200'
                  : 'border-gray-200 text-gray-900'
              } first:rounded-t-lg last:rounded-b-lg last:border-b-0`}
            >
              <div className="flex items-center gap-3">
                <div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${
                  isDark ? 'bg-gray-700' : 'bg-gray-100'
                }`}>
                  <User className={`w-4 h-4 ${isDark ? 'text-gray-400' : 'text-gray-600'}`} />
                </div>
                <div className="flex items-center gap-4 flex-1 min-w-0">
                  <div className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {getDisplayName(contact)}
                  </div>
                  {contact.phone && (
                    <div className={`flex items-center gap-1 text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                      <Phone className="w-3 h-3 flex-shrink-0" />
                      <span>{contact.phone}</span>
                    </div>
                  )}
                  {contact.email && (
                    <div className={`flex items-center gap-1 text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                      <Mail className="w-3 h-3 flex-shrink-0" />
                      <span>{contact.email}</span>
                    </div>
                  )}
                </div>
              </div>
            </button>
          ))}
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/components/ContactSearch.tsx">
'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { Search, User, Phone, Mail, Loader2, X } from 'lucide-react'
import { useContacts } from '@/hooks/useContacts'
import type { Contact } from '@/lib/supabase/types'

interface ContactSearchProps {
  branchId: string | null
  onSelectContact: (contact: Contact | null) => void
  selectedContact: Contact | null
  isDark: boolean
  placeholder?: string
  className?: string
}

export function ContactSearch({
  branchId,
  onSelectContact,
  selectedContact,
  isDark,
  placeholder = 'Rechercher un contact (nom, téléphone, email)...',
  className = '',
}: ContactSearchProps) {
  const [searchQuery, setSearchQuery] = useState('')
  const [showResults, setShowResults] = useState(false)
  const [searchResults, setSearchResults] = useState<Contact[]>([])
  const [isSearching, setIsSearching] = useState(false)
  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const { searchContacts } = useContacts(branchId)

  // Recherche avec debounce
  useEffect(() => {
    if (!branchId) {
      setSearchResults([])
      return
    }

    // Nettoyer le timeout précédent
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current)
    }

    // Si la recherche est vide, réinitialiser
    if (!searchQuery.trim()) {
      setSearchResults([])
      setShowResults(false)
      return
    }

    // Debounce de 300ms
    setIsSearching(true)
    searchTimeoutRef.current = setTimeout(async () => {
      try {
        const result = await searchContacts({
          query: searchQuery.trim(),
          branchId,
          includeArchived: false,
          page: 1,
          pageSize: 10, // Limiter à 10 résultats pour l'autocomplete
        })

        setSearchResults(result.contacts)
        setShowResults(true)
      } catch (error) {
        console.error('Error searching contacts:', error)
        setSearchResults([])
      } finally {
        setIsSearching(false)
      }
    }, 300)

    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current)
      }
    }
  }, [searchQuery, branchId, searchContacts])

  // Fermer les résultats si on clique en dehors
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setShowResults(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Sélectionner un contact
  const handleSelectContact = useCallback((contact: Contact) => {
    onSelectContact(contact)
    setSearchQuery('')
    setShowResults(false)
  }, [onSelectContact])

  // Effacer la sélection
  const handleClearSelection = useCallback(() => {
    onSelectContact(null)
    setSearchQuery('')
    setShowResults(false)
  }, [onSelectContact])

  // Formater le nom complet
  const getDisplayName = (contact: Contact): string => {
    const parts = [contact.first_name, contact.last_name].filter(Boolean)
    return parts.length > 0 ? parts.join(' ') : contact.phone
  }

  return (
    <div ref={containerRef} className={`relative ${className}`}>
      {/* Input de recherche */}
      <div className="relative">
        <Search className={`absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
        <input
          type="text"
          value={selectedContact ? getDisplayName(selectedContact) : searchQuery}
          onChange={(e) => {
            if (selectedContact) {
              handleClearSelection()
            }
            setSearchQuery(e.target.value)
          }}
          onFocus={() => {
            if (searchQuery.trim() && searchResults.length > 0) {
              setShowResults(true)
            }
          }}
          placeholder={placeholder}
          className={`w-full pl-10 pr-10 py-2 rounded-lg border ${
            isDark
              ? 'bg-gray-800 border-gray-700 text-white placeholder-gray-500'
              : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
          } focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
        />
        {isSearching && (
          <Loader2 className={`absolute right-3 top-1/2 -translate-y-1/2 w-5 h-5 animate-spin ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
        )}
        {selectedContact && !isSearching && (
          <button
            type="button"
            onClick={handleClearSelection}
            className={`absolute right-3 top-1/2 -translate-y-1/2 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700 ${isDark ? 'text-gray-400 hover:text-gray-300' : 'text-gray-500 hover:text-gray-700'}`}
          >
            <X className="w-4 h-4" />
          </button>
        )}
      </div>

      {/* Résultats de recherche */}
      {showResults && searchResults.length > 0 && (
        <div
          className={`absolute z-50 w-full mt-1 rounded-lg border shadow-lg max-h-64 overflow-y-auto ${
            isDark
              ? 'bg-gray-800 border-gray-700'
              : 'bg-white border-gray-300'
          }`}
        >
          {searchResults.map((contact) => (
            <button
              key={contact.id}
              type="button"
              onClick={() => handleSelectContact(contact)}
              className={`w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors border-b ${
                isDark
                  ? 'border-gray-700 text-gray-200'
                  : 'border-gray-200 text-gray-900'
              } first:rounded-t-lg last:rounded-b-lg last:border-b-0`}
            >
              <div className="flex items-center gap-3">
                <div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${
                  isDark ? 'bg-gray-700' : 'bg-gray-100'
                }`}>
                  <User className={`w-4 h-4 ${isDark ? 'text-gray-400' : 'text-gray-600'}`} />
                </div>
                <div className="flex-1 min-w-0">
                  <div className={`font-medium truncate ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {getDisplayName(contact)}
                  </div>
                  <div className="flex items-center gap-3 mt-1 text-sm">
                    {contact.phone && (
                      <div className={`flex items-center gap-1 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                        <Phone className="w-3 h-3" />
                        <span className="truncate">{contact.phone}</span>
                      </div>
                    )}
                    {contact.email && (
                      <div className={`flex items-center gap-1 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                        <Mail className="w-3 h-3" />
                        <span className="truncate">{contact.email}</span>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </button>
          ))}
        </div>
      )}

      {/* Message "Aucun résultat" */}
      {showResults && searchQuery.trim() && !isSearching && searchResults.length === 0 && (
        <div
          className={`absolute z-50 w-full mt-1 rounded-lg border shadow-lg p-4 text-center ${
            isDark
              ? 'bg-gray-800 border-gray-700 text-gray-400'
              : 'bg-white border-gray-300 text-gray-600'
          }`}
        >
          Aucun contact trouvé. Un nouveau contact sera créé à la validation.
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/components/CustomSelect.tsx">
'use client'

import { ChevronDown } from 'lucide-react'
import { useState, useRef, useEffect } from 'react'

interface Option {
  value: string
  label: string
}

interface CustomSelectProps {
  value: string
  onChange: (value: string) => void
  options: Option[]
  placeholder?: string
  isDark: boolean
  disabled?: boolean
}

export function CustomSelect({
  value,
  onChange,
  options,
  placeholder = 'Sélectionner...',
  isDark,
  disabled = false,
}: CustomSelectProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [mounted, setMounted] = useState(false)
  const dropdownRef = useRef<HTMLDivElement>(null)

  // Éviter les problèmes d'hydratation
  useEffect(() => {
    setMounted(true)
  }, [])

  // Fermer le dropdown quand on clique ailleurs
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside)
    }
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [isOpen])

  const selectedOption = options.find(opt => opt.value === value)

  return (
    <div ref={dropdownRef} className="relative w-full">
      <button
        type="button"
        onClick={() => !disabled && setIsOpen(!isOpen)}
        disabled={disabled}
        className={`w-full flex items-center justify-between gap-2 px-4 py-2 rounded-lg transition-colors ${
          isDark
            ? 'bg-gray-800 hover:bg-gray-700 text-white'
            : 'bg-gray-100 hover:bg-gray-200 text-gray-900'
        } ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
      >
        <span className="flex-1 text-left">
          {selectedOption ? selectedOption.label : placeholder}
        </span>
        <ChevronDown className={`w-4 h-4 transition-transform flex-shrink-0 ${
          isDark ? 'text-gray-400' : 'text-gray-600'
        } ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {mounted && isOpen && (
        <div className={`absolute top-full left-0 mt-2 w-full rounded-lg shadow-xl z-50 overflow-hidden ${
          isDark
            ? 'bg-gray-800 border border-gray-700'
            : 'bg-white border border-gray-200'
        }`}>
          {options.map((option) => (
            <button
              key={option.value}
              type="button"
              onClick={() => {
                onChange(option.value)
                setIsOpen(false)
              }}
              className={`w-full px-4 py-3 text-left transition-colors ${
                value === option.value
                  ? isDark
                    ? 'bg-blue-600/20 text-blue-400'
                    : 'bg-blue-100 text-blue-700'
                  : isDark
                  ? 'text-white hover:bg-gray-700'
                  : 'text-gray-900 hover:bg-gray-100'
              }`}
            >
              <div className="font-medium">{option.label}</div>
            </button>
          ))}
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/components/index.ts">
/**
 * Admin Components - Point d'entrée
 */
export { AdminHeader } from './AdminHeader'
export { BranchSelector } from './BranchSelector'
export { DateNavigation } from './DateNavigation'
export { ClientOnly } from './ClientOnly'
</file>

<file path="src/app/admin/components/PermissionToast.tsx">
'use client'

import { useEffect, useState } from 'react'
import { X, ShieldX, ShieldAlert, AlertTriangle } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'

export type ToastType = 'error' | 'warning' | 'permission_denied'

export interface ToastMessage {
  id: string
  type: ToastType
  title: string
  message: string
  messageKey?: string
  duration?: number // en ms, 0 = infini
}

interface PermissionToastProps {
  toasts: ToastMessage[]
  onDismiss: (id: string) => void
  isDark: boolean
}

export function PermissionToast({ toasts, onDismiss, isDark }: PermissionToastProps) {
  return (
    <div className="fixed top-4 right-4 z-[100] flex flex-col gap-2 max-w-md">
      {toasts.map((toast) => (
        <ToastItem
          key={toast.id}
          toast={toast}
          onDismiss={() => onDismiss(toast.id)}
          isDark={isDark}
        />
      ))}
    </div>
  )
}

interface ToastItemProps {
  toast: ToastMessage
  onDismiss: () => void
  isDark: boolean
}

function ToastItem({ toast, onDismiss, isDark }: ToastItemProps) {
  const { t } = useTranslation()
  const [isExiting, setIsExiting] = useState(false)

  useEffect(() => {
    const duration = toast.duration ?? 5000
    if (duration > 0) {
      const timer = setTimeout(() => {
        setIsExiting(true)
        setTimeout(onDismiss, 300) // Attendre l'animation
      }, duration)
      return () => clearTimeout(timer)
    }
  }, [toast.duration, onDismiss])

  const handleDismiss = () => {
    setIsExiting(true)
    setTimeout(onDismiss, 300)
  }

  const getIcon = () => {
    switch (toast.type) {
      case 'permission_denied':
        return <ShieldX className="w-5 h-5 text-red-400" />
      case 'error':
        return <ShieldAlert className="w-5 h-5 text-red-400" />
      case 'warning':
        return <AlertTriangle className="w-5 h-5 text-yellow-400" />
      default:
        return <ShieldX className="w-5 h-5 text-red-400" />
    }
  }

  const getBorderColor = () => {
    switch (toast.type) {
      case 'permission_denied':
      case 'error':
        return isDark ? 'border-red-500/50' : 'border-red-200'
      case 'warning':
        return isDark ? 'border-yellow-500/50' : 'border-yellow-200'
      default:
        return isDark ? 'border-red-500/50' : 'border-red-200'
    }
  }

  const getBackgroundColor = () => {
    switch (toast.type) {
      case 'permission_denied':
      case 'error':
        return isDark ? 'bg-red-900/20' : 'bg-red-50'
      case 'warning':
        return isDark ? 'bg-yellow-900/20' : 'bg-yellow-50'
      default:
        return isDark ? 'bg-red-900/20' : 'bg-red-50'
    }
  }

  // Utiliser la traduction si une clé est fournie
  const displayMessage = toast.messageKey
    ? t(toast.messageKey) !== toast.messageKey
      ? t(toast.messageKey)
      : toast.message
    : toast.message

  return (
    <div
      className={`
        flex items-start gap-3 p-4 rounded-lg border shadow-lg
        transform transition-all duration-300 ease-out
        ${isExiting ? 'opacity-0 translate-x-4' : 'opacity-100 translate-x-0'}
        ${isDark ? 'bg-gray-800' : 'bg-white'}
        ${getBorderColor()}
        ${getBackgroundColor()}
      `}
    >
      <div className="flex-shrink-0 mt-0.5">
        {getIcon()}
      </div>
      <div className="flex-1 min-w-0">
        <p className={`text-sm font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
          {toast.title}
        </p>
        <p className={`text-sm mt-1 ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
          {displayMessage}
        </p>
      </div>
      <button
        onClick={handleDismiss}
        className={`flex-shrink-0 p-1 rounded transition-colors ${
          isDark
            ? 'text-gray-400 hover:text-white hover:bg-gray-700'
            : 'text-gray-400 hover:text-gray-600 hover:bg-gray-100'
        }`}
      >
        <X className="w-4 h-4" />
      </button>
    </div>
  )
}

// Hook pour gérer les toasts
export function usePermissionToast() {
  const [toasts, setToasts] = useState<ToastMessage[]>([])

  const showToast = (toast: Omit<ToastMessage, 'id'>) => {
    const id = Math.random().toString(36).substr(2, 9)
    setToasts((prev) => [...prev, { ...toast, id }])
  }

  const dismissToast = (id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id))
  }

  const showPermissionError = (message: string, messageKey?: string) => {
    showToast({
      type: 'permission_denied',
      title: 'Permission refusée',
      message,
      messageKey,
      duration: 6000,
    })
  }

  const showError = (message: string, messageKey?: string) => {
    showToast({
      type: 'error',
      title: 'Erreur',
      message,
      messageKey,
      duration: 5000,
    })
  }

  const showWarning = (message: string, messageKey?: string) => {
    showToast({
      type: 'warning',
      title: 'Attention',
      message,
      messageKey,
      duration: 5000,
    })
  }

  return {
    toasts,
    showToast,
    dismissToast,
    showPermissionError,
    showError,
    showWarning,
  }
}
</file>

<file path="src/app/admin/logs/components/LogsTable.tsx">
'use client'

import React, { useState, useMemo } from 'react'
import {
  Clock,
  User,
  Calendar,
  ChevronUp,
  ChevronDown,
  ChevronDown as FilterIcon,
  X,
  BookOpen,
  ShoppingCart,
  Users,
  Settings,
  Shield,
  Trash2,
  FileText,
  LogIn,
  LogOut,
  Edit,
  PlusCircle,
  XCircle,
  Archive
} from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { ActivityLogWithRelations, ActionType, TargetType, UserRole } from '@/lib/supabase/types'

type SortField = 'created_at' | 'action_type' | 'user_name' | 'target_type'
type SortDirection = 'asc' | 'desc'

interface LogsTableProps {
  logs: ActivityLogWithRelations[]
  isDark: boolean
  currentUserRole: UserRole
  onDeleteLogs?: (logIds: string[]) => Promise<boolean>
}

// Filter Dropdown Component (same as OrdersTable)
function FilterDropdown({
  label,
  options,
  value,
  onChange,
  isDark
}: {
  label: string
  options: { value: string; label: string }[]
  value: string
  onChange: (value: string) => void
  isDark: boolean
}) {
  const [isOpen, setIsOpen] = useState(false)
  const [position, setPosition] = useState({ top: 0, left: 0 })
  const buttonRef = React.useRef<HTMLButtonElement>(null)
  const selectedOption = options.find(o => o.value === value)

  const handleOpen = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect()
      setPosition({ top: rect.bottom + 4, left: rect.left })
    }
    setIsOpen(!isOpen)
  }

  return (
    <div className="relative">
      <button
        ref={buttonRef}
        onClick={handleOpen}
        className={`flex items-center gap-1 text-xs font-semibold uppercase tracking-wider ${
          value !== 'all'
            ? 'text-blue-500'
            : isDark ? 'text-gray-400' : 'text-gray-600'
        } hover:text-blue-500`}
      >
        {label}
        {value !== 'all' && (
          <span className="text-[10px] bg-blue-500 text-white px-1 rounded">
            {selectedOption?.label}
          </span>
        )}
        <FilterIcon className="w-3 h-3" />
      </button>

      {isOpen && (
        <>
          <div className="fixed inset-0 z-40" onClick={() => setIsOpen(false)} />
          <div
            className={`fixed z-50 rounded-lg shadow-lg border min-w-[160px] max-h-64 overflow-y-auto ${
              isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
            }`}
            style={{ top: position.top, left: position.left }}
          >
            {options.map((option) => (
              <button
                key={option.value}
                onClick={(e) => {
                  e.stopPropagation()
                  onChange(option.value)
                  setIsOpen(false)
                }}
                className={`w-full text-left px-3 py-2 text-sm first:rounded-t-lg last:rounded-b-lg ${
                  value === option.value
                    ? 'bg-blue-500 text-white'
                    : isDark
                      ? 'text-gray-300 hover:bg-gray-700'
                      : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                {option.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  )
}

const PAGE_SIZE_OPTIONS = [20, 50, 100, 200, 500]

export function LogsTable({ logs, isDark, currentUserRole, onDeleteLogs }: LogsTableProps) {
  const { t, locale } = useTranslation()
  const [sortField, setSortField] = useState<SortField>('created_at')
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc')
  const [currentPage, setCurrentPage] = useState(1)
  const [itemsPerPage, setItemsPerPage] = useState(50)
  const [selectedLogs, setSelectedLogs] = useState<Set<string>>(new Set())

  // Filters
  const [actionFilter, setActionFilter] = useState<string>('all')
  const [targetFilter, setTargetFilter] = useState<string>('all')
  const [roleFilter, setRoleFilter] = useState<string>('all')

  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')
    } else {
      setSortField(field)
      setSortDirection('desc')
    }
  }

  // Apply filters
  const filteredLogs = useMemo(() => {
    return logs.filter(log => {
      if (actionFilter !== 'all' && log.action_type !== actionFilter) return false
      if (targetFilter !== 'all' && log.target_type !== targetFilter) return false
      if (roleFilter !== 'all' && log.user_role !== roleFilter) return false
      return true
    })
  }, [logs, actionFilter, targetFilter, roleFilter])

  // Sort
  const sortedLogs = useMemo(() => {
    return [...filteredLogs].sort((a, b) => {
      let comparison = 0
      switch (sortField) {
        case 'created_at':
          comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
          break
        case 'action_type':
          comparison = a.action_type.localeCompare(b.action_type)
          break
        case 'user_name':
          comparison = (a.user_name || '').localeCompare(b.user_name || '')
          break
        case 'target_type':
          comparison = (a.target_type || '').localeCompare(b.target_type || '')
          break
      }
      return sortDirection === 'asc' ? comparison : -comparison
    })
  }, [filteredLogs, sortField, sortDirection])

  // Pagination
  const totalPages = Math.ceil(sortedLogs.length / itemsPerPage)
  const paginatedLogs = useMemo(() => {
    const start = (currentPage - 1) * itemsPerPage
    return sortedLogs.slice(start, start + itemsPerPage)
  }, [sortedLogs, currentPage, itemsPerPage])

  // Reset page when filters change
  React.useEffect(() => {
    setCurrentPage(1)
    setSelectedLogs(new Set())
  }, [actionFilter, targetFilter, roleFilter, itemsPerPage])

  const SortIcon = ({ field }: { field: SortField }) => {
    if (sortField !== field) return null
    return sortDirection === 'asc'
      ? <ChevronUp className="w-3 h-3 inline ml-1" />
      : <ChevronDown className="w-3 h-3 inline ml-1" />
  }

  const formatDateTime = (dateStr: string) => {
    const date = new Date(dateStr)
    return {
      date: date.toLocaleDateString(getDateLocale(), {
        day: '2-digit',
        month: '2-digit',
        year: '2-digit'
      }),
      time: date.toLocaleTimeString(getDateLocale(), {
        hour: '2-digit',
        minute: '2-digit'
      })
    }
  }

  const getActionIcon = (action: ActionType) => {
    if (action.includes('created')) return PlusCircle
    if (action.includes('updated')) return Edit
    if (action.includes('deleted')) return Trash2
    if (action.includes('cancelled')) return XCircle
    if (action.includes('archived')) return Archive
    if (action.includes('confirmed')) return Shield
    if (action === 'user_login') return LogIn
    if (action === 'user_logout') return LogOut
    if (action === 'permission_changed') return Shield
    if (action === 'settings_updated') return Settings
    return FileText
  }

  const getActionColor = (action: ActionType) => {
    if (action.includes('created')) return 'text-green-500 bg-green-100 dark:bg-green-900/30'
    if (action.includes('updated') || action.includes('confirmed')) return 'text-blue-500 bg-blue-100 dark:bg-blue-900/30'
    if (action.includes('deleted')) return 'text-red-500 bg-red-100 dark:bg-red-900/30'
    if (action.includes('cancelled') || action.includes('archived')) return 'text-orange-500 bg-orange-100 dark:bg-orange-900/30'
    if (action === 'user_login') return 'text-cyan-500 bg-cyan-100 dark:bg-cyan-900/30'
    if (action === 'user_logout') return 'text-gray-500 bg-gray-100 dark:bg-gray-700'
    if (action === 'permission_changed') return 'text-purple-500 bg-purple-100 dark:bg-purple-900/30'
    return 'text-gray-500 bg-gray-100 dark:bg-gray-700'
  }

  const getTargetIcon = (target: TargetType | null) => {
    switch (target) {
      case 'booking': return BookOpen
      case 'order': return ShoppingCart
      case 'contact': return User
      case 'user': return Users
      case 'settings': return Settings
      case 'log': return FileText
      default: return FileText
    }
  }

  const getRoleBadgeColor = (role: UserRole) => {
    switch (role) {
      case 'super_admin':
        return isDark
          ? 'bg-purple-500/20 text-purple-400'
          : 'bg-purple-100 text-purple-700'
      case 'branch_admin':
        return isDark
          ? 'bg-blue-500/20 text-blue-400'
          : 'bg-blue-100 text-blue-700'
      case 'agent':
        return isDark
          ? 'bg-green-500/20 text-green-400'
          : 'bg-green-100 text-green-700'
      default:
        return isDark
          ? 'bg-gray-500/20 text-gray-400'
          : 'bg-gray-100 text-gray-700'
    }
  }

  // Action type options for filter
  const actionOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'booking_created', label: t('admin.logs.actions.booking_created') },
    { value: 'booking_updated', label: t('admin.logs.actions.booking_updated') },
    { value: 'booking_cancelled', label: t('admin.logs.actions.booking_cancelled') },
    { value: 'booking_deleted', label: t('admin.logs.actions.booking_deleted') },
    { value: 'order_confirmed', label: t('admin.logs.actions.order_confirmed') },
    { value: 'order_cancelled', label: t('admin.logs.actions.order_cancelled') },
    { value: 'order_deleted', label: t('admin.logs.actions.order_deleted') },
    { value: 'contact_created', label: t('admin.logs.actions.contact_created') },
    { value: 'contact_updated', label: t('admin.logs.actions.contact_updated') },
    { value: 'contact_archived', label: t('admin.logs.actions.contact_archived') },
    { value: 'contact_deleted', label: t('admin.logs.actions.contact_deleted') },
    { value: 'user_created', label: t('admin.logs.actions.user_created') },
    { value: 'user_updated', label: t('admin.logs.actions.user_updated') },
    { value: 'user_deleted', label: t('admin.logs.actions.user_deleted') },
    { value: 'user_login', label: t('admin.logs.actions.user_login') },
    { value: 'user_logout', label: t('admin.logs.actions.user_logout') },
    { value: 'permission_changed', label: t('admin.logs.actions.permission_changed') },
    { value: 'settings_updated', label: t('admin.logs.actions.settings_updated') },
    { value: 'log_deleted', label: t('admin.logs.actions.log_deleted') },
  ]

  const targetOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'booking', label: t('admin.logs.targets.booking') },
    { value: 'order', label: t('admin.logs.targets.order') },
    { value: 'contact', label: t('admin.logs.targets.contact') },
    { value: 'user', label: t('admin.logs.targets.user') },
    { value: 'settings', label: t('admin.logs.targets.settings') },
    { value: 'log', label: t('admin.logs.targets.log') },
  ]

  const roleOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'super_admin', label: t('admin.roles.super_admin') },
    { value: 'branch_admin', label: t('admin.roles.branch_admin') },
    { value: 'agent', label: t('admin.roles.agent') },
  ]

  const hasActiveFilters = actionFilter !== 'all' || targetFilter !== 'all' || roleFilter !== 'all'

  const clearAllFilters = () => {
    setActionFilter('all')
    setTargetFilter('all')
    setRoleFilter('all')
  }

  const toggleLogSelection = (logId: string) => {
    const newSelected = new Set(selectedLogs)
    if (newSelected.has(logId)) {
      newSelected.delete(logId)
    } else {
      newSelected.add(logId)
    }
    setSelectedLogs(newSelected)
  }

  const toggleAllSelection = () => {
    if (selectedLogs.size === paginatedLogs.length) {
      setSelectedLogs(new Set())
    } else {
      setSelectedLogs(new Set(paginatedLogs.map(l => l.id)))
    }
  }

  const handleDeleteSelected = async () => {
    if (onDeleteLogs && selectedLogs.size > 0) {
      const confirmed = window.confirm(t('admin.logs.delete_confirm', { count: selectedLogs.size }))
      if (confirmed) {
        const success = await onDeleteLogs(Array.from(selectedLogs))
        if (success) {
          setSelectedLogs(new Set())
        }
      }
    }
  }

  if (logs.length === 0) {
    return (
      <div className={`text-center py-12 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
        {t('admin.logs.no_logs')}
      </div>
    )
  }

  return (
    <div className={`${isDark ? 'bg-gray-800' : 'bg-white'} rounded-xl border ${isDark ? 'border-gray-700' : 'border-gray-200'} overflow-hidden`}>
      {/* Header with filters */}
      <div className={`grid grid-cols-12 gap-2 px-4 py-3 border-b ${isDark ? 'border-gray-700 bg-gray-900' : 'border-gray-200 bg-gray-50'}`}>
        {/* Checkbox column */}
        {currentUserRole === 'super_admin' && (
          <div className="col-span-1 flex items-center">
            <input
              type="checkbox"
              checked={selectedLogs.size === paginatedLogs.length && paginatedLogs.length > 0}
              onChange={toggleAllSelection}
              className="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            />
          </div>
        )}

        <div className={currentUserRole === 'super_admin' ? 'col-span-2' : 'col-span-2'}>
          <button
            onClick={() => handleSort('created_at')}
            className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'} hover:text-blue-500`}
          >
            {t('admin.logs.table.timestamp')}<SortIcon field="created_at" />
          </button>
        </div>
        <div className="col-span-2">
          <FilterDropdown
            label={t('admin.logs.table.action')}
            options={actionOptions}
            value={actionFilter}
            onChange={setActionFilter}
            isDark={isDark}
          />
        </div>
        <div className="col-span-2">
          <button
            onClick={() => handleSort('user_name')}
            className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'} hover:text-blue-500`}
          >
            {t('admin.logs.table.user')}<SortIcon field="user_name" />
          </button>
        </div>
        <div className="col-span-1">
          <FilterDropdown
            label={t('admin.logs.table.role')}
            options={roleOptions}
            value={roleFilter}
            onChange={setRoleFilter}
            isDark={isDark}
          />
        </div>
        <div className="col-span-2">
          <FilterDropdown
            label={t('admin.logs.table.target')}
            options={targetOptions}
            value={targetFilter}
            onChange={setTargetFilter}
            isDark={isDark}
          />
        </div>
        <div className={`${currentUserRole === 'super_admin' ? 'col-span-2' : 'col-span-3'} flex items-center justify-between`}>
          <span className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
            {t('admin.logs.table.details')}
          </span>
          {hasActiveFilters && (
            <button
              onClick={clearAllFilters}
              className="flex items-center gap-1 text-xs text-red-500 hover:text-red-600"
            >
              <X className="w-3 h-3" />
              Reset
            </button>
          )}
        </div>
      </div>

      {/* Results counter and delete button */}
      {(hasActiveFilters || selectedLogs.size > 0) && (
        <div className={`px-4 py-2 flex items-center justify-between text-xs ${isDark ? 'bg-gray-800/50 text-gray-400' : 'bg-gray-50 text-gray-500'} border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <span>
            {sortedLogs.length} {t('admin.logs.results')} {t('admin.common.of')} {logs.length} {t('admin.logs.logs_count')}
          </span>
          {currentUserRole === 'super_admin' && selectedLogs.size > 0 && (
            <button
              onClick={handleDeleteSelected}
              className="flex items-center gap-1 px-2 py-1 text-xs text-red-500 hover:text-red-600 hover:bg-red-100 dark:hover:bg-red-900/30 rounded"
            >
              <Trash2 className="w-3 h-3" />
              {t('admin.logs.delete_selected', { count: selectedLogs.size })}
            </button>
          )}
        </div>
      )}

      {/* Rows */}
      <div className="divide-y divide-gray-200 dark:divide-gray-700 min-h-[300px]">
        {paginatedLogs.length === 0 ? (
          <div className={`text-center py-8 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
            {t('admin.logs.no_matching_logs')}
          </div>
        ) : (
          paginatedLogs.map((log) => {
            const ActionIcon = getActionIcon(log.action_type)
            const TargetIcon = getTargetIcon(log.target_type)
            const { date, time } = formatDateTime(log.created_at)
            const actionColor = getActionColor(log.action_type)

            return (
              <div
                key={log.id}
                className={`grid grid-cols-12 gap-2 px-4 py-3 items-center hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors`}
              >
                {/* Checkbox */}
                {currentUserRole === 'super_admin' && (
                  <div className="col-span-1 flex items-center">
                    <input
                      type="checkbox"
                      checked={selectedLogs.has(log.id)}
                      onChange={() => toggleLogSelection(log.id)}
                      className="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                  </div>
                )}

                {/* Timestamp */}
                <div className={`${currentUserRole === 'super_admin' ? 'col-span-2' : 'col-span-2'} flex items-center gap-2`}>
                  <Clock className={`w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
                  <div>
                    <div className={`text-sm ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>{date}</div>
                    <div className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>{time}</div>
                  </div>
                </div>

                {/* Action */}
                <div className="col-span-2">
                  <div className={`inline-flex items-center gap-1 px-2 py-1 rounded text-xs font-medium ${actionColor}`}>
                    <ActionIcon className="w-3 h-3" />
                    <span className="truncate max-w-[120px]">
                      {t(`admin.logs.actions.${log.action_type}`)}
                    </span>
                  </div>
                </div>

                {/* User */}
                <div className="col-span-2">
                  <span className={`font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {log.user_name || '-'}
                  </span>
                </div>

                {/* Role */}
                <div className="col-span-1">
                  <span className={`text-xs px-2 py-0.5 rounded ${getRoleBadgeColor(log.user_role)}`}>
                    {t(`admin.roles.${log.user_role}`)}
                  </span>
                </div>

                {/* Target */}
                <div className="col-span-2">
                  {log.target_type && (
                    <div className="flex items-center gap-1">
                      <TargetIcon className={`w-3 h-3 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
                      <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                        {t(`admin.logs.targets.${log.target_type}`)}
                      </span>
                      {log.target_name && (
                        <span className={`text-xs font-mono ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                          ({log.target_name.length > 15 ? log.target_name.substring(0, 15) + '...' : log.target_name})
                        </span>
                      )}
                    </div>
                  )}
                </div>

                {/* Details/Branch */}
                <div className={currentUserRole === 'super_admin' ? 'col-span-2' : 'col-span-3'}>
                  {log.branch?.name && (
                    <span className={`text-xs px-2 py-0.5 rounded ${isDark ? 'bg-gray-700 text-gray-400' : 'bg-gray-100 text-gray-600'}`}>
                      {locale === 'en' ? log.branch.name_en || log.branch.name : log.branch.name}
                    </span>
                  )}
                </div>
              </div>
            )
          })
        )}
      </div>

      {/* Pagination */}
      <div className={`flex items-center justify-between px-4 py-3 border-t ${isDark ? 'border-gray-700 bg-gray-900' : 'border-gray-200 bg-gray-50'}`}>
        <div className="flex items-center gap-4">
          <div className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
            {sortedLogs.length} {t('admin.logs.logs_count')}
            {totalPages > 1 && ` • ${t('admin.common.page')} ${currentPage}/${totalPages}`}
          </div>

          <div className="flex items-center gap-2">
            <span className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>{t('admin.common.show')}</span>
            <select
              value={itemsPerPage}
              onChange={(e) => setItemsPerPage(Number(e.target.value))}
              className={`px-2 py-1 rounded text-sm border ${
                isDark
                  ? 'bg-gray-800 border-gray-700 text-gray-300'
                  : 'bg-white border-gray-300 text-gray-700'
              }`}
            >
              {PAGE_SIZE_OPTIONS.map(size => (
                <option key={size} value={size}>{size}</option>
              ))}
            </select>
            <span className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>{t('admin.common.rows')}</span>
          </div>
        </div>

        {/* Page navigation */}
        {totalPages > 1 && (
          <div className="flex items-center gap-2">
            <button
              onClick={() => setCurrentPage(1)}
              disabled={currentPage === 1}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              ««
            </button>
            <button
              onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
              disabled={currentPage === 1}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              «
            </button>
            <span className={`px-3 py-1 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {currentPage}
            </span>
            <button
              onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
              disabled={currentPage === totalPages}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              »
            </button>
            <button
              onClick={() => setCurrentPage(totalPages)}
              disabled={currentPage === totalPages}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              »»
            </button>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/roles/components/RoleModal.tsx">
'use client'

import { useState, useEffect } from 'react'
import { X, Loader2, AlertCircle, Save, Shield, Users, UserCog, Crown, User, Lock } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { Role } from '@/lib/supabase/types'

interface RoleModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (data: Partial<Role>) => Promise<{ success: boolean; error?: string }>
  role?: Role | null
  userLevel: number
  isDark: boolean
  mode: 'create' | 'edit'
}

// Available icons
const AVAILABLE_ICONS = [
  { name: 'Shield', icon: Shield },
  { name: 'UserCog', icon: UserCog },
  { name: 'Users', icon: Users },
  { name: 'Crown', icon: Crown },
  { name: 'User', icon: User },
  { name: 'Lock', icon: Lock },
]

// Preset colors
const PRESET_COLORS = [
  '#EF4444', // red
  '#F97316', // orange
  '#EAB308', // yellow
  '#22C55E', // green
  '#14B8A6', // teal
  '#3B82F6', // blue
  '#8B5CF6', // purple
  '#EC4899', // pink
  '#6B7280', // gray
]

export function RoleModal({
  isOpen,
  onClose,
  onSubmit,
  role,
  userLevel,
  isDark,
  mode,
}: RoleModalProps) {
  const { t } = useTranslation()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Form state
  const [name, setName] = useState('')
  const [displayName, setDisplayName] = useState('')
  const [description, setDescription] = useState('')
  const [level, setLevel] = useState(5)
  const [color, setColor] = useState('#3B82F6')
  const [icon, setIcon] = useState('User')

  // Initialize form
  useEffect(() => {
    if (isOpen) {
      if (mode === 'edit' && role) {
        setName(role.name)
        setDisplayName(role.display_name)
        setDescription(role.description || '')
        setLevel(role.level)
        setColor(role.color)
        setIcon(role.icon)
      } else {
        setName('')
        setDisplayName('')
        setDescription('')
        setLevel(userLevel + 1 > 10 ? 10 : userLevel + 1)
        setColor('#3B82F6')
        setIcon('User')
      }
      setError(null)
    }
  }, [isOpen, mode, role, userLevel])

  // Generate slug from display name
  const handleDisplayNameChange = (value: string) => {
    setDisplayName(value)
    if (mode === 'create') {
      const slug = value
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
      setName(slug)
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    // Validation
    if (!name.trim()) {
      setError('L\'identifiant est requis')
      return
    }

    if (!displayName.trim()) {
      setError('Le nom affiché est requis')
      return
    }

    // Le super_admin (level 1) peut assigner n'importe quel level >= 2
    // Les autres doivent avoir un level > leur propre level
    if (userLevel !== 1 && level <= userLevel) {
      setError(`Le niveau doit être supérieur à ${userLevel}`)
      return
    }

    // Le level 1 est toujours réservé au super_admin
    if (level === 1) {
      setError('Le niveau 1 est réservé au super_admin')
      return
    }

    setLoading(true)

    const data: Partial<Role> = {
      display_name: displayName.trim(),
      description: description.trim() || null,
      level,
      color,
      icon,
    }

    if (mode === 'create') {
      data.name = name.trim()
    }

    const result = await onSubmit(data)

    setLoading(false)

    if (!result.success) {
      setError(result.error || 'Erreur lors de l\'enregistrement')
    }
  }

  if (!isOpen) return null

  // Minimum level user can assign
  // Super_admin (level 1) peut assigner à partir de 2, les autres à partir de leur level + 1
  const minLevel = userLevel === 1 ? 2 : userLevel + 1

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 overflow-y-auto">
      <div className={`relative w-full max-w-xl my-8 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
        {/* Header */}
        <div className={`flex items-center justify-between p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <h2 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {mode === 'create' ? t('admin.roles.create_title') : t('admin.roles.edit_title')}
          </h2>
          <button
            onClick={onClose}
            disabled={loading}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'hover:bg-gray-700 text-gray-400 hover:text-white'
                : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
            } disabled:opacity-50`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {error && (
            <div className={`p-4 rounded-lg border flex items-start gap-2 ${
              isDark
                ? 'bg-red-500/10 border-red-500/50 text-red-400'
                : 'bg-red-50 border-red-200 text-red-600'
            }`}>
              <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
              <span>{error}</span>
            </div>
          )}

          {/* Display Name */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.roles.display_name')} *
            </label>
            <input
              type="text"
              value={displayName}
              onChange={(e) => handleDisplayNameChange(e.target.value)}
              required
              className={`w-full px-3 py-2 rounded-lg border ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="Ex: Superviseur"
            />
          </div>

          {/* Slug (Name) */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.roles.name')} *
            </label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              required
              disabled={mode === 'edit'}
              className={`w-full px-3 py-2 rounded-lg border font-mono ${
                mode === 'edit' ? 'opacity-50 cursor-not-allowed' : ''
              } ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="ex: superviseur"
            />
            <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
              {t('admin.roles.name_help')}
            </p>
          </div>

          {/* Description */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.roles.description')}
            </label>
            <textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={2}
              className={`w-full px-3 py-2 rounded-lg border ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="Description optionnelle..."
            />
          </div>

          {/* Level */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.roles.level')} *
            </label>
            <div className="flex items-center gap-4">
              <input
                type="range"
                min={minLevel}
                max={10}
                value={level}
                onChange={(e) => setLevel(parseInt(e.target.value))}
                className="flex-1"
              />
              <span className={`w-12 text-center text-2xl font-bold ${
                level <= 3 ? 'text-red-500' : level <= 5 ? 'text-yellow-500' : 'text-blue-500'
              }`}>
                {level}
              </span>
            </div>
            <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
              {t('admin.roles.level_help')}
            </p>
          </div>

          {/* Color */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.roles.color')}
            </label>
            <div className="flex items-center gap-3 flex-wrap">
              {PRESET_COLORS.map((presetColor) => (
                <button
                  key={presetColor}
                  type="button"
                  onClick={() => setColor(presetColor)}
                  className={`w-8 h-8 rounded-lg transition-transform ${
                    color === presetColor ? 'ring-2 ring-offset-2 ring-blue-500 scale-110' : ''
                  } ${isDark ? 'ring-offset-gray-800' : 'ring-offset-white'}`}
                  style={{ backgroundColor: presetColor }}
                />
              ))}
              <input
                type="color"
                value={color}
                onChange={(e) => setColor(e.target.value)}
                className="w-8 h-8 rounded-lg cursor-pointer"
              />
            </div>
          </div>

          {/* Icon */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.roles.icon')}
            </label>
            <div className="flex items-center gap-3 flex-wrap">
              {AVAILABLE_ICONS.map(({ name: iconName, icon: IconComponent }) => (
                <button
                  key={iconName}
                  type="button"
                  onClick={() => setIcon(iconName)}
                  className={`w-10 h-10 rounded-lg flex items-center justify-center transition-all ${
                    icon === iconName
                      ? 'ring-2 ring-offset-2 ring-blue-500 scale-110'
                      : ''
                  } ${isDark ? 'bg-gray-700 ring-offset-gray-800' : 'bg-gray-100 ring-offset-white'}`}
                >
                  <IconComponent className="w-5 h-5" style={{ color: color }} />
                </button>
              ))}
            </div>
          </div>

          {/* Preview */}
          <div className={`p-4 rounded-lg border ${isDark ? 'border-gray-700 bg-gray-700/50' : 'border-gray-200 bg-gray-50'}`}>
            <p className={`text-sm font-medium mb-2 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
              {t('admin.roles.preview')}
            </p>
            <div className="flex items-center gap-3">
              <div
                className="w-10 h-10 rounded-lg flex items-center justify-center"
                style={{ backgroundColor: `${color}20` }}
              >
                {(() => {
                  const IconComponent = AVAILABLE_ICONS.find(i => i.name === icon)?.icon || User
                  return <IconComponent className="w-5 h-5" style={{ color }} />
                })()}
              </div>
              <div>
                <div className="font-medium" style={{ color }}>
                  {displayName || 'Nom du rôle'}
                </div>
                <div className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  Level {level}
                </div>
              </div>
            </div>
          </div>

          {/* Footer */}
          <div className={`flex items-center justify-end gap-3 pt-4 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className={`px-4 py-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              } disabled:opacity-50`}
            >
              {t('admin.common.cancel')}
            </button>
            <button
              type="submit"
              disabled={loading}
              className="px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  {t('admin.common.saving')}
                </>
              ) : (
                <>
                  <Save className="w-4 h-4" />
                  {mode === 'create' ? t('admin.roles.create') : t('admin.common.save')}
                </>
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/users/components/CreateUserModal.tsx">
'use client'

import { useState, useEffect, useMemo } from 'react'
import { X, Loader2, User, Phone, Mail, Shield, Building2, AlertCircle, Eye, EyeOff, Copy, Check } from 'lucide-react'
import type { UserRole, Branch, Role } from '@/lib/supabase/types'
import { validateEmail, validateIsraeliPhone, VALIDATION_MESSAGES } from '@/lib/validation'
import { CustomSelect } from '../../components/CustomSelect'
import { useRoles } from '@/hooks/useRoles'

interface CreateUserModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (data: {
    email: string
    first_name: string
    last_name: string
    phone: string
    role_id: string
    branch_ids: string[]
    password?: string
  }) => Promise<{ success: boolean; error?: string; temporaryPassword?: string }>
  branches: Branch[]
  currentUserRole: UserRole
  currentUserBranchIds: string[]
  currentUserLevel?: number
  isDark: boolean
}

export function CreateUserModal({
  isOpen,
  onClose,
  onSubmit,
  branches,
  currentUserRole,
  currentUserBranchIds,
  currentUserLevel = 10,
  isDark,
}: CreateUserModalProps) {
  const { roles, getAssignableRoles, loading: rolesLoading } = useRoles()

  const [email, setEmail] = useState('')
  const [firstName, setFirstName] = useState('')
  const [lastName, setLastName] = useState('')
  const [phone, setPhone] = useState('')
  const [selectedRoleId, setSelectedRoleId] = useState<string>('')
  const [selectedBranchIds, setSelectedBranchIds] = useState<string[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [validationErrors, setValidationErrors] = useState<{ email?: string; phone?: string }>({})
  const [temporaryPassword, setTemporaryPassword] = useState<string | null>(null)
  const [showPassword, setShowPassword] = useState(false)
  const [passwordCopied, setPasswordCopied] = useState(false)

  // Get available roles for assignment based on user level
  const assignableRoles = useMemo(() => {
    return getAssignableRoles(currentUserLevel)
  }, [getAssignableRoles, currentUserLevel])

  // Set default role when assignable roles are loaded
  useEffect(() => {
    if (assignableRoles.length > 0 && !selectedRoleId) {
      // Default to the role with highest level (lowest authority) among assignable
      const defaultRole = assignableRoles[assignableRoles.length - 1]
      setSelectedRoleId(defaultRole.id)
    }
  }, [assignableRoles, selectedRoleId])

  // Réinitialiser le formulaire à l'ouverture
  useEffect(() => {
    if (isOpen) {
      setEmail('')
      setFirstName('')
      setLastName('')
      setPhone('')
      // Reset role to default (will be set by above effect)
      setSelectedRoleId('')
      setSelectedBranchIds([])
      setError(null)
      setValidationErrors({})
      setTemporaryPassword(null)
      setShowPassword(false)
      setPasswordCopied(false)
    }
  }, [isOpen])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    // Validation finale
    if (!validateEmail(email)) {
      setError(VALIDATION_MESSAGES.email.invalid)
      return
    }

    if (!validateIsraeliPhone(phone)) {
      setError(VALIDATION_MESSAGES.phone.israeliFormat)
      return
    }

    if (selectedBranchIds.length === 0) {
      setError('Veuillez sélectionner au moins une branche')
      return
    }

    if (!selectedRoleId) {
      setError('Veuillez sélectionner un rôle')
      return
    }

    setLoading(true)

    const result = await onSubmit({
      email: email.trim(),
      first_name: firstName.trim(),
      last_name: lastName.trim(),
      phone,
      role_id: selectedRoleId,
      branch_ids: selectedBranchIds,
    })

    setLoading(false)

    if (result.success) {
      if (result.temporaryPassword) {
        setTemporaryPassword(result.temporaryPassword)
      } else {
        onClose()
      }
    } else {
      setError(result.error || 'Erreur lors de la création')
    }
  }

  const handleCopyPassword = () => {
    if (temporaryPassword) {
      navigator.clipboard.writeText(temporaryPassword)
      setPasswordCopied(true)
      setTimeout(() => setPasswordCopied(false), 2000)
    }
  }

  const handleToggleBranch = (branchId: string) => {
    setSelectedBranchIds(prev =>
      prev.includes(branchId)
        ? prev.filter(id => id !== branchId)
        : [...prev, branchId]
    )
  }

  // Filtrer les branches disponibles selon le niveau
  // Level < 5 peut voir toutes les branches
  const availableBranches = currentUserLevel < 5
    ? branches
    : branches.filter(b => currentUserBranchIds.includes(b.id))

  // Build role options from dynamic roles
  const roleOptions = useMemo(() => {
    return assignableRoles.map(role => ({
      value: role.id,
      label: role.display_name,
      color: role.color
    }))
  }, [assignableRoles])

  if (!isOpen) return null

  // Loading state for roles
  if (rolesLoading) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
        <div className={`relative w-full max-w-md rounded-2xl shadow-2xl p-8 ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
          <div className="flex items-center justify-center">
            <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
          </div>
        </div>
      </div>
    )
  }

  // Si mot de passe temporaire généré, afficher l'écran de confirmation
  if (temporaryPassword) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
        <div className={`relative w-full max-w-md rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
          <div className={`p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <div className="flex items-center gap-3">
              <div className="w-12 h-12 rounded-full bg-green-100 dark:bg-green-900/30 flex items-center justify-center">
                <Check className="w-6 h-6 text-green-600 dark:text-green-400" />
              </div>
              <div>
                <h2 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  Utilisateur créé !
                </h2>
                <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                  {email}
                </p>
              </div>
            </div>
          </div>

          <div className="p-6 space-y-4">
            <div className={`p-4 rounded-lg ${isDark ? 'bg-yellow-900/20 border border-yellow-700' : 'bg-yellow-50 border border-yellow-200'}`}>
              <div className="flex items-start gap-2">
                <AlertCircle className="w-5 h-5 text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-0.5" />
                <div className="flex-1">
                  <p className={`text-sm font-medium ${isDark ? 'text-yellow-300' : 'text-yellow-800'}`}>
                    Mot de passe temporaire généré
                  </p>
                  <p className={`text-sm mt-1 ${isDark ? 'text-yellow-400' : 'text-yellow-700'}`}>
                    Copiez ce mot de passe et communiquez-le à l'utilisateur. Il devra le changer à sa première connexion.
                  </p>
                </div>
              </div>
            </div>

            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                Mot de passe temporaire
              </label>
              <div className="flex items-center gap-2">
                <input
                  type={showPassword ? 'text' : 'password'}
                  value={temporaryPassword}
                  readOnly
                  className={`flex-1 px-3 py-2 rounded-lg border font-mono text-sm ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-gray-50 border-gray-300 text-gray-900'
                  }`}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className={`p-2 rounded-lg transition-colors ${
                    isDark
                      ? 'hover:bg-gray-700 text-gray-400'
                      : 'hover:bg-gray-100 text-gray-600'
                  }`}
                  title={showPassword ? 'Masquer' : 'Afficher'}
                >
                  {showPassword ? <EyeOff className="w-5 h-5" /> : <Eye className="w-5 h-5" />}
                </button>
                <button
                  type="button"
                  onClick={handleCopyPassword}
                  className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 ${
                    passwordCopied
                      ? 'bg-green-600 text-white'
                      : 'bg-blue-600 hover:bg-blue-700 text-white'
                  }`}
                >
                  {passwordCopied ? (
                    <>
                      <Check className="w-4 h-4" />
                      Copié
                    </>
                  ) : (
                    <>
                      <Copy className="w-4 h-4" />
                      Copier
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>

          <div className={`p-6 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <button
              onClick={onClose}
              className="w-full px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white transition-colors"
            >
              Fermer
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 overflow-y-auto">
      <div className={`relative w-full max-w-2xl my-8 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
        {/* Header */}
        <div className={`flex items-center justify-between p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <h2 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            Créer un utilisateur
          </h2>
          <button
            onClick={onClose}
            disabled={loading}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'hover:bg-gray-700 text-gray-400 hover:text-white'
                : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
            } disabled:opacity-50`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {error && (
            <div className={`p-4 rounded-lg border flex items-start gap-2 ${
              isDark
                ? 'bg-red-500/10 border-red-500/50 text-red-400'
                : 'bg-red-50 border-red-200 text-red-600'
            }`}>
              <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
              <span>{error}</span>
            </div>
          )}

          {/* Email */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Mail className="w-4 h-4 inline mr-1" />
              Email *
            </label>
            <input
              type="email"
              value={email}
              onChange={(e) => {
                const newEmail = e.target.value
                setEmail(newEmail)
                if (newEmail.trim() && !validateEmail(newEmail)) {
                  setValidationErrors({ ...validationErrors, email: VALIDATION_MESSAGES.email.invalid })
                } else {
                  const { email: _, ...rest } = validationErrors
                  setValidationErrors(rest)
                }
              }}
              required
              className={`w-full px-3 py-2 rounded-lg border ${
                validationErrors.email
                  ? 'border-red-500'
                  : isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="utilisateur@example.com"
            />
            {validationErrors.email && (
              <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>{validationErrors.email}</span>
              </div>
            )}
          </div>

          {/* Prénom et Nom */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                <User className="w-4 h-4 inline mr-1" />
                Prénom *
              </label>
              <input
                type="text"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                placeholder="Prénom"
              />
            </div>
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                Nom *
              </label>
              <input
                type="text"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                placeholder="Nom"
              />
            </div>
          </div>

          {/* Téléphone */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Phone className="w-4 h-4 inline mr-1" />
              Téléphone *
            </label>
            <input
              type="tel"
              value={phone}
              onChange={(e) => {
                const newPhone = e.target.value
                setPhone(newPhone)
                if (newPhone.trim() && !validateIsraeliPhone(newPhone)) {
                  setValidationErrors({ ...validationErrors, phone: VALIDATION_MESSAGES.phone.israeliFormat })
                } else {
                  const { phone: _, ...rest } = validationErrors
                  setValidationErrors(rest)
                }
              }}
              required
              className={`w-full px-3 py-2 rounded-lg border ${
                validationErrors.phone
                  ? 'border-red-500'
                  : isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="05XXXXXXXX"
            />
            {validationErrors.phone && (
              <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>{validationErrors.phone}</span>
              </div>
            )}
          </div>

          {/* Rôle */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Shield className="w-4 h-4 inline mr-1" />
              Rôle *
            </label>
            <CustomSelect
              value={selectedRoleId}
              onChange={(value) => setSelectedRoleId(value)}
              options={roleOptions}
              isDark={isDark}
            />
            {assignableRoles.length === 0 && (
              <p className={`text-xs mt-1 ${isDark ? 'text-yellow-400' : 'text-yellow-600'}`}>
                Aucun rôle disponible pour l'assignation
              </p>
            )}
          </div>

          {/* Branches */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Building2 className="w-4 h-4 inline mr-1" />
              Branche(s) *
            </label>
            <div className={`border rounded-lg p-3 space-y-2 max-h-40 overflow-y-auto ${
              isDark ? 'border-gray-600 bg-gray-700' : 'border-gray-300 bg-gray-50'
            }`}>
              {availableBranches.map(branch => (
                <label
                  key={branch.id}
                  className="flex items-center gap-2 cursor-pointer"
                >
                  <input
                    type="checkbox"
                    checked={selectedBranchIds.includes(branch.id)}
                    onChange={() => handleToggleBranch(branch.id)}
                    className="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  />
                  <span className={isDark ? 'text-white' : 'text-gray-900'}>
                    {branch.name}
                  </span>
                </label>
              ))}
            </div>
            {selectedBranchIds.length === 0 && (
              <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                Veuillez sélectionner au moins une branche
              </p>
            )}
          </div>

          {/* Footer */}
          <div className={`flex items-center justify-end gap-3 pt-4 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className={`px-4 py-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              } disabled:opacity-50`}
            >
              Annuler
            </button>
            <button
              type="submit"
              disabled={loading || Object.keys(validationErrors).length > 0}
              className="px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Création...
                </>
              ) : (
                'Créer l\'utilisateur'
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/users/components/EditSelfModal.tsx">
'use client'

import { useState, useEffect } from 'react'
import { X, Loader2, User, Phone, AlertCircle, Save } from 'lucide-react'
import type { UserWithBranches } from '@/lib/supabase/types'
import { validateIsraeliPhone, VALIDATION_MESSAGES } from '@/lib/validation'

interface EditSelfModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (userId: string, data: {
    first_name?: string
    last_name?: string
    phone?: string
  }) => Promise<{ success: boolean; error?: string }>
  user: UserWithBranches | null
  isDark: boolean
}

export function EditSelfModal({
  isOpen,
  onClose,
  onSubmit,
  user,
  isDark,
}: EditSelfModalProps) {
  const [firstName, setFirstName] = useState('')
  const [lastName, setLastName] = useState('')
  const [phone, setPhone] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [validationErrors, setValidationErrors] = useState<{ phone?: string }>({})

  // Initialiser avec les données de l'utilisateur
  useEffect(() => {
    if (isOpen && user) {
      setFirstName(user.first_name)
      setLastName(user.last_name)
      setPhone(user.phone)
      setError(null)
      setValidationErrors({})
    }
  }, [isOpen, user])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!user) return

    setError(null)

    // Validation
    if (!validateIsraeliPhone(phone)) {
      setError(VALIDATION_MESSAGES.phone.israeliFormat)
      return
    }

    setLoading(true)

    const result = await onSubmit(user.id, {
      first_name: firstName.trim(),
      last_name: lastName.trim(),
      phone,
    })

    setLoading(false)

    if (result.success) {
      onClose()
    } else {
      setError(result.error || 'Erreur lors de la modification')
    }
  }

  if (!isOpen || !user) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 overflow-y-auto">
      <div className={`relative w-full max-w-md my-8 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
        <div className={`flex items-center justify-between p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <h2 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            Modifier mon profil
          </h2>
          <button
            onClick={onClose}
            disabled={loading}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'hover:bg-gray-700 text-gray-400 hover:text-white'
                : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
            } disabled:opacity-50`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {error && (
            <div className={`p-4 rounded-lg border flex items-start gap-2 ${
              isDark
                ? 'bg-red-500/10 border-red-500/50 text-red-400'
                : 'bg-red-50 border-red-200 text-red-600'
            }`}>
              <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
              <span>{error}</span>
            </div>
          )}

          {/* Email (non modifiable) */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              Email
            </label>
            <input
              type="text"
              value={user.email || 'N/A'}
              disabled
              className={`w-full px-3 py-2 rounded-lg border ${
                isDark
                  ? 'bg-gray-900 border-gray-700 text-gray-500'
                  : 'bg-gray-100 border-gray-300 text-gray-500'
              } cursor-not-allowed`}
            />
            <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
              L'email ne peut pas être modifié
            </p>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                <User className="w-4 h-4 inline mr-1" />
                Prénom *
              </label>
              <input
                type="text"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white'
                    : 'bg-white border-gray-300 text-gray-900'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              />
            </div>
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                Nom *
              </label>
              <input
                type="text"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white'
                    : 'bg-white border-gray-300 text-gray-900'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              />
            </div>
          </div>

          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Phone className="w-4 h-4 inline mr-1" />
              Téléphone *
            </label>
            <input
              type="tel"
              value={phone}
              onChange={(e) => {
                const newPhone = e.target.value
                setPhone(newPhone)
                if (newPhone.trim() && !validateIsraeliPhone(newPhone)) {
                  setValidationErrors({ phone: VALIDATION_MESSAGES.phone.israeliFormat })
                } else {
                  setValidationErrors({})
                }
              }}
              required
              className={`w-full px-3 py-2 rounded-lg border ${
                validationErrors.phone
                  ? 'border-red-500'
                  : isDark
                  ? 'bg-gray-700 border-gray-600 text-white'
                  : 'bg-white border-gray-300 text-gray-900'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="05XXXXXXXX"
            />
            {validationErrors.phone && (
              <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>{validationErrors.phone}</span>
              </div>
            )}
          </div>

          <div className={`flex items-center justify-end gap-3 pt-4 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className={`px-4 py-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              } disabled:opacity-50`}
            >
              Annuler
            </button>
            <button
              type="submit"
              disabled={loading || Object.keys(validationErrors).length > 0}
              className="px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Enregistrement...
                </>
              ) : (
                <>
                  <Save className="w-4 h-4" />
                  Enregistrer
                </>
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/users/components/EditUserModal.tsx">
'use client'

import { useState, useEffect, useMemo } from 'react'
import { X, Loader2, User, Phone, Shield, Building2, AlertCircle, Save, Mail, Lock } from 'lucide-react'
import type { UserWithBranches, UserRole, Branch } from '@/lib/supabase/types'
import { validateIsraeliPhone, validateEmail, VALIDATION_MESSAGES } from '@/lib/validation'
import { CustomSelect } from '../../components/CustomSelect'
import { useRoles } from '@/hooks/useRoles'

interface EditUserModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (userId: string, data: {
    first_name?: string
    last_name?: string
    phone?: string
    email?: string
    password?: string
    role_id?: string
    branch_ids?: string[]
  }) => Promise<{ success: boolean; error?: string }>
  user: UserWithBranches | null
  branches: Branch[]
  currentUserRole: UserRole
  currentUserBranchIds: string[]
  currentUserLevel?: number
  isDark: boolean
}

export function EditUserModal({
  isOpen,
  onClose,
  onSubmit,
  user,
  branches,
  currentUserRole,
  currentUserBranchIds,
  currentUserLevel = 10,
  isDark,
}: EditUserModalProps) {
  const { roles, getAssignableRoles, getRoleByName, loading: rolesLoading } = useRoles()

  const [firstName, setFirstName] = useState('')
  const [lastName, setLastName] = useState('')
  const [phone, setPhone] = useState('')
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [selectedRoleId, setSelectedRoleId] = useState<string>('')
  const [selectedBranchIds, setSelectedBranchIds] = useState<string[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [validationErrors, setValidationErrors] = useState<{ phone?: string; email?: string; password?: string }>({})

  // Get available roles for assignment based on user level
  const assignableRoles = useMemo(() => {
    return getAssignableRoles(currentUserLevel)
  }, [getAssignableRoles, currentUserLevel])

  // Initialiser avec les données de l'utilisateur
  useEffect(() => {
    if (isOpen && user) {
      setFirstName(user.first_name)
      setLastName(user.last_name)
      setPhone(user.phone)
      setEmail(user.email || '')
      setPassword('') // Toujours vide au départ (optionnel)

      // Find role_id from user's role name
      const userRole = getRoleByName(user.role)
      setSelectedRoleId(userRole?.id || user.role_id || '')

      setSelectedBranchIds(user.branches.map(b => b.id))
      setError(null)
      setValidationErrors({})
    }
  }, [isOpen, user, getRoleByName])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!user) return

    setError(null)
    const newValidationErrors: { phone?: string; email?: string; password?: string } = {}

    // Validation téléphone
    if (!validateIsraeliPhone(phone)) {
      newValidationErrors.phone = VALIDATION_MESSAGES.phone.israeliFormat
    }

    // Validation email si modifié
    if (email.trim() && email.trim() !== user.email) {
      if (!validateEmail(email.trim())) {
        newValidationErrors.email = VALIDATION_MESSAGES.email.invalid
      }
    }

    // Validation mot de passe si fourni (minimum 6 caractères)
    if (password.trim()) {
      if (password.length < 6) {
        newValidationErrors.password = 'Le mot de passe doit contenir au moins 6 caractères'
      }
    }

    if (Object.keys(newValidationErrors).length > 0) {
      setValidationErrors(newValidationErrors)
      return
    }

    if (selectedBranchIds.length === 0) {
      setError('Veuillez sélectionner au moins une branche')
      return
    }

    setLoading(true)

    const submitData: {
      first_name?: string
      last_name?: string
      phone?: string
      email?: string
      password?: string
      role_id?: string
      branch_ids?: string[]
    } = {
      first_name: firstName.trim(),
      last_name: lastName.trim(),
      phone,
      role_id: selectedRoleId,
      branch_ids: selectedBranchIds,
    }

    // Ajouter email seulement si modifié
    if (email.trim() && email.trim() !== user.email) {
      submitData.email = email.trim()
    }

    // Ajouter password seulement si fourni
    if (password.trim()) {
      submitData.password = password
    }

    const result = await onSubmit(user.id, submitData)

    setLoading(false)

    if (result.success) {
      onClose()
    } else {
      setError(result.error || 'Erreur lors de la modification')
    }
  }

  const handleToggleBranch = (branchId: string) => {
    setSelectedBranchIds(prev =>
      prev.includes(branchId)
        ? prev.filter(id => id !== branchId)
        : [...prev, branchId]
    )
  }

  // Filter branches based on user level
  const availableBranches = currentUserLevel < 5
    ? branches
    : branches.filter(b => currentUserBranchIds.includes(b.id))

  // Build role options from dynamic roles
  const roleOptions = useMemo(() => {
    return assignableRoles.map(role => ({
      value: role.id,
      label: role.display_name,
      color: role.color
    }))
  }, [assignableRoles])

  if (!isOpen || !user) return null

  // Loading state for roles
  if (rolesLoading) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
        <div className={`relative w-full max-w-md rounded-2xl shadow-2xl p-8 ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
          <div className="flex items-center justify-center">
            <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 overflow-y-auto">
      <div className={`relative w-full max-w-2xl my-8 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
        <div className={`flex items-center justify-between p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <h2 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            Modifier l'utilisateur
          </h2>
          <button
            onClick={onClose}
            disabled={loading}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'hover:bg-gray-700 text-gray-400 hover:text-white'
                : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
            } disabled:opacity-50`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {error && (
            <div className={`p-4 rounded-lg border flex items-start gap-2 ${
              isDark
                ? 'bg-red-500/10 border-red-500/50 text-red-400'
                : 'bg-red-50 border-red-200 text-red-600'
            }`}>
              <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
              <span>{error}</span>
            </div>
          )}

          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                <User className="w-4 h-4 inline mr-1" />
                Prénom *
              </label>
              <input
                type="text"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white'
                    : 'bg-white border-gray-300 text-gray-900'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              />
            </div>
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                Nom *
              </label>
              <input
                type="text"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white'
                    : 'bg-white border-gray-300 text-gray-900'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              />
            </div>
          </div>

          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Phone className="w-4 h-4 inline mr-1" />
              Téléphone *
            </label>
            <input
              type="tel"
              value={phone}
              onChange={(e) => {
                const newPhone = e.target.value
                setPhone(newPhone)
                const newErrors = { ...validationErrors }
                if (newPhone.trim() && !validateIsraeliPhone(newPhone)) {
                  newErrors.phone = VALIDATION_MESSAGES.phone.israeliFormat
                } else {
                  delete newErrors.phone
                }
                setValidationErrors(newErrors)
              }}
              required
              className={`w-full px-3 py-2 rounded-lg border ${
                validationErrors.phone
                  ? 'border-red-500'
                  : isDark
                  ? 'bg-gray-700 border-gray-600 text-white'
                  : 'bg-white border-gray-300 text-gray-900'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="05XXXXXXXX"
            />
            {validationErrors.phone && (
              <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>{validationErrors.phone}</span>
              </div>
            )}
          </div>

          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Mail className="w-4 h-4 inline mr-1" />
              Email (identifiant)
            </label>
            <input
              type="email"
              value={email}
              onChange={(e) => {
                const newEmail = e.target.value
                setEmail(newEmail)
                const newErrors = { ...validationErrors }
                if (newEmail.trim() && newEmail.trim() !== user.email && !validateEmail(newEmail.trim())) {
                  newErrors.email = VALIDATION_MESSAGES.email.invalid
                } else {
                  delete newErrors.email
                }
                setValidationErrors(newErrors)
              }}
              className={`w-full px-3 py-2 rounded-lg border ${
                validationErrors.email
                  ? 'border-red-500'
                  : isDark
                  ? 'bg-gray-700 border-gray-600 text-white'
                  : 'bg-white border-gray-300 text-gray-900'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="exemple@email.com"
            />
            {validationErrors.email && (
              <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>{validationErrors.email}</span>
              </div>
            )}
            <p className={`text-xs mt-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
              Laissez vide pour ne pas modifier. L'email sert d'identifiant de connexion.
            </p>
          </div>

          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Lock className="w-4 h-4 inline mr-1" />
              Nouveau mot de passe
            </label>
            <input
              type="password"
              value={password}
              onChange={(e) => {
                const newPassword = e.target.value
                setPassword(newPassword)
                const newErrors = { ...validationErrors }
                if (newPassword.trim() && newPassword.length < 6) {
                  newErrors.password = 'Le mot de passe doit contenir au moins 6 caractères'
                } else {
                  delete newErrors.password
                }
                setValidationErrors(newErrors)
              }}
              className={`w-full px-3 py-2 rounded-lg border ${
                validationErrors.password
                  ? 'border-red-500'
                  : isDark
                  ? 'bg-gray-700 border-gray-600 text-white'
                  : 'bg-white border-gray-300 text-gray-900'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="Laissez vide pour ne pas modifier"
            />
            {validationErrors.password && (
              <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>{validationErrors.password}</span>
              </div>
            )}
            <p className={`text-xs mt-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
              Laissez vide pour ne pas modifier le mot de passe. Minimum 6 caractères.
            </p>
          </div>

          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Shield className="w-4 h-4 inline mr-1" />
              Rôle *
            </label>
            <CustomSelect
              value={selectedRoleId}
              onChange={(value) => setSelectedRoleId(value)}
              options={roleOptions}
              isDark={isDark}
            />
            {assignableRoles.length === 0 && (
              <p className={`text-xs mt-1 ${isDark ? 'text-yellow-400' : 'text-yellow-600'}`}>
                Aucun rôle disponible pour l'assignation
              </p>
            )}
          </div>

          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Building2 className="w-4 h-4 inline mr-1" />
              Branche(s) *
            </label>
            <div className={`border rounded-lg p-3 space-y-2 max-h-40 overflow-y-auto ${
              isDark ? 'border-gray-600 bg-gray-700' : 'border-gray-300 bg-gray-50'
            }`}>
              {availableBranches.map(branch => (
                <label
                  key={branch.id}
                  className="flex items-center gap-2 cursor-pointer"
                >
                  <input
                    type="checkbox"
                    checked={selectedBranchIds.includes(branch.id)}
                    onChange={() => handleToggleBranch(branch.id)}
                    className="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  />
                  <span className={isDark ? 'text-white' : 'text-gray-900'}>
                    {branch.name}
                  </span>
                </label>
              ))}
            </div>
          </div>

          <div className={`flex items-center justify-end gap-3 pt-4 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className={`px-4 py-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              } disabled:opacity-50`}
            >
              Annuler
            </button>
            <button
              type="submit"
              disabled={loading || Object.keys(validationErrors).length > 0}
              className="px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Enregistrement...
                </>
              ) : (
                <>
                  <Save className="w-4 h-4" />
                  Enregistrer
                </>
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/app/api/auth/log/route.ts">
/**
 * API Route pour logger les événements d'authentification
 * POST: Logger une connexion ou déconnexion
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { logUserAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import type { UserRole, Profile } from '@/lib/supabase/types'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { action } = body // 'login' ou 'logout'

    if (!action || !['login', 'logout'].includes(action)) {
      return NextResponse.json(
        { success: false, error: 'Invalid action' },
        { status: 400 }
      )
    }

    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      // Pour logout, on peut ne pas avoir d'utilisateur
      if (action === 'logout') {
        return NextResponse.json({ success: true })
      }
      return NextResponse.json(
        { success: false, error: 'Not authenticated' },
        { status: 401 }
      )
    }

    // Récupérer le profil
    const serviceClient = createServiceRoleClient()
    const { data: profile } = await serviceClient
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single<Profile>()

    if (!profile) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    const ipAddress = getClientIpFromHeaders(request.headers)

    // Logger l'action
    await logUserAction({
      userId: user.id,
      userRole: profile.role as UserRole,
      userName: `${profile.first_name || ''} ${profile.last_name || ''}`.trim(),
      action: action as 'login' | 'logout',
      targetUserId: user.id,
      targetUserName: `${profile.first_name || ''} ${profile.last_name || ''}`.trim(),
      details: {
        email: user.email,
        method: action === 'login' ? 'password' : undefined
      },
      ipAddress
    })

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Error logging auth event:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/branches/route.ts">
/**
 * API Route pour récupérer les branches
 * GET: Liste toutes les branches actives
 */

import { NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

const supabase = createClient(supabaseUrl, supabaseKey)

/**
 * GET /api/branches
 * Retourne toutes les branches actives
 */
export async function GET() {
  try {
    const { data: branches, error } = await supabase
      .from('branches')
      .select('id, slug, name, name_en, address, phone, is_active')
      .eq('is_active', true)
      .order('name')
    
    if (error) {
      console.error('Error fetching branches:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch branches' },
        { status: 500 }
      )
    }
    
    return NextResponse.json({
      success: true,
      branches
    })
    
  } catch (error) {
    console.error('Error fetching branches:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/contacts/[id]/bookings/route.ts">
/**
 * API Route pour récupérer les réservations liées à un contact
 * GET: Liste des réservations d'un contact
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'

/**
 * GET /api/contacts/[id]/bookings
 * Récupère les réservations liées à un contact
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('clients', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id: contactId } = await params
    const searchParams = request.nextUrl.searchParams
    const branchId = searchParams.get('branchId') || searchParams.get('branch_id')

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branchId is required', messageKey: 'errors.branchRequired' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // Récupérer les réservations via booking_contacts
    const { data: bookingContacts, error: bookingContactsError } = await supabase
      .from('booking_contacts')
      .select('booking_id')
      .eq('contact_id', contactId)
      .returns<Array<{ booking_id: string }>>()

    if (bookingContactsError) {
      console.error('Error fetching booking contacts:', bookingContactsError)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch booking links', messageKey: 'errors.fetchFailed' },
        { status: 500 }
      )
    }

    if (!bookingContacts || bookingContacts.length === 0) {
      return NextResponse.json({ success: true, bookings: [] })
    }

    const bookingIds = bookingContacts.map((bc) => bc.booking_id)

    // Récupérer les bookings avec leurs game_sessions
    const { data: bookings, error: bookingsError } = await supabase
      .from('bookings')
      .select('id, reference_code, type, status, start_datetime, end_datetime, participants_count, created_at, game_sessions(id, game_area)')
      .in('id', bookingIds)
      .eq('branch_id', branchId)
      .order('start_datetime', { ascending: false })

    if (bookingsError) {
      console.error('Error fetching bookings:', bookingsError)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch bookings', messageKey: 'errors.fetchFailed' },
        { status: 500 }
      )
    }

    return NextResponse.json({ success: true, bookings: bookings || [] })

  } catch (error) {
    console.error('Error in GET /api/contacts/[id]/bookings:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/contacts/[id]/stats/route.ts">
/**
 * API Route pour récupérer les statistiques d'un contact
 * GET: Stats d'un contact (nombre de réservations, participants, etc.)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'

interface BookingStat {
  id: string
  type: string
  status: string
  start_datetime: string
  participants_count: number
  created_at: string
}

/**
 * GET /api/contacts/[id]/stats
 * Récupère les statistiques d'un contact
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('clients', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id: contactId } = await params
    const searchParams = request.nextUrl.searchParams
    const branchId = searchParams.get('branchId') || searchParams.get('branch_id')

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branchId is required', messageKey: 'errors.branchRequired' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // Récupérer les réservations liées
    const { data: bookingContacts, error: bookingContactsError } = await supabase
      .from('booking_contacts')
      .select('booking_id')
      .eq('contact_id', contactId)
      .returns<Array<{ booking_id: string }>>()

    if (bookingContactsError) {
      console.error('Error fetching booking contacts:', bookingContactsError)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch stats', messageKey: 'errors.fetchFailed' },
        { status: 500 }
      )
    }

    // Si pas de réservations, retourner des stats vides
    if (!bookingContacts || bookingContacts.length === 0) {
      return NextResponse.json({
        success: true,
        stats: {
          totalBookings: 0,
          totalParticipants: 0,
          upcomingBookings: 0,
          pastBookings: 0,
          lastActivity: null,
          firstBooking: null,
          gameBookings: 0,
          eventBookings: 0,
        }
      })
    }

    const bookingIds = bookingContacts.map((bc) => bc.booking_id)
    const now = new Date().toISOString()

    // Récupérer les bookings avec stats
    const { data: bookings, error: bookingsError } = await supabase
      .from('bookings')
      .select('id, type, status, start_datetime, participants_count, created_at')
      .in('id', bookingIds)
      .eq('branch_id', branchId)
      .returns<BookingStat[]>()

    if (bookingsError) {
      console.error('Error fetching bookings:', bookingsError)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch stats', messageKey: 'errors.fetchFailed' },
        { status: 500 }
      )
    }

    const bookingsList = bookings || []
    const totalBookings = bookingsList.length
    const totalParticipants = bookingsList.reduce((sum, b) => sum + (b.participants_count || 0), 0)

    const upcomingBookings = bookingsList.filter((b) => b.start_datetime > now && b.status !== 'CANCELLED').length
    const pastBookings = bookingsList.filter((b) => b.start_datetime <= now || b.status === 'CANCELLED').length

    const gameBookings = bookingsList.filter((b) => b.type === 'GAME').length
    const eventBookings = bookingsList.filter((b) => b.type === 'EVENT').length

    // Dernière activité (dernière réservation)
    const sortedByDate = [...bookingsList].sort((a, b) =>
      new Date(b.start_datetime).getTime() - new Date(a.start_datetime).getTime()
    )
    const lastActivity = sortedByDate.length > 0 ? sortedByDate[0].start_datetime : null

    // Première réservation
    const sortedByCreated = [...bookingsList].sort((a, b) =>
      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    )
    const firstBooking = sortedByCreated.length > 0 ? sortedByCreated[0].created_at : null

    return NextResponse.json({
      success: true,
      stats: {
        totalBookings,
        totalParticipants,
        upcomingBookings,
        pastBookings,
        lastActivity,
        firstBooking,
        gameBookings,
        eventBookings,
      }
    })

  } catch (error) {
    console.error('Error in GET /api/contacts/[id]/stats:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/debug/settings/route.ts">
/**
 * API Debug - Vérifier et corriger les settings
 * GET /api/debug/settings?branch_id=xxx
 * PATCH /api/debug/settings - Corriger les settings
 */
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

// Corriger les settings
export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json()
    
    if (body.action === 'fix_duration') {
      // Corriger game_duration_minutes à 30 pour toutes les branches
      const { data, error } = await supabase
        .from('branch_settings')
        .update({ game_duration_minutes: 30 })
        .neq('game_duration_minutes', 30)
        .select()
      
      if (error) {
        return NextResponse.json({ error: 'Failed to update', details: error }, { status: 500 })
      }
      
      return NextResponse.json({ 
        success: true, 
        message: 'game_duration_minutes mis à jour à 30 minutes',
        updated: data?.length || 0
      })
    }
    
    if (body.branch_id && body.settings) {
      // Mise à jour personnalisée
      const { data, error } = await supabase
        .from('branch_settings')
        .update(body.settings)
        .eq('branch_id', body.branch_id)
        .select()
      
      if (error) {
        return NextResponse.json({ error: 'Failed to update', details: error }, { status: 500 })
      }
      
      return NextResponse.json({ success: true, updated: data })
    }
    
    return NextResponse.json({ error: 'Invalid request. Use action: "fix_duration" or provide branch_id + settings' }, { status: 400 })
    
  } catch (error) {
    console.error('PATCH error:', error)
    return NextResponse.json({ error: 'Internal error', details: String(error) }, { status: 500 })
  }
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const branchId = searchParams.get('branch_id')
  
  try {
    // Récupérer toutes les branches
    const { data: branches, error: branchesError } = await supabase
      .from('branches')
      .select('id, name')
    
    if (branchesError) {
      return NextResponse.json({ error: 'Failed to fetch branches', details: branchesError }, { status: 500 })
    }
    
    // Récupérer tous les settings
    const { data: allSettings, error: settingsError } = await supabase
      .from('branch_settings')
      .select('*')
    
    if (settingsError) {
      return NextResponse.json({ error: 'Failed to fetch settings', details: settingsError }, { status: 500 })
    }
    
    // Si branch_id spécifié, filtrer
    const settings = branchId 
      ? allSettings?.filter(s => s.branch_id === branchId)
      : allSettings
    
    // Récupérer les salles laser
    const { data: laserRooms } = await supabase
      .from('laser_rooms')
      .select('*')
      .order('branch_id, sort_order')
    
    // Récupérer les salles event
    const { data: eventRooms } = await supabase
      .from('event_rooms')
      .select('*')
      .order('branch_id, sort_order')
    
    // Formater les settings pour affichage
    const formattedSettings = settings?.map(s => ({
      branch_id: s.branch_id,
      branch_name: branches?.find(b => b.id === s.branch_id)?.name || 'Unknown',
      game_duration_minutes: s.game_duration_minutes,
      event_total_duration_minutes: s.event_total_duration_minutes,
      event_buffer_before_minutes: s.event_buffer_before_minutes,
      event_buffer_after_minutes: s.event_buffer_after_minutes,
      max_concurrent_players: s.max_concurrent_players,
      laser_total_vests: s.laser_total_vests,
      laser_spare_vests: s.laser_spare_vests,
      laser_exclusive_threshold: s.laser_exclusive_threshold,
      opening_time: s.opening_time,
      closing_time: s.closing_time,
    }))
    
    return NextResponse.json({
      branches,
      settings: formattedSettings,
      laser_rooms: laserRooms,
      event_rooms: eventRooms,
      message: 'Configuration actuelle de la base de données'
    })
    
  } catch (error) {
    console.error('Debug settings error:', error)
    return NextResponse.json({ error: 'Internal error', details: String(error) }, { status: 500 })
  }
}
</file>

<file path="src/app/api/logs/route.ts">
/**
 * API Logs - Activity Logs Management
 *
 * GET /api/logs - List logs with filters
 * DELETE /api/logs - Delete logs (super_admin only)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logLogDeletion, getClientIpFromHeaders } from '@/lib/activity-logger'

/**
 * GET /api/logs
 * List activity logs with optional filters
 */
export async function GET(request: NextRequest) {
  try {
    // Vérifier les permissions via le système de permissions de la base de données
    const { success, user, errorResponse } = await verifyApiPermission('logs', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const supabase = await createClient()
    const userProfile = { role: user.role }

    // Parse query parameters
    const searchParams = request.nextUrl.searchParams
    const branchId = searchParams.get('branch_id')
    const actionType = searchParams.get('action_type')
    const targetType = searchParams.get('target_type')
    const userRole = searchParams.get('user_role')
    const userId = searchParams.get('user_id')
    const dateFrom = searchParams.get('date_from')
    const dateTo = searchParams.get('date_to')
    const search = searchParams.get('search')
    const limit = parseInt(searchParams.get('limit') || '500')
    const offset = parseInt(searchParams.get('offset') || '0')

    // Use service role client to bypass RLS for more flexible querying
    const serviceClient = createServiceRoleClient()

    let query = serviceClient
      .from('activity_logs')
      .select(`
        *,
        branch:branches(id, name, name_en)
      `)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    // Apply filters

    // For non-super_admin, always filter by their branches
    if (userProfile.role !== 'super_admin') {
      // Get user's branches from the already loaded user data
      const branchIds = user.branchIds || []
      if (branchIds.length > 0) {
        query = query.in('branch_id', branchIds)
      } else {
        // No branches = no logs
        return NextResponse.json({
          success: true,
          logs: [],
          total: 0
        })
      }
    } else if (branchId) {
      // Super admin can filter by specific branch
      query = query.eq('branch_id', branchId)
    }

    if (actionType) {
      query = query.eq('action_type', actionType)
    }

    if (targetType) {
      query = query.eq('target_type', targetType)
    }

    if (userRole) {
      query = query.eq('user_role', userRole)
    }

    if (userId) {
      query = query.eq('user_id', userId)
    }

    if (dateFrom) {
      query = query.gte('created_at', new Date(dateFrom).toISOString())
    }

    if (dateTo) {
      // Add 1 day to include the entire end date
      const endDate = new Date(dateTo)
      endDate.setDate(endDate.getDate() + 1)
      query = query.lt('created_at', endDate.toISOString())
    }

    if (search) {
      // Search in user_name, target_name, or details
      query = query.or(`user_name.ilike.%${search}%,target_name.ilike.%${search}%`)
    }

    const { data: logs, error } = await query

    if (error) {
      console.error('Error fetching logs:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch logs' },
        { status: 500 }
      )
    }

    // Get total count for pagination (without limit/offset)
    let countQuery = serviceClient
      .from('activity_logs')
      .select('id', { count: 'exact', head: true })

    if (userProfile.role !== 'super_admin') {
      const branchIds = user.branchIds || []
      if (branchIds.length > 0) {
        countQuery = countQuery.in('branch_id', branchIds)
      }
    } else if (branchId) {
      countQuery = countQuery.eq('branch_id', branchId)
    }

    const { count } = await countQuery

    return NextResponse.json({
      success: true,
      logs: logs || [],
      total: count || 0
    })

  } catch (error) {
    console.error('Error in logs API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/logs
 * Delete activity logs (super_admin only)
 */
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Get user profile
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role, first_name, last_name')
      .eq('id', user.id)
      .single()

    if (profileError || !profile) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    const userProfile = profile as { role: string; first_name: string; last_name: string }

    // Only super_admin can delete logs
    if (userProfile.role !== 'super_admin') {
      return NextResponse.json(
        { success: false, error: 'Only super admin can delete logs' },
        { status: 403 }
      )
    }

    const body = await request.json()
    const { ids } = body

    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No log IDs provided' },
        { status: 400 }
      )
    }

    // Use service role client to delete
    const serviceClient = createServiceRoleClient()

    const { error } = await serviceClient
      .from('activity_logs')
      .delete()
      .in('id', ids)

    if (error) {
      console.error('Error deleting logs:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to delete logs' },
        { status: 500 }
      )
    }

    // Log this deletion action
    const ipAddress = getClientIpFromHeaders(request.headers)
    await logLogDeletion({
      userId: user.id,
      userRole: userProfile.role as 'super_admin',
      userName: `${userProfile.first_name} ${userProfile.last_name}`,
      deletedLogIds: ids,
      ipAddress
    })

    return NextResponse.json({
      success: true,
      deleted_count: ids.length
    })

  } catch (error) {
    console.error('Error in logs delete API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/permissions/route.ts">
/**
 * API Permissions - Role Permissions Management
 *
 * GET /api/permissions - List all role permissions
 * PATCH /api/permissions - Update a permission (super_admin only)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { logPermissionChange, getClientIpFromHeaders } from '@/lib/activity-logger'
import type { UserRole, ResourceType } from '@/lib/supabase/types'

/**
 * GET /api/permissions
 * List role permissions
 * - Super admin: returns all permissions (for admin page)
 * - Other users: returns only permissions for their role (for UI visibility)
 */
export async function GET() {
  try {
    const supabase = await createClient()

    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Get user profile
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (profileError || !profile) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    const userProfile = profile as { role: string }

    // Use service role client to fetch permissions
    const serviceClient = createServiceRoleClient()

    // Super admin gets all permissions (for the admin permissions page)
    // Other users get only their role's permissions (for UI visibility)
    let query = serviceClient
      .from('role_permissions')
      .select('*')
      .order('role')
      .order('resource')

    // Non-super_admin users only see their own role's permissions
    if (userProfile.role !== 'super_admin') {
      query = query.eq('role', userProfile.role)
    }

    const { data: permissions, error } = await query

    if (error) {
      console.error('Error fetching permissions:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch permissions' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      permissions: permissions || []
    })

  } catch (error) {
    console.error('Error in permissions API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * PATCH /api/permissions
 * Update a permission (super_admin only)
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Get user profile
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role, first_name, last_name')
      .eq('id', user.id)
      .single()

    if (profileError || !profile) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    const userProfile = profile as { role: string; first_name: string; last_name: string }

    // Only super_admin can update permissions
    if (userProfile.role !== 'super_admin') {
      return NextResponse.json(
        { success: false, error: 'Only super admin can update permissions' },
        { status: 403 }
      )
    }

    const body = await request.json()
    const { id, can_view, can_create, can_edit, can_delete } = body

    if (!id) {
      return NextResponse.json(
        { success: false, error: 'Permission ID is required' },
        { status: 400 }
      )
    }

    // Use service role client to update
    const serviceClient = createServiceRoleClient()

    // Get current permission to log the change
    const { data: currentPerm, error: permError } = await serviceClient
      .from('role_permissions')
      .select('*')
      .eq('id', id)
      .single()

    if (permError || !currentPerm) {
      return NextResponse.json(
        { success: false, error: 'Permission not found' },
        { status: 404 }
      )
    }

    const currentPermission = currentPerm as {
      id: string
      role: string
      resource: string
      can_view: boolean
      can_create: boolean
      can_edit: boolean
      can_delete: boolean
    }

    // Build update object
    const updates: Record<string, boolean> = {}
    const changes: Record<string, boolean> = {}

    if (typeof can_view === 'boolean' && can_view !== currentPermission.can_view) {
      updates.can_view = can_view
      changes.can_view = can_view
    }
    if (typeof can_create === 'boolean' && can_create !== currentPermission.can_create) {
      updates.can_create = can_create
      changes.can_create = can_create
    }
    if (typeof can_edit === 'boolean' && can_edit !== currentPermission.can_edit) {
      updates.can_edit = can_edit
      changes.can_edit = can_edit
    }
    if (typeof can_delete === 'boolean' && can_delete !== currentPermission.can_delete) {
      updates.can_delete = can_delete
      changes.can_delete = can_delete
    }

    if (Object.keys(updates).length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No changes to apply'
      })
    }

    const { error } = await (serviceClient as any)
      .from('role_permissions')
      .update(updates)
      .eq('id', id)

    if (error) {
      console.error('Error updating permission:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to update permission' },
        { status: 500 }
      )
    }

    // Log the permission change
    const ipAddress = getClientIpFromHeaders(request.headers)
    await logPermissionChange({
      userId: user.id,
      userRole: userProfile.role as UserRole,
      userName: `${userProfile.first_name} ${userProfile.last_name}`,
      targetRole: currentPermission.role as UserRole,
      resource: currentPermission.resource as ResourceType,
      changes,
      ipAddress
    })

    return NextResponse.json({
      success: true,
      updated: true
    })

  } catch (error) {
    console.error('Error in permissions update API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/globals.css">
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&family=Poppins:wght@300;400;500;600;700&family=Roboto:wght@400;500;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary: #00f0ff;
  --secondary: #ff00ff;
  --accent: #ffff00;
  --dark: #0a0a0a;
  --dark-100: #1a1a1a;
  --dark-200: #2a2a2a;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
}

body {
  background-color: var(--dark);
  color: white;
  font-family: 'Poppins', 'Inter', system-ui, sans-serif;
  overflow-x: hidden;
}

/* RTL Support for Hebrew */
[dir="rtl"] {
  text-align: right;
}

[dir="rtl"] .text-left {
  text-align: right;
}

[dir="rtl"] .text-right {
  text-align: left;
}

/* Neon Text Effects */
.neon-text {
  text-shadow: 
    0 0 5px var(--primary),
    0 0 10px var(--primary),
    0 0 20px var(--primary),
    0 0 40px var(--primary);
}

.neon-text-magenta {
  text-shadow: 
    0 0 5px var(--secondary),
    0 0 10px var(--secondary),
    0 0 20px var(--secondary);
}

/* Neon Border Effects */
.neon-border {
  box-shadow: 
    0 0 5px var(--primary),
    0 0 10px var(--primary),
    inset 0 0 5px rgba(0, 240, 255, 0.1);
  border: 1px solid var(--primary);
}

.neon-border-magenta {
  box-shadow: 
    0 0 5px var(--secondary),
    0 0 10px var(--secondary),
    inset 0 0 5px rgba(255, 0, 255, 0.1);
  border: 1px solid var(--secondary);
}

/* Glow Button */
.glow-button {
  position: relative;
  background: linear-gradient(135deg, var(--primary), var(--secondary));
  border: none;
  padding: 12px 32px;
  border-radius: 50px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.3s ease;
  overflow: hidden;
}

.glow-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  transition: left 0.5s ease;
}

.glow-button:hover::before {
  left: 100%;
}

.glow-button:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 0 20px var(--primary),
    0 0 40px var(--secondary);
}

/* Gradient Text */
.gradient-text {
  background: linear-gradient(135deg, var(--primary), var(--secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Card Hover Effect */
.game-card {
  position: relative;
  overflow: hidden;
  border-radius: 16px;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.game-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    180deg,
    transparent 0%,
    rgba(0, 0, 0, 0.8) 100%
  );
  z-index: 1;
  opacity: 0.7;
  transition: opacity 0.3s ease;
}

.game-card:hover::before {
  opacity: 0.9;
}

.game-card:hover {
  transform: translateY(-10px);
  box-shadow: 
    0 20px 40px rgba(0, 240, 255, 0.2),
    0 0 20px rgba(255, 0, 255, 0.1);
}

/* Video Container */
.video-container {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.video-container video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--dark-100);
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(var(--primary), var(--secondary));
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--primary);
}

/* Animations */
@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 20px var(--primary);
  }
  50% {
    box-shadow: 0 0 40px var(--primary), 0 0 60px var(--secondary);
  }
}

@keyframes scan-line {
  0% {
    transform: translateY(-100%);
  }
  100% {
    transform: translateY(100vh);
  }
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

.animate-pulse-glow {
  animation: pulse-glow 2s ease-in-out infinite;
}

/* Section Styling */
.section-title {
  font-family: 'Orbitron', sans-serif;
  font-weight: 700;
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: #FFFFFF;
  text-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 40px rgba(8, 247, 254, 0.55), 0 0 60px rgba(255, 0, 229, 0.3);
}

@media (min-width: 768px) {
  .section-title {
    font-size: 3.5rem;
  }
}

/* Select Styling - Styles globaux pour le site public uniquement */
/* Note: Les styles admin utilisent des classes Tailwind spécifiques qui override ces styles */
select {
  background-color: rgba(50, 50, 70, 0.7);
  background-image: none;
  color: #00f0ff;
  border: 2px solid rgba(0, 240, 255, 0.3);
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  cursor: pointer;
}

select::-ms-expand {
  display: none;
}

select option {
  background-color: rgba(50, 50, 70, 0.95);
  color: #00f0ff;
  padding: 12px 16px;
  border: none;
  font-weight: 600;
  font-family: 'Orbitron', 'Poppins', sans-serif;
}

select option:hover {
  background-color: rgba(0, 240, 255, 0.2);
}

select option:checked,
select option:focus {
  background-color: rgba(0, 240, 255, 0.3);
  color: #00f0ff;
}

select:focus {
  outline: none;
  border-color: rgba(0, 240, 255, 0.7);
  box-shadow: 0 0 15px rgba(0, 240, 255, 0.4);
  background-color: rgba(50, 50, 70, 0.9);
}

select:hover {
  border-color: rgba(0, 240, 255, 0.7);
  box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
}

/* Admin Time Select - Override des styles globaux pour les selects d'heure dans l'admin */
/* Ces styles ont une spécificité élevée pour override les styles globaux select:focus et select:hover */
.admin-time-select:focus {
  outline: none !important;
  border-color: #3b82f6 !important;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5) !important;
  /* Le background-color est géré par les classes Tailwind (bg-white ou bg-gray-700) */
}

.admin-time-select:hover {
  border-color: #60a5fa !important;
  box-shadow: none !important;
  /* Le background-color est géré par les classes Tailwind */
}

.admin-time-select option {
  /* Les couleurs des options sont gérées par les classes Tailwind du select parent */
}

/* Month Selector Specific Styling */
.month-selector {
  background-color: rgba(50, 50, 70, 0.7) !important;
  color: #00f0ff !important;
  border: 2px solid rgba(0, 240, 255, 0.3) !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  appearance: none !important;
  font-family: 'Orbitron', sans-serif !important;
  font-weight: 700 !important;
  text-shadow: 0 0 8px rgba(0, 240, 255, 0.6) !important;
}

.month-selector option {
  background-color: rgba(50, 50, 70, 0.95) !important;
  color: #00f0ff !important;
  font-family: 'Orbitron', sans-serif !important;
  font-weight: 600 !important;
  padding: 12px 16px !important;
}

.month-selector option:hover,
.month-selector option:focus,
.month-selector option:checked {
  background-color: rgba(0, 240, 255, 0.3) !important;
  color: #00f0ff !important;
}

.month-selector:focus {
  outline: none !important;
  border-color: rgba(0, 240, 255, 0.7) !important;
  box-shadow: 0 0 15px rgba(0, 240, 255, 0.4) !important;
  background-color: rgba(50, 50, 70, 0.9) !important;
}

.month-selector:hover {
  border-color: rgba(0, 240, 255, 0.7) !important;
  box-shadow: 0 0 10px rgba(0, 240, 255, 0.3) !important;
}

/* Hide default number input spinners */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type="number"] {
  -moz-appearance: textfield;
}

/* Form Styling */
.form-input {
  background: var(--dark-100);
  border: 1px solid var(--dark-200);
  border-radius: 8px;
  padding: 12px 16px;
  color: white;
  width: 100%;
  transition: all 0.3s ease;
}

.form-input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
}

.form-input::placeholder {
  color: #666;
}

/* Modal/Popup Styling */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(10px);
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: var(--dark-100);
  border: 1px solid var(--primary);
  border-radius: 20px;
  max-width: 800px;
  width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
}

/* WhatsApp Button */
.whatsapp-float {
  position: fixed;
  bottom: 30px;
  right: 30px;
  width: 60px;
  height: 60px;
  background: #25d366;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 20px rgba(37, 211, 102, 0.4);
  z-index: 99;
  transition: all 0.3s ease;
}

.whatsapp-float:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 30px rgba(37, 211, 102, 0.6);
}

[dir="rtl"] .whatsapp-float {
  right: auto;
  left: 30px;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'Active Games - New Generation Leisure Activities',
  description: 'Fully immersive interactive arenas, where neon lighting, sound, and physical challenges combine to create unique experiences.',
  keywords: ['active games', 'interactive games', 'LED games', 'entertainment', 'franchise', 'laser', 'arena'],
  authors: [{ name: 'Active Games World' }],
  openGraph: {
    title: 'Active Games - New Generation Leisure Activities',
    description: 'Fully immersive interactive arenas, where neon lighting, sound, and physical challenges combine to create unique experiences.',
    url: 'https://activegamesworld.com',
    siteName: 'Active Games',
    type: 'website',
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" dir="ltr" suppressHydrationWarning>
      <body className="antialiased" suppressHydrationWarning>
        {children}
      </body>
    </html>
  )
}
</file>

<file path="src/app/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import {
  Header,
  HeroSection,
  ConceptSection,
  GamesSection,
  PricingSection,
  BranchesSection,
  ContactSection,
  Footer,
  WhatsAppButton,
} from '@/components'
import { getTranslations, getDirection, Locale, defaultLocale } from '@/i18n'

export default function Home() {
  const [locale, setLocale] = useState<Locale>(defaultLocale)
  const [translations, setTranslations] = useState(getTranslations(defaultLocale))

  useEffect(() => {
    // Check for saved locale preference
    if (typeof window !== 'undefined') {
      const savedLocale = localStorage.getItem('locale') as Locale
      if (savedLocale && ['en', 'he'].includes(savedLocale)) {
        setLocale(savedLocale)
        setTranslations(getTranslations(savedLocale))
      }
    }
  }, [])

  const handleLocaleChange = (newLocale: Locale) => {
    setLocale(newLocale)
    setTranslations(getTranslations(newLocale))
    localStorage.setItem('locale', newLocale)
    
    // Update document direction for RTL support
    document.documentElement.dir = getDirection(newLocale)
    document.documentElement.lang = newLocale
  }

  const isRTL = locale === 'he'

  return (
    <div dir={getDirection(locale)}>
      <Header 
        translations={translations} 
        locale={locale} 
        onLocaleChange={handleLocaleChange} 
      />
      
      <main>
        <HeroSection translations={translations} />
        <ConceptSection translations={translations} />
        <GamesSection translations={translations} />
        <PricingSection translations={translations} isRTL={isRTL} />
        <BranchesSection translations={translations} />
        <ContactSection translations={translations} />
      </main>

      <Footer translations={translations} />
      <WhatsAppButton />
    </div>
  )
}
</file>

<file path="src/components/BranchesSection.tsx">
'use client'

import { motion } from 'framer-motion'
import { MapPin } from 'lucide-react'
import Image from 'next/image'

interface BranchesSectionProps {
  translations: {
    branches: {
      title: string
      subtitle: string
      items: Array<{
        name: string
        address: string
        city: string
        phone: string
        venue: string
      }>
    }
  }
}

export default function BranchesSection({ translations }: BranchesSectionProps) {
  if (!translations?.branches) {
    return null
  }

  return (
    <section id="branches" className="py-10 md:py-16 relative overflow-hidden" style={{
      background: 'linear-gradient(135deg, rgba(0, 240, 255, 0.7) 0%, rgba(0, 240, 255, 0.6) 25%, rgba(0, 200, 255, 0.7) 50%, rgba(0, 240, 255, 0.6) 75%, rgba(0, 240, 255, 0.8) 100%)'
    }}>
      {/* Wave separator from previous section */}
      <div className="absolute top-0 left-0 right-0" style={{ transform: 'translateY(-100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,60 Q300,20 600,60 T1200,60 L1200,120 L0,120 Z" fill="rgba(0, 240, 255, 0.7)" />
        </svg>
      </div>
      
      {/* Background decorative elements */}
      <div className="absolute inset-0 opacity-95">
        <div className="absolute top-0 right-1/4 w-[700px] h-[700px] bg-primary/60 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '4s', animationDelay: '1s' }} />
        <div className="absolute bottom-0 left-1/4 w-[700px] h-[700px] bg-primary/50 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '5s' }} />
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[900px] h-[900px] bg-primary/40 rounded-full blur-[350px]" />
      </div>
      
      <div className="container mx-auto px-4 relative z-10">
        {/* Section Header */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          className="text-center mb-12"
        >
          <h2 className="section-title">{translations.branches.title}</h2>
          <p className="text-white max-w-2xl mx-auto text-lg" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
            {translations.branches.subtitle}
          </p>
        </motion.div>

        {/* Branches Grid */}
        <div className="max-w-4xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-6">
          {translations.branches.items.map((branch, index) => (
            <motion.div
              key={index}
              initial={{ opacity: 0, y: 30 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
              transition={{ delay: index * 0.1 }}
              className="backdrop-blur-sm rounded-xl p-6 border border-primary/30 hover:border-primary/50 transition-all duration-300 hover:shadow-[0_0_20px_rgba(0,240,255,0.2)]"
              style={{ backgroundColor: 'rgba(50, 50, 70, 0.7)' }}
            >
              <div className="flex items-start gap-4 w-full">
                <div className="w-12 h-12 bg-primary/20 rounded-full flex items-center justify-center flex-shrink-0">
                  <MapPin className="w-6 h-6 text-primary" />
                </div>
                <div className="flex-1">
                  <h3 className="text-white font-bold text-xl mb-2" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {branch.name}
                  </h3>
                  <p className="text-gray-300 mb-1" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {branch.address}
                  </p>
                  <div className="flex items-center gap-6 mb-1">
                    <p className="text-primary font-medium text-base" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      {branch.venue}
                    </p>
                    <a 
                      href="https://laser-city.co.il" 
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="inline-block transition-opacity hover:opacity-90"
                      style={{ 
                        maxWidth: '120px', 
                        maxHeight: '42px',
                        opacity: 1,
                        filter: 'drop-shadow(0 0 8px rgba(0, 240, 255, 0.6)) brightness(1.2)'
                      }}
                      onClick={(e) => e.stopPropagation()}
                    >
                      <Image
                        src="/images/logo_laser_city.png"
                        alt="Laser City"
                        width={120}
                        height={42}
                        style={{ width: '120px', height: 'auto', maxWidth: '120px', display: 'block' }}
                        unoptimized
                      />
                    </a>
                  </div>
                  <a 
                    href={`tel:${branch.phone.replace(/[^\d]/g, '')}`}
                    className="text-primary hover:text-primary/80 transition-colors font-medium"
                    style={{ fontFamily: 'Poppins, sans-serif' }}
                  >
                    {branch.phone}
                  </a>
                </div>
              </div>
            </motion.div>
          ))}
        </div>
      </div>
      
      {/* Wave separator to next section */}
      <div className="absolute bottom-0 left-0 right-0" style={{ transform: 'translateY(100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,0 Q300,40 600,0 T1200,0 L1200,120 L0,120 Z" fill="rgba(0, 240, 255, 0.7)" />
        </svg>
      </div>
    </section>
  )
}
</file>

<file path="src/components/ConceptSection.tsx">
'use client'

import { Watch, Users, Clock, Gamepad2, Trophy, Zap } from 'lucide-react'

interface ConceptSectionProps {
  translations: {
    concept: {
      title: string
      intro: string
      features: {
        players: string
        duration: string
        bracelet: string
        rooms: string
        modes: string
        strategy: string
      }
      description: string[]
    }
  }
}

export default function ConceptSection({ translations }: ConceptSectionProps) {
  // Debug: vérifier que les traductions sont présentes
  if (!translations?.concept) {
    console.error('ConceptSection: translations.concept is missing', translations)
    return <section id="concept" className="py-20 md:py-32 bg-dark-100 min-h-[400px]"><div className="container mx-auto px-4"><p className="text-white">Loading translations...</p></div></section>
  }

  const features = [
    {
      icon: Users,
      text: translations.concept.features.players,
    },
    {
      icon: Clock,
      text: translations.concept.features.duration,
    },
    {
      icon: Watch,
      text: translations.concept.features.bracelet,
    },
    {
      icon: Gamepad2,
      text: translations.concept.features.rooms,
    },
    {
      icon: Trophy,
      text: translations.concept.features.modes,
    },
    {
      icon: Zap,
      text: translations.concept.features.strategy,
    },
  ]

  return (
    <section id="concept" className="py-10 md:py-16 min-h-[400px] w-full relative overflow-hidden" style={{
      background: 'linear-gradient(135deg, rgba(255, 0, 229, 0.7) 0%, rgba(255, 0, 255, 0.6) 25%, rgba(255, 50, 200, 0.7) 50%, rgba(255, 0, 255, 0.6) 75%, rgba(255, 0, 229, 0.8) 100%)'
    }}>
      {/* Background decorative elements */}
      <div className="absolute inset-0 opacity-95">
        <div className="absolute top-0 left-1/4 w-[700px] h-[700px] bg-secondary/60 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '4s' }} />
        <div className="absolute bottom-0 right-1/4 w-[700px] h-[700px] bg-secondary/50 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '5s', animationDelay: '1s' }} />
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[900px] h-[900px] bg-secondary/40 rounded-full blur-[350px]" />
      </div>
      
      <div className="container mx-auto px-4 relative z-10">
        {/* Section Header */}
        <div className="text-center mb-6">
          <h2 className="section-title">{translations.concept.title}</h2>
          <p className="text-white max-w-4xl mx-auto text-lg leading-relaxed" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
            {translations.concept.intro}
          </p>
        </div>

        {/* Features Grid - 2 lignes de 3 */}
        <div className="max-w-4xl mx-auto">
          <div className="grid grid-cols-3 gap-4 mb-12">
            {features.map((feature, index) => (
              <div
                key={index}
                className="backdrop-blur-sm rounded-xl p-4 text-center border border-primary/30 hover:border-primary/50 transition-all duration-300 hover:shadow-[0_0_20px_rgba(0,240,255,0.2)]"
                style={{ backgroundColor: 'rgba(50, 50, 70, 0.7)' }}
              >
                <feature.icon className="w-8 h-8 text-primary mx-auto mb-3" />
                <p className="text-gray-300 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>{feature.text}</p>
              </div>
            ))}
          </div>
        </div>

        {/* Description Paragraphs */}
        <div className="max-w-4xl mx-auto space-y-6">
          {translations.concept.description.map((paragraph, index) => (
            <p key={index} className="text-white leading-relaxed text-center md:text-start" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
              {paragraph}
            </p>
          ))}
        </div>
      </div>
      
      {/* Wave separator to next section */}
      <div className="absolute bottom-0 left-0 right-0" style={{ transform: 'translateY(100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,0 Q300,40 600,0 T1200,0 L1200,120 L0,120 Z" fill="rgba(0, 240, 255, 0.7)" />
        </svg>
      </div>
    </section>
  )
}
</file>

<file path="src/components/ErrorBoundary.tsx">
'use client'

import React from 'react'

interface ErrorBoundaryProps {
  children: React.ReactNode
}

interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends React.Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: { children: React.ReactNode }) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen bg-dark text-white flex items-center justify-center p-4">
          <div className="text-center">
            <h1 className="text-2xl font-bold mb-4 text-primary">Une erreur s'est produite</h1>
            <p className="text-gray-400 mb-4">
              Le site a rencontré un problème. Veuillez rafraîchir la page.
            </p>
            <button
              onClick={() => {
                this.setState({ hasError: false })
                window.location.reload()
              }}
              className="glow-button px-6 py-3 rounded-xl"
            >
              Rafraîchir la page
            </button>
            {this.state.error && (
              <details className="mt-4 text-left max-w-2xl mx-auto">
                <summary className="cursor-pointer text-gray-500">Détails de l'erreur</summary>
                <pre className="mt-2 text-xs text-gray-600 overflow-auto">
                  {this.state.error.toString()}
                </pre>
              </details>
            )}
          </div>
        </div>
      )
    }

    return this.props.children
  }
}
</file>

<file path="src/components/ErrorBoundaryWrapper.tsx">
'use client'

import { ErrorBoundary } from './ErrorBoundary'

export default function ErrorBoundaryWrapper({ children }: { children: React.ReactNode }) {
  return <ErrorBoundary>{children}</ErrorBoundary>
}
</file>

<file path="src/components/Footer.tsx">
'use client'

import Image from 'next/image'
import Link from 'next/link'
import { Mail, Phone, MapPin } from 'lucide-react'

interface FooterProps {
  translations: {
    footer: {
      games_title: string
      concept_title: string
      pricing_title: string
    }
    branches: {
      title: string
      items: Array<{
        name: string
        address: string
        city: string
        phone: string
        venue: string
      }>
    }
    contact: {
      info: {
        phone: string
        email: string
      }
    }
  }
}

export default function Footer({ translations }: FooterProps) {
  // Protection contre les traductions manquantes
  const branches = translations?.branches?.items || []
  const branch1 = branches[0]
  const branch2 = branches[1]
  const branchesTitle = translations?.branches?.title || 'Locations'
  const contactPhone = translations?.contact?.info?.phone || ''
  const contactEmail = translations?.contact?.info?.email || ''

  return (
    <footer className="bg-dark border-t border-dark-200 py-12">
      <div className="container mx-auto px-4">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
          {/* Logo + Laser City */}
          <div className="flex flex-col items-center space-y-4">
            <Link href="/" className="block">
              <Image
                src="/images/logo.png"
                alt="Active Games"
                width={250}
                height={65}
                className="h-auto w-auto"
                style={{
                  height: '65px',
                  width: 'auto',
                  filter: 'drop-shadow(0 0 8px rgba(0, 240, 255, 0.4)) brightness(1.15)'
                }}
              />
            </Link>
            <a
              href="https://laser-city.co.il"
              target="_blank"
              rel="noopener noreferrer"
              className="block transition-opacity hover:opacity-90"
              style={{
                opacity: 1,
                filter: 'drop-shadow(0 0 8px rgba(0, 240, 255, 0.6)) brightness(1.2)'
              }}
            >
              <Image
                src="/images/logo_laser_city.png"
                alt="Laser City"
                width={200}
                height={71}
                className="h-auto w-auto max-w-[200px]"
                unoptimized
              />
            </a>
          </div>

          {/* First Branch (Rishon LeZion) */}
          <div>
            <h4 className="text-white font-bold mb-4 text-sm uppercase tracking-wider">
              {branch1?.name || branchesTitle}
            </h4>
            {branch1 && (
              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <MapPin className="w-4 h-4 text-primary flex-shrink-0" />
                  <p className="text-gray-400 text-sm">{branch1.address}</p>
                </div>
                <p className="text-primary text-sm pl-6">{branch1.venue}</p>
                <a
                  href={`tel:${branch1.phone?.replace(/[^\d]/g, '') || ''}`}
                  className="flex items-center gap-2 text-gray-400 hover:text-primary transition-colors text-sm pl-6"
                >
                  <Phone className="w-3 h-3" />
                  {branch1.phone}
                </a>
              </div>
            )}
          </div>

          {/* Second Branch (Petah Tikva) */}
          <div>
            <h4 className="text-white font-bold mb-4 text-sm uppercase tracking-wider">
              {branch2?.name || ''}
            </h4>
            {branch2 && (
              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <MapPin className="w-4 h-4 text-primary flex-shrink-0" />
                  <p className="text-gray-400 text-sm">{branch2.address}</p>
                </div>
                <p className="text-primary text-sm pl-6">{branch2.venue}</p>
                <a
                  href={`tel:${branch2.phone?.replace(/[^\d]/g, '') || ''}`}
                  className="flex items-center gap-2 text-gray-400 hover:text-primary transition-colors text-sm pl-6"
                >
                  <Phone className="w-3 h-3" />
                  {branch2.phone}
                </a>
              </div>
            )}
          </div>

          {/* Contact */}
          <div>
            <h4 className="text-white font-bold mb-4 text-sm uppercase tracking-wider">
              Contact
            </h4>
            <ul className="space-y-3">
              {contactPhone && (
                <li>
                  <a
                    href={`tel:${contactPhone.replace(/\s/g, '')}`}
                    className="flex items-center gap-2 text-gray-400 hover:text-primary transition-colors text-sm"
                  >
                    <Phone className="w-4 h-4" />
                    {contactPhone}
                  </a>
                </li>
              )}
              {contactEmail && (
                <li>
                  <a
                    href={`mailto:${contactEmail}`}
                    className="flex items-center gap-2 text-gray-400 hover:text-primary transition-colors text-sm"
                  >
                    <Mail className="w-4 h-4" />
                    {contactEmail}
                  </a>
                </li>
              )}
            </ul>
          </div>
        </div>

        {/* Copyright */}
        <div className="border-t border-dark-200 mt-8 pt-8 text-center">
          <p className="text-gray-500 text-sm">
            © {new Date().getFullYear()} Active Games Rishon LeZion. All rights reserved.
          </p>
        </div>
      </div>
    </footer>
  )
}
</file>

<file path="src/components/FranchiseSection.tsx">
'use client'

import { motion } from 'framer-motion'
import { 
  TrendingUp, 
  Zap, 
  Rocket, 
  Globe, 
  DollarSign, 
  Flag 
} from 'lucide-react'

interface FranchiseSectionProps {
  translations: {
    franchise: {
      title: string
      subtitle: string
      description: string
      benefits: Array<{
        title: string
        description: string
      }>
    }
  }
}

const icons = [TrendingUp, Zap, Rocket, Globe, DollarSign, Flag]

export default function FranchiseSection({ translations }: FranchiseSectionProps) {
  return (
    <section className="py-20 md:py-32 bg-dark relative overflow-hidden">
      {/* Background Effect */}
      <div className="absolute inset-0 opacity-20">
        <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-br from-primary/10 via-transparent to-secondary/10" />
      </div>

      <div className="container mx-auto px-4 relative z-10">
        {/* Section Header */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          className="text-center mb-16"
        >
          <h2 className="section-title gradient-text">{translations.franchise.title}</h2>
          <p className="text-primary font-medium text-xl mb-6">
            {translations.franchise.subtitle}
          </p>
          <p className="text-gray-400 max-w-4xl mx-auto text-lg leading-relaxed">
            {translations.franchise.description}
          </p>
        </motion.div>

        {/* Benefits Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {translations.franchise.benefits.map((benefit, index) => {
            const Icon = icons[index % icons.length]
            
            return (
              <motion.div
                key={index}
                initial={{ opacity: 0, y: 30 }}
                whileInView={{ opacity: 1, y: 0 }}
                viewport={{ once: true }}
                transition={{ delay: index * 0.1 }}
                className="relative group"
              >
                <div className="bg-dark-100 p-6 rounded-2xl border border-dark-200 hover:border-primary/50 transition-all duration-300 h-full">
                  {/* Icon */}
                  <div className="w-12 h-12 bg-primary/10 rounded-lg flex items-center justify-center mb-4 group-hover:bg-primary/20 transition-colors">
                    <Icon className="w-6 h-6 text-primary" />
                  </div>

                  {/* Content */}
                  <h3 className="text-lg font-bold text-white mb-2">
                    {benefit.title}
                  </h3>
                  <p className="text-gray-400 text-sm leading-relaxed">
                    {benefit.description}
                  </p>
                </div>

                {/* Glow Effect on Hover */}
                <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-primary/0 via-primary/5 to-secondary/0 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none" />
              </motion.div>
            )
          })}
        </div>
      </div>
    </section>
  )
}
</file>

<file path="src/components/GamesSection.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import Image from 'next/image'
import { X, Volume2, VolumeX } from 'lucide-react'
import { localAssets } from '@/data/games'

interface GamesSectionProps {
  translations: {
    games: {
      title: string
      subtitle: string
      more_info: string
      items: Record<string, {
        name: string
        description: string
        popup_description: string
        features: string[]
      }>
    }
  }
}

export default function GamesSection({ translations }: GamesSectionProps) {
  const [selectedGame, setSelectedGame] = useState<string | null>(null)
  const [mutedVideos, setMutedVideos] = useState<Record<string, boolean>>({})
  const videoRefs = useRef<Record<string, HTMLVideoElement | null>>({})

  // Filtrer pour exclure "control" (8 jeux seulement pour le franchisé)
  const gameKeys = (Object.keys(localAssets.games) as Array<keyof typeof localAssets.games>)
    .filter(key => key !== 'control')

  const toggleMute = (gameKey: string, e: React.MouseEvent) => {
    e.stopPropagation()
    const video = videoRefs.current[gameKey]
    if (video) {
      video.muted = !video.muted
      setMutedVideos(prev => ({ ...prev, [gameKey]: video.muted }))
    }
  }

  return (
    <section id="games" className="py-10 md:py-16 relative overflow-hidden" style={{
      background: 'linear-gradient(135deg, rgba(0, 240, 255, 0.7) 0%, rgba(0, 240, 255, 0.6) 25%, rgba(0, 200, 255, 0.7) 50%, rgba(0, 240, 255, 0.6) 75%, rgba(0, 240, 255, 0.8) 100%)'
    }}>
      {/* Wave separator from previous section */}
      <div className="absolute top-0 left-0 right-0" style={{ transform: 'translateY(-100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,60 Q300,20 600,60 T1200,60 L1200,120 L0,120 Z" fill="rgba(0, 240, 255, 0.7)" />
        </svg>
      </div>
      
      {/* Background decorative elements */}
      <div className="absolute inset-0 opacity-95">
        <div className="absolute top-1/4 right-1/4 w-[700px] h-[700px] bg-primary/60 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '4s', animationDelay: '1s' }} />
        <div className="absolute bottom-1/4 left-1/4 w-[700px] h-[700px] bg-primary/50 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '5s' }} />
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[900px] h-[900px] bg-primary/40 rounded-full blur-[350px]" />
      </div>
      
      <div className="container mx-auto px-4 relative z-10">
        {/* Section Header */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          className="text-center mb-6"
        >
          <h2 className="section-title">{translations.games.title}</h2>
          <p className="text-white mx-auto text-lg" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)', lineHeight: '1.7', maxWidth: 'clamp(768px, 85vw, 1200px)', paddingLeft: 'clamp(40px, 6vw, 100px)', paddingRight: 'clamp(40px, 6vw, 100px)' }}>
            {translations.games.subtitle}
          </p>
        </motion.div>

        {/* Games Grid - Layout avec texte EN DESSOUS */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          {gameKeys.map((gameKey, index) => {
            const gameData = translations.games.items[gameKey]
            const assets = localAssets.games[gameKey]
            const hasVideo = assets.video !== null
            const isMuted = mutedVideos[gameKey] !== false
            
            if (!gameData) return null

            return (
              <motion.div
                key={gameKey}
                initial={{ opacity: 0, y: 30 }}
                whileInView={{ opacity: 1, y: 0 }}
                viewport={{ once: true }}
                transition={{ delay: index * 0.05 }}
                className="game-card-new group cursor-pointer bg-dark-100/90 backdrop-blur-sm rounded-2xl overflow-hidden border border-primary/30 hover:border-primary/50 transition-all duration-300 hover:shadow-[0_0_30px_rgba(0,240,255,0.2)]"
                onClick={() => setSelectedGame(gameKey)}
              >
                {/* Vidéo/Image Container */}
                <div className="relative aspect-video overflow-hidden">
                  {hasVideo ? (
                    <>
                      <video
                        ref={(el) => { videoRefs.current[gameKey] = el }}
                        src={assets.video!}
                        muted={isMuted}
                        loop
                        playsInline
                        autoPlay
                        className="w-full h-full object-cover"
                      />
                      {/* Bouton Mute */}
                      <button
                        onClick={(e) => toggleMute(gameKey, e)}
                        className="absolute top-3 right-3 z-10 w-8 h-8 bg-black/60 backdrop-blur-sm rounded-full flex items-center justify-center hover:bg-black/80 transition-all opacity-0 group-hover:opacity-100"
                      >
                        {isMuted ? (
                          <VolumeX size={14} className="text-white" />
                        ) : (
                          <Volume2 size={14} className="text-white" />
                        )}
                      </button>
                    </>
                  ) : (
                    <Image
                      src={assets.thumb}
                      alt={gameData.name}
                      fill
                      className="object-cover"
                      unoptimized
                    />
                  )}
                </div>

                {/* Texte EN DESSOUS de la vidéo */}
                <div className="p-5">
                  <h3 className="font-display text-xl font-bold text-white mb-2 group-hover:text-primary transition-colors">
                    {gameData.name}
                  </h3>
                  <p className="text-gray-400 text-sm line-clamp-3 mb-3 leading-relaxed" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {gameData.description}
                  </p>
                  <button className="text-primary text-sm font-medium hover:underline flex items-center gap-2" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {translations.games.more_info}
                    <span className="group-hover:translate-x-1 transition-transform">→</span>
                  </button>
                </div>
              </motion.div>
            )
          })}
        </div>
      </div>

      {/* Game Modal */}
      <AnimatePresence>
        {selectedGame && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="modal-overlay"
            onClick={() => setSelectedGame(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.9, y: 20 }}
              animate={{ opacity: 1, scale: 1, y: 0 }}
              exit={{ opacity: 0, scale: 0.9, y: 20 }}
              className="modal-content"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Close Button */}
              <button
                onClick={() => setSelectedGame(null)}
                className="absolute top-4 right-4 z-10 w-10 h-10 bg-dark-200 rounded-full flex items-center justify-center hover:bg-dark-300 transition-colors"
              >
                <X size={20} />
              </button>

              {/* Modal Content */}
              {(() => {
                const gameData = translations.games.items[selectedGame]
                const assets = localAssets.games[selectedGame as keyof typeof localAssets.games]
                
                if (!gameData || !assets) return null

                const hasVideo = assets.video !== null

                return (
                  <>
                    {/* Vidéo ou Image */}
                    <div className="relative aspect-video bg-black">
                      {hasVideo ? (
                        <video
                          src={assets.video!}
                          autoPlay
                          loop
                          muted
                          playsInline
                          className="w-full h-full object-cover rounded-t-[20px]"
                        />
                      ) : (
                        <Image
                          src={assets.popup}
                          alt={gameData.name}
                          fill
                          className="object-cover rounded-t-[20px]"
                          unoptimized
                        />
                      )}
                    </div>

                    {/* Info */}
                    <div className="p-8">
                      <h3 className="font-display text-3xl font-bold gradient-text mb-4">
                        {gameData.name}
                      </h3>
                      <p className="text-gray-300 mb-6 leading-relaxed" style={{ fontFamily: 'Poppins, sans-serif' }}>
                        {gameData.popup_description}
                      </p>
                      
                      {/* Features */}
                      <ul className="space-y-3">
                        {gameData.features.map((feature, i) => (
                          <li key={i} className="flex items-center gap-3 text-gray-400" style={{ fontFamily: 'Poppins, sans-serif' }}>
                            <span className="w-2 h-2 bg-primary rounded-full flex-shrink-0" />
                            {feature}
                          </li>
                        ))}
                      </ul>
                    </div>
                  </>
                )
              })()}
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Wave separator to next section */}
      <div className="absolute bottom-0 left-0 right-0" style={{ transform: 'translateY(100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,0 Q300,40 600,0 T1200,0 L1200,120 L0,120 Z" fill="rgba(255, 0, 229, 0.7)" />
        </svg>
      </div>
    </section>
  )
}
</file>

<file path="src/components/Header.tsx">
'use client'

import { useState, useEffect } from 'react'
import Link from 'next/link'
import Image from 'next/image'
import { motion, AnimatePresence } from 'framer-motion'
import { Menu, X } from 'lucide-react'
import { Locale, languageFlags, locales } from '@/i18n'

interface HeaderProps {
  translations: {
    nav: {
      concept: string
      games: string
      pricing: string
      branches: string
      contact: string
    }
    booking?: {
      order_now: string
    }
  }
  locale: Locale
  onLocaleChange: (locale: Locale) => void
}

export default function Header({ translations, locale, onLocaleChange }: HeaderProps) {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const [isLangOpen, setIsLangOpen] = useState(false)
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    if (typeof window === 'undefined') return
    
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768)
      if (window.innerWidth >= 768) {
        setIsMenuOpen(false)
      }
    }
    
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  useEffect(() => {
    if (typeof window === 'undefined') return
    
    const handleClickOutside = (event: MouseEvent) => {
      if (isMobile && isMenuOpen) {
        const target = event.target as HTMLElement
        if (!target.closest('header') && !target.closest('nav')) {
          setIsMenuOpen(false)
        }
      }
    }

    if (isMenuOpen) {
      document.addEventListener('click', handleClickOutside)
      return () => document.removeEventListener('click', handleClickOutside)
    }
  }, [isMobile, isMenuOpen])

  // Menu items
  const menuItems = [
    { href: '#concept', label: translations.nav.concept },
    { href: '#games', label: translations.nav.games },
    { href: '#pricing', label: translations.nav.pricing },
    { href: '#branches', label: translations.nav.branches },
    { href: '#contact', label: translations.nav.contact },
  ]

  const handleMenuItemClick = (href: string) => {
    const element = document.querySelector(href)
    element?.scrollIntoView({ behavior: 'smooth' })
  }

  return (
    <header 
      className="fixed top-0 left-0 right-0 z-50"
      style={{
        background: 'rgba(26, 26, 46, 0.95)',
        backdropFilter: 'blur(10px)',
        borderBottom: '1px solid rgba(8, 247, 254, 0.3)',
        height: '75px',
        boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)',
      }}
    >
      <div className="container mx-auto px-4" style={{ height: '75px' }}>
        <div className="flex items-center justify-between" style={{ height: '75px' }}>
          {/* Logo + Order Now Button (always visible) */}
          <div className="flex items-center gap-36 md:gap-44" style={{ flexShrink: 0 }}>
            <Link href="/" className="relative z-10 flex items-center" style={{ height: '75px', flexShrink: 0 }}>
              <Image
                src="/images/logo.png"
                alt="Active Games"
                width={220}
                height={60}
                className="h-auto"
                style={{ 
                  height: 'clamp(45px, 6vw, 60px)',
                  width: 'auto',
                  filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.5)) drop-shadow(0 0 8px rgba(0, 240, 255, 0.4)) brightness(1.15)',
                }}
                priority
              />
            </Link>
            
            {/* Order Now Button - Always visible, like logo */}
            <Link
              href="/reservation"
              className="glow-button inline-flex items-center gap-1 md:gap-2 px-2 md:px-5 py-1.5 md:py-2 text-[10px] md:text-xs font-bold text-dark hover:scale-105 transition-transform duration-300"
              style={{ 
                fontFamily: 'Orbitron, sans-serif',
                whiteSpace: 'nowrap',
                display: 'flex',
                alignItems: 'center',
                height: 'auto',
                flexShrink: 0
              }}
            >
              {translations.booking?.order_now || 'Order now'}
            </Link>
          </div>

          {/* Desktop Navigation */}
          {!isMobile && (
            <nav className="flex items-center gap-0" style={{ height: '75px', marginRight: '0' }}>

              {menuItems.map((item) => (
                <a
                  key={item.href}
                  href={item.href}
                  onClick={(e) => {
                    e.preventDefault()
                    handleMenuItemClick(item.href)
                  }}
                  className="uppercase transition-all relative"
                  style={{
                    fontFamily: 'Roboto, sans-serif',
                    fontSize: 'clamp(12px, 1.6vw, 18px)',
                    fontWeight: 700,
                    lineHeight: '10px',
                    letterSpacing: '0.8px',
                    color: '#05f6f7',
                    paddingLeft: 'clamp(6px, 1.2vw, 14px)',
                    paddingRight: 'clamp(6px, 1.2vw, 14px)',
                    paddingTop: '11px',
                    paddingBottom: '11px',
                    backgroundImage: 'linear-gradient(to right, #00F0FF, #F000F0)',
                    backgroundPosition: 'bottom left',
                    backgroundRepeat: 'no-repeat',
                    backgroundSize: '0% 3px',
                    transition: 'background-size 0.3s ease, color 0.3s ease',
                    textDecoration: 'none',
                    whiteSpace: 'nowrap',
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.backgroundSize = '100% 3px'
                    e.currentTarget.style.color = '#C7D0FF'
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.backgroundSize = '0% 3px'
                    e.currentTarget.style.color = '#05f6f7'
                  }}
                >
                  {item.label}
                </a>
              ))}
              
              {/* Laser City Logo */}
              <a 
                href="https://laser-city.co.il" 
                target="_blank" 
                rel="noopener noreferrer"
                className="transition-opacity hover:opacity-90"
                style={{ 
                  marginLeft: '8px',
                  marginRight: '8px',
                  display: 'flex',
                  alignItems: 'center',
                  height: '75px',
                  opacity: 1,
                  filter: 'drop-shadow(0 0 8px rgba(0, 240, 255, 0.6)) brightness(1.2)'
                }}
              >
                <Image
                  src="/images/logo_laser_city.png"
                  alt="Laser City"
                  width={100}
                  height={35}
                  style={{ 
                    height: 'auto',
                    width: '100px',
                    maxWidth: '100px'
                  }}
                  unoptimized
                />
              </a>
              
              {/* Language Selector */}
              <div 
                className="relative" 
                style={{ marginLeft: '0' }}
                onMouseEnter={() => setIsLangOpen(true)}
                onMouseLeave={() => setIsLangOpen(false)}
              >
                <button
                  onClick={() => setIsLangOpen(!isLangOpen)}
                    style={{
                      backgroundColor: 'transparent',
                      color: '#05f6f7',
                      border: 'none',
                      fontSize: 'clamp(12px, 1.6vw, 18px)',
                      fontFamily: 'Roboto, sans-serif',
                      fontWeight: 700,
                      cursor: 'pointer',
                      padding: '11px clamp(6px, 1.2vw, 14px)',
                    outline: 'none',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '4px',
                    transition: 'color 0.3s ease'
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.color = '#C7D0FF'
                  }}
                  onMouseLeave={(e) => {
                    if (!isLangOpen) {
                      e.currentTarget.style.color = '#05f6f7'
                    }
                  }}
                >
                  <span>{languageFlags[locale]}</span>
                  <svg 
                    style={{ 
                      width: '12px', 
                      height: '12px', 
                      fill: 'currentColor', 
                      transition: 'transform 0.3s ease', 
                      transform: isLangOpen ? 'rotate(180deg)' : 'rotate(0deg)' 
                    }} 
                    xmlns="http://www.w3.org/2000/svg" 
                    viewBox="0 0 20 20"
                  >
                    <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" />
                  </svg>
                </button>
                {isLangOpen && (
                  <div 
                    onMouseEnter={() => setIsLangOpen(true)}
                    onMouseLeave={() => setIsLangOpen(false)}
                    style={{
                      position: 'absolute',
                      top: '100%',
                      ...(locale === 'he' ? { left: '0' } : { right: '0' }),
                      paddingTop: '8px',
                      backgroundColor: 'transparent',
                    }}
                  >
                    <div style={{
                      backgroundColor: 'rgba(26, 26, 46, 0.95)',
                      backdropFilter: 'blur(10px)',
                      borderRadius: '4px',
                      border: '1px solid rgba(8, 247, 254, 0.3)',
                      boxShadow: '0 4px 15px rgba(0, 0, 0, 0.5)',
                      zIndex: 1000,
                      minWidth: '120px',
                      padding: '4px 0'
                    }}>
                    {locales.map((loc) => (
                      <button
                        key={loc}
                        onClick={() => {
                          onLocaleChange(loc)
                          setIsLangOpen(false)
                        }}
                        style={{
                          width: '100%',
                          backgroundColor: 'transparent',
                          color: locale === loc ? '#C7D0FF' : '#05f6f7',
                          border: 'none',
                          fontSize: 'clamp(12px, 1.6vw, 18px)',
                          fontFamily: 'Roboto, sans-serif',
                          fontWeight: locale === loc ? 700 : 400,
                          cursor: 'pointer',
                          padding: '10px 16px',
                          textAlign: locale === 'he' ? 'right' : 'left',
                          outline: 'none',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '8px',
                          transition: 'background-color 0.3s ease, color 0.3s ease',
                          whiteSpace: 'nowrap',
                          flexDirection: locale === 'he' ? 'row-reverse' : 'row'
                        }}
                        onMouseEnter={(e) => {
                          e.currentTarget.style.backgroundColor = 'rgba(8, 247, 254, 0.1)'
                          e.currentTarget.style.color = '#C7D0FF'
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.backgroundColor = 'transparent'
                          e.currentTarget.style.color = locale === loc ? '#C7D0FF' : '#05f6f7'
                        }}
                      >
                        <span style={{ fontSize: '18px' }}>{languageFlags[loc]}</span>
                        <span style={{ fontSize: '14px', fontWeight: 400 }}>
                          {loc === 'en' ? 'English' : loc === 'fr' ? 'Francais' : 'עברית'}
                        </span>
                      </button>
                    ))}
                    </div>
                  </div>
                )}
              </div>
            </nav>
          )}

          {/* Mobile Menu Button */}
          {isMobile && (
            <button
              onClick={() => setIsMenuOpen(!isMenuOpen)}
              style={{
                backgroundColor: 'transparent',
                border: 'none',
                cursor: 'pointer',
                padding: '8px',
                display: 'flex',
                flexDirection: 'column',
                gap: '5px',
                outline: 'none'
              }}
              aria-label="Toggle menu"
            >
              <span style={{
                display: 'block',
                width: '25px',
                height: '3px',
                backgroundColor: '#05f6f7',
                borderRadius: '2px',
                transition: 'all 0.3s ease',
                transform: isMenuOpen ? 'rotate(45deg) translate(8px, 8px)' : 'none'
              }}></span>
              <span style={{
                display: 'block',
                width: '25px',
                height: '3px',
                backgroundColor: '#05f6f7',
                borderRadius: '2px',
                transition: 'all 0.3s ease',
                opacity: isMenuOpen ? 0 : 1
              }}></span>
              <span style={{
                display: 'block',
                width: '25px',
                height: '3px',
                backgroundColor: '#05f6f7',
                borderRadius: '2px',
                transition: 'all 0.3s ease',
                transform: isMenuOpen ? 'rotate(-45deg) translate(7px, -7px)' : 'none'
              }}></span>
            </button>
          )}
        </div>
      </div>

      {/* Mobile Menu */}
      {isMobile && (
        <AnimatePresence>
          {isMenuOpen && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              style={{
                position: 'fixed',
                top: '75px',
                left: 0,
                right: 0,
                backgroundColor: 'rgba(26, 26, 46, 0.98)',
                backdropFilter: 'blur(10px)',
                borderBottom: '1px solid rgba(8, 247, 254, 0.3)',
                boxShadow: '0 4px 15px rgba(0, 0, 0, 0.5)',
                zIndex: 1000,
                padding: '20px',
                display: 'flex',
                flexDirection: 'column',
                gap: '16px'
              }}
            >
              {menuItems.map((item) => (
                <a
                  key={item.href}
                  href={item.href}
                  onClick={(e) => {
                    e.preventDefault()
                    setIsMenuOpen(false)
                    handleMenuItemClick(item.href)
                  }}
                  style={{
                    fontFamily: 'Roboto, sans-serif',
                          fontSize: '16px',
                    fontWeight: 700,
                    letterSpacing: '0.8px',
                    color: '#05f6f7',
                    textDecoration: 'none',
                    padding: '12px 0',
                    borderBottom: '1px solid rgba(8, 247, 254, 0.2)',
                    transition: 'color 0.3s ease'
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.color = '#C7D0FF'
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.color = '#05f6f7'
                  }}
                >
                  {item.label}
                </a>
              ))}
              <div style={{
                display: 'flex',
                gap: '16px',
                paddingTop: '12px',
                borderTop: '1px solid rgba(8, 247, 254, 0.2)'
              }}>
                {locales.map((loc) => (
                  <button
                    key={loc}
                    onClick={() => {
                      onLocaleChange(loc)
                      setIsMenuOpen(false)
                    }}
                    style={{
                      backgroundColor: 'transparent',
                      color: locale === loc ? '#C7D0FF' : '#05f6f7',
                      border: '1px solid rgba(8, 247, 254, 0.3)',
                      borderRadius: '4px',
                      fontSize: '16px',
                      fontFamily: 'Roboto, sans-serif',
                      fontWeight: locale === loc ? 700 : 400,
                      cursor: 'pointer',
                      padding: '10px 16px',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '8px',
                      transition: 'all 0.3s ease'
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = 'rgba(8, 247, 254, 0.1)'
                      e.currentTarget.style.color = '#C7D0FF'
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent'
                      e.currentTarget.style.color = locale === loc ? '#C7D0FF' : '#05f6f7'
                    }}
                  >
                    <span style={{ fontSize: '20px' }}>{languageFlags[loc]}</span>
                    <span>{loc === 'en' ? 'English' : loc === 'fr' ? 'Francais' : 'עברית'}</span>
                  </button>
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      )}
    </header>
  )
}
</file>

<file path="src/components/HeroSection.tsx">
'use client'

import { motion } from 'framer-motion'
import { ChevronDown } from 'lucide-react'

interface HeroSectionProps {
  translations: {
    hero: {
      subtitle: string
      title: string
      description: string
      cta_games: string
      cta_concept: string
    }
  }
}

export default function HeroSection({ translations }: HeroSectionProps) {
  return (
    <section className="relative min-h-screen flex items-center justify-center overflow-hidden">
      {/* Background Video */}
      <div className="absolute inset-0">
        <video
          autoPlay
          muted
          loop
          playsInline
          className="w-full h-full object-cover"
        >
          <source src="/videos/grid.mp4" type="video/mp4" />
        </video>
        {/* Dark overlay for readability */}
        <div className="absolute inset-0 bg-gradient-to-b from-dark/70 via-dark/50 to-dark" />
        {/* Animated glow effects */}
        <div className="absolute inset-0 opacity-40">
          <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-primary/30 rounded-full blur-[120px] animate-pulse" />
          <div className="absolute bottom-1/4 right-1/4 w-96 h-96 bg-secondary/30 rounded-full blur-[120px] animate-pulse delay-1000" />
        </div>
      </div>

      {/* Grid Pattern Overlay */}
      <div 
        className="absolute inset-0 opacity-10"
        style={{
          backgroundImage: `
            linear-gradient(rgba(0, 240, 255, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 240, 255, 0.1) 1px, transparent 1px)
          `,
          backgroundSize: '50px 50px',
        }}
      />

      {/* Content */}
      <div className="relative z-10 container mx-auto px-4 text-center">
        <motion.div
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8 }}
        >
          {/* Subtitle */}
          <motion.p
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.2 }}
            style={{
              color: '#FF00E5',
              fontFamily: 'Orbitron, sans-serif',
              fontSize: 'clamp(16px, 2.4vw, 24px)',
              fontWeight: 700,
              textShadow: '0 0 10px rgba(255, 0, 229, 0.9), 0 0 30px rgba(255, 0, 229, 0.5)',
              marginBottom: 'clamp(-5px, -0.5vw, -2px)',
              marginTop: 0,
            }}
            className="uppercase tracking-widest"
          >
            {translations.hero.subtitle}
          </motion.p>

          {/* Title */}
          <motion.h1
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ delay: 0.4, duration: 0.6 }}
            style={{
              color: '#08F7FE',
              fontFamily: 'Orbitron, sans-serif',
              fontSize: 'clamp(38px, 6.5vw, 72px)',
              fontWeight: 700,
              textTransform: 'uppercase',
              textShadow: '0 0 15px rgba(8, 247, 254, 0.9), 0 0 40px rgba(8, 247, 254, 0.55), 0 0 60px rgba(8, 247, 254, 0.3)',
              marginBottom: 'clamp(5px, 1vw, 10px)',
              marginTop: 0,
            }}
            className="tracking-tight"
          >
            {translations.hero.title}
          </motion.h1>

          {/* Description */}
          <motion.p
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.6 }}
            style={{
              color: '#D2DDFF',
              fontFamily: 'Poppins, sans-serif',
              fontSize: 'clamp(16px, 2.5vw, 22px)',
              fontWeight: 400,
              lineHeight: '1.5',
              marginTop: 'clamp(5px, 1vw, 10px)',
              marginBottom: 'clamp(30px, 5vw, 60px)',
              maxWidth: 'min(90vw, 768px)',
              marginLeft: 'auto',
              marginRight: 'auto',
            }}
            className="text-center"
          >
            {translations.hero.description}
          </motion.p>

          {/* CTAs */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.8 }}
            className="flex flex-col sm:flex-row gap-4 justify-center mb-8"
          >
            <a
              href="#games"
              onClick={(e) => {
                e.preventDefault()
                document.querySelector('#games')?.scrollIntoView({ behavior: 'smooth' })
              }}
              className="glow-button text-dark font-semibold"
              style={{ fontFamily: 'Poppins, sans-serif' }}
            >
              {translations.hero.cta_games}
            </a>
            <a
              href="#concept"
              onClick={(e) => {
                e.preventDefault()
                document.querySelector('#concept')?.scrollIntoView({ behavior: 'smooth' })
              }}
              className="glow-button text-dark font-semibold"
              style={{ fontFamily: 'Poppins, sans-serif' }}
            >
              {translations.hero.cta_concept}
            </a>
          </motion.div>

          {/* Scroll Indicator - Maintenant juste après les boutons */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 1.2 }}
            style={{ marginTop: 'clamp(10px, 2vw, 20px)' }}
          >
            <motion.div
              animate={{ y: [0, 10, 0] }}
              transition={{ duration: 1.5, repeat: Infinity }}
              style={{ color: '#08F7FE' }}
            >
              <ChevronDown size={32} />
            </motion.div>
          </motion.div>
        </motion.div>
      </div>
    </section>
  )
}
</file>

<file path="src/components/index.ts">
export { default as Header } from './Header'
export { default as HeroSection } from './HeroSection'
export { default as ConceptSection } from './ConceptSection'
export { default as GamesSection } from './GamesSection'
export { default as PricingSection } from './PricingSection'
export { default as BranchesSection } from './BranchesSection'
export { default as ContactSection } from './ContactSection'
export { default as Footer } from './Footer'
export { default as WhatsAppButton } from './WhatsAppButton'
export { ErrorBoundary } from './ErrorBoundary'

// Anciens composants du franchiseur (gardés mais non utilisés)
// export { default as WhyChooseUsSection } from './WhyChooseUsSection'
// export { default as FranchiseSection } from './FranchiseSection'
</file>

<file path="src/components/PricingSection.tsx">
'use client'

import { Check, Sparkles, Users, PartyPopper } from 'lucide-react'
import Link from 'next/link'

interface PricingSectionProps {
  translations: {
    pricing: {
      title: string
      subtitle: string
      single: {
        title: string
        price: string
        currency: string
        duration: string
        features: string[]
      }
      packages: {
        title: string
        items: {
          name: string
          minParticipants: string
          price: string
          currency: string
          features: string[]
        }[]
      }
    }
    booking?: {
      order_now: string
    }
  }
  isRTL?: boolean
}

export default function PricingSection({ translations, isRTL }: PricingSectionProps) {
  // Debug: vérifier que les traductions sont présentes
  if (!translations?.pricing) {
    console.error('PricingSection: translations.pricing is missing', translations)
    return <section id="pricing" className="py-20 md:py-32 bg-dark min-h-[600px]"><div className="container mx-auto px-4"><p className="text-white">Loading translations...</p></div></section>
  }

  return (
    <section id="pricing" className="py-10 md:py-16 min-h-[600px] w-full relative overflow-hidden" style={{
      background: 'linear-gradient(135deg, rgba(255, 0, 229, 0.7) 0%, rgba(255, 0, 255, 0.6) 25%, rgba(255, 50, 200, 0.7) 50%, rgba(255, 0, 255, 0.6) 75%, rgba(255, 0, 229, 0.8) 100%)'
    }}>
      {/* Wave separator from previous section */}
      <div className="absolute top-0 left-0 right-0" style={{ transform: 'translateY(-100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,60 Q300,20 600,60 T1200,60 L1200,120 L0,120 Z" fill="rgba(255, 0, 229, 0.7)" />
        </svg>
      </div>
      
      {/* Background decorative elements */}
      <div className="absolute inset-0 opacity-95">
        <div className="absolute top-1/3 left-1/4 w-[700px] h-[700px] bg-secondary/60 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '4s' }} />
        <div className="absolute bottom-1/3 right-1/4 w-[700px] h-[700px] bg-secondary/50 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '5s', animationDelay: '1s' }} />
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[900px] h-[900px] bg-secondary/40 rounded-full blur-[350px]" />
      </div>
      
      <div className="container mx-auto px-4 relative z-10">
        {/* Section Header */}
        <div className="text-center mb-6">
          <h2 className="section-title">{translations.pricing.title}</h2>
          <p className="text-white max-w-2xl mx-auto text-lg" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
            {translations.pricing.subtitle}
          </p>
        </div>

        {/* Single Player Pricing */}
        <div className="max-w-md mx-auto mb-16">
          <div className="backdrop-blur-sm rounded-2xl p-6 border border-primary/30 hover:border-primary/50 transition-all duration-300 hover:shadow-[0_0_30px_rgba(0,240,255,0.2)] text-center" style={{ backgroundColor: 'rgba(50, 50, 70, 0.7)' }}>
            <Sparkles className="w-10 h-10 text-secondary mx-auto mb-4" />
            <h3 className="text-2xl font-bold text-white mb-2" style={{ fontFamily: 'Poppins, sans-serif' }}>{translations.pricing.single.title}</h3>
            <p className="text-white mb-6" style={{ fontFamily: 'Poppins, sans-serif' }}>{translations.pricing.single.duration}</p>
            
            <div className="flex items-center justify-center gap-2 mb-6">
              <span className="text-5xl font-display font-bold text-white">
                {translations.pricing.single.price}
              </span>
              <span className="text-2xl text-white" style={{ fontFamily: 'Poppins, sans-serif' }}>{translations.pricing.single.currency}</span>
            </div>

            <ul className="space-y-3">
              {translations.pricing.single.features.map((feature, i) => (
                <li key={i} className="flex items-center gap-3 text-white justify-center" style={{ fontFamily: 'Poppins, sans-serif' }}>
                  <Check size={18} className="text-secondary flex-shrink-0" />
                  {feature}
                </li>
              ))}
            </ul>
          </div>
        </div>

        {/* Event Packages */}
        <div className="text-center mb-8">
          <div className="flex items-center justify-center gap-3 mb-8">
            <PartyPopper className="w-8 h-8 text-secondary" />
            <h3 className="text-3xl font-bold text-white" style={{ fontFamily: 'Poppins, sans-serif' }}>{translations.pricing.packages.title}</h3>
          </div>

          <div className="grid md:grid-cols-2 gap-6 max-w-3xl mx-auto">
            {translations.pricing.packages.items.map((pkg, index) => (
              <div
                key={index}
                className="backdrop-blur-sm rounded-2xl p-6 border border-primary/30 hover:border-primary/50 transition-all duration-300 hover:shadow-[0_0_30px_rgba(0,240,255,0.2)]"
                style={{ backgroundColor: 'rgba(50, 50, 70, 0.7)' }}
              >
                <div className="flex items-center gap-2 justify-center mb-4">
                  <Users className="w-5 h-5 text-secondary" />
                  <span className="text-white" style={{ fontFamily: 'Poppins, sans-serif' }}>{pkg.minParticipants}</span>
                </div>
                
                <div className="flex items-center justify-center gap-2 mb-4">
                  <span className="text-4xl font-display font-bold text-white">
                    {pkg.price}
                  </span>
                  <span className="text-xl text-white" style={{ fontFamily: 'Poppins, sans-serif' }}>{pkg.currency}</span>
                </div>

                <ul className="space-y-2 text-start">
                  {pkg.features.map((feature, i) => (
                    <li key={i} className="flex items-start gap-2 text-white text-sm" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      <Check size={16} className="text-secondary flex-shrink-0 mt-0.5" />
                      {feature}
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </div>

        {/* Order Now Button */}
        <div className="text-center mt-12">
          <Link
            href="/reservation"
            className="glow-button inline-flex items-center gap-3 px-10 py-4 text-lg font-bold text-dark hover:scale-105 transition-transform duration-300"
            style={{ fontFamily: 'Orbitron, sans-serif' }}
          >
            <Sparkles className="w-6 h-6" />
            {translations.booking?.order_now || 'Order now'}
          </Link>
        </div>
      </div>
      
      {/* Wave separator to next section */}
      <div className="absolute bottom-0 left-0 right-0" style={{ transform: 'translateY(100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,0 Q300,40 600,0 T1200,0 L1200,120 L0,120 Z" fill="rgba(0, 240, 255, 0.7)" />
        </svg>
      </div>
    </section>
  )
}
</file>

<file path="src/components/WhatsAppButton.tsx">
'use client'

export default function WhatsAppButton() {
  return (
    <a
      href="https://wa.me/972586266770"
      target="_blank"
      rel="noopener noreferrer"
      className="whatsapp-float"
      aria-label="Contact us on WhatsApp"
    >
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z" fill="#FFF"/>
      </svg>
    </a>
  )
}
</file>

<file path="src/components/WhyChooseUsSection.tsx">
'use client'

import { motion } from 'framer-motion'
import { 
  Award, 
  MapPin, 
  Headphones, 
  User, 
  Palette 
} from 'lucide-react'

interface WhyChooseUsSectionProps {
  translations: {
    whyChooseUs: {
      title: string
      subtitle: string
      reasons: Array<{
        title: string
        description: string
      }>
    }
  }
}

const icons = [Award, MapPin, Headphones, User, Palette]

export default function WhyChooseUsSection({ translations }: WhyChooseUsSectionProps) {
  return (
    <section id="concept" className="py-20 md:py-32 bg-dark-100">
      <div className="container mx-auto px-4">
        {/* Section Header */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          className="text-center mb-16"
        >
          <h2 className="section-title gradient-text">{translations.whyChooseUs.title}</h2>
          <p className="text-gray-400 max-w-3xl mx-auto text-lg">
            {translations.whyChooseUs.subtitle}
          </p>
        </motion.div>

        {/* Reasons Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
          {translations.whyChooseUs.reasons.map((reason, index) => {
            const Icon = icons[index % icons.length]
            
            return (
              <motion.div
                key={index}
                initial={{ opacity: 0, y: 30 }}
                whileInView={{ opacity: 1, y: 0 }}
                viewport={{ once: true }}
                transition={{ delay: index * 0.1 }}
                className="bg-dark-200/50 p-8 rounded-2xl border border-dark-300 hover:border-primary/30 transition-all duration-300 group"
              >
                {/* Icon */}
                <div className="w-14 h-14 bg-gradient-to-br from-primary/20 to-secondary/20 rounded-xl flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
                  <Icon className="w-7 h-7 text-primary" />
                </div>

                {/* Content */}
                <h3 className="text-xl font-bold text-white mb-3">
                  {reason.title}
                </h3>
                <p className="text-gray-400 leading-relaxed">
                  {reason.description}
                </p>
              </motion.div>
            )
          })}
        </div>
      </div>
    </section>
  )
}
</file>

<file path="src/hooks/index.ts">
/**
 * Hooks - Point d'entrée
 */
export { useAuth } from './useAuth'
export type { AuthUser } from './useAuth'

export { useBranches } from './useBranches'

export { useBookings } from './useBookings'
export type { BookingWithSlots, CreateBookingData } from './useBookings'
</file>

<file path="src/hooks/useAuth.ts">
'use client'

import { useEffect, useState, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import { getClient } from '@/lib/supabase/client'
import type { User } from '@supabase/supabase-js'
import type { Profile, Branch, UserRole, ProfileInsert } from '@/lib/supabase/types'

export interface AuthUser {
  id: string
  email: string
  profile: Profile | null
  branches: Branch[]
  role: UserRole | null
  isSuperAdmin: boolean
  isBranchAdmin: boolean
  isAgent: boolean
}

export function useAuth() {
  const router = useRouter()
  const [user, setUser] = useState<AuthUser | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchUserData = useCallback(async (authUser: User) => {
    const supabase = getClient()

    try {
      // Récupérer le profil
      let { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', authUser.id)
        .single<Profile>()

      // Si le profil n'existe pas (code PGRST116 = no rows), le créer
      if (profileError && profileError.code === 'PGRST116') {
        const userName = authUser.email?.split('@')[0] || 'Admin'
        const profileData: ProfileInsert = {
          id: authUser.id,
          role: 'super_admin', // Premier utilisateur = super_admin
          first_name: userName,
          last_name: '',
          phone: '0500000000', // Placeholder phone - super admin should update later
          full_name: userName,
        }
        const { data: newProfile, error: createError } = await supabase
          .from('profiles')
          // @ts-expect-error - Supabase SSR typing limitation with insert
          .insert(profileData)
          .select()
          .single<Profile>()

        if (createError) {
          throw createError
        }
        profile = newProfile
        profileError = null
      } else if (profileError) {
        throw profileError
      }

      // Récupérer les branches autorisées
      let branches: Branch[] = []

      if (profile?.role === 'super_admin') {
        // Super admin voit toutes les branches
        const { data: allBranches } = await supabase
          .from('branches')
          .select('*')
          .eq('is_active', true)
          .order('name')
          .returns<Branch[]>()

        branches = allBranches || []
      } else {
        // Autres utilisateurs voient leurs branches
        const { data: userBranches } = await supabase
          .from('user_branches')
          .select('branch_id')
          .eq('user_id', authUser.id)
          .returns<Array<{ branch_id: string }>>()

        if (userBranches && userBranches.length > 0) {
          const branchIds = userBranches.map(ub => ub.branch_id)
          const { data: authorizedBranches } = await supabase
            .from('branches')
            .select('*')
            .in('id', branchIds)
            .eq('is_active', true)
            .order('name')
            .returns<Branch[]>()

          branches = authorizedBranches || []
        }
      }

      const role = profile?.role || null

      setUser({
        id: authUser.id,
        email: authUser.email || '',
        profile: profile || null,
        branches,
        role,
        isSuperAdmin: role === 'super_admin',
        isBranchAdmin: role === 'branch_admin',
        isAgent: role === 'agent',
      })
    } catch (err) {
      console.error('Error fetching user data:', err)
      setError('Erreur lors du chargement des données utilisateur')
    }
  }, [])

  useEffect(() => {
    const supabase = getClient()

    // Vérifier la session actuelle
    const checkSession = async () => {
      try {
        const { data: { user: authUser } } = await supabase.auth.getUser()

        if (authUser) {
          await fetchUserData(authUser)
        } else {
          setUser(null)
        }
      } catch (err) {
        console.error('Error checking session:', err)
        setUser(null)
      } finally {
        setLoading(false)
      }
    }

    checkSession()

    // Écouter les changements d'auth
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        if (event === 'SIGNED_IN' && session?.user) {
          await fetchUserData(session.user)
          // Logger la connexion
          try {
            await fetch('/api/auth/log', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ action: 'login' })
            })
          } catch (e) {
            console.error('Failed to log login:', e)
          }
        } else if (event === 'SIGNED_OUT') {
          setUser(null)
        }
      }
    )

    return () => {
      subscription.unsubscribe()
    }
  }, [fetchUserData])

  const signOut = useCallback(async () => {
    const supabase = getClient()
    // Logger la déconnexion AVANT de se déconnecter (sinon plus de session)
    try {
      await fetch('/api/auth/log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'logout' })
      })
    } catch (e) {
      console.error('Failed to log logout:', e)
    }
    await supabase.auth.signOut()
    setUser(null)
    router.push('/admin/login')
  }, [router])

  const refreshUser = useCallback(async () => {
    const supabase = getClient()
    const { data: { user: authUser } } = await supabase.auth.getUser()
    if (authUser) {
      await fetchUserData(authUser)
    }
  }, [fetchUserData])

  return {
    user,
    loading,
    error,
    signOut,
    refreshUser,
    isAuthenticated: !!user,
  }
}
</file>

<file path="src/hooks/useLogs.ts">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRealtimeRefresh } from './useRealtimeSubscription'
import type { ActivityLogWithRelations, ActionType, TargetType, UserRole } from '@/lib/supabase/types'

interface LogsFilters {
  actionType?: ActionType
  targetType?: TargetType
  userRole?: UserRole
  userId?: string
  branchId?: string
  dateFrom?: string
  dateTo?: string
  search?: string
}

interface LogsStats {
  total: number
  today: number
  thisWeek: number
  byActionType: Record<string, number>
}

export function useLogs(branchId: string | null, userRole: UserRole) {
  const [logs, setLogs] = useState<ActivityLogWithRelations[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [stats, setStats] = useState<LogsStats>({
    total: 0,
    today: 0,
    thisWeek: 0,
    byActionType: {}
  })

  const fetchLogs = useCallback(async (filters?: LogsFilters) => {
    setLoading(true)
    setError(null)

    try {
      const params = new URLSearchParams()

      // For super_admin, don't filter by branch unless explicitly selected
      // For branch_admin, always filter by their branches
      if (branchId && userRole !== 'super_admin') {
        params.append('branch_id', branchId)
      } else if (branchId && filters?.branchId) {
        params.append('branch_id', filters.branchId)
      }

      if (filters?.actionType) params.append('action_type', filters.actionType)
      if (filters?.targetType) params.append('target_type', filters.targetType)
      if (filters?.userRole) params.append('user_role', filters.userRole)
      if (filters?.userId) params.append('user_id', filters.userId)
      if (filters?.dateFrom) params.append('date_from', filters.dateFrom)
      if (filters?.dateTo) params.append('date_to', filters.dateTo)
      if (filters?.search) params.append('search', filters.search)

      const response = await fetch(`/api/logs?${params.toString()}`)
      const data = await response.json()

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch logs')
      }

      setLogs(data.logs || [])

      // Calculate stats
      const allLogs = data.logs || []
      const now = new Date()
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate())
      const weekStart = new Date(todayStart)
      weekStart.setDate(weekStart.getDate() - 7)

      const byActionType: Record<string, number> = {}
      let today = 0
      let thisWeek = 0

      allLogs.forEach((log: ActivityLogWithRelations) => {
        const logDate = new Date(log.created_at)
        if (logDate >= todayStart) today++
        if (logDate >= weekStart) thisWeek++
        byActionType[log.action_type] = (byActionType[log.action_type] || 0) + 1
      })

      setStats({
        total: allLogs.length,
        today,
        thisWeek,
        byActionType
      })

    } catch (err) {
      console.error('Error fetching logs:', err)
      setError('Erreur lors du chargement des logs')
    } finally {
      setLoading(false)
    }
  }, [branchId, userRole])

  useEffect(() => {
    fetchLogs()
  }, [fetchLogs])

  // Realtime updates for logs
  useRealtimeRefresh('activity_logs', branchId, fetchLogs)

  // Delete logs (super_admin only)
  const deleteLogs = useCallback(async (logIds: string[]): Promise<boolean> => {
    if (userRole !== 'super_admin') {
      setError('Seul un super admin peut supprimer les logs')
      return false
    }

    setError(null)
    try {
      const response = await fetch('/api/logs', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ids: logIds })
      })

      const data = await response.json()
      if (!data.success) {
        throw new Error(data.error || 'Failed to delete logs')
      }

      await fetchLogs()
      return true
    } catch (err) {
      console.error('Error deleting logs:', err)
      setError('Erreur lors de la suppression des logs')
      return false
    }
  }, [userRole, fetchLogs])

  return {
    logs,
    loading,
    error,
    stats,
    fetchLogs,
    deleteLogs,
    refresh: fetchLogs
  }
}
</file>

<file path="src/hooks/useRoles.ts">
'use client'

import { useState, useEffect, useCallback } from 'react'
import type { Role } from '@/lib/supabase/types'

interface UseRolesReturn {
  roles: Role[]
  loading: boolean
  error: string | null
  getRoleById: (id: string) => Role | undefined
  getRoleByName: (name: string) => Role | undefined
  getRoleLevel: (roleNameOrId: string) => number
  canManageRole: (userLevel: number, targetLevel: number) => boolean
  getManageableRoles: (userLevel: number) => Role[]
  getAssignableRoles: (userLevel: number) => Role[]
  isSystemRole: (roleNameOrId: string) => boolean
  refresh: () => Promise<void>
}

/**
 * Hook pour gérer les rôles dynamiques avec hiérarchie
 *
 * Règles de hiérarchie:
 * - Level 1 = autorité maximale (super_admin)
 * - Level 10 = autorité minimale
 * - Un utilisateur peut gérer les rôles avec level > son level
 * - Un utilisateur peut assigner des rôles avec level > son level
 * - Les rôles is_system=true ne peuvent pas être modifiés/supprimés
 */
export function useRoles(): UseRolesReturn {
  const [roles, setRoles] = useState<Role[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchRoles = useCallback(async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/roles')
      const data = await response.json()

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch roles')
      }

      // Les rôles sont triés par level (1 en premier = plus haute autorité)
      const sortedRoles = (data.roles || []).sort((a: Role, b: Role) => a.level - b.level)
      setRoles(sortedRoles)
    } catch (err) {
      console.error('Error fetching roles:', err)
      setError('Erreur lors du chargement des rôles')

      // Fallback avec les rôles par défaut en cas d'erreur
      setRoles([
        {
          id: 'default-super-admin',
          name: 'super_admin',
          display_name: 'Super Admin',
          description: 'Full access to all features',
          level: 1,
          color: '#EF4444',
          icon: 'Shield',
          is_system: true,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        },
        {
          id: 'default-branch-admin',
          name: 'branch_admin',
          display_name: 'Branch Admin',
          description: 'Branch administration',
          level: 5,
          color: '#8B5CF6',
          icon: 'UserCog',
          is_system: false,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        },
        {
          id: 'default-agent',
          name: 'agent',
          display_name: 'Agent',
          description: 'Agent with limited access',
          level: 8,
          color: '#3B82F6',
          icon: 'Users',
          is_system: false,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }
      ])
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    fetchRoles()
  }, [fetchRoles])

  /**
   * Obtenir un rôle par son ID
   */
  const getRoleById = useCallback((id: string): Role | undefined => {
    return roles.find(r => r.id === id)
  }, [roles])

  /**
   * Obtenir un rôle par son nom (slug)
   */
  const getRoleByName = useCallback((name: string): Role | undefined => {
    return roles.find(r => r.name === name)
  }, [roles])

  /**
   * Obtenir le niveau d'un rôle par son nom ou ID
   * Retourne 10 (niveau le plus bas) si non trouvé
   */
  const getRoleLevel = useCallback((roleNameOrId: string): number => {
    const role = roles.find(r => r.id === roleNameOrId || r.name === roleNameOrId)
    return role?.level ?? 10
  }, [roles])

  /**
   * Vérifier si un utilisateur peut gérer un rôle
   * Un utilisateur peut gérer les rôles avec level > son level
   */
  const canManageRole = useCallback((userLevel: number, targetLevel: number): boolean => {
    // Level plus bas = plus d'autorité
    // userLevel < targetLevel signifie que l'utilisateur a plus d'autorité
    return userLevel < targetLevel
  }, [])

  /**
   * Obtenir les rôles qu'un utilisateur peut modifier/supprimer
   * Exclut les rôles système et les rôles avec level <= userLevel
   */
  const getManageableRoles = useCallback((userLevel: number): Role[] => {
    return roles.filter(r => !r.is_system && r.level > userLevel)
  }, [roles])

  /**
   * Obtenir les rôles qu'un utilisateur peut assigner à d'autres utilisateurs
   * Inclut tous les rôles avec level > userLevel (même les rôles système comme super_admin ne peuvent pas être assignés par d'autres)
   */
  const getAssignableRoles = useCallback((userLevel: number): Role[] => {
    return roles.filter(r => r.level > userLevel)
  }, [roles])

  /**
   * Vérifier si un rôle est un rôle système (non modifiable/supprimable)
   */
  const isSystemRole = useCallback((roleNameOrId: string): boolean => {
    const role = roles.find(r => r.id === roleNameOrId || r.name === roleNameOrId)
    return role?.is_system ?? false
  }, [roles])

  return {
    roles,
    loading,
    error,
    getRoleById,
    getRoleByName,
    getRoleLevel,
    canManageRole,
    getManageableRoles,
    getAssignableRoles,
    isSystemRole,
    refresh: fetchRoles
  }
}

/**
 * Hook simplifié pour obtenir le niveau du rôle de l'utilisateur connecté
 */
export function useUserRoleLevel(userRole: string | null): number {
  const { getRoleLevel } = useRoles()

  if (!userRole) return 10 // Niveau le plus bas par défaut
  return getRoleLevel(userRole)
}
</file>

<file path="src/hooks/useUsers.ts">
import { useState, useEffect, useCallback } from 'react'
import type { UserWithBranches, UserRole } from '@/lib/supabase/types'

interface CreateUserData {
  email: string
  first_name: string
  last_name: string
  phone: string
  role_id: string
  branch_ids: string[]
  password?: string
}

interface UpdateUserData {
  first_name?: string
  last_name?: string
  phone?: string
  email?: string
  password?: string
  role_id?: string
  branch_ids?: string[]
}

export function useUsers() {
  const [users, setUsers] = useState<UserWithBranches[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Charger les utilisateurs
  const fetchUsers = useCallback(async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/admin/users')
      const data = await response.json()

      if (data.success) {
        setUsers(data.users)
      } else {
        setError(data.error || 'Erreur lors du chargement')
      }
    } catch (err) {
      console.error('Error fetching users:', err)
      setError('Erreur de connexion')
    } finally {
      setLoading(false)
    }
  }, [])

  // Créer un utilisateur
  const createUser = useCallback(async (userData: CreateUserData): Promise<{ success: boolean; user?: UserWithBranches; temporaryPassword?: string; error?: string }> => {
    try {
      const response = await fetch('/api/admin/users', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      })

      const data = await response.json()

      if (data.success) {
        // Rafraîchir la liste
        await fetchUsers()
        return { success: true, user: data.user, temporaryPassword: data.temporaryPassword }
      } else {
        return { success: false, error: data.error }
      }
    } catch (err) {
      console.error('Error creating user:', err)
      return { success: false, error: 'Erreur de connexion' }
    }
  }, [fetchUsers])

  // Mettre à jour un utilisateur
  const updateUser = useCallback(async (userId: string, updates: UpdateUserData): Promise<{ success: boolean; user?: UserWithBranches; error?: string }> => {
    try {
      const response = await fetch(`/api/admin/users/${userId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updates),
      })

      const data = await response.json()

      if (data.success) {
        // Rafraîchir la liste
        await fetchUsers()
        return { success: true, user: data.user }
      } else {
        return { success: false, error: data.error }
      }
    } catch (err) {
      console.error('Error updating user:', err)
      return { success: false, error: 'Erreur de connexion' }
    }
  }, [fetchUsers])

  // Supprimer un utilisateur
  const deleteUser = useCallback(async (userId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/admin/users/${userId}`, {
        method: 'DELETE',
      })

      const data = await response.json()

      if (data.success) {
        // Rafraîchir la liste
        await fetchUsers()
        return { success: true }
      } else {
        return { success: false, error: data.error }
      }
    } catch (err) {
      console.error('Error deleting user:', err)
      return { success: false, error: 'Erreur de connexion' }
    }
  }, [fetchUsers])

  // Charger au montage
  useEffect(() => {
    fetchUsers()
  }, [fetchUsers])

  return {
    users,
    loading,
    error,
    fetchUsers,
    createUser,
    updateUser,
    deleteUser,
  }
}
</file>

<file path="src/i18n/index.ts">
import en from './locales/en.json'
import fr from './locales/fr.json'
import he from './locales/he.json'

// 3 langues supportées : Français, Anglais, Hébreu
export const locales = ['fr', 'en', 'he'] as const
export type Locale = (typeof locales)[number]

// Hébreu par défaut pour le site public (franchisé en Israël)
export const defaultLocale: Locale = 'he'

// Français par défaut pour le CRM admin
export const defaultAdminLocale: Locale = 'fr'

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const translations: Record<Locale, any> = { en, fr, he }

export function getTranslations(locale: Locale) {
  return translations[locale] || translations.he
}

export function getDirection(locale: Locale): 'ltr' | 'rtl' {
  return locale === 'he' ? 'rtl' : 'ltr'
}

export const languageNames: Record<Locale, string> = {
  fr: 'Français',
  en: 'English',
  he: 'עברית',
}

export const languageFlags: Record<Locale, string> = {
  fr: '🇫🇷',
  en: '🇺🇸',
  he: '🇮🇱',
}

// Clé localStorage pour le site public
export const PUBLIC_LOCALE_KEY = 'locale'

// Clé localStorage pour le CRM admin
export const ADMIN_LOCALE_KEY = 'admin_locale'
</file>

<file path="src/lib/supabase/client.ts">
/**
 * Supabase Client - Browser
 * Utilisé côté client (composants React)
 */
import { createBrowserClient } from '@supabase/ssr'
import type { Database } from './types'

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// Singleton pour éviter de créer plusieurs instances
let client: ReturnType<typeof createClient> | null = null

export function getClient() {
  if (!client) {
    client = createClient()
  }
  return client
}
</file>

<file path="src/lib/supabase/index.ts">
/**
 * Supabase - Point d'entrée
 */
export { createClient, getClient } from './client'
export { createClient as createServerClient } from './server'
export * from './types'
</file>

<file path="src/lib/supabase/server.ts">
/**
 * Supabase Client - Server
 * Utilisé côté serveur (API routes, Server Components)
 */
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import type { Database } from './types'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Ignoré si appelé depuis un Server Component
          }
        },
      },
    }
  )
}
</file>

<file path="src/lib/supabase/service-role.ts">
/**
 * Supabase Admin Client - Service Role
 * UTILISÉ UNIQUEMENT CÔTÉ SERVEUR POUR LES OPÉRATIONS ADMIN
 * 
 * Ce client utilise la clé service_role qui contourne RLS (Row Level Security)
 * et permet des opérations privilégiées comme :
 * - Création de comptes utilisateurs (auth.admin.createUser)
 * - Suppression de comptes utilisateurs (auth.admin.deleteUser)
 * - Accès à toutes les données sans restrictions RLS
 * 
 * ⚠️ SÉCURITÉ : Ne JAMAIS exposer ce client côté client !
 */

import { createClient } from '@supabase/supabase-js'
import type { Database } from './types'

/**
 * Crée un client Supabase avec les privilèges service_role
 * À utiliser UNIQUEMENT dans les API routes côté serveur
 */
export function createServiceRoleClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error(
      'Missing Supabase environment variables. ' +
      'NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set.'
    )
  }

  return createClient<Database>(supabaseUrl, supabaseServiceKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  })
}
</file>

<file path="src/lib/dates.ts">
/**
 * Utilitaires pour la gestion des dates et timezones
 * Toutes les branches sont en Israel (Asia/Jerusalem)
 */

// Israel timezone
const ISRAEL_TIMEZONE = 'Asia/Jerusalem'

/**
 * Crée une date ISO string a partir d'une date et heure locales Israel
 * Utilisé côté serveur pour interpreter correctement les heures envoyées par le client
 *
 * @param date - Date au format YYYY-MM-DD
 * @param time - Heure au format HH:MM
 * @returns ISO string avec le bon timezone offset
 */
export function createIsraelDateTime(date: string, time: string): Date {
  // Creer la date en specifiant explicitement que c'est en timezone Israel
  // Format: "2024-01-15T12:00:00" + offset Israel
  const dateTimeStr = `${date}T${time}:00`

  // Obtenir l'offset Israel pour cette date specifique (gere le DST)
  const tempDate = new Date(dateTimeStr + 'Z') // Parse comme UTC d'abord
  const israelOffset = getIsraelOffset(tempDate)

  // Creer la date avec le bon offset
  // Si l'offset Israel est +02:00, et l'utilisateur veut 12:00 Israel,
  // on doit stocker 10:00 UTC
  const utcHours = parseInt(time.split(':')[0]) - Math.floor(israelOffset / 60)
  const utcMinutes = parseInt(time.split(':')[1]) - (israelOffset % 60)

  const result = new Date(`${date}T00:00:00Z`)
  result.setUTCHours(utcHours, utcMinutes, 0, 0)

  return result
}

/**
 * Obtient l'offset Israel en minutes pour une date donnee
 * Israel est en UTC+2 (hiver) ou UTC+3 (ete avec DST)
 */
export function getIsraelOffset(date: Date): number {
  // Utiliser Intl pour obtenir l'offset correct incluant DST
  const formatter = new Intl.DateTimeFormat('en-US', {
    timeZone: ISRAEL_TIMEZONE,
    timeZoneName: 'shortOffset'
  })

  const parts = formatter.formatToParts(date)
  const tzPart = parts.find(p => p.type === 'timeZoneName')

  if (tzPart) {
    // Parse "GMT+2" ou "GMT+3"
    const match = tzPart.value.match(/GMT([+-])(\d+)/)
    if (match) {
      const sign = match[1] === '+' ? 1 : -1
      const hours = parseInt(match[2])
      return sign * hours * 60
    }
  }

  // Fallback: +2 heures (Israel Standard Time)
  return 120
}

/**
 * Formate une date ISO en heure locale Israel pour l'affichage
 */
export function formatIsraelTime(isoString: string): string {
  const date = new Date(isoString)
  return date.toLocaleTimeString('he-IL', {
    timeZone: ISRAEL_TIMEZONE,
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  })
}

/**
 * Formate une date ISO en date locale Israel pour l'affichage
 */
export function formatIsraelDate(isoString: string): string {
  const date = new Date(isoString)
  return date.toLocaleDateString('he-IL', {
    timeZone: ISRAEL_TIMEZONE,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
  })
}

/**
 * Extrait la date (YYYY-MM-DD) d'une ISO string en timezone Israel
 */
export function extractIsraelDate(isoString: string): string {
  const date = new Date(isoString)
  const year = date.toLocaleString('en-US', { timeZone: ISRAEL_TIMEZONE, year: 'numeric' })
  const month = date.toLocaleString('en-US', { timeZone: ISRAEL_TIMEZONE, month: '2-digit' })
  const day = date.toLocaleString('en-US', { timeZone: ISRAEL_TIMEZONE, day: '2-digit' })
  return `${year}-${month}-${day}`
}

/**
 * Extrait l'heure (HH:MM) d'une ISO string en timezone Israel
 */
export function extractIsraelTime(isoString: string): string {
  const date = new Date(isoString)
  return date.toLocaleTimeString('en-US', {
    timeZone: ISRAEL_TIMEZONE,
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  })
}
</file>

<file path="src/lib/laser-allocation.ts">
/**
 * Utilitaires partagés pour la gestion des réservations LASER
 * Utilisé par l'admin ET l'API site pour garantir une logique identique
 */

import type { LaserRoom } from './supabase/types'

export interface LaserAllocationResult {
  roomIds: string[]
  requiresTwoRooms: boolean
}

export interface LaserAllocationSettings {
  laser_exclusive_threshold: number // Par défaut 10
  laser_total_vests: number
  laser_spare_vests?: number
}

/**
 * Trouve les meilleures salles laser pour un booking
 * LOGIQUE IDENTIQUE à findBestLaserRoom de l'admin
 */
export async function findBestLaserRoomsForBooking(params: {
  participants: number
  startDateTime: Date
  endDateTime: Date
  branchId: string
  laserRooms: LaserRoom[]
  settings: LaserAllocationSettings
  allBookings: Array<{
    id: string
    branch_id: string
    participants_count: number
    game_sessions?: Array<{
      game_area: string
      laser_room_id: string | null
      start_datetime: string
      end_datetime: string
    }>
  }>
  excludeBookingId?: string
  allocationMode?: 'auto' | 'petit' | 'grand' | 'maxi'
}): Promise<LaserAllocationResult | null> {
  
  const {
    participants,
    startDateTime,
    endDateTime,
    branchId,
    laserRooms,
    settings,
    allBookings,
    excludeBookingId,
    allocationMode = 'auto'
  } = params

  const exclusiveThreshold = settings.laser_exclusive_threshold || 10
  const activeLaserRooms = laserRooms.filter(r => r.is_active)

  if (activeLaserRooms.length === 0) {
    return null
  }

  // Trier par capacité croissante (plus petite salle en premier)
  const sortedRoomsByCapacity = [...activeLaserRooms].sort((a, b) => {
    if (a.capacity !== b.capacity) {
      return a.capacity - b.capacity
    }
    return a.sort_order - b.sort_order
  })

  // Filtrer les bookings qui chevauchent et sont sur la même branche
  const overlappingLaserBookings = allBookings.filter(b => {
    if (b.branch_id !== branchId) return false
    if (excludeBookingId && b.id === excludeBookingId) return false
    if (!b.game_sessions || b.game_sessions.length === 0) return false
    
    return b.game_sessions.some(s => {
      if (s.game_area !== 'LASER') return false
      const sessionStart = new Date(s.start_datetime)
      const sessionEnd = new Date(s.end_datetime)
      return sessionStart < endDateTime && sessionEnd > startDateTime
    })
  })

  // Fonction pour calculer la capacité restante d'une salle
  const getRoomRemainingCapacity = (roomId: string): number => {
    const room = activeLaserRooms.find(r => r.id === roomId)
    if (!room) return 0
    
    // RÈGLE 1 : Vérifier si une résa utilise mode MAXI (2+ salles)
    const hasMaxiMode = overlappingLaserBookings.some(b => {
      const laserRoomIds = b.game_sessions
        ?.filter(s => s.game_area === 'LASER')
        .map(s => s.laser_room_id)
        .filter((id): id is string => id !== null) || []
      const uniqueRoomIds = [...new Set(laserRoomIds)]
      return uniqueRoomIds.length > 1
    })
    
    if (hasMaxiMode) {
      return 0 // Tout le laser bloqué
    }
    
    // RÈGLE 2 : Vérifier si un groupe >= exclusiveThreshold utilise cette salle
    const hasExclusiveGroup = overlappingLaserBookings.some(b => 
      b.participants_count >= exclusiveThreshold &&
      b.game_sessions?.some(s => s.game_area === 'LASER' && s.laser_room_id === roomId)
    )
    
    if (hasExclusiveGroup) {
      return 0 // Salle exclusive
    }
    
    // RÈGLE 3 : Calcul normal de capacité restante
    const bookingsInThisRoom = overlappingLaserBookings.filter(b => 
      b.game_sessions?.some(s => s.game_area === 'LASER' && s.laser_room_id === roomId)
    )
    const currentParticipants = bookingsInThisRoom.reduce((sum, b) => sum + b.participants_count, 0)
    return room.capacity - currentParticipants
  }

  // ALLOCATION MANUELLE : Forcer une salle spécifique si mode != 'auto'
  if (allocationMode !== 'auto') {
    const smallRoom = sortedRoomsByCapacity[0]
    const largeRoom = sortedRoomsByCapacity[sortedRoomsByCapacity.length - 1]
    
    let forcedRoomIds: string[] = []
    
    if (allocationMode === 'petit') {
      forcedRoomIds = [smallRoom.id]
    } else if (allocationMode === 'grand') {
      forcedRoomIds = [largeRoom.id]
    } else if (allocationMode === 'maxi') {
      forcedRoomIds = activeLaserRooms.map(r => r.id)
    }
    
    // Vérifier si les salles forcées ont assez de capacité
    const totalCapacity = forcedRoomIds.reduce((sum, roomId) => {
      const remaining = getRoomRemainingCapacity(roomId)
      return sum + remaining
    }, 0)
    
    if (totalCapacity >= participants) {
      return {
        roomIds: forcedRoomIds,
        requiresTwoRooms: forcedRoomIds.length > 1
      }
    } else {
      return null // Pas assez de capacité en mode forcé
    }
  }

  // ALLOCATION AUTO : Optimiser l'espace

  // Cas 1 : Groupe >= exclusiveThreshold → Besoin d'une salle exclusive
  if (participants >= exclusiveThreshold) {
    // Trouver une salle vide avec capacité suffisante (plus petite possible)
    for (const room of sortedRoomsByCapacity) {
      const remaining = getRoomRemainingCapacity(room.id)

      if (remaining === room.capacity && room.capacity >= participants) {
        return {
          roomIds: [room.id],
          requiresTwoRooms: false
        }
      }
    }

    // Si aucune salle simple ne suffit, essayer combinaison de 2 salles
    const totalCapacityAllRooms = sortedRoomsByCapacity.reduce((sum, r) => {
      const remaining = getRoomRemainingCapacity(r.id)
      return sum + (remaining === r.capacity ? r.capacity : 0) // Seulement salles vides
    }, 0)

    if (totalCapacityAllRooms >= participants) {
      // Prendre toutes les salles disponibles vides
      const emptyRooms = sortedRoomsByCapacity.filter(r => getRoomRemainingCapacity(r.id) === r.capacity)
      return {
        roomIds: emptyRooms.map(r => r.id),
        requiresTwoRooms: true
      }
    }

    return null // Pas de capacité pour groupe exclusif
  }
  
  // Cas 2 : Petit groupe (< exclusiveThreshold) → Peut partager
  // Trouver la plus petite salle avec capacité suffisante
  for (const room of sortedRoomsByCapacity) {
    const remaining = getRoomRemainingCapacity(room.id)
    if (remaining >= participants) {
      return {
        roomIds: [room.id],
        requiresTwoRooms: false
      }
    }
  }
  
  return null // Aucune salle disponible
}
</file>

<file path="src/lib/permissions.ts">
/**
 * Utilitaires de gestion des permissions utilisateurs
 *
 * Ce module centralise toute la logique de permissions pour garantir
 * la cohérence dans toute l'application.
 */

import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import type { UserRole, ResourceType, Branch, Profile } from '@/lib/supabase/types'
import { NextResponse } from 'next/server'

// Types pour les vérifications de permissions
export type PermissionAction = 'view' | 'create' | 'edit' | 'delete'

export interface PermissionCheckResult {
  allowed: boolean
  user: {
    id: string
    role: UserRole
    profile: Profile
  } | null
  error?: {
    status: number
    code: string
    message: string
    messageKey: string // Clé de traduction pour le frontend
  }
}

export interface AuthenticatedUser {
  id: string
  email: string
  role: UserRole
  profile: Profile
  branchIds: string[]
}

/**
 * Vérifie l'authentification et récupère l'utilisateur avec son profil
 */
export async function getAuthenticatedUser(): Promise<{
  user: AuthenticatedUser | null
  error?: { status: number; code: string; message: string; messageKey: string }
}> {
  const supabase = await createClient()

  // Vérifier l'authentification
  const { data: { user }, error: authError } = await supabase.auth.getUser()

  if (authError || !user) {
    return {
      user: null,
      error: {
        status: 401,
        code: 'UNAUTHORIZED',
        message: 'You must be logged in to perform this action',
        messageKey: 'errors.unauthorized'
      }
    }
  }

  // Récupérer le profil avec le service role pour éviter les problèmes RLS
  const serviceClient = createServiceRoleClient()
  const { data: profile, error: profileError } = await serviceClient
    .from('profiles')
    .select('*')
    .eq('id', user.id)
    .single<Profile>()

  if (profileError || !profile) {
    return {
      user: null,
      error: {
        status: 403,
        code: 'NO_PROFILE',
        message: 'User profile not found',
        messageKey: 'errors.noProfile'
      }
    }
  }

  // Récupérer les branches de l'utilisateur
  const { data: userBranches } = await serviceClient
    .from('user_branches')
    .select('branch_id')
    .eq('user_id', user.id)
    .returns<Array<{ branch_id: string }>>()

  const branchIds = userBranches?.map(ub => ub.branch_id) || []

  return {
    user: {
      id: user.id,
      email: user.email || '',
      role: profile.role as UserRole,
      profile,
      branchIds
    }
  }
}

/**
 * Vérifie si un utilisateur a une permission spécifique sur une ressource
 */
// Type pour les permissions de rôle
interface RolePermissionRow {
  id: string
  role: string
  resource: string
  can_view: boolean
  can_create: boolean
  can_edit: boolean
  can_delete: boolean
}

export async function checkPermission(
  userRole: UserRole,
  resource: ResourceType,
  action: PermissionAction
): Promise<boolean> {
  // Super admin a toutes les permissions
  if (userRole === 'super_admin') {
    return true
  }

  const serviceClient = createServiceRoleClient()

  const { data: permission } = await serviceClient
    .from('role_permissions')
    .select('*')
    .eq('role', userRole)
    .eq('resource', resource)
    .single<RolePermissionRow>()

  if (!permission) {
    return false
  }

  switch (action) {
    case 'view':
      return permission.can_view
    case 'create':
      return permission.can_create
    case 'edit':
      return permission.can_edit
    case 'delete':
      return permission.can_delete
    default:
      return false
  }
}

/**
 * Vérifie si un utilisateur a accès à une branche spécifique
 */
export async function checkBranchAccess(
  userId: string,
  userRole: UserRole,
  branchId: string
): Promise<boolean> {
  // Super admin a accès à toutes les branches
  if (userRole === 'super_admin') {
    return true
  }

  const serviceClient = createServiceRoleClient()

  const { data: userBranch } = await serviceClient
    .from('user_branches')
    .select('id')
    .eq('user_id', userId)
    .eq('branch_id', branchId)
    .single()

  return !!userBranch
}

/**
 * Fonction complète de vérification pour les API routes
 * Vérifie: authentification + permission + accès branche (optionnel)
 */
export async function verifyApiPermission(
  resource: ResourceType,
  action: PermissionAction,
  branchId?: string
): Promise<{
  success: boolean
  user?: AuthenticatedUser
  errorResponse?: NextResponse
}> {
  // 1. Vérifier l'authentification
  const { user, error: authError } = await getAuthenticatedUser()

  if (authError || !user) {
    return {
      success: false,
      errorResponse: NextResponse.json(
        {
          success: false,
          error: authError?.code || 'UNAUTHORIZED',
          message: authError?.message || 'Authentication required',
          messageKey: authError?.messageKey || 'errors.unauthorized'
        },
        { status: authError?.status || 401 }
      )
    }
  }

  // 2. Vérifier la permission sur la ressource
  const hasPermission = await checkPermission(user.role, resource, action)

  if (!hasPermission) {
    return {
      success: false,
      errorResponse: NextResponse.json(
        {
          success: false,
          error: 'PERMISSION_DENIED',
          message: `You don't have permission to ${action} ${resource}`,
          messageKey: `errors.permission.${action}.${resource}`
        },
        { status: 403 }
      )
    }
  }

  // 3. Vérifier l'accès à la branche si spécifiée
  if (branchId) {
    const hasBranchAccess = await checkBranchAccess(user.id, user.role, branchId)

    if (!hasBranchAccess) {
      return {
        success: false,
        errorResponse: NextResponse.json(
          {
            success: false,
            error: 'BRANCH_ACCESS_DENIED',
            message: 'You don\'t have access to this branch',
            messageKey: 'errors.branchAccessDenied'
          },
          { status: 403 }
        )
      }
    }
  }

  return {
    success: true,
    user
  }
}

/**
 * Récupère les branches autorisées pour un utilisateur
 * 
 * @param userId - ID de l'utilisateur
 * @param userRole - Rôle de l'utilisateur
 * @returns Liste des branches autorisées
 */
export async function getUserAuthorizedBranches(
  userId: string,
  userRole: UserRole
): Promise<Branch[]> {
  const supabase = await createClient()

  if (userRole === 'super_admin') {
    // Super admin voit toutes les branches actives
    const { data: branches, error } = await supabase
      .from('branches')
      .select('*')
      .eq('is_active', true)
      .order('name')
      .returns<Branch[]>()

    if (error) {
      console.error('Error fetching all branches for super_admin:', error)
      return []
    }

    return branches || []
  } else {
    // Branch admin et agent voient uniquement leurs branches assignées
    const { data: userBranches, error } = await supabase
      .from('user_branches')
      .select('branch_id, branches(*)')
      .eq('user_id', userId)

    if (error) {
      console.error('Error fetching user branches:', error)
      return []
    }

    if (!userBranches || userBranches.length === 0) {
      return []
    }

    // Extraire les branches depuis les résultats
    const branches = userBranches
      .map((ub: any) => ub.branches)
      .filter(Boolean) as Branch[]

    return branches
  }
}

/**
 * Vérifie si un utilisateur a accès à une branche spécifique
 * 
 * @param userId - ID de l'utilisateur
 * @param userRole - Rôle de l'utilisateur
 * @param branchId - ID de la branche à vérifier
 * @returns true si l'utilisateur a accès, false sinon
 */
export async function checkUserBranchAccess(
  userId: string,
  userRole: UserRole,
  branchId: string
): Promise<boolean> {
  if (userRole === 'super_admin') {
    return true // Super admin a accès à tout
  }

  const authorizedBranches = await getUserAuthorizedBranches(userId, userRole)
  return authorizedBranches.some(b => b.id === branchId)
}

/**
 * Vérifie si un utilisateur peut gérer un autre utilisateur
 * 
 * @param currentUserId - ID de l'utilisateur connecté
 * @param currentUserRole - Rôle de l'utilisateur connecté
 * @param targetUserId - ID de l'utilisateur cible
 * @returns true si l'utilisateur peut gérer la cible, false sinon
 */
export async function canManageUser(
  currentUserId: string,
  currentUserRole: UserRole,
  targetUserId: string
): Promise<boolean> {
  // Super admin peut gérer tout le monde (sauf se supprimer lui-même, géré ailleurs)
  if (currentUserRole === 'super_admin') {
    return true
  }

  // Branch admin peut gérer les utilisateurs qui partagent au moins une branche
  if (currentUserRole === 'branch_admin') {
    const supabase = await createClient()

    // Récupérer les branches du branch_admin
    const { data: adminBranches } = await supabase
      .from('user_branches')
      .select('branch_id')
      .eq('user_id', currentUserId)
      .returns<Array<{ branch_id: string }>>()

    if (!adminBranches || adminBranches.length === 0) {
      return false
    }

    const adminBranchIds = adminBranches.map((b: { branch_id: string }) => b.branch_id)

    // Récupérer les branches de l'utilisateur cible
    const { data: targetBranches } = await supabase
      .from('user_branches')
      .select('branch_id')
      .eq('user_id', targetUserId)
      .returns<Array<{ branch_id: string }>>()

    if (!targetBranches || targetBranches.length === 0) {
      return false
    }

    const targetBranchIds = targetBranches.map((b: { branch_id: string }) => b.branch_id)

    // Vérifier s'il y a au moins une branche en commun
    return targetBranchIds.some(id => adminBranchIds.includes(id))
  }

  // Agent ne peut gérer personne
  return false
}

/**
 * Récupère tous les IDs de branches autorisées pour un utilisateur
 * 
 * @param userId - ID de l'utilisateur
 * @param userRole - Rôle de l'utilisateur
 * @returns Liste des IDs de branches autorisées
 */
export async function getUserAuthorizedBranchIds(
  userId: string,
  userRole: UserRole
): Promise<string[]> {
  const branches = await getUserAuthorizedBranches(userId, userRole)
  return branches.map(b => b.id)
}
</file>

<file path="src/lib/reservations.ts">
/**
 * Utilitaire pour gérer les réservations (lecture/écriture fichier JSON)
 * Simple et efficace pour débuter
 */

import { promises as fs } from 'fs'
import { join } from 'path'

export interface Reservation {
  id: string
  branch: string
  type: 'game' | 'event'
  players: number
  date: string
  time: string
  firstName: string
  lastName: string
  phone: string
  email: string | null
  specialRequest: string | null
  eventType: string | null // "birthday", "bar_mitzvah", "corporate", "party", "other"
  eventAge: number | null
  reservationNumber: string
  createdAt: string
  status: 'confirmed' | 'cancelled'
}

const RESERVATIONS_FILE = join(process.cwd(), 'data', 'reservations.json')

/**
 * Lit toutes les réservations depuis le fichier JSON
 */
export async function getAllReservations(): Promise<Reservation[]> {
  try {
    const data = await fs.readFile(RESERVATIONS_FILE, 'utf-8')
    return JSON.parse(data)
  } catch (error) {
    // Si le fichier n'existe pas, retourner un tableau vide
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return []
    }
    console.error('Error reading reservations:', error)
    throw error
  }
}

/**
 * Sauvegarde une nouvelle réservation
 */
export async function saveReservation(reservation: Omit<Reservation, 'id' | 'createdAt' | 'status'>): Promise<Reservation> {
  try {
    const reservations = await getAllReservations()
    
    const newReservation: Reservation = {
      ...reservation,
      id: `res-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString(),
      status: 'confirmed',
    }
    
    reservations.push(newReservation)
    
    await fs.writeFile(RESERVATIONS_FILE, JSON.stringify(reservations, null, 2), 'utf-8')
    
    return newReservation
  } catch (error) {
    console.error('Error saving reservation:', error)
    throw error
  }
}

/**
 * Met à jour le statut d'une réservation
 */
export async function updateReservationStatus(id: string, status: 'confirmed' | 'cancelled'): Promise<Reservation | null> {
  try {
    const reservations = await getAllReservations()
    const index = reservations.findIndex(r => r.id === id)
    
    if (index === -1) {
      return null
    }
    
    reservations[index].status = status
    await fs.writeFile(RESERVATIONS_FILE, JSON.stringify(reservations, null, 2), 'utf-8')
    
    return reservations[index]
  } catch (error) {
    console.error('Error updating reservation:', error)
    throw error
  }
}
</file>

<file path="src/lib/session-builder.ts">
/**
 * Construction des sessions de jeu
 * LOGIQUE IDENTIQUE à BookingModal.handleSubmit
 * Utilisée par l'admin ET l'API site
 */

import type { LaserRoom, GameSession } from './supabase/types'

export interface SessionBuilderParams {
  bookingType: 'GAME' | 'EVENT'
  gameArea?: 'ACTIVE' | 'LASER' | null
  numberOfGames: number
  participants: number
  startDateTime: Date
  branchId: string
  gameDuration: number // En minutes
  // Fonction pour trouver les meilleures salles laser
  findBestLaserRoom?: (
    participants: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string,
    branchId?: string | null
  ) => Promise<{ roomIds: string[]; requiresTwoRooms: boolean } | null>
  excludeBookingId?: string
}

export interface SessionBuilderResult {
  game_sessions: Array<{
    game_area: 'ACTIVE' | 'LASER'
    start_datetime: string
    end_datetime: string
    laser_room_id: string | null
    session_order: number
    pause_before_minutes: number
  }>
  error?: string
}

/**
 * Construit les game_sessions pour un booking GAME
 * IDENTIQUE à BookingModal ligne 1244-1397
 */
export async function buildGameSessions(
  params: SessionBuilderParams
): Promise<SessionBuilderResult> {
  
  const {
    gameArea,
    numberOfGames,
    participants,
    startDateTime,
    branchId,
    gameDuration,
    findBestLaserRoom,
    excludeBookingId
  } = params

  const game_sessions: SessionBuilderResult['game_sessions'] = []

  if (gameArea === 'ACTIVE') {
    // ACTIVE : créer des sessions pour chaque jeu
    let currentStart = new Date(startDateTime)
    
    for (let i = 0; i < numberOfGames; i++) {
      const sessionStart = new Date(currentStart)
      const sessionEnd = new Date(sessionStart)
      sessionEnd.setMinutes(sessionEnd.getMinutes() + gameDuration)
      
      game_sessions.push({
        game_area: 'ACTIVE',
        start_datetime: sessionStart.toISOString(),
        end_datetime: sessionEnd.toISOString(),
        laser_room_id: null,
        session_order: i + 1,
        pause_before_minutes: 0
      })
      
      // Prochain jeu commence directement après (pas de pause par défaut site)
      currentStart = sessionEnd
    }
    
  } else if (gameArea === 'LASER') {
    // LASER : créer des sessions pour chaque jeu
    // IDENTIQUE à BookingModal ligne 1279-1333
    let currentStart = new Date(startDateTime)
    
    for (let i = 0; i < numberOfGames; i++) {
      const sessionStart = new Date(currentStart)
      const sessionEnd = new Date(sessionStart)
      sessionEnd.setMinutes(sessionEnd.getMinutes() + gameDuration)
      
      // Trouver la meilleure salle laser pour cette session
      let allocatedRoomIds: string[] = []
      
      if (findBestLaserRoom) {
        const allocation = await findBestLaserRoom(
          participants,
          sessionStart,
          sessionEnd,
          excludeBookingId,
          branchId
        )
        
        if (allocation) {
          allocatedRoomIds = allocation.roomIds
        } else {
          // AUCUNE SALLE DISPONIBLE
          const timeStr = `${String(sessionStart.getHours()).padStart(2, '0')}:${String(sessionStart.getMinutes()).padStart(2, '0')}`
          return {
            game_sessions: [],
            error: `No laser room available for ${participants} participants at ${timeStr}`
          }
        }
      }
      
      // Créer une session par salle (si L1+L2, créer 2 sessions)
      // IDENTIQUE à BookingModal ligne 1316-1326
      allocatedRoomIds.forEach((roomId) => {
        game_sessions.push({
          game_area: 'LASER',
          start_datetime: sessionStart.toISOString(),
          end_datetime: sessionEnd.toISOString(),
          laser_room_id: roomId,
          session_order: i + 1, // Ordre du jeu (1, 2, 3, etc.)
          pause_before_minutes: 0
        })
      })
      
      // Prochain jeu commence après la pause (30 min par défaut, comme l'admin)
      // IDENTIQUE à BookingModal ligne 1328-1332
      const pauseAfter = i < numberOfGames - 1 ? 30 : 0 // 30 min pause entre les jeux
      currentStart = new Date(sessionEnd)
      if (pauseAfter > 0) {
        currentStart.setMinutes(currentStart.getMinutes() + pauseAfter)
      }
    }
  }

  return { game_sessions }
}

/**
 * Wrapper pour l'API qui gère la récupération des bookings et appelle findBestLaserRoomsForBooking
 */
export async function buildGameSessionsForAPI(params: {
  gameArea?: 'ACTIVE' | 'LASER' | null
  numberOfGames: number
  participants: number
  startDateTime: Date
  branchId: string
  gameDuration: number
  supabase: any // Supabase client
}): Promise<SessionBuilderResult> {
  
  const { gameArea, supabase, branchId, startDateTime, gameDuration, numberOfGames, participants } = params
  
  // Si LASER, on doit récupérer les données pour findBestLaserRoom
  if (gameArea === 'LASER') {
    // Récupérer salles laser
    const { data: laserRooms } = await supabase
      .from('laser_rooms')
      .select('*')
      .eq('branch_id', branchId)
      .eq('is_active', true)
      .order('sort_order')
    
    // Récupérer settings
    const { data: settings } = await supabase
      .from('branch_settings')
      .select('*')
      .eq('branch_id', branchId)
      .single()
    
    // Récupérer tous les bookings
    const { data: allBookings } = await supabase
      .from('bookings')
      .select(`
        id,
        branch_id,
        participants_count,
        status,
        game_sessions (
          id,
          game_area,
          laser_room_id,
          start_datetime,
          end_datetime
        )
      `)
      .eq('branch_id', branchId)
      .neq('status', 'CANCELLED')
    
    // Créer une fonction findBestLaserRoom pour ce contexte
    const findBestLaserRoom = async (
      participants: number,
      start: Date,
      end: Date,
      excludeId?: string
    ) => {
      const { findBestLaserRoomsForBooking } = await import('./laser-allocation')

      const result = await findBestLaserRoomsForBooking({
        participants,
        startDateTime: start,
        endDateTime: end,
        branchId,
        laserRooms: laserRooms || [],
        settings: {
          laser_exclusive_threshold: settings?.laser_exclusive_threshold || 10,
          laser_total_vests: settings?.laser_total_vests || 30,
          laser_spare_vests: settings?.laser_spare_vests || 0
        },
        allBookings: allBookings || [],
        excludeBookingId: excludeId,
        allocationMode: 'auto'
      })

      return result
    }
    
    return await buildGameSessions({
      bookingType: 'GAME',
      gameArea,
      numberOfGames,
      participants,
      startDateTime,
      branchId,
      gameDuration,
      findBestLaserRoom
    })
  }
  
  // Pour ACTIVE, pas besoin de fonction spéciale
  return await buildGameSessions({
    bookingType: 'GAME',
    gameArea,
    numberOfGames,
    participants,
    startDateTime,
    branchId,
    gameDuration
  })
}
</file>

<file path="src/lib/validation.ts">
/**
 * Utilitaires de validation pour les formulaires
 */

/**
 * Valide le format d'un email
 * @param email - L'adresse email à valider
 * @returns true si l'email est valide
 */
export function validateEmail(email: string): boolean {
  if (!email || typeof email !== 'string') return false
  
  // Regex standard pour validation email
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email.trim())
}

/**
 * Valide un numéro de téléphone israélien
 * Format attendu : 05XXXXXXXX (10 chiffres commençant par 05)
 * @param phone - Le numéro de téléphone à valider
 * @returns true si le téléphone est valide
 */
export function validateIsraeliPhone(phone: string): boolean {
  if (!phone || typeof phone !== 'string') return false
  
  // Nettoyer le numéro (retirer espaces, tirets, etc.)
  const cleaned = phone.replace(/[\s\-\(\)\.]/g, '')
  
  // Vérifier le format : 10 chiffres commençant par 05
  const phoneRegex = /^05\d{8}$/
  return phoneRegex.test(cleaned)
}

/**
 * Formate un numéro de téléphone israélien en retirant les caractères inutiles
 * @param phone - Le numéro de téléphone à formater
 * @returns Le numéro nettoyé (05XXXXXXXX) ou la chaîne vide si invalide
 */
export function formatIsraeliPhone(phone: string): string {
  if (!phone || typeof phone !== 'string') return ''
  
  // Nettoyer le numéro
  const cleaned = phone.replace(/[\s\-\(\)\.]/g, '')
  
  // Vérifier si c'est un format valide
  if (validateIsraeliPhone(cleaned)) {
    return cleaned
  }
  
  // Si le format est invalide, retourner tel quel pour que l'utilisateur corrige
  return phone.trim()
}

/**
 * Affiche un numéro de téléphone israélien avec formatage visuel
 * Format : 05X-XXX-XXXX
 * @param phone - Le numéro de téléphone
 * @returns Le numéro formaté pour l'affichage
 */
export function displayIsraeliPhone(phone: string): string {
  const cleaned = formatIsraeliPhone(phone)
  
  if (cleaned.length === 10 && cleaned.startsWith('05')) {
    return `${cleaned.slice(0, 3)}-${cleaned.slice(3, 6)}-${cleaned.slice(6)}`
  }
  
  return phone
}

/**
 * Messages d'erreur pour les validations
 */
export const VALIDATION_MESSAGES = {
  email: {
    invalid: 'Adresse email invalide',
    required: 'Email requis'
  },
  phone: {
    invalid: 'Numéro de téléphone invalide (format : 05XXXXXXXX)',
    required: 'Numéro de téléphone requis',
    israeliFormat: 'Le numéro doit commencer par 05 et contenir 10 chiffres'
  }
}
</file>

<file path="conditions.txt">
הערות


תנאים כלליים
- ההשתתפות בנעליים סגורות ושטוחות בלבד 
- אסורה ההשתתפות לנשים בהריון חולי אפילפסיה קוצבי לב.


- זמן משחק: 20 דקות נטו + 10-15 דקות של הדרכה והלבשה.

החברה שומרת לעצמה את הזכות לבצע משחקים עם פחות מ30 משתתפים במקרה של תקלות טכניות.
*החברה אינה עובדת עם שוברים. 
*חל איסור להכניס למקום קומקום חשמלי, מי-חם, מכשירי חשמל, קונפטי, פנייטות, זיקוקים, בועות סבון, סיגריות ואלכוהול.

***אין אפשרות להביא כיבוד אם לא הזמנתם חדר. 

מחירים

משחק 1 - 70 ש׳׳ח למשתתף 
2 משחקים - 120 ש׳׳ח למשתתף 
3 משחקים - 150 ש׳׳ח למשתתף

30 משתתפים ומעלה -
משחק 1 - 60 ש׳׳ח למשתתף
2 משחקים - 100 ש׳׳ח למשתתף
3 משחקים - 130 ש׳׳ח למשתתף
*המחירים לאדם אחד בלבד.


חבילות יום הולדת/גיבוש/סוף שנה:
15 משתתפים 2200 ש"ח - כל משתתף נוסף בתוספת 120 ש"ח למשתתף
30 משתתפים- 3450 ש"ח- כל משתתף נוסף בתוספת 100 ש"ח למשתתף
*ניתן לשנות את גודל החבילה עד 3 ימים לפני האירוע. 

אירועים

- שתייה קלה: מוגז/מיץ - בקבוקים 1.5L - טעמים לפי זמינות במלאי/ מים בתמי 4. 
- כיבוד קל: מגוון חטיפים של אסם/עלית - הטעמים לפי זמינות במלאי.
- 2 משולשי פיצה למשתתף (ניתן להוסיף מגשים נוספים - 40 ש׳׳ח לכל מגש אקסטרא).
- חדרי אירועים: אין התחייבות לחדר אירוע ספציפי, החברה שומרת לעצמה את הזכות לבחור את שיבוץ החדרים.
*לתשומת ליבכם, ילד בעל אלרגיה מסכנת חיים חייב בליווי מבוגר צמוד אליו. חברת לייזר בלאסט בע׳׳מ אינה יכולה לקחת אחריות על אלרגיות. אנחנו כן יכולים לתת הנחייה לא להגיש חטיף כזה או אחר וכמובן לתת לכם בעלי האירוע להחליט איזה חטיפים יוגשו לפני פתיחתם.

- תחילת אירועים ופעילות: הלקוח מתבקש להגיע 15 דקות לפני תחילת האירוע, את האורחים יש להזמין לשעה שנקבעה, את הפעילות נתחיל 15 דק׳ לאחר השעה שנקבעה.
במידה והלקוח יסרב להתחיל את הפעילות חברת "לייזר אניגמה בע׳׳מ" בע"מ לא מתחייבת לשעה ולכניסה למשחק.
- מספר משתתפים באירוע:  מינימום 15 משתתפים. 
*משך האירוע - שעה וחצי/שעתיים - תלוי בכמות המשחקים. 

חברת לייזר אניגמה בע׳׳מ מספקת -
ֿ- שולחנות 180/70 ערוכים עם מפות אל-בד. 
- צלחות לחטיפים שמוגשים + כוסות לשתיה קרה. 
- משחקי שולחן - במקרה של נזק המזמין יישא באחריות מלאה ובהחזר כספי.
- קישוט החדר - חדרי האירוח של המתחם מעוצבים בציורי קיר מרהיבים. ניתן להביא קישוטים נוספים באופן עצמאי - ללא הדבקה על הקירות. 
- ניתן להוסיף כוסות ברד לילדים - 15 כוסות בעלות 120 ש׳׳ח / 30 כוסות בעלות 240 ש׳׳ח. 



מספר משתתפים במשחק:
החברה שומרת לעצמה את הזכות להחליט על כמות המשתתפים שנכנסים בו זמנית למשחק,
במידה ומספר המשתתפים בקבוצה גדול מכמות האפודים תבוצע חלוקה לסבבים.


תנאי תשלום

- ביטולים /דחיה : עד 8 ימים לפני האירוע בהחזר מלא של המקדמה.
7-6 ימים לפני האירוע - דמי ביטול של 30% מסך האירוע 
5-4 ימים לפני האירוע - דמי ביטול של 50% מסך האירוע
3 ימים לפני האירוע - דמי ביטול של 100% מסך האירוע
מקדמה - שליש מעלות האירוע, היתרה תשולם ביום האירוע. 


התשלום בתנאי מזומן או אשראי - התשלום הינו על פי פרטי האירוע והתאריך כפי שמופיעים לעיל וסוכמו בין הצדדים.
כל שינוי בפרטי האירוע והתאריך עשויים לגרור לתשלום נוסף בגין שינוי זה. רק שינויים אשר אושרו על ידי "לייזר בלאסט בע"מ״ יחייבו.


הזמנת עבודה תכנס לתוקף רק מעת תשלום מלוא המקדמה

*** בעת לחימה - אם האיזור יוגדר כאיזור סיכון ע"י פיקוד העורף, משמע הנחיות פיקוד העורף יאסרו התקהלות במבנה סגור באזורנו, האירוע יידחה ויתואם מחדש עד שבועיים מהרגע בו פיקוד העורף הוריד הנחיות מעודכנות המאפשרות לקיים את האירוע.
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
</file>

<file path="next.config.ts">
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'activegamesworld.com',
      },
    ],
  },
}

export default nextConfig
</file>

<file path="postcss.config.mjs">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: '#00f0ff',
        secondary: '#ff00ff',
        accent: '#ffff00',
        dark: {
          DEFAULT: '#0a0a0a',
          100: '#1a1a1a',
          200: '#2a2a2a',
          300: '#3a3a3a',
        },
        neon: {
          cyan: '#00f0ff',
          magenta: '#ff00ff',
          yellow: '#ffff00',
          green: '#00ff00',
          orange: '#ff6600',
        },
      },
      fontFamily: {
        sans: ['Poppins', 'Inter', 'system-ui', 'sans-serif'],
        display: ['Orbitron', 'sans-serif'],
        menu: ['Roboto', 'sans-serif'],
      },
      animation: {
        'glow': 'glow 2s ease-in-out infinite alternate',
        'float': 'float 3s ease-in-out infinite',
        'pulse-neon': 'pulse-neon 2s ease-in-out infinite',
      },
      keyframes: {
        glow: {
          '0%': { boxShadow: '0 0 5px #00f0ff, 0 0 10px #00f0ff, 0 0 20px #00f0ff' },
          '100%': { boxShadow: '0 0 10px #00f0ff, 0 0 20px #00f0ff, 0 0 40px #00f0ff' },
        },
        float: {
          '0%, 100%': { transform: 'translateY(0)' },
          '50%': { transform: 'translateY(-10px)' },
        },
        'pulse-neon': {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.5' },
        },
      },
    },
  },
  plugins: [],
}

export default config
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2018",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "prisma.config.ts", "prisma"]
}
</file>

<file path=".github/workflows/backup.yml">
name: Backup Supabase (Hourly 10h-22h)

on:
  schedule:
    # Toutes les heures de 10h à 22h (UTC+2 = Israel Time)
    # UTC: 8h à 20h
    - cron: '0 8-20 * * *'

  # Permet de lancer manuellement
  workflow_dispatch:

jobs:
  backup:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @supabase/supabase-js

      - name: Run backup
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          node << 'EOF'
          const { createClient } = require('@supabase/supabase-js');

          async function backup() {
            console.log('🔄 Début du backup automatique (GitHub Actions)...');

            const supabase = createClient(
              process.env.SUPABASE_URL,
              process.env.SUPABASE_SERVICE_KEY
            );

            const tables = [
              'activity_logs', 'ai_conversations', 'ai_messages',
              'booking_contacts', 'booking_slots', 'bookings',
              'branch_settings', 'branches', 'contacts',
              'email_logs', 'email_settings', 'email_templates',
              'event_rooms', 'game_sessions', 'icount_event_formulas',
              'icount_products', 'icount_rooms', 'laser_rooms',
              'orders', 'payment_credentials', 'payments',
              'profiles', 'role_permissions', 'roles', 'user_branches'
            ];

            const backupData = {
              timestamp: new Date().toISOString(),
              version: '1.0',
              source: 'github-actions',
              tables: {},
              metadata: {
                project: 'activelaser',
                database: 'zapwlcrjnabrfhoxfgqo',
                workflow: 'hourly-backup'
              }
            };

            let totalRecords = 0;

            for (const table of tables) {
              try {
                const { data, error, count } = await supabase
                  .from(table)
                  .select('*', { count: 'exact' });

                if (error) {
                  console.error(`❌ ${table}: ${error.message}`);
                  backupData.tables[table] = { error: error.message, records: 0 };
                  continue;
                }

                backupData.tables[table] = {
                  data: data || [],
                  records: count || 0
                };

                totalRecords += count || 0;
                console.log(`✅ ${table}: ${count || 0} enregistrements`);
              } catch (err) {
                console.error(`❌ ${table}: ${err.message}`);
                backupData.tables[table] = { error: err.message, records: 0 };
              }
            }

            const backupJSON = JSON.stringify(backupData, null, 2);
            const backupBuffer = Buffer.from(backupJSON);

            console.log(`📊 Total: ${totalRecords} enregistrements`);
            console.log(`📦 Taille: ${(backupBuffer.length / 1024).toFixed(2)} KB`);

            // Upload dans Supabase Storage
            const filename = `backup_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;

            const { error: uploadError } = await supabase
              .storage
              .from('backups')
              .upload(filename, backupBuffer, {
                contentType: 'application/json',
                upsert: false
              });

            if (uploadError) {
              console.error('❌ Upload error:', uploadError.message);
              process.exit(1);
            }

            console.log(`✅ Backup uploadé: ${filename}`);

            // Nettoyer les vieux backups (garder les 50 derniers)
            const { data: files } = await supabase
              .storage
              .from('backups')
              .list('', {
                limit: 100,
                sortBy: { column: 'created_at', order: 'desc' }
              });

            if (files && files.length > 50) {
              const filesToDelete = files
                .filter(f => f.name.startsWith('backup_') && f.name.endsWith('.json'))
                .slice(50)
                .map(f => f.name);

              if (filesToDelete.length > 0) {
                const { error: deleteError } = await supabase
                  .storage
                  .from('backups')
                  .remove(filesToDelete);

                if (!deleteError) {
                  console.log(`🗑️  ${filesToDelete.length} vieux backups supprimés`);
                }
              }
            }

            console.log('✅ Backup terminé avec succès');
          }

          backup().catch(err => {
            console.error('❌ Erreur:', err);
            process.exit(1);
          });
          EOF

      - name: Backup summary
        if: always()
        run: echo "Backup job completed at $(date)"
</file>

<file path="src/app/admin/clara/settings/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { ArrowLeft, Save, Key, MessageSquare, Link2, Loader2, CheckCircle, AlertCircle, Sparkles } from 'lucide-react'
import Link from 'next/link'

interface ClaraSettings {
  anthropic_api_key: string
  system_prompt: string
  model: string
  max_tokens: number
  connectors: {
    supabase: boolean
    github: boolean
    vercel: boolean
  }
}

export default function ClaraSettingsPage() {
  const [settings, setSettings] = useState<ClaraSettings>({
    anthropic_api_key: '',
    system_prompt: `Tu es Clara, l'assistante IA virtuelle pour ActiveLaser.

Tu peux:
- Analyser les données de l'entreprise (commandes, clients, revenus)
- Effectuer des actions administratives (fermer commandes, corriger statuts, etc.)
- Aider les utilisateurs à comprendre le logiciel
- Répondre aux questions en français de manière professionnelle

Sois proactive: si tu détectes des problèmes dans les données, mentionne-les.`,
    model: 'claude-sonnet-4-20250514',
    max_tokens: 2048,
    connectors: {
      supabase: true,
      github: false,
      vercel: false
    }
  })
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [message, setMessage] = useState<{ type: 'success' | 'error'; text: string } | null>(null)
  const [testResult, setTestResult] = useState<{ success: boolean; message: string } | null>(null)

  // Load settings from API/localStorage
  useEffect(() => {
    const loadSettings = async () => {
      try {
        // For now, load from localStorage (in production, this would be from API)
        const saved = localStorage.getItem('clara_settings')
        if (saved) {
          const parsed = JSON.parse(saved)
          setSettings(prev => ({ ...prev, ...parsed }))
        }
      } catch (error) {
        console.error('Error loading Clara settings:', error)
      } finally {
        setLoading(false)
      }
    }

    loadSettings()
  }, [])

  // Save settings
  const handleSave = async () => {
    setSaving(true)
    setMessage(null)

    try {
      // Save to localStorage (in production, would save to API/database)
      localStorage.setItem('clara_settings', JSON.stringify(settings))

      // Also update environment variable via API (if needed)
      // For security, the API key should be stored server-side
      // This is a simplified version for demo purposes

      setMessage({ type: 'success', text: 'Paramètres sauvegardés avec succès!' })
    } catch (error) {
      console.error('Error saving settings:', error)
      setMessage({ type: 'error', text: 'Erreur lors de la sauvegarde' })
    } finally {
      setSaving(false)
    }
  }

  // Test API connection
  const handleTestConnection = async () => {
    setTestResult(null)

    if (!settings.anthropic_api_key) {
      setTestResult({ success: false, message: 'Veuillez entrer une clé API' })
      return
    }

    try {
      const response = await fetch('/api/admin/statistics/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: 'Dis simplement "Connexion réussie!" en une phrase.',
          dateRange: 'today'
        })
      })

      const data = await response.json()

      if (data.success && data.answer) {
        setTestResult({ success: true, message: 'Connexion réussie! Clara est prête.' })
      } else {
        setTestResult({ success: false, message: data.error || 'Erreur de connexion' })
      }
    } catch (error) {
      console.error('Test error:', error)
      setTestResult({ success: false, message: 'Erreur de connexion à l\'API' })
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-dark-100 flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-primary" />
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-dark-100">
      {/* Header */}
      <header className="bg-dark-200 border-b border-primary/20 px-6 py-4">
        <div className="max-w-4xl mx-auto flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Link
              href="/admin/orders"
              className="p-2 hover:bg-dark-300 rounded-lg transition-colors"
            >
              <ArrowLeft className="w-5 h-5 text-gray-400" />
            </Link>
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-gradient-to-r from-primary to-purple-500 flex items-center justify-center">
                <Sparkles className="w-5 h-5 text-white" />
              </div>
              <div>
                <h1 className="text-xl font-bold text-white">Paramètres Clara</h1>
                <p className="text-sm text-gray-400">Configuration de l&apos;assistant IA</p>
              </div>
            </div>
          </div>

          <button
            onClick={handleSave}
            disabled={saving}
            className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-primary to-purple-500 text-white rounded-lg hover:opacity-90 disabled:opacity-50 transition-opacity"
          >
            {saving ? (
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Save className="w-4 h-4" />
            )}
            Sauvegarder
          </button>
        </div>
      </header>

      {/* Content */}
      <main className="max-w-4xl mx-auto px-6 py-8 space-y-8">
        {/* Message */}
        {message && (
          <div className={`flex items-center gap-3 p-4 rounded-lg ${
            message.type === 'success'
              ? 'bg-green-900/20 border border-green-500/30 text-green-400'
              : 'bg-red-900/20 border border-red-500/30 text-red-400'
          }`}>
            {message.type === 'success' ? (
              <CheckCircle className="w-5 h-5" />
            ) : (
              <AlertCircle className="w-5 h-5" />
            )}
            {message.text}
          </div>
        )}

        {/* API Key Section */}
        <section className="bg-dark-200/50 rounded-xl border border-primary/20 p-6">
          <div className="flex items-center gap-3 mb-6">
            <Key className="w-5 h-5 text-primary" />
            <h2 className="text-lg font-bold text-white">Clé API Anthropic</h2>
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-sm text-gray-400 mb-2">
                Clé API (sk-ant-...)
              </label>
              <input
                type="password"
                value={settings.anthropic_api_key}
                onChange={(e) => setSettings(prev => ({ ...prev, anthropic_api_key: e.target.value }))}
                placeholder="sk-ant-api03-..."
                className="w-full bg-dark-300 border border-primary/20 rounded-lg px-4 py-3 text-white placeholder-gray-500 focus:outline-none focus:border-primary"
              />
              <p className="text-xs text-gray-500 mt-2">
                Obtenez votre clé sur <a href="https://console.anthropic.com" target="_blank" rel="noopener noreferrer" className="text-primary hover:underline">console.anthropic.com</a>
              </p>
            </div>

            <div className="flex items-center gap-4">
              <button
                onClick={handleTestConnection}
                className="px-4 py-2 border border-primary text-primary rounded-lg hover:bg-primary/10 transition-colors"
              >
                Tester la connexion
              </button>

              {testResult && (
                <div className={`flex items-center gap-2 text-sm ${
                  testResult.success ? 'text-green-400' : 'text-red-400'
                }`}>
                  {testResult.success ? (
                    <CheckCircle className="w-4 h-4" />
                  ) : (
                    <AlertCircle className="w-4 h-4" />
                  )}
                  {testResult.message}
                </div>
              )}
            </div>
          </div>
        </section>

        {/* System Prompt Section */}
        <section className="bg-dark-200/50 rounded-xl border border-primary/20 p-6">
          <div className="flex items-center gap-3 mb-6">
            <MessageSquare className="w-5 h-5 text-primary" />
            <h2 className="text-lg font-bold text-white">Prompt Système</h2>
          </div>

          <div>
            <label className="block text-sm text-gray-400 mb-2">
              Instructions de base pour Clara
            </label>
            <textarea
              value={settings.system_prompt}
              onChange={(e) => setSettings(prev => ({ ...prev, system_prompt: e.target.value }))}
              rows={10}
              className="w-full bg-dark-300 border border-primary/20 rounded-lg px-4 py-3 text-white placeholder-gray-500 focus:outline-none focus:border-primary resize-y"
            />
            <p className="text-xs text-gray-500 mt-2">
              Ce prompt définit la personnalité et les capacités de Clara.
            </p>
          </div>
        </section>

        {/* Model Settings */}
        <section className="bg-dark-200/50 rounded-xl border border-primary/20 p-6">
          <div className="flex items-center gap-3 mb-6">
            <Sparkles className="w-5 h-5 text-primary" />
            <h2 className="text-lg font-bold text-white">Modèle IA</h2>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm text-gray-400 mb-2">
                Modèle Claude
              </label>
              <select
                value={settings.model}
                onChange={(e) => setSettings(prev => ({ ...prev, model: e.target.value }))}
                className="w-full bg-dark-300 border border-primary/20 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-primary"
              >
                <option value="claude-sonnet-4-20250514">Claude Sonnet 4 (Recommandé)</option>
                <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
                <option value="claude-3-haiku-20240307">Claude 3 Haiku (Rapide)</option>
              </select>
            </div>

            <div>
              <label className="block text-sm text-gray-400 mb-2">
                Max Tokens
              </label>
              <input
                type="number"
                value={settings.max_tokens}
                onChange={(e) => setSettings(prev => ({ ...prev, max_tokens: parseInt(e.target.value) || 2048 }))}
                min={256}
                max={8192}
                className="w-full bg-dark-300 border border-primary/20 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-primary"
              />
            </div>
          </div>
        </section>

        {/* Connectors Section */}
        <section className="bg-dark-200/50 rounded-xl border border-primary/20 p-6">
          <div className="flex items-center gap-3 mb-6">
            <Link2 className="w-5 h-5 text-primary" />
            <h2 className="text-lg font-bold text-white">Connecteurs</h2>
          </div>

          <div className="space-y-4">
            <div className="flex items-center justify-between p-4 bg-dark-300/50 rounded-lg">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-lg bg-green-600/20 flex items-center justify-center">
                  <span className="text-lg">🗄️</span>
                </div>
                <div>
                  <h3 className="font-medium text-white">Supabase</h3>
                  <p className="text-sm text-gray-400">Base de données & Auth</p>
                </div>
              </div>
              <div className={`px-3 py-1 rounded-full text-xs ${
                settings.connectors.supabase
                  ? 'bg-green-600/20 text-green-400'
                  : 'bg-gray-600/20 text-gray-400'
              }`}>
                {settings.connectors.supabase ? 'Connecté' : 'Non connecté'}
              </div>
            </div>

            <div className="flex items-center justify-between p-4 bg-dark-300/50 rounded-lg opacity-50">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-lg bg-gray-600/20 flex items-center justify-center">
                  <span className="text-lg">🐙</span>
                </div>
                <div>
                  <h3 className="font-medium text-white">GitHub</h3>
                  <p className="text-sm text-gray-400">Gestion de code (Bientôt)</p>
                </div>
              </div>
              <div className="px-3 py-1 rounded-full text-xs bg-gray-600/20 text-gray-400">
                Bientôt disponible
              </div>
            </div>

            <div className="flex items-center justify-between p-4 bg-dark-300/50 rounded-lg opacity-50">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-lg bg-gray-600/20 flex items-center justify-center">
                  <span className="text-lg">▲</span>
                </div>
                <div>
                  <h3 className="font-medium text-white">Vercel</h3>
                  <p className="text-sm text-gray-400">Déploiement (Bientôt)</p>
                </div>
              </div>
              <div className="px-3 py-1 rounded-full text-xs bg-gray-600/20 text-gray-400">
                Bientôt disponible
              </div>
            </div>
          </div>
        </section>

        {/* Info */}
        <div className="text-center text-gray-500 text-sm">
          <p>Clara utilise l&apos;API Anthropic Claude pour fournir des réponses intelligentes.</p>
          <p>Les données sont traitées de manière sécurisée et ne sont pas stockées par Anthropic.</p>
        </div>
      </main>
    </div>
  )
}
</file>

<file path="src/app/admin/components/AgendaSearch.tsx">
'use client'

import { Search } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { BookingWithSlots } from '@/hooks/useBookings'
import type { Contact } from '@/lib/supabase/types'

interface AgendaSearchProps {
  searchQuery: string
  onSearchChange: (query: string) => void
  searchResults: BookingWithSlots[]
  onSelectBooking: (booking: BookingWithSlots, bookingDate: Date) => void
  isDark: boolean
}

// Helper pour obtenir les données du contact
function getContactDisplayData(booking: BookingWithSlots) {
  if (booking.primaryContact) {
    return {
      firstName: booking.primaryContact.first_name || '',
      lastName: booking.primaryContact.last_name || '',
      phone: booking.primaryContact.phone || '',
      email: booking.primaryContact.email || '',
      notes: booking.primaryContact.notes_client || '',
    }
  }

  return {
    firstName: booking.customer_first_name || '',
    lastName: booking.customer_last_name || '',
    phone: booking.customer_phone || '',
    email: booking.customer_email || '',
    notes: booking.customer_notes_at_booking || '',
  }
}

export function AgendaSearch({
  searchQuery,
  onSearchChange,
  searchResults,
  onSelectBooking,
  isDark,
}: AgendaSearchProps) {
  const { t, locale } = useTranslation()

  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }

  return (
    <div className={`${isDark ? 'bg-gray-800' : 'bg-white'} rounded-xl p-6 border ${isDark ? 'border-gray-700' : 'border-gray-200'} mb-6`}>
      <div className="flex items-start gap-4">
        <div className="flex-1 relative">
          <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 ${isDark ? 'text-gray-400' : 'text-gray-600'}`} />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder={t('admin.agenda.search_placeholder')}
            className={`w-full pl-10 pr-4 py-3 ${isDark ? 'bg-gray-700 border-gray-600 text-white' : 'bg-gray-50 border-gray-300 text-gray-900'} border rounded-lg text-base placeholder-gray-500 focus:border-blue-500 focus:outline-none`}
          />
        </div>

        {/* Liste des résultats de recherche */}
        {searchQuery && searchResults.length > 0 && (
          <div className={`w-96 ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'} rounded-lg shadow-xl max-h-96 overflow-y-auto`}>
            <div className={`px-3 py-2 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'} ${isDark ? 'text-white' : 'text-gray-900'} font-semibold text-sm`}>
              {searchResults.length} {t('admin.agenda.results_found')}
            </div>
            <div className="divide-y divide-gray-700">
              {searchResults.map((booking) => {
                const bookingDate = new Date(booking.start_datetime)
                const dateFormatted = bookingDate.toLocaleDateString(getDateLocale(), {
                  day: '2-digit',
                  month: 'short',
                  year: 'numeric'
                })
                const timeFormatted = `${String(bookingDate.getHours()).padStart(2, '0')}:${String(bookingDate.getMinutes()).padStart(2, '0')}`
                const contactData = getContactDisplayData(booking)
                const customerName = `${contactData.firstName || ''} ${contactData.lastName || ''}`.trim() || t('admin.agenda.booking.no_name')

                return (
                  <button
                    key={booking.id}
                    type="button"
                    onClick={() => onSelectBooking(booking, bookingDate)}
                    className={`w-full text-left px-3 py-2 ${isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-50'} transition-colors`}
                  >
                    <div className="flex items-center justify-between gap-2">
                      <div className="flex-1 min-w-0">
                        <div className={`font-semibold ${isDark ? 'text-white' : 'text-gray-900'} truncate`}>
                          {customerName}
                        </div>
                        <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-600'} mt-0.5`}>
                          {dateFormatted} à {timeFormatted}
                        </div>
                        {booking.reference_code && (
                          <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-600'} mt-0.5`}>
                            {t('admin.agenda.ref')}: {booking.reference_code}
                          </div>
                        )}
                      </div>
                      <div className="flex-shrink-0">
                        <div
                          className="w-3 h-3 rounded-full"
                          style={{ backgroundColor: booking.status === 'CANCELLED' ? '#ef4444' : (booking.color || (booking.type === 'EVENT' ? '#22c55e' : '#3b82f6')) }}
                        />
                      </div>
                    </div>
                  </button>
                )
              })}
            </div>
          </div>
        )}

        {/* Message si aucun résultat */}
        {searchQuery && searchResults.length === 0 && (
          <div className={`w-96 ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'} rounded-lg shadow-xl px-4 py-3 ${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm`}>
            {t('admin.agenda.no_results')}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/components/AgendaStats.tsx">
'use client'

import { useTranslation } from '@/contexts/LanguageContext'

interface StatsData {
  day: {
    withRoom: number
    withoutRoom: number
    totalParticipants: number
    dateStr: string
  }
  week: {
    withRoom: number
    withoutRoom: number
    totalParticipants: number
    period: string
  }
  month: {
    withRoom: number
    withoutRoom: number
    totalParticipants: number
    period: string
  }
}

interface AgendaStatsProps {
  stats: StatsData
  isDark: boolean
}

export function AgendaStats({ stats, isDark }: AgendaStatsProps) {
  const { t } = useTranslation()

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
      {/* Jour */}
      <div className={`${isDark ? 'bg-gray-800' : 'bg-white'} rounded-xl p-4 border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
        <div className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-base mb-2`}>
          {stats.day.dateStr}
        </div>
        <div className="space-y-1">
          <div className="flex items-center justify-between">
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm`}>{t('admin.agenda.stats.with_room')}:</span>
            <span className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>{stats.day.withRoom}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm`}>{t('admin.agenda.stats.without_room')}:</span>
            <span className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>{stats.day.withoutRoom}</span>
          </div>
          <div className={`flex items-center justify-between pt-2 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm font-semibold`}>{t('admin.agenda.stats.total_people')}:</span>
            <span className={`text-2xl font-bold ${isDark ? 'text-blue-400' : 'text-blue-600'}`}>{stats.day.totalParticipants}</span>
          </div>
        </div>
      </div>

      {/* Semaine */}
      <div className={`${isDark ? 'bg-gray-800' : 'bg-white'} rounded-xl p-4 border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
        <div className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-base mb-2`}>
          {t('admin.agenda.week')} ({stats.week.period})
        </div>
        <div className="space-y-1">
          <div className="flex items-center justify-between">
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm`}>{t('admin.agenda.stats.with_room')}:</span>
            <span className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>{stats.week.withRoom}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm`}>{t('admin.agenda.stats.without_room')}:</span>
            <span className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>{stats.week.withoutRoom}</span>
          </div>
          <div className={`flex items-center justify-between pt-2 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm font-semibold`}>{t('admin.agenda.stats.total_people')}:</span>
            <span className={`text-2xl font-bold ${isDark ? 'text-blue-400' : 'text-blue-600'}`}>{stats.week.totalParticipants}</span>
          </div>
        </div>
      </div>

      {/* Mois */}
      <div className={`${isDark ? 'bg-gray-800' : 'bg-white'} rounded-xl p-4 border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
        <div className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-base mb-2`}>
          {t('admin.agenda.month')} ({stats.month.period})
        </div>
        <div className="space-y-1">
          <div className="flex items-center justify-between">
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm`}>{t('admin.agenda.stats.with_room')}:</span>
            <span className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>{stats.month.withRoom}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm`}>{t('admin.agenda.stats.without_room')}:</span>
            <span className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>{stats.month.withoutRoom}</span>
          </div>
          <div className={`flex items-center justify-between pt-2 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <span className={`${isDark ? 'text-gray-400' : 'text-gray-600'} text-sm font-semibold`}>{t('admin.agenda.stats.total_people')}:</span>
            <span className={`text-2xl font-bold ${isDark ? 'text-blue-400' : 'text-blue-600'}`}>{stats.month.totalParticipants}</span>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/components/ConfirmationModal.tsx">
'use client'

import { X, AlertTriangle, CheckCircle, Info } from 'lucide-react'

interface ConfirmationModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: () => void | Promise<void>
  title: string
  message: string
  type?: 'warning' | 'info' | 'success'
  confirmText?: string
  cancelText?: string
  isDark: boolean
}

export function ConfirmationModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  type = 'warning',
  confirmText = 'Confirmer',
  cancelText = 'Annuler',
  isDark,
}: ConfirmationModalProps) {
  if (!isOpen) return null

  const handleConfirm = async () => {
    await onConfirm()
    onClose()
  }

  const getIcon = () => {
    switch (type) {
      case 'warning':
        return <AlertTriangle className="w-6 h-6 text-yellow-400" />
      case 'success':
        return <CheckCircle className="w-6 h-6 text-green-400" />
      case 'info':
        return <Info className="w-6 h-6 text-blue-400" />
      default:
        return <AlertTriangle className="w-6 h-6 text-yellow-400" />
    }
  }

  const getConfirmButtonColor = () => {
    switch (type) {
      case 'warning':
        return 'bg-yellow-600 hover:bg-yellow-700'
      case 'success':
        return 'bg-green-600 hover:bg-green-700'
      case 'info':
        return 'bg-blue-600 hover:bg-blue-700'
      default:
        return 'bg-yellow-600 hover:bg-yellow-700'
    }
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
      <div className={`w-full max-w-md rounded-lg shadow-xl ${
        isDark ? 'bg-gray-800 border border-gray-700' : 'bg-white border border-gray-200'
      }`}>
        {/* Header */}
        <div className={`flex items-center gap-3 p-6 border-b ${
          isDark ? 'border-gray-700' : 'border-gray-200'
        }`}>
          <div className="flex-shrink-0">
            {getIcon()}
          </div>
          <h3 className={`text-lg font-semibold flex-1 ${
            isDark ? 'text-white' : 'text-gray-900'
          }`}>
            {title}
          </h3>
          <button
            onClick={onClose}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'text-gray-400 hover:text-white hover:bg-gray-700'
                : 'text-gray-500 hover:text-gray-900 hover:bg-gray-100'
            }`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          <p className={`text-sm whitespace-pre-line ${
            isDark ? 'text-gray-300' : 'text-gray-700'
          }`}>
            {message}
          </p>
        </div>

        {/* Actions */}
        <div className={`flex items-center justify-end gap-3 p-6 border-t ${
          isDark ? 'border-gray-700' : 'border-gray-200'
        }`}>
          {type === 'info' ? (
            <button
              onClick={onClose}
              className={`px-4 py-2 rounded-lg transition-colors text-white ${getConfirmButtonColor()}`}
            >
              OK
            </button>
          ) : (
            <>
              <button
                onClick={onClose}
                className={`px-4 py-2 rounded-lg transition-colors ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-white'
                    : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                }`}
              >
                {cancelText}
              </button>
              <button
                onClick={handleConfirm}
                className={`px-4 py-2 rounded-lg transition-colors text-white ${getConfirmButtonColor()}`}
              >
                {confirmText}
              </button>
            </>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/components/ContactDetailsModal.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import {
  X,
  Loader2,
  Calendar,
  TrendingUp,
  Gamepad2,
  PartyPopper,
  Clock,
  Zap,
  Target
} from 'lucide-react'
import { createClient } from '@/lib/supabase/client'
import { useTranslation } from '@/contexts/LanguageContext'
import type { Contact } from '@/lib/supabase/types'

interface ContactDetailsModalProps {
  contactId: string
  onClose: () => void
  isDark: boolean
  branchId?: string // Optionnel - pour filtrer par branche si fourni
}

interface ContactStats {
  totalBookings: number
  upcomingBookings: number
  totalParticipants: number
  gameBookings: number
  eventBookings: number
  lastActivity: string | null
}

export function ContactDetailsModal({
  contactId,
  onClose,
  isDark,
}: ContactDetailsModalProps) {
  const router = useRouter()
  const { t, locale } = useTranslation()
  const [contact, setContact] = useState<Contact | null>(null)

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }
  const [contactStats, setContactStats] = useState<ContactStats | null>(null)
  const [linkedBookings, setLinkedBookings] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [loadingBookings, setLoadingBookings] = useState(true)

  const getDisplayName = (c: Contact) => {
    if (c.first_name || c.last_name) {
      return `${c.first_name || ''} ${c.last_name || ''}`.trim()
    }
    return c.phone || t('admin.clients.contact_no_name')
  }

  const loadContactData = useCallback(async () => {
    setLoading(true)
    setLoadingBookings(true)
    const supabase = createClient()

    // Charger le contact
    const { data: contactData } = await supabase
      .from('contacts')
      .select('*')
      .eq('id', contactId)
      .single()

    if (contactData) {
      setContact(contactData)

      // Charger les ORDERS liées au contact (pas les bookings)
      // Les orders contiennent TOUTES les commandes, y compris annulées
      const ordersList: any[] = []
      
      // Méthode 1: Via contact_id directement
      const { data: contactOrders, error: contactOrdersError } = await supabase
        .from('orders')
        .select(`
          id,
          order_type,
          status,
          requested_date,
          requested_time,
          participants_count,
          game_area,
          request_reference,
          source,
          created_at,
          booking:bookings(id, reference_code, start_datetime, status)
        `)
        .eq('contact_id', contactId)
        .order('created_at', { ascending: false })

      if (contactOrdersError) {
        console.error('Error fetching orders by contact_id:', contactOrdersError)
      }
      if (contactOrders && Array.isArray(contactOrders)) {
        ordersList.push(...contactOrders)
      }
      
      // Méthode 2: Via téléphone (fallback pour anciennes commandes sans contact_id)
      const phoneNumber = (contactData as Contact).phone
      if (phoneNumber && ordersList.length === 0) {
        const { data: phoneOrders, error: phoneOrdersError } = await supabase
          .from('orders')
          .select(`
            id,
            order_type,
            status,
            requested_date,
            requested_time,
            participants_count,
            game_area,
            request_reference,
            source,
            created_at,
            booking:bookings(id, reference_code, start_datetime, status)
          `)
          .eq('customer_phone', phoneNumber)
          .order('created_at', { ascending: false })

        if (phoneOrdersError) {
          console.error('Error fetching orders by phone:', phoneOrdersError)
        }
        if (phoneOrders && Array.isArray(phoneOrders)) {
          // Fusionner et dédupliquer
          const existingIds = new Set(ordersList.map((o: any) => o.id))
          phoneOrders.forEach((o: any) => {
            if (!existingIds.has(o.id)) {
              ordersList.push(o)
            }
          })
        }
      }
      
      const orders = ordersList

      // Transformer les orders pour l'affichage (format similaire aux anciens bookings)
      const linkedItems = orders.map((order: any) => ({
        id: order.id,
        type: order.order_type,
        status: order.status === 'cancelled' ? 'CANCELLED' : 
                order.status === 'pending' ? 'PENDING' : 'CONFIRMED',
        start_datetime: order.booking?.start_datetime || `${order.requested_date}T${order.requested_time}`,
        participants_count: order.participants_count,
        reference_code: order.booking?.reference_code || order.request_reference,
        game_area: order.game_area,
        source: order.source,
        isOrder: true, // Flag pour identifier que c'est une order
        booking_id: order.booking?.id || null
      }))

      setLinkedBookings(linkedItems)

      // Calculer les statistiques basées sur les orders
      const now = new Date()
      const gameCount = linkedItems.filter((b: any) => b.type === 'GAME').length
      const eventCount = linkedItems.filter((b: any) => b.type === 'EVENT').length
      const totalParticipants = linkedItems
        .filter((b: any) => b.status !== 'CANCELLED')
        .reduce((sum: number, b: any) => sum + (b.participants_count || 0), 0)
      const upcomingCount = linkedItems.filter((b: any) => 
        new Date(b.start_datetime) >= now && b.status !== 'CANCELLED'
      ).length
      const lastItem = linkedItems.find((b: any) => b.status !== 'CANCELLED')

      setContactStats({
        totalBookings: linkedItems.length,
        gameBookings: gameCount,
        eventBookings: eventCount,
        totalParticipants,
        upcomingBookings: upcomingCount,
        lastActivity: lastItem ? lastItem.start_datetime : null,
      })
    }

    setLoading(false)
    setLoadingBookings(false)
  }, [contactId])

  useEffect(() => {
    loadContactData()
  }, [loadContactData])

  if (loading) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
        <div className={`rounded-lg border p-8 ${
          isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
        }`}>
          <Loader2 className={`w-8 h-8 animate-spin ${
            isDark ? 'text-blue-400' : 'text-blue-600'
          }`} />
        </div>
      </div>
    )
  }

  if (!contact) {
    return null
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
      <div className={`rounded-lg border max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        <div className="p-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className={`text-xl font-bold ${
              isDark ? 'text-white' : 'text-gray-900'
            }`}>{t('admin.clients.contact_details')}</h2>
            <button
              onClick={onClose}
              className={`p-2 rounded-lg transition-colors ${
                isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'
              }`}
            >
              <X className={`w-5 h-5 ${
                isDark ? 'text-gray-300' : 'text-gray-700'
              }`} />
            </button>
          </div>
          <div className="space-y-6">
            {/* Informations de base */}
            <div className="space-y-4">
              <div>
                <label className={`text-sm ${
                  isDark ? 'text-gray-400' : 'text-gray-600'
                }`}>{t('admin.clients.full_name')}</label>
                <p className={`font-medium text-lg ${
                  isDark ? 'text-white' : 'text-gray-900'
                }`}>{getDisplayName(contact)}</p>
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className={`text-sm ${
                    isDark ? 'text-gray-400' : 'text-gray-600'
                  }`}>{t('admin.clients.table.phone')}</label>
                  <p className={isDark ? 'text-white' : 'text-gray-900'}>{contact.phone}</p>
                </div>
                {contact.email && (
                  <div>
                    <label className={`text-sm ${
                      isDark ? 'text-gray-400' : 'text-gray-600'
                    }`}>{t('admin.clients.table.email')}</label>
                    <p className={isDark ? 'text-white' : 'text-gray-900'}>{contact.email}</p>
                  </div>
                )}
              </div>
              {/* Langue préférée pour les emails */}
              <div>
                <label className={`text-sm ${
                  isDark ? 'text-gray-400' : 'text-gray-600'
                }`}>{t('admin.clients.email_language') || 'Email Language'}</label>
                <div className="flex items-center gap-2 mt-1">
                  <span className="text-xl">
                    {contact.preferred_locale === 'he' ? '🇮🇱' : contact.preferred_locale === 'fr' ? '🇫🇷' : '🇬🇧'}
                  </span>
                  <span className={isDark ? 'text-white' : 'text-gray-900'}>
                    {contact.preferred_locale === 'he' ? 'עברית (Hebrew)' :
                     contact.preferred_locale === 'fr' ? 'Français (French)' : 'English'}
                  </span>
                </div>
              </div>
              {contact.notes_client && (
                <div>
                  <label className={`text-sm ${
                    isDark ? 'text-gray-400' : 'text-gray-600'
                  }`}>{t('admin.clients.table.notes')}</label>
                  <p className={`whitespace-pre-wrap p-3 rounded-lg ${
                    isDark
                      ? 'text-white bg-gray-700/50'
                      : 'text-gray-900 bg-gray-100'
                  }`}>{contact.notes_client}</p>
                </div>
              )}
            </div>

            {/* Statistiques */}
            {contactStats && (
              <div className={`pt-4 border-t ${
                isDark ? 'border-gray-700' : 'border-gray-200'
              }`}>
                <h3 className={`text-lg font-semibold mb-4 flex items-center gap-2 ${
                  isDark ? 'text-white' : 'text-gray-900'
                }`}>
                  <TrendingUp className="w-5 h-5" />
                  {t('admin.clients.statistics')}
                </h3>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <div className={`p-4 rounded-lg ${
                    isDark ? 'bg-gray-700/50' : 'bg-gray-100'
                  }`}>
                    <div className="text-2xl font-bold text-blue-400">{contactStats.totalBookings}</div>
                    <div className={`text-sm mt-1 ${
                      isDark ? 'text-gray-400' : 'text-gray-600'
                    }`}>{t('admin.clients.stats.total_bookings')}</div>
                  </div>
                  <div className={`p-4 rounded-lg ${
                    isDark ? 'bg-gray-700/50' : 'bg-gray-100'
                  }`}>
                    <div className="text-2xl font-bold text-green-400">{contactStats.upcomingBookings}</div>
                    <div className={`text-sm mt-1 ${
                      isDark ? 'text-gray-400' : 'text-gray-600'
                    }`}>{t('admin.clients.stats.upcoming')}</div>
                  </div>
                  <div className={`p-4 rounded-lg ${
                    isDark ? 'bg-gray-700/50' : 'bg-gray-100'
                  }`}>
                    <div className="text-2xl font-bold text-purple-400">{contactStats.totalParticipants}</div>
                    <div className={`text-sm mt-1 ${
                      isDark ? 'text-gray-400' : 'text-gray-600'
                    }`}>{t('admin.clients.stats.total_participants')}</div>
                  </div>
                  <div className={`p-4 rounded-lg ${
                    isDark ? 'bg-gray-700/50' : 'bg-gray-100'
                  }`}>
                    <div className="flex items-center gap-2">
                      <div className="text-2xl font-bold text-yellow-400">{contactStats.gameBookings}</div>
                      <Gamepad2 className="w-5 h-5 text-blue-400" />
                    </div>
                    <div className="flex items-center gap-2 mt-1">
                      <div className="text-2xl font-bold text-green-400">{contactStats.eventBookings}</div>
                      <PartyPopper className="w-5 h-5 text-green-400" />
                    </div>
                    <div className={`text-sm mt-1 ${
                      isDark ? 'text-gray-400' : 'text-gray-600'
                    }`}>{t('admin.clients.stats.games_events')}</div>
                  </div>
                </div>
                {contactStats.lastActivity && (
                  <div className={`mt-4 flex items-center gap-2 text-sm ${
                    isDark ? 'text-gray-400' : 'text-gray-600'
                  }`}>
                    <Clock className="w-4 h-4" />
                    {t('admin.clients.stats.last_activity')}: {new Date(contactStats.lastActivity).toLocaleDateString(getDateLocale(), {
                      day: 'numeric',
                      month: 'long',
                      year: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit',
                    })}
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Réservations liées */}
          <div className={`mt-6 pt-6 border-t ${
            isDark ? 'border-gray-700' : 'border-gray-200'
          }`}>
            <h3 className={`text-lg font-semibold mb-4 flex items-center gap-2 ${
              isDark ? 'text-white' : 'text-gray-900'
            }`}>
              <Calendar className="w-5 h-5" />
              {t('admin.clients.linked_bookings')} ({linkedBookings.length})
            </h3>
            {loadingBookings ? (
              <div className="flex items-center justify-center py-8">
                <Loader2 className={`w-6 h-6 animate-spin ${
                  isDark ? 'text-blue-400' : 'text-blue-600'
                }`} />
              </div>
            ) : linkedBookings.length === 0 ? (
              <p className={`text-sm ${
                isDark ? 'text-gray-400' : 'text-gray-600'
              }`}>{t('admin.clients.no_linked_bookings')}</p>
            ) : (
              <div className="space-y-2 max-h-96 overflow-y-auto">
                {linkedBookings.map((booking) => {
                  const bookingDate = new Date(booking.start_datetime)
                  const isPast = bookingDate < new Date()
                  const isCancelled = booking.status === 'CANCELLED'
                  const isPending = booking.status === 'PENDING'
                  
                  // Déterminer l'icône selon le type et la zone
                  let icon = null
                  if (booking.type === 'EVENT') {
                    icon = <PartyPopper className="w-5 h-5 flex-shrink-0 text-green-400" />
                  } else if (booking.game_area === 'LASER') {
                    icon = <Target className="w-5 h-5 flex-shrink-0 text-purple-400" />
                  } else {
                    icon = <Zap className="w-5 h-5 flex-shrink-0 text-blue-400" />
                  }
                  
                  return (
                    <div
                      key={booking.id}
                      onClick={() => {
                        // Toujours aller vers la fiche order dans /admin/orders
                        router.push(`/admin/orders?order=${booking.id}`)
                        onClose()
                      }}
                      className={`p-3 rounded-lg border transition-colors cursor-pointer ${
                        isCancelled
                          ? isDark
                            ? 'bg-red-900/20 border-red-800/50 opacity-60'
                            : 'bg-red-50 border-red-200 opacity-60'
                          : isPast
                            ? isDark
                              ? 'bg-gray-700/50 border-gray-600 hover:bg-gray-700'
                              : 'bg-gray-100 border-gray-300 hover:bg-gray-200'
                            : 'bg-blue-600/10 border-blue-600/30 hover:bg-blue-600/20'
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-3 flex-1 min-w-0">
                          {icon}
                          <div className="flex-1 min-w-0">
                            <div className={`font-medium truncate ${
                              isDark ? 'text-white' : 'text-gray-900'
                            }`}>
                              {booking.reference_code || 'N/A'} - {booking.participants_count || 0} pers.
                            </div>
                            <div className={`text-sm flex items-center gap-2 ${
                              isDark ? 'text-gray-400' : 'text-gray-600'
                            }`}>
                              <span>
                                {bookingDate.toLocaleDateString(getDateLocale(), {
                                  day: 'numeric',
                                  month: 'short',
                                  year: 'numeric'
                                })} {t('admin.common.at')} {bookingDate.toLocaleTimeString(getDateLocale(), { hour: '2-digit', minute: '2-digit' })}
                              </span>
                              {booking.source && (
                                <span className={`text-xs px-1.5 py-0.5 rounded ${
                                  booking.source === 'admin_agenda'
                                    ? 'bg-orange-500/20 text-orange-400'
                                    : 'bg-teal-500/20 text-teal-400'
                                }`}>
                                  {booking.source === 'admin_agenda' ? 'Admin' : 'Site'}
                                </span>
                              )}
                            </div>
                          </div>
                        </div>
                        <div className="flex items-center gap-2">
                          {isCancelled && (
                            <span className="px-2 py-1 text-xs rounded bg-red-500/20 text-red-400">
                              {t('admin.orders.status.cancelled')}
                            </span>
                          )}
                          {isPending && (
                            <span className="px-2 py-1 text-xs rounded bg-yellow-500/20 text-yellow-400">
                              {t('admin.orders.status.pending')}
                            </span>
                          )}
                        </div>
                      </div>
                    </div>
                  )
                })}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/components/DateNavigation.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { ChevronLeft, ChevronRight, CalendarDays } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'

interface DateNavigationProps {
  selectedDate: Date
  onDateChange: (date: Date) => void
  view: 'day' | 'week'
  onViewChange: (view: 'day' | 'week') => void
}

export function DateNavigation({
  selectedDate,
  onDateChange,
  view,
  onViewChange,
}: DateNavigationProps) {
  const { t, tArray, locale } = useTranslation()

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }

  // Helper pour obtenir le nom du mois traduit
  const getMonthName = (monthIndex: number) => {
    const monthKeys = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
    return t(`admin.agenda.months.${monthKeys[monthIndex]}`)
  }

  // Helper pour obtenir les jours de la semaine traduits (format court)
  const getDaysShort = (): string[] => {
    const days = tArray('admin.agenda.days_short')
    return days.length > 0 ? days : ['L', 'M', 'M', 'J', 'V', 'S', 'D']
  }

  const [showCalendar, setShowCalendar] = useState(false)
  const [calendarMonth, setCalendarMonth] = useState(selectedDate.getMonth())
  const [calendarYear, setCalendarYear] = useState(selectedDate.getFullYear())
  const [mounted, setMounted] = useState(false)
  const calendarRef = useRef<HTMLDivElement>(null)

  // Éviter les problèmes d'hydratation
  useEffect(() => {
    setMounted(true)
  }, [])

  // Fermer le calendrier quand on clique ailleurs
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (calendarRef.current && !calendarRef.current.contains(event.target as Node)) {
        setShowCalendar(false)
      }
    }

    if (showCalendar) {
      document.addEventListener('mousedown', handleClickOutside)
    }
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [showCalendar])

  const formatDateLong = (date: Date) => {
    return date.toLocaleDateString(getDateLocale(), {
      weekday: 'long',
      day: 'numeric',
      month: 'long',
      year: 'numeric',
    })
  }

  const formatWeekRange = () => {
    const startOfWeek = getStartOfWeek(selectedDate)
    const endOfWeek = new Date(startOfWeek)
    endOfWeek.setDate(endOfWeek.getDate() + 6)

    const startStr = startOfWeek.toLocaleDateString(getDateLocale(), { day: 'numeric', month: 'short' })
    const endStr = endOfWeek.toLocaleDateString(getDateLocale(), { day: 'numeric', month: 'short', year: 'numeric' })

    return `${startStr} - ${endStr}`
  }

  const getStartOfWeek = (date: Date) => {
    const d = new Date(date)
    const day = d.getDay()
    const diff = d.getDate() - day + (day === 0 ? -6 : 1)
    d.setDate(diff)
    d.setHours(0, 0, 0, 0)
    return d
  }

  const handlePrevious = () => {
    const newDate = new Date(selectedDate)
    if (view === 'day') {
      newDate.setDate(newDate.getDate() - 1)
    } else {
      newDate.setDate(newDate.getDate() - 7)
    }
    onDateChange(newDate)
  }

  const handleNext = () => {
    const newDate = new Date(selectedDate)
    if (view === 'day') {
      newDate.setDate(newDate.getDate() + 1)
    } else {
      newDate.setDate(newDate.getDate() + 7)
    }
    onDateChange(newDate)
  }

  const handleToday = () => {
    onDateChange(new Date())
    setShowCalendar(false)
  }

  const getDaysInMonth = (month: number, year: number) => {
    return new Date(year, month + 1, 0).getDate()
  }

  const getFirstDayOfMonth = (month: number, year: number) => {
    const day = new Date(year, month, 1).getDay()
    return day === 0 ? 6 : day - 1 // Lundi = 0
  }

  const renderCalendar = () => {
    const daysInMonth = getDaysInMonth(calendarMonth, calendarYear)
    const firstDay = getFirstDayOfMonth(calendarMonth, calendarYear)
    const days = []

    // Jours du mois précédent
    for (let i = 0; i < firstDay; i++) {
      days.push(<div key={`empty-${i}`} className="p-2" />)
    }

    // Jours du mois
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(calendarYear, calendarMonth, day)
      const isToday = date.toDateString() === new Date().toDateString()
      const isSelected = date.toDateString() === selectedDate.toDateString()

      days.push(
        <button
          key={day}
          onClick={() => {
            onDateChange(date)
            setShowCalendar(false)
          }}
          className={`p-2 rounded-lg text-sm transition-colors ${
            isSelected
              ? 'bg-blue-600 text-white'
              : isToday
              ? 'bg-blue-600/20 text-blue-400'
              : 'text-gray-300 hover:bg-gray-700'
          }`}
        >
          {day}
        </button>
      )
    }

    return days
  }

  // monthNames est maintenant dynamique via getMonthName()

  return (
    <div className="flex items-center gap-4 flex-wrap">
      {/* Sélecteur de vue */}
      <div className="flex bg-gray-800 rounded-lg p-1">
        <button
          onClick={() => onViewChange('day')}
          className={`px-3 py-1.5 rounded-md text-sm font-medium transition-colors ${
            view === 'day'
              ? 'bg-blue-600 text-white'
              : 'text-gray-400 hover:text-white'
          }`}
        >
          {t('admin.agenda.view.day')}
        </button>
        <button
          onClick={() => onViewChange('week')}
          className={`px-3 py-1.5 rounded-md text-sm font-medium transition-colors ${
            view === 'week'
              ? 'bg-blue-600 text-white'
              : 'text-gray-400 hover:text-white'
          }`}
        >
          {t('admin.agenda.view.week')}
        </button>
      </div>

      {/* Navigation */}
      <div className="flex items-center gap-2">
        <button
          onClick={handlePrevious}
          className="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors"
        >
          <ChevronLeft className="w-5 h-5" />
        </button>

        <div ref={calendarRef} className="relative">
          <button
            onClick={() => setShowCalendar(!showCalendar)}
            className="flex items-center gap-2 px-4 py-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-white transition-colors min-w-[200px] justify-center"
          >
            <CalendarDays className="w-5 h-5 text-blue-400" />
            <span className="font-medium">
              {view === 'day' ? formatDateLong(selectedDate) : formatWeekRange()}
            </span>
          </button>

          {mounted && showCalendar && (
            <div className="absolute top-full left-1/2 -translate-x-1/2 mt-2 w-80 bg-gray-800 border border-gray-700 rounded-xl shadow-xl z-50 p-4">
              {/* Navigation mois */}
              <div className="flex items-center justify-between mb-4">
                <button
                  onClick={() => {
                    if (calendarMonth === 0) {
                      setCalendarMonth(11)
                      setCalendarYear(calendarYear - 1)
                    } else {
                      setCalendarMonth(calendarMonth - 1)
                    }
                  }}
                  className="p-1 hover:bg-gray-700 rounded-lg"
                >
                  <ChevronLeft className="w-5 h-5 text-gray-400" />
                </button>
                <span className="text-white font-medium">
                  {getMonthName(calendarMonth)} {calendarYear}
                </span>
                <button
                  onClick={() => {
                    if (calendarMonth === 11) {
                      setCalendarMonth(0)
                      setCalendarYear(calendarYear + 1)
                    } else {
                      setCalendarMonth(calendarMonth + 1)
                    }
                  }}
                  className="p-1 hover:bg-gray-700 rounded-lg"
                >
                  <ChevronRight className="w-5 h-5 text-gray-400" />
                </button>
              </div>

              {/* Jours de la semaine */}
              <div className="grid grid-cols-7 gap-1 mb-2">
                {getDaysShort().map((day, i) => (
                  <div key={i} className="p-2 text-center text-xs text-gray-500 font-medium">
                    {day}
                  </div>
                ))}
              </div>

              {/* Calendrier */}
              <div className="grid grid-cols-7 gap-1">
                {renderCalendar()}
              </div>

              {/* Bouton Aujourd'hui */}
              <button
                onClick={handleToday}
                className="w-full mt-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition-colors"
              >
                {t('admin.agenda.today')}
              </button>
            </div>
          )}
        </div>

        <button
          onClick={handleNext}
          className="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors"
        >
          <ChevronRight className="w-5 h-5" />
        </button>
      </div>

      {/* Bouton Aujourd'hui (raccourci) */}
      <button
        onClick={handleToday}
        className="px-3 py-2 text-sm text-blue-400 hover:text-blue-300 hover:bg-gray-800 rounded-lg transition-colors"
      >
        Aujourd&apos;hui
      </button>
    </div>
  )
}
</file>

<file path="src/app/admin/components/OrderDetailModalWrapper.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import { Loader2, AlertCircle } from 'lucide-react'
import { createClient } from '@/lib/supabase/client'
import { useTranslation } from '@/contexts/LanguageContext'
import { OrderDetailModal } from '../orders/components/OrderDetailModal'
import { ConfirmationModal } from './ConfirmationModal'
import type { OrderWithRelations } from '@/lib/supabase/types'

interface OrderDetailModalWrapperProps {
  orderId: string
  onClose: () => void
  isDark: boolean
  onOpenAccounting?: (orderId: string) => void
}

interface ConfirmModalState {
  isOpen: boolean
  title: string
  message: string
  type: 'warning' | 'info' | 'success'
  onConfirm: () => void
}

/**
 * Wrapper autour de OrderDetailModal qui charge l'order à partir de l'orderId
 * Utilisé depuis l'agenda pour ouvrir la fiche commande sans naviguer
 * Implémente toutes les fonctionnalités (resend email, cancel, reactivate, etc.)
 */
export function OrderDetailModalWrapper({
  orderId,
  onClose,
  isDark,
  onOpenAccounting,
}: OrderDetailModalWrapperProps) {
  const { t } = useTranslation()
  const router = useRouter()
  const [order, setOrder] = useState<OrderWithRelations | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [confirmModal, setConfirmModal] = useState<ConfirmModalState>({
    isOpen: false,
    title: '',
    message: '',
    type: 'warning',
    onConfirm: () => {}
  })

  const loadOrder = useCallback(async () => {
    setLoading(true)
    setError(null)
    const supabase = createClient()

    const { data, error: fetchError } = await supabase
      .from('orders')
      .select(`
        *,
        contact:contacts(*),
        booking:bookings(
          *,
          slots:booking_slots(*)
        )
      `)
      .eq('id', orderId)
      .single()

    if (fetchError) {
      console.error('Error loading order:', fetchError)
      setError(t('admin.orders.loading_error'))
    } else {
      setOrder(data as OrderWithRelations)
    }
    setLoading(false)
  }, [orderId, t])

  useEffect(() => {
    loadOrder()
  }, [loadOrder])

  // Annuler une commande
  const handleCancel = async (orderId: string) => {
    setConfirmModal({
      isOpen: true,
      title: t('admin.orders.modal.cancel_title'),
      message: t('admin.orders.modal.cancel_message'),
      type: 'warning',
      onConfirm: async () => {
        try {
          const response = await fetch(`/api/orders/${orderId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'cancel' })
          })

          const data = await response.json()
          if (!data.success) throw new Error(data.error)

          // Recharger la commande pour mettre à jour l'affichage
          loadOrder()
          setConfirmModal(prev => ({ ...prev, isOpen: false }))
        } catch (error) {
          console.error('Error cancelling order:', error)
        }
      }
    })
  }

  // Renvoyer l'email de confirmation
  const handleResendEmail = async (orderId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/orders/${orderId}/resend-email`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      })

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error resending email:', error)
      return { success: false, error: 'Network error' }
    }
  }

  // Renvoyer un rappel CGV
  const handleResendCgvReminder = async (orderId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/orders/${orderId}/resend-cgv`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      })

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error resending CGV reminder:', error)
      return { success: false, error: 'Network error' }
    }
  }

  // Réactiver une réservation annulée - redirige vers l'agenda pour vérifier les disponibilités
  const handleReactivate = (orderId: string) => {
    if (!order) return

    setConfirmModal({
      isOpen: true,
      title: t('admin.orders.modal.reactivate_title'),
      message: t('admin.orders.modal.reactivate_message'),
      type: 'success',
      onConfirm: () => {
        // Construire les query params avec les données de la commande
        const params = new URLSearchParams({
          reactivate: 'true',
          orderId: order.id,
          date: order.requested_date,
          time: order.requested_time,
          type: order.order_type,
          participants: order.participants_count.toString(),
          firstName: order.customer_first_name,
          lastName: order.customer_last_name || '',
          phone: order.customer_phone,
          email: order.customer_email || '',
          reference: order.request_reference
        })

        if (order.game_area) {
          params.set('gameArea', order.game_area)
        }
        if (order.number_of_games) {
          params.set('numberOfGames', order.number_of_games.toString())
        }
        if (order.contact_id) {
          params.set('contactId', order.contact_id)
        }

        onClose()
        router.push(`/admin?${params.toString()}`)
      }
    })
  }

  // Aller à l'agenda
  const handleGoToAgenda = (date: string, bookingId?: string) => {
    onClose()
    const params = new URLSearchParams({ date })
    if (bookingId) {
      params.set('booking', bookingId)
    }
    router.push(`/admin?${params.toString()}`)
  }

  // Aller au client
  const handleGoToClient = (contactId: string) => {
    onClose()
    router.push(`/admin/clients?contact=${contactId}`)
  }

  // Loading state
  if (loading) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
        <div className={`rounded-2xl border p-8 ${
          isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
        }`}>
          <Loader2 className={`w-8 h-8 animate-spin ${
            isDark ? 'text-blue-400' : 'text-blue-600'
          }`} />
        </div>
      </div>
    )
  }

  // Error state
  if (error || !order) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
        <div className={`rounded-2xl border p-6 max-w-md ${
          isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
        }`}>
          <div className="flex items-center gap-3 text-red-400">
            <AlertCircle className="w-6 h-6" />
            <span>{error || t('admin.common.error')}</span>
          </div>
          <button
            onClick={onClose}
            className={`mt-4 w-full px-4 py-2 rounded-lg transition-colors ${
              isDark
                ? 'bg-gray-700 hover:bg-gray-600 text-white'
                : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
            }`}
          >
            {t('admin.common.close')}
          </button>
        </div>
      </div>
    )
  }

  // Render the actual modal
  return (
    <>
      <OrderDetailModal
        order={order}
        onClose={onClose}
        onCancel={handleCancel}
        onRecreate={handleReactivate}
        onResendEmail={handleResendEmail}
        onResendCgvReminder={handleResendCgvReminder}
        onGoToAgenda={handleGoToAgenda}
        onGoToClient={handleGoToClient}
        onOpenAccounting={onOpenAccounting}
        isDark={isDark}
        canEdit={true}
        canDelete={true}
      />

      {/* Modal de confirmation */}
      <ConfirmationModal
        isOpen={confirmModal.isOpen}
        onClose={() => setConfirmModal(prev => ({ ...prev, isOpen: false }))}
        onConfirm={confirmModal.onConfirm}
        title={confirmModal.title}
        message={confirmModal.message}
        confirmText={t('admin.common.confirm')}
        cancelText={t('admin.common.cancel')}
        type={confirmModal.type}
        isDark={isDark}
      />
    </>
  )
}
</file>

<file path="src/app/admin/components/PaymentModal.tsx">
'use client'

import { useState } from 'react'
import { X, CreditCard, Banknote, Building2, FileText, Loader2, AlertCircle, CheckCircle, Lock, ShieldCheck } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'

export type PaymentMode = 'payment' | 'preauth' // paiement immédiat ou pré-autorisation

interface PaymentModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (data: PaymentData) => Promise<{ success: boolean; error?: string }>
  orderId: string
  orderRef: string
  totalAmount: number
  paidAmount: number
  isDark: boolean
  // Mode initial (paiement ou pré-autorisation)
  initialMode?: PaymentMode
  // Optionnel: si on a une carte stockée pour ce client
  storedCard?: {
    tokenId: number
    last4: string
    type: string
  } | null
  // Optionnel: si on a une pré-autorisation existante
  existingPreauth?: {
    code: string
    amount: number
    ccLast4: string
  } | null
}

export interface PaymentData {
  amount: number
  paymentType: 'full' | 'deposit' | 'balance'
  paymentMethod: 'card' | 'cash' | 'transfer' | 'check'
  // Mode: paiement immédiat ou pré-autorisation
  mode?: PaymentMode
  // Pour les cartes
  cardInfo?: {
    cc_number: string
    cc_validity: string
    cc_cvv: string
    cc_holder_id: string
    cc_holder_name?: string
  }
  tokenId?: number
  saveCard?: boolean // Sauvegarder la carte pour utilisation future
  // Pour utiliser une pré-autorisation existante (J5)
  usePreauth?: boolean
  preauthCode?: string
  // Pour les chèques
  checkNumber?: string
  checkBank?: string
  checkDate?: string
  // Pour les virements
  transferReference?: string
  // Notes
  notes?: string
}

export function PaymentModal({
  isOpen,
  onClose,
  onSubmit,
  orderRef,
  totalAmount,
  paidAmount,
  isDark,
  initialMode = 'payment',
  storedCard,
  existingPreauth,
}: PaymentModalProps) {
  const { t } = useTranslation()
  const remainingAmount = Math.max(0, totalAmount - paidAmount)

  // State
  const [mode, setMode] = useState<PaymentMode>(initialMode)
  const [paymentMethod, setPaymentMethod] = useState<'card' | 'cash' | 'transfer' | 'check'>('card')
  const [paymentType, setPaymentType] = useState<'full' | 'deposit' | 'balance'>('full')
  // Si préauth existe, utiliser son montant par défaut (ou le reste à payer si inférieur)
  const [amount, setAmount] = useState(
    existingPreauth
      ? Math.min(existingPreauth.amount, remainingAmount).toString()
      : remainingAmount.toString()
  )
  const [useStoredCard, setUseStoredCard] = useState(!!storedCard && !existingPreauth)
  // Sélectionner la préauth par défaut si elle existe
  const [useExistingPreauth, setUseExistingPreauth] = useState(!!existingPreauth)

  // Card fields
  const [ccNumber, setCcNumber] = useState('')
  const [ccValidity, setCcValidity] = useState('')
  const [ccCvv, setCcCvv] = useState('')
  const [ccHolderId, setCcHolderId] = useState('')
  const [ccHolderName, setCcHolderName] = useState('')
  const [saveCard, setSaveCard] = useState(false)

  // Check fields
  const [checkNumber, setCheckNumber] = useState('')
  const [checkBank, setCheckBank] = useState('')
  const [checkDate, setCheckDate] = useState('')

  // Transfer fields
  const [transferReference, setTransferReference] = useState('')

  // Notes
  const [notes, setNotes] = useState('')

  // UI state
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState(false)

  if (!isOpen) return null

  const formatCurrency = (value: number) => {
    return `${value.toLocaleString('he-IL')}₪`
  }

  // Format card number as user types (add spaces every 4 digits)
  const handleCardNumberChange = (value: string) => {
    const cleaned = value.replace(/\D/g, '').slice(0, 16)
    const formatted = cleaned.replace(/(\d{4})(?=\d)/g, '$1 ')
    setCcNumber(formatted)
  }

  // Format validity as MM/YY
  const handleValidityChange = (value: string) => {
    const cleaned = value.replace(/\D/g, '').slice(0, 4)
    if (cleaned.length >= 2) {
      setCcValidity(`${cleaned.slice(0, 2)}/${cleaned.slice(2)}`)
    } else {
      setCcValidity(cleaned)
    }
  }

  // Validate form
  const isValid = () => {
    const parsedAmount = parseFloat(amount)
    if (isNaN(parsedAmount) || parsedAmount <= 0) return false

    // Pour pré-autorisation, montant minimum 5₪
    if (mode === 'preauth' && parsedAmount < 5) return false

    // Pour paiement, ne pas dépasser le reste à payer
    if (mode === 'payment' && parsedAmount > remainingAmount) return false

    if (paymentMethod === 'card' || mode === 'preauth') {
      // Si on utilise une pré-auth existante pour payer
      if (useExistingPreauth && existingPreauth) return true
      // Si on utilise une carte stockée
      if (useStoredCard && storedCard) return true
      // Sinon valider les champs carte
      const cleanedNumber = ccNumber.replace(/\s/g, '')
      if (cleanedNumber.length < 13 || cleanedNumber.length > 19) return false
      if (ccValidity.length !== 5) return false // MM/YY format
      if (ccCvv.length < 3 || ccCvv.length > 4) return false
      if (ccHolderId.length < 5) return false
    }

    if (paymentMethod === 'check') {
      if (!checkNumber || !checkBank) return false
    }

    return true
  }

  const handleSubmit = async () => {
    if (!isValid()) return

    setLoading(true)
    setError(null)

    const data: PaymentData = {
      amount: parseFloat(amount),
      paymentType,
      paymentMethod: mode === 'preauth' ? 'card' : paymentMethod,
      mode,
    }

    // Mode pré-autorisation ou paiement par carte
    if (mode === 'preauth' || paymentMethod === 'card') {
      // En mode préauth, on doit TOUJOURS envoyer les infos de carte (les tokens ne marchent pas pour J5)
      if (mode === 'preauth') {
        data.cardInfo = {
          cc_number: ccNumber.replace(/\s/g, ''),
          cc_validity: ccValidity.replace('/', ''),
          cc_cvv: ccCvv,
          cc_holder_id: ccHolderId,
          cc_holder_name: ccHolderName || undefined,
        }
      }
      // Mode paiement: utiliser une pré-autorisation existante pour payer
      else if (useExistingPreauth && existingPreauth) {
        data.usePreauth = true
        data.preauthCode = existingPreauth.code
      }
      // Mode paiement: utiliser une carte stockée
      else if (useStoredCard && storedCard) {
        data.tokenId = storedCard.tokenId
      }
      // Mode paiement: nouvelle carte
      else {
        data.cardInfo = {
          cc_number: ccNumber.replace(/\s/g, ''),
          cc_validity: ccValidity.replace('/', ''),
          cc_cvv: ccCvv,
          cc_holder_id: ccHolderId,
          cc_holder_name: ccHolderName || undefined,
        }
        // Sauvegarder la carte si demandé
        if (saveCard) {
          data.saveCard = true
        }
      }
    } else if (paymentMethod === 'check') {
      data.checkNumber = checkNumber
      data.checkBank = checkBank
      data.checkDate = checkDate || undefined
    } else if (paymentMethod === 'transfer') {
      data.transferReference = transferReference || undefined
    }

    if (notes) {
      data.notes = notes
    }

    try {
      const result = await onSubmit(data)
      if (result.success) {
        setLoading(false)
        setSuccess(true)
        // Ne pas fermer automatiquement - l'utilisateur fermera manuellement
      } else {
        setLoading(false)
        setError(result.error || t('admin.payment.error_generic'))
      }
    } catch (err) {
      console.error('Payment modal error:', err)
      setLoading(false)
      setError(t('admin.payment.error_generic'))
    }
  }

  const methodButtons = [
    { id: 'card' as const, icon: CreditCard, label: t('admin.payment.method_card') },
    { id: 'cash' as const, icon: Banknote, label: t('admin.payment.method_cash') },
    { id: 'transfer' as const, icon: Building2, label: t('admin.payment.method_transfer') },
    { id: 'check' as const, icon: FileText, label: t('admin.payment.method_check') },
  ]

  return (
    <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/60 backdrop-blur-sm">
      <div className={`relative w-full max-w-lg mx-4 rounded-2xl border shadow-2xl ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        {/* Header */}
        <div className={`flex items-center justify-between px-6 py-4 border-b ${
          isDark ? 'border-gray-700' : 'border-gray-200'
        }`}>
          <div>
            <h2 className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {t('admin.payment.title')}
            </h2>
            <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
              {t('admin.payment.order_ref')}: {orderRef}
            </p>
          </div>
          <button
            onClick={onClose}
            disabled={loading}
            className={`p-2 rounded-lg transition-colors ${
              isDark ? 'hover:bg-gray-700 text-gray-400' : 'hover:bg-gray-100 text-gray-500'
            }`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Success state */}
        {success ? (
          <div className="p-8 text-center">
            <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-green-100 flex items-center justify-center">
              <CheckCircle className="w-8 h-8 text-green-600" />
            </div>
            <h3 className={`text-lg font-semibold mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {t('admin.payment.success')}
            </h3>
            <p className={`text-sm mb-6 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
              {formatCurrency(parseFloat(amount))} {t('admin.payment.paid_successfully')}
            </p>
            <button
              onClick={onClose}
              className="px-6 py-2 rounded-xl font-medium bg-green-600 hover:bg-green-700 text-white transition-colors"
            >
              {t('admin.common.close')}
            </button>
          </div>
        ) : (
          <>
            {/* Content */}
            <div className="p-6 space-y-6 max-h-[70vh] overflow-y-auto">

              {/* Préautorisation disponible - Affichage prioritaire */}
              {existingPreauth && mode === 'payment' && (
                <div
                  onClick={() => setUseExistingPreauth(true)}
                  className={`p-4 rounded-xl border-2 cursor-pointer transition-all ${
                    useExistingPreauth
                      ? 'border-green-500 bg-green-500/10'
                      : isDark
                        ? 'border-blue-500/50 bg-blue-500/10 hover:border-blue-500'
                        : 'border-blue-300 bg-blue-50 hover:border-blue-500'
                  }`}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <div className={`p-2 rounded-lg ${
                        useExistingPreauth
                          ? 'bg-green-500/20'
                          : isDark ? 'bg-blue-500/20' : 'bg-blue-100'
                      }`}>
                        <ShieldCheck className={`w-6 h-6 ${
                          useExistingPreauth ? 'text-green-500' : isDark ? 'text-blue-400' : 'text-blue-600'
                        }`} />
                      </div>
                      <div>
                        <p className={`font-semibold ${
                          useExistingPreauth ? 'text-green-500' : isDark ? 'text-blue-300' : 'text-blue-700'
                        }`}>
                          {t('admin.payment.preauth_available_title')}
                        </p>
                        <div className="flex items-center gap-3 mt-1">
                          <span className={`text-lg font-bold ${
                            useExistingPreauth ? 'text-green-400' : isDark ? 'text-blue-400' : 'text-blue-600'
                          }`}>
                            {formatCurrency(existingPreauth.amount)}
                          </span>
                          <span className={`text-sm font-mono ${
                            isDark ? 'text-gray-400' : 'text-gray-500'
                          }`}>
                            •••• {existingPreauth.ccLast4}
                          </span>
                        </div>
                      </div>
                    </div>
                    <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                      useExistingPreauth
                        ? 'border-green-500 bg-green-500'
                        : isDark ? 'border-gray-500' : 'border-gray-300'
                    }`}>
                      {useExistingPreauth && (
                        <CheckCircle className="w-4 h-4 text-white" />
                      )}
                    </div>
                  </div>
                  {useExistingPreauth && (
                    <p className={`text-xs mt-2 ${isDark ? 'text-green-400/70' : 'text-green-600/70'}`}>
                      {t('admin.payment.preauth_will_be_captured')}
                    </p>
                  )}
                </div>
              )}

              {/* Mode selection: Payment vs Preauthorization */}
              <div className="grid grid-cols-2 gap-3">
                <button
                  onClick={() => setMode('payment')}
                  className={`flex items-center gap-3 p-4 rounded-xl border-2 transition-all ${
                    mode === 'payment'
                      ? 'border-green-500 bg-green-500/10'
                      : isDark
                        ? 'border-gray-700 hover:border-gray-600 bg-gray-800'
                        : 'border-gray-200 hover:border-gray-300 bg-white'
                  }`}
                >
                  <CreditCard className={`w-6 h-6 ${
                    mode === 'payment' ? 'text-green-500' : isDark ? 'text-gray-400' : 'text-gray-500'
                  }`} />
                  <div className="text-left">
                    <p className={`font-medium ${
                      mode === 'payment' ? 'text-green-500' : isDark ? 'text-white' : 'text-gray-900'
                    }`}>
                      {t('admin.payment.mode_payment')}
                    </p>
                    <p className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.payment.mode_payment_desc')}
                    </p>
                  </div>
                </button>
                <button
                  onClick={() => setMode('preauth')}
                  className={`flex items-center gap-3 p-4 rounded-xl border-2 transition-all ${
                    mode === 'preauth'
                      ? 'border-blue-500 bg-blue-500/10'
                      : isDark
                        ? 'border-gray-700 hover:border-gray-600 bg-gray-800'
                        : 'border-gray-200 hover:border-gray-300 bg-white'
                  }`}
                >
                  <ShieldCheck className={`w-6 h-6 ${
                    mode === 'preauth' ? 'text-blue-500' : isDark ? 'text-gray-400' : 'text-gray-500'
                  }`} />
                  <div className="text-left">
                    <p className={`font-medium ${
                      mode === 'preauth' ? 'text-blue-500' : isDark ? 'text-white' : 'text-gray-900'
                    }`}>
                      {t('admin.payment.mode_preauth')}
                    </p>
                    <p className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.payment.mode_preauth_desc')}
                    </p>
                  </div>
                </button>
              </div>

              {/* Amount summary */}
              <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-900/50' : 'bg-gray-50'}`}>
                <div className="flex justify-between items-center mb-2">
                  <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>
                    {t('admin.payment.total')}
                  </span>
                  <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {formatCurrency(totalAmount)}
                  </span>
                </div>
                <div className="flex justify-between items-center mb-2">
                  <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>
                    {t('admin.payment.already_paid')}
                  </span>
                  <span className="text-green-500 font-medium">
                    {formatCurrency(paidAmount)}
                  </span>
                </div>
                <div className={`flex justify-between items-center pt-2 border-t ${
                  isDark ? 'border-gray-700' : 'border-gray-200'
                }`}>
                  <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {t('admin.payment.remaining')}
                  </span>
                  <span className={`text-lg font-bold ${
                    remainingAmount > 0 ? 'text-orange-500' : 'text-green-500'
                  }`}>
                    {formatCurrency(remainingAmount)}
                  </span>
                </div>
              </div>

              {/* Payment method selection - only in payment mode */}
              {mode === 'payment' ? (
              <div>
                <label className={`block text-sm font-medium mb-3 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.payment.method')}
                </label>
                <div className="grid grid-cols-4 gap-2">
                  {methodButtons.map(({ id, icon: Icon, label }) => (
                    <button
                      key={id}
                      onClick={() => setPaymentMethod(id)}
                      className={`flex flex-col items-center gap-1 p-3 rounded-xl border-2 transition-all ${
                        paymentMethod === id
                          ? 'border-blue-500 bg-blue-500/10'
                          : isDark
                            ? 'border-gray-700 hover:border-gray-600 bg-gray-800'
                            : 'border-gray-200 hover:border-gray-300 bg-white'
                      }`}
                    >
                      <Icon className={`w-5 h-5 ${
                        paymentMethod === id ? 'text-blue-500' : isDark ? 'text-gray-400' : 'text-gray-500'
                      }`} />
                      <span className={`text-xs ${
                        paymentMethod === id
                          ? 'text-blue-500 font-medium'
                          : isDark ? 'text-gray-400' : 'text-gray-600'
                      }`}>
                        {label}
                      </span>
                    </button>
                  ))}
                </div>
              </div>
              ) : (
                /* En mode préauthorisation, afficher un indicateur que c'est uniquement par carte */
                <div className={`p-3 rounded-xl flex items-center gap-3 ${
                  isDark ? 'bg-blue-500/10 border border-blue-500/30' : 'bg-blue-50 border border-blue-200'
                }`}>
                  <CreditCard className={`w-5 h-5 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
                  <span className={`text-sm ${isDark ? 'text-blue-300' : 'text-blue-700'}`}>
                    {t('admin.payment.preauth_card_only')}
                  </span>
                </div>
              )}

              {/* Amount input */}
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.payment.amount')}
                </label>
                <div className="flex gap-2">
                  <div className="relative flex-1">
                    <input
                      type="number"
                      value={amount}
                      onChange={(e) => setAmount(e.target.value)}
                      min="0"
                      max={remainingAmount}
                      step="0.01"
                      dir="ltr"
                      className={`w-full py-3 ps-10 pe-4 rounded-xl border text-lg font-medium text-left ${
                        isDark
                          ? 'bg-gray-900 border-gray-700 text-white'
                          : 'bg-white border-gray-200 text-gray-900'
                      }`}
                    />
                    <span className={`absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none ${
                      isDark ? 'text-gray-500' : 'text-gray-400'
                    }`}>
                      ₪
                    </span>
                  </div>
                  <button
                    onClick={() => setAmount(remainingAmount.toString())}
                    className={`px-4 py-2 rounded-xl text-sm font-medium transition-colors ${
                      isDark
                        ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                        : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                    }`}
                  >
                    {t('admin.payment.pay_full')}
                  </button>
                </div>
                {/* Quick amount buttons */}
                <div className="flex gap-2 mt-2">
                  {[100, 200, 500].map((quickAmount) => (
                    <button
                      key={quickAmount}
                      onClick={() => setAmount(Math.min(quickAmount, remainingAmount).toString())}
                      disabled={quickAmount > remainingAmount}
                      className={`px-3 py-1.5 rounded-lg text-sm transition-colors ${
                        isDark
                          ? 'bg-gray-700 hover:bg-gray-600 text-gray-300 disabled:opacity-50'
                          : 'bg-gray-100 hover:bg-gray-200 text-gray-700 disabled:opacity-50'
                      }`}
                    >
                      {quickAmount}₪
                    </button>
                  ))}
                </div>
              </div>

              {/* Card payment fields - show for card payment or preauth mode */}
              {(paymentMethod === 'card' || mode === 'preauth') && (
                <div className="space-y-4">
                  {/* Existing preauthorization option - only in payment mode */}
                  {mode === 'payment' && existingPreauth && (
                    <div className={`p-4 rounded-xl border ${
                      useExistingPreauth
                        ? 'border-green-500 bg-green-500/10'
                        : isDark ? 'border-gray-700' : 'border-gray-200'
                    }`}>
                      <label className="flex items-center gap-3 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={useExistingPreauth}
                          onChange={(e) => {
                            setUseExistingPreauth(e.target.checked)
                            if (e.target.checked) setUseStoredCard(false)
                          }}
                          className="w-5 h-5 rounded border-gray-300 text-green-500 focus:ring-green-500"
                        />
                        <div>
                          <div className="flex items-center gap-2">
                            <ShieldCheck className={`w-5 h-5 ${isDark ? 'text-green-400' : 'text-green-500'}`} />
                            <span className={isDark ? 'text-white' : 'text-gray-900'}>
                              {t('admin.payment.use_preauth')}
                            </span>
                            <span className={`font-mono ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                              •••• {existingPreauth.ccLast4}
                            </span>
                          </div>
                          <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                            {t('admin.payment.preauth_available')}: {existingPreauth.amount}₪
                          </p>
                        </div>
                      </label>
                    </div>
                  )}

                  {/* Stored card option - only in payment mode and if no preauth selected */}
                  {mode === 'payment' && storedCard && !useExistingPreauth && (
                    <div className={`p-4 rounded-xl border ${
                      useStoredCard
                        ? 'border-blue-500 bg-blue-500/10'
                        : isDark ? 'border-gray-700' : 'border-gray-200'
                    }`}>
                      <label className="flex items-center gap-3 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={useStoredCard}
                          onChange={(e) => setUseStoredCard(e.target.checked)}
                          className="w-5 h-5 rounded border-gray-300 text-blue-500 focus:ring-blue-500"
                        />
                        <div className="flex items-center gap-2">
                          <CreditCard className={`w-5 h-5 ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
                          <span className={isDark ? 'text-white' : 'text-gray-900'}>
                            {t('admin.payment.use_stored_card')}
                          </span>
                          <span className={`font-mono ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                            •••• {storedCard.last4}
                          </span>
                        </div>
                      </label>
                    </div>
                  )}

                  {/* New card fields - show if:
                      - In preauth mode (always need card for new preauth)
                      - In payment mode without preauth selected and without stored card selected */}
                  {(mode === 'preauth' || (!useExistingPreauth && (!storedCard || !useStoredCard))) && (
                    <div className="space-y-4">
                      {/* Card number */}
                      <div>
                        <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                          {t('admin.payment.card_number')}
                        </label>
                        <div className="relative">
                          <input
                            type="text"
                            value={ccNumber}
                            onChange={(e) => handleCardNumberChange(e.target.value)}
                            placeholder="1234 5678 9012 3456"
                            maxLength={19}
                            dir="ltr"
                            className={`w-full px-4 py-3 ps-10 rounded-xl border font-mono text-left ${
                              isDark
                                ? 'bg-gray-900 border-gray-700 text-white placeholder-gray-600'
                                : 'bg-white border-gray-200 text-gray-900 placeholder-gray-400'
                            }`}
                          />
                          <Lock className={`absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 ${
                            isDark ? 'text-gray-600' : 'text-gray-400'
                          }`} />
                        </div>
                      </div>

                      {/* Validity and CVV */}
                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                            {t('admin.payment.card_validity')}
                          </label>
                          <input
                            type="text"
                            value={ccValidity}
                            onChange={(e) => handleValidityChange(e.target.value)}
                            placeholder="MM/YY"
                            maxLength={5}
                            dir="ltr"
                            className={`w-full px-4 py-3 rounded-xl border font-mono text-left ${
                              isDark
                                ? 'bg-gray-900 border-gray-700 text-white placeholder-gray-600'
                                : 'bg-white border-gray-200 text-gray-900 placeholder-gray-400'
                            }`}
                          />
                        </div>
                        <div>
                          <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                            CVV
                          </label>
                          <input
                            type="text"
                            value={ccCvv}
                            onChange={(e) => setCcCvv(e.target.value.replace(/\D/g, '').slice(0, 4))}
                            placeholder="123"
                            maxLength={4}
                            dir="ltr"
                            className={`w-full px-4 py-3 rounded-xl border font-mono text-left ${
                              isDark
                                ? 'bg-gray-900 border-gray-700 text-white placeholder-gray-600'
                                : 'bg-white border-gray-200 text-gray-900 placeholder-gray-400'
                            }`}
                          />
                        </div>
                      </div>

                      {/* Holder ID */}
                      <div>
                        <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                          {t('admin.payment.card_holder_id')}
                        </label>
                        <input
                          type="text"
                          value={ccHolderId}
                          onChange={(e) => setCcHolderId(e.target.value.replace(/\D/g, '').slice(0, 9))}
                          placeholder="123456789"
                          maxLength={9}
                          dir="ltr"
                          className={`w-full px-4 py-3 rounded-xl border font-mono text-left ${
                            isDark
                              ? 'bg-gray-900 border-gray-700 text-white placeholder-gray-600'
                              : 'bg-white border-gray-200 text-gray-900 placeholder-gray-400'
                          }`}
                        />
                      </div>

                      {/* Holder name (optional) */}
                      <div>
                        <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                          {t('admin.payment.card_holder_name')} <span className={isDark ? 'text-gray-500' : 'text-gray-400'}>({t('admin.common.optional')})</span>
                        </label>
                        <input
                          type="text"
                          value={ccHolderName}
                          onChange={(e) => setCcHolderName(e.target.value)}
                          placeholder="John Doe"
                          className={`w-full px-4 py-3 rounded-xl border ${
                            isDark
                              ? 'bg-gray-900 border-gray-700 text-white placeholder-gray-600'
                              : 'bg-white border-gray-200 text-gray-900 placeholder-gray-400'
                          }`}
                        />
                      </div>

                      {/* Save card option - only in payment mode */}
                      {mode === 'payment' && (
                        <div className={`p-4 rounded-xl border ${
                          isDark ? 'border-gray-700' : 'border-gray-200'
                        }`}>
                          <label className="flex items-center gap-3 cursor-pointer">
                            <input
                              type="checkbox"
                              checked={saveCard}
                              onChange={(e) => setSaveCard(e.target.checked)}
                              className="w-5 h-5 rounded border-gray-300 text-blue-500 focus:ring-blue-500"
                            />
                            <div>
                              <span className={isDark ? 'text-white' : 'text-gray-900'}>
                                {t('admin.payment.save_card')}
                              </span>
                              <p className={`text-xs mt-0.5 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                                {t('admin.payment.save_card_description')}
                              </p>
                            </div>
                          </label>
                        </div>
                      )}

                      {/* Preauth info message */}
                      {mode === 'preauth' && (
                        <div className={`p-4 rounded-xl border ${
                          isDark ? 'border-blue-500/30 bg-blue-500/10' : 'border-blue-200 bg-blue-50'
                        }`}>
                          <div className="flex items-start gap-3">
                            <ShieldCheck className={`w-5 h-5 mt-0.5 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
                            <div>
                              <p className={`font-medium ${isDark ? 'text-blue-300' : 'text-blue-700'}`}>
                                {t('admin.payment.preauth_info_title')}
                              </p>
                              <p className={`text-sm mt-1 ${isDark ? 'text-blue-400/70' : 'text-blue-600/70'}`}>
                                {t('admin.payment.preauth_info_desc')}
                              </p>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}

              {/* Check payment fields */}
              {paymentMethod === 'check' && (
                <div className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                        {t('admin.payment.check_number')}
                      </label>
                      <input
                        type="text"
                        value={checkNumber}
                        onChange={(e) => setCheckNumber(e.target.value)}
                        className={`w-full px-4 py-3 rounded-xl border ${
                          isDark
                            ? 'bg-gray-900 border-gray-700 text-white'
                            : 'bg-white border-gray-200 text-gray-900'
                        }`}
                      />
                    </div>
                    <div>
                      <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                        {t('admin.payment.check_bank')}
                      </label>
                      <input
                        type="text"
                        value={checkBank}
                        onChange={(e) => setCheckBank(e.target.value)}
                        className={`w-full px-4 py-3 rounded-xl border ${
                          isDark
                            ? 'bg-gray-900 border-gray-700 text-white'
                            : 'bg-white border-gray-200 text-gray-900'
                        }`}
                      />
                    </div>
                  </div>
                  <div>
                    <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      {t('admin.payment.check_date')} <span className={isDark ? 'text-gray-500' : 'text-gray-400'}>({t('admin.common.optional')})</span>
                    </label>
                    <input
                      type="date"
                      value={checkDate}
                      onChange={(e) => setCheckDate(e.target.value)}
                      className={`w-full px-4 py-3 rounded-xl border ${
                        isDark
                          ? 'bg-gray-900 border-gray-700 text-white'
                          : 'bg-white border-gray-200 text-gray-900'
                      }`}
                    />
                  </div>
                </div>
              )}

              {/* Transfer payment fields */}
              {paymentMethod === 'transfer' && (
                <div>
                  <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {t('admin.payment.transfer_reference')} <span className={isDark ? 'text-gray-500' : 'text-gray-400'}>({t('admin.common.optional')})</span>
                  </label>
                  <input
                    type="text"
                    value={transferReference}
                    onChange={(e) => setTransferReference(e.target.value)}
                    placeholder="REF-123456"
                    className={`w-full px-4 py-3 rounded-xl border ${
                      isDark
                        ? 'bg-gray-900 border-gray-700 text-white placeholder-gray-600'
                        : 'bg-white border-gray-200 text-gray-900 placeholder-gray-400'
                    }`}
                  />
                </div>
              )}

              {/* Notes */}
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.payment.notes')} <span className={isDark ? 'text-gray-500' : 'text-gray-400'}>({t('admin.common.optional')})</span>
                </label>
                <textarea
                  value={notes}
                  onChange={(e) => setNotes(e.target.value)}
                  rows={2}
                  className={`w-full px-4 py-3 rounded-xl border resize-none ${
                    isDark
                      ? 'bg-gray-900 border-gray-700 text-white placeholder-gray-600'
                      : 'bg-white border-gray-200 text-gray-900 placeholder-gray-400'
                  }`}
                />
              </div>

              {/* Error message */}
              {error && (
                <div className="flex items-center gap-2 p-3 rounded-xl bg-red-500/10 text-red-500">
                  <AlertCircle className="w-5 h-5 flex-shrink-0" />
                  <span className="text-sm">{error}</span>
                </div>
              )}
            </div>

            {/* Footer */}
            <div className={`flex items-center justify-between px-6 py-4 border-t ${
              isDark ? 'border-gray-700' : 'border-gray-200'
            }`}>
              <button
                onClick={onClose}
                disabled={loading}
                className={`px-4 py-2 rounded-xl font-medium transition-colors ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                {t('admin.common.cancel')}
              </button>
              <button
                onClick={handleSubmit}
                disabled={loading || !isValid()}
                className={`flex items-center gap-2 px-6 py-2 rounded-xl font-medium transition-colors ${
                  isValid() && !loading
                    ? mode === 'preauth'
                      ? 'bg-blue-600 hover:bg-blue-700 text-white'
                      : 'bg-green-600 hover:bg-green-700 text-white'
                    : 'bg-gray-400 text-gray-200 cursor-not-allowed'
                }`}
              >
                {loading ? (
                  <>
                    <Loader2 className="w-4 h-4 animate-spin" />
                    {t('admin.payment.processing')}
                  </>
                ) : mode === 'preauth' ? (
                  <>
                    <ShieldCheck className="w-4 h-4" />
                    {t('admin.payment.authorize')} {formatCurrency(parseFloat(amount) || 0)}
                  </>
                ) : (
                  <>
                    <CreditCard className="w-4 h-4" />
                    {t('admin.payment.pay')} {formatCurrency(parseFloat(amount) || 0)}
                  </>
                )}
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/components/SettingsModal.tsx">
'use client'

import { useState, useEffect } from 'react'
import { X, Save, Loader2, Settings, Gamepad2, Target, Cake, DollarSign } from 'lucide-react'
import { getClient } from '@/lib/supabase/client'
import type { EventRoom, BranchSettings, LaserRoom } from '@/lib/supabase/types'
import type { PostgrestError } from '@supabase/supabase-js'

type SettingsTab = 'general' | 'active' | 'laser' | 'rooms' | 'pricing'

interface SettingsModalProps {
  isOpen: boolean
  onClose: () => void
  branchId: string | null
  rooms: EventRoom[]
  settings: BranchSettings | null
  onUpdate: () => Promise<void>
  isDark: boolean
}

export function SettingsModal({
  isOpen,
  onClose,
  branchId,
  rooms,
  settings,
  onUpdate,
  isDark,
}: SettingsModalProps) {
  const [roomCapacities, setRoomCapacities] = useState<Record<string, number>>({})
  const [roomNames, setRoomNames] = useState<Record<string, string>>({})
  const [playersPerSlot, setPlayersPerSlot] = useState<number>(6)
  const [totalSlots, setTotalSlots] = useState<number>(14)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState(false)
  
  // États pour les laser rooms
  const [laserRooms, setLaserRooms] = useState<LaserRoom[]>([])
  const [laserTotalVests, setLaserTotalVests] = useState<number>(0)
  const [laserExclusiveThreshold, setLaserExclusiveThreshold] = useState<number>(10)
  const [laserEnabled, setLaserEnabled] = useState<boolean>(false)
  const [newLaserRoomName, setNewLaserRoomName] = useState('')
  const [newLaserRoomCapacity, setNewLaserRoomCapacity] = useState(15)
  
  // Paramètres d'affichage du texte dans les cellules
  const [textSize, setTextSize] = useState<'xs' | 'sm' | 'base' | 'lg'>('sm')
  const [textWeight, setTextWeight] = useState<'normal' | 'semibold' | 'bold'>('bold')
  const [textAlign, setTextAlign] = useState<'left' | 'center' | 'right'>('left')

  // Paramètres iCount
  const [icountAutoSendQuote, setIcountAutoSendQuote] = useState<boolean>(true)
  
  // Onglet actif
  const [activeTab, setActiveTab] = useState<SettingsTab>('general')

  // Initialiser les capacités et noms des salles
  useEffect(() => {
    if (rooms && rooms.length > 0) {
      const capacities: Record<string, number> = {}
      const names: Record<string, string> = {}
      rooms.forEach(room => {
        capacities[room.id] = room.capacity
        names[room.id] = room.name || ''
      })
      setRoomCapacities(capacities)
      setRoomNames(names)
    }
  }, [rooms])

  // Initialiser les paramètres depuis les settings de la branche
  useEffect(() => {
    if (settings) {
      // Utiliser max_players_per_slot depuis branch_settings, ou valeur par défaut
      setPlayersPerSlot(settings.max_players_per_slot || 6)
      // Utiliser total_slots depuis branch_settings, ou valeur par défaut
      setTotalSlots(settings.total_slots || 14)
      // Paramètres Laser
      setLaserTotalVests(settings.laser_total_vests || 0)
      setLaserExclusiveThreshold(settings.laser_exclusive_threshold || 10)
      setLaserEnabled(settings.laser_enabled || false)
      // iCount settings - default to true if not set
      setIcountAutoSendQuote((settings as unknown as { icount_auto_send_quote?: boolean }).icount_auto_send_quote ?? true)
    } else {
      setPlayersPerSlot(6) // Valeur par défaut si pas de settings
      setTotalSlots(14) // Valeur par défaut si pas de settings
      setLaserTotalVests(0)
      setLaserExclusiveThreshold(10)
      setLaserEnabled(false)
      setIcountAutoSendQuote(true) // Par défaut activé
    }
  }, [settings, branchId]) // Recharger quand branchId change pour avoir les bons paramètres

  // Charger les laser rooms
  useEffect(() => {
    const loadLaserRooms = async () => {
      if (!branchId) {
        setLaserRooms([])
        return
      }

      const supabase = getClient()
      try {
        const { data, error } = await supabase
          .from('laser_rooms')
          .select('*')
          .eq('branch_id', branchId)
          .order('sort_order')
          .returns<LaserRoom[]>()

        // Si la table n'existe pas, retourner un tableau vide silencieusement
        if (error) {
          const errorCode = error.code || ''
          const errorMessage = String(error.message || '')
          const isEmptyError = (
            !errorMessage || 
            errorMessage === '{}' || 
            errorMessage === '[object Object]' ||
            (typeof error === 'object' && error !== null && Object.keys(error).length === 0)
          )
          const isTableNotExist = 
            isEmptyError ||
            errorCode === '42P01' || 
            errorMessage.toLowerCase().includes('does not exist') || 
            errorMessage.toLowerCase().includes('n\'existe pas')
          
          if (isTableNotExist) {
            setLaserRooms([])
            return
          }
          throw error
        }

        setLaserRooms(data || [])
      } catch (err) {
        // Ne pas logger si c'est juste que la table n'existe pas
        const errorObj = err as PostgrestError
        const errorCode = String(errorObj?.code || '')
        const errorMessage = String(errorObj?.message || '')
        const isEmptyError = (
          !errorMessage || 
          errorMessage === '{}' || 
          errorMessage === '[object Object]' ||
          (typeof err === 'object' && err !== null && Object.keys(err).length === 0)
        )
        const isTableNotExist = 
          isEmptyError ||
          errorCode === '42P01' || 
          errorMessage.toLowerCase().includes('does not exist')
        
        if (!isTableNotExist) {
          console.error('Error loading laser rooms:', err)
        }
        setLaserRooms([])
      }
    }

    loadLaserRooms()
  }, [branchId])

  // Charger les paramètres d'affichage depuis localStorage
  useEffect(() => {
    if (branchId) {
      const storageKey = `displaySettings_${branchId}`
      const saved = localStorage.getItem(storageKey)
      if (saved) {
        try {
          const parsed = JSON.parse(saved)
          if (parsed.textSize) setTextSize(parsed.textSize)
          if (parsed.textWeight) setTextWeight(parsed.textWeight)
          if (parsed.textAlign) setTextAlign(parsed.textAlign)
        } catch (e) {
          console.error('Error loading display settings:', e)
        }
      }
    }
  }, [branchId])

  if (!isOpen || !branchId) return null

  const handleSave = async () => {
    if (!branchId) return

    setLoading(true)
    setError(null)
    setSuccess(false)

    try {
      const supabase = getClient()

      // Mettre à jour les capacités et noms des salles
      for (const room of rooms) {
        const newCapacity = roomCapacities[room.id] !== undefined ? roomCapacities[room.id] : room.capacity
        // Si roomNames[room.id] existe (même vide), on l'utilise, sinon on garde le nom actuel
        const newName = roomNames[room.id] !== undefined ? roomNames[room.id] : room.name

        const { error: roomError } = await supabase
          .from('event_rooms')
          // @ts-expect-error - Type assertion nécessaire pour contourner le problème de typage Supabase
          .update({ 
            capacity: newCapacity,
            name: newName || `Salle ${room.sort_order + 1}` // Valeur par défaut si vide
          })
          .eq('id', room.id)

        if (roomError) {
          console.error('Error updating room:', roomError)
          throw roomError
        }
      }

      // Mettre à jour les paramètres de slots dans branch_settings
      const maxConcurrentPlayers = playersPerSlot * totalSlots

      const { error: settingsError } = await supabase
        .from('branch_settings')
        // @ts-expect-error - Type assertion nécessaire pour contourner le problème de typage Supabase
        .update({
          total_slots: totalSlots,
          max_players_per_slot: playersPerSlot,
          max_concurrent_players: maxConcurrentPlayers,
          laser_total_vests: laserTotalVests,
          laser_exclusive_threshold: laserExclusiveThreshold,
          laser_enabled: laserEnabled,
          icount_auto_send_quote: icountAutoSendQuote
        })
        .eq('branch_id', branchId)

      if (settingsError) throw settingsError

      // Mettre à jour les laser rooms (noms et capacités)
      for (const laserRoom of laserRooms) {
        const { error: laserRoomError } = await supabase
          .from('laser_rooms')
          // @ts-expect-error
          .update({
            name: laserRoom.name,
            capacity: laserRoom.capacity
          })
          .eq('id', laserRoom.id)
        
        if (laserRoomError) {
          // Si la table n'existe pas, ignorer silencieusement
          const errorCode = laserRoomError.code || ''
          const errorMessage = String(laserRoomError.message || '')
          const isTableNotExist = 
            errorCode === '42P01' || 
            errorMessage.toLowerCase().includes('does not exist')
          
          if (!isTableNotExist) {
            throw laserRoomError
          }
        }
      }

      // Sauvegarder les paramètres d'affichage dans localStorage
      if (branchId) {
        const storageKey = `displaySettings_${branchId}`
        localStorage.setItem(storageKey, JSON.stringify({
          textSize,
          textWeight,
          textAlign,
        }))
      }

      setSuccess(true)
      
      // Rafraîchir les données avant de fermer
      await onUpdate()
      
      // Attendre un peu pour que l'utilisateur voie le message de succès
      setTimeout(() => {
        onClose()
        setSuccess(false)
      }, 1500)
    } catch (err) {
      console.error('Error saving settings:', err)
      setError(err instanceof Error ? err.message : 'Erreur lors de la sauvegarde')
    } finally {
      setLoading(false)
    }
  }

  const sortedRooms = [...rooms].sort((a, b) => a.sort_order - b.sort_order)

  const tabs = [
    { id: 'general' as SettingsTab, label: 'Général', icon: Settings },
    { id: 'active' as SettingsTab, label: 'Active Games', icon: Gamepad2 },
    { id: 'laser' as SettingsTab, label: 'Laser', icon: Target },
    { id: 'rooms' as SettingsTab, label: 'Salles Anniversaire', icon: Cake },
    { id: 'pricing' as SettingsTab, label: 'Tarifs', icon: DollarSign },
  ]

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
      <div
        className={`w-full max-w-6xl max-h-[90vh] flex flex-col rounded-lg shadow-xl ${
          isDark ? 'bg-gray-800' : 'bg-white'
        }`}
      >
        {/* Header */}
        <div
          className={`flex items-center justify-between p-6 border-b ${
            isDark ? 'border-gray-700' : 'border-gray-200'
          }`}
        >
          <h2 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            Paramètres
          </h2>
          <button
            onClick={onClose}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'text-gray-400 hover:bg-gray-700 hover:text-white'
                : 'text-gray-500 hover:bg-gray-100 hover:text-gray-900'
            }`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Tabs */}
        <div className={`border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <div className="flex space-x-1 p-2">
            {tabs.map((tab) => {
              const Icon = tab.icon
              return (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`flex items-center gap-2 px-6 py-3 rounded-lg font-medium transition-all ${
                    activeTab === tab.id
                      ? isDark
                        ? 'bg-blue-600 text-white'
                        : 'bg-blue-500 text-white'
                      : isDark
                        ? 'text-gray-400 hover:bg-gray-700 hover:text-white'
                        : 'text-gray-600 hover:bg-gray-100 hover:text-gray-900'
                  }`}
                >
                  <Icon className="w-4 h-4" />
                  {tab.label}
                </button>
              )
            })}
          </div>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6 space-y-8">
          {/* ONGLET: Salles Anniversaire */}
          {activeTab === 'rooms' && (
          <div>
          {/* Capacités des salles */}
          <div>
            <h3 className={`text-lg font-semibold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              Capacités des salles
            </h3>
            <div className="space-y-3">
              {sortedRooms.map((room, index) => (
                <div
                  key={room.id}
                  className={`space-y-3 p-4 rounded-lg ${
                    isDark ? 'bg-gray-700/50' : 'bg-gray-50'
                  }`}
                >
                  {/* Nom de la salle */}
                  <div className="flex items-center justify-between">
                    <label
                      className={`text-sm font-medium ${
                        isDark ? 'text-gray-300' : 'text-gray-700'
                      }`}
                    >
                      Nom de la salle
                    </label>
                    <input
                      type="text"
                      value={roomNames[room.id] !== undefined ? roomNames[room.id] : (room.name || `Salle ${index + 1}`)}
                      onChange={(e) => {
                        setRoomNames({
                          ...roomNames,
                          [room.id]: e.target.value,
                        })
                      }}
                      placeholder={`Salle ${index + 1}`}
                      className={`flex-1 max-w-xs px-3 py-2 rounded-lg border ${
                        isDark
                          ? 'bg-gray-800 border-gray-600 text-white'
                          : 'bg-white border-gray-300 text-gray-900'
                      } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                    />
                  </div>
                  {/* Capacité de la salle */}
                  <div className="flex items-center justify-between">
                    <label
                      className={`text-sm font-medium ${
                        isDark ? 'text-gray-300' : 'text-gray-700'
                      }`}
                    >
                      Capacité
                    </label>
                    <div className="flex items-center gap-3">
                      <input
                        type="number"
                        min="1"
                        max="200"
                        value={roomCapacities[room.id] || room.capacity}
                        onChange={(e) => {
                          const value = parseInt(e.target.value) || 1
                          setRoomCapacities({
                            ...roomCapacities,
                            [room.id]: value,
                          })
                        }}
                        className={`w-24 px-3 py-2 rounded-lg border ${
                          isDark
                            ? 'bg-gray-800 border-gray-600 text-white'
                            : 'bg-white border-gray-300 text-gray-900'
                        } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      />
                      <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                        personnes
                      </span>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
          </div>
          )}

          {/* ONGLET: Active Games */}
          {activeTab === 'active' && (
          <div>
          {/* Configuration des slots */}
          <div>
            <h3 className={`text-lg font-semibold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              Configuration des slots
            </h3>
            <div className="space-y-4">
              {/* Nombre total de slots */}
              <div
                className={`flex items-center justify-between p-4 rounded-lg ${
                  isDark ? 'bg-gray-700/50' : 'bg-gray-50'
                }`}
              >
                <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  Nombre total de slots
                </label>
                <div className="flex items-center gap-3">
                  <input
                    type="number"
                    min="1"
                    max="30"
                    value={totalSlots}
                    onChange={(e) => {
                      const value = parseInt(e.target.value) || 1
                      setTotalSlots(value)
                    }}
                    className={`w-24 px-3 py-2 rounded-lg border ${
                      isDark
                        ? 'bg-gray-800 border-gray-600 text-white'
                        : 'bg-white border-gray-300 text-gray-900'
                    } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                  />
                  <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    slots
                  </span>
                </div>
              </div>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                Nombre total de slots disponibles pour les réservations.
              </p>

              {/* Personnes par slot */}
              <div
                className={`flex items-center justify-between p-4 rounded-lg ${
                  isDark ? 'bg-gray-700/50' : 'bg-gray-50'
                }`}
              >
                <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  Personnes par slot
                </label>
                <div className="flex items-center gap-3">
                  <input
                    type="number"
                    min="1"
                    max="20"
                    value={playersPerSlot}
                    onChange={(e) => {
                      const value = parseInt(e.target.value) || 1
                      setPlayersPerSlot(value)
                    }}
                    className={`w-24 px-3 py-2 rounded-lg border ${
                      isDark
                        ? 'bg-gray-800 border-gray-600 text-white'
                        : 'bg-white border-gray-300 text-gray-900'
                    } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                  />
                  <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    personnes
                  </span>
                </div>
              </div>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                Nombre de personnes pouvant occuper un slot de jeu simultanément.
              </p>
            </div>
          </div>
          </div>
          )}

          {/* ONGLET: Laser */}
          {activeTab === 'laser' && (
          <div>
          {/* Activation Laser */}
          <div>
            <h3 className={`text-lg font-semibold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              Activation Laser
            </h3>
            <div className={`flex items-center justify-between p-4 rounded-lg ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
              <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                Activer les salles Laser pour cette branche
              </label>
              <input
                type="checkbox"
                checked={laserEnabled}
                onChange={(e) => setLaserEnabled(e.target.checked)}
                className="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
            </div>
            <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
              Activez cette option pour permettre les réservations Laser dans cette branche.
            </p>
          </div>

          {/* Gestion des salles Laser */}
          {laserEnabled && (
            <div>
              <h3 className={`text-lg font-semibold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                Gestion des salles Laser
              </h3>
              <div className="space-y-4">
                {/* Nombre total de vestes */}
                <div className={`flex items-center justify-between p-4 rounded-lg ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
                  <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    Nombre total de vestes disponibles
                  </label>
                  <div className="flex items-center gap-3">
                    <input
                      type="number"
                      min="0"
                      max="100"
                      value={laserTotalVests}
                      onChange={(e) => {
                        const value = parseInt(e.target.value) || 0
                        setLaserTotalVests(value)
                      }}
                      className={`w-24 px-3 py-2 rounded-lg border ${
                        isDark
                          ? 'bg-gray-800 border-gray-600 text-white'
                          : 'bg-white border-gray-300 text-gray-900'
                      } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                    />
                    <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                      vestes
                    </span>
                  </div>
                </div>
                <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  Limite principale de vestes disponibles pour toutes les salles Laser combinées.
                </p>

                {/* Seuil salle exclusive */}
                <div>
                  <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    Seuil salle exclusive
                  </label>
                  <div className="flex items-center gap-3">
                    <input
                      type="number"
                      min="1"
                      max="50"
                      value={laserExclusiveThreshold}
                      onChange={(e) => {
                        const value = parseInt(e.target.value) || 10
                        setLaserExclusiveThreshold(value)
                      }}
                      className={`w-24 px-3 py-2 rounded-lg border ${
                        isDark
                          ? 'bg-gray-800 border-gray-600 text-white'
                          : 'bg-white border-gray-300 text-gray-900'
                      } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                    />
                    <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                      personnes
                    </span>
                  </div>
                </div>
                <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  À partir de ce nombre de participants, le groupe doit avoir une salle vide pour lui seul ET la salle devient exclusive (bloquée aux autres groupes). Utilisé pour l'allocation automatique et le blocage de capacité.
                </p>

                {/* Liste des salles Laser */}
                <div className="space-y-3">
                  {laserRooms.map((room, index) => (
                    <div
                      key={room.id}
                      className={`space-y-3 p-4 rounded-lg ${
                        isDark ? 'bg-gray-700/50' : 'bg-gray-50'
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                          Nom de la salle
                        </label>
                        <input
                          type="text"
                          value={room.name || `L${index + 1}`}
                          onChange={async (e) => {
                            const newName = e.target.value
                            const updatedRooms = laserRooms.map(r => 
                              r.id === room.id ? { ...r, name: newName } : r
                            )
                            setLaserRooms(updatedRooms)
                          }}
                          className={`flex-1 max-w-xs px-3 py-2 rounded-lg border ${
                            isDark
                              ? 'bg-gray-800 border-gray-600 text-white'
                              : 'bg-white border-gray-300 text-gray-900'
                          } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                        />
                      </div>
                      <div className="flex items-center justify-between">
                        <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                          Capacité
                        </label>
                        <div className="flex items-center gap-3">
                          <input
                            type="number"
                            min="1"
                            max="50"
                            value={room.capacity}
                            onChange={async (e) => {
                              const newCapacity = parseInt(e.target.value) || 1
                              const updatedRooms = laserRooms.map(r => 
                                r.id === room.id ? { ...r, capacity: newCapacity } : r
                              )
                              setLaserRooms(updatedRooms)
                            }}
                            className={`w-24 px-3 py-2 rounded-lg border ${
                              isDark
                                ? 'bg-gray-800 border-gray-600 text-white'
                                : 'bg-white border-gray-300 text-gray-900'
                            } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                          />
                          <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                            personnes
                          </span>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>

                {/* Ajouter une nouvelle salle Laser */}
                <div className={`p-4 rounded-lg border-2 border-dashed ${
                  isDark ? 'border-gray-600 bg-gray-700/30' : 'border-gray-300 bg-gray-50'
                }`}>
                  <h4 className={`text-sm font-medium mb-3 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    Ajouter une nouvelle salle Laser
                  </h4>
                  <div className="space-y-3">
                    <div className="flex items-center gap-3">
                      <input
                        type="text"
                        placeholder="Nom (ex: L3)"
                        value={newLaserRoomName}
                        onChange={(e) => setNewLaserRoomName(e.target.value)}
                        className={`flex-1 px-3 py-2 rounded-lg border ${
                          isDark
                            ? 'bg-gray-800 border-gray-600 text-white'
                            : 'bg-white border-gray-300 text-gray-900'
                        } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      />
                      <input
                        type="number"
                        min="1"
                        max="50"
                        placeholder="Capacité"
                        value={newLaserRoomCapacity}
                        onChange={(e) => setNewLaserRoomCapacity(parseInt(e.target.value) || 15)}
                        className={`w-24 px-3 py-2 rounded-lg border ${
                          isDark
                            ? 'bg-gray-800 border-gray-600 text-white'
                            : 'bg-white border-gray-300 text-gray-900'
                        } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      />
                      <button
                        onClick={async () => {
                          if (!newLaserRoomName || !branchId) return
                          
                          const supabase = getClient()
                          try {
                            const maxSortOrder = laserRooms.length > 0 
                              ? Math.max(...laserRooms.map(r => r.sort_order || 0))
                              : -1
                            
                            const { data, error } = await supabase
                              .from('laser_rooms')
                              // @ts-expect-error
                              .insert({
                                branch_id: branchId,
                                slug: newLaserRoomName.toLowerCase().replace(/\s+/g, '-'),
                                name: newLaserRoomName,
                                capacity: newLaserRoomCapacity,
                                sort_order: maxSortOrder + 1,
                                is_active: true
                              })
                              .select()
                              .single()
                              .returns<LaserRoom>()

                            if (error) {
                              const errorCode = error.code || ''
                              const errorMessage = String(error.message || '')
                              const isTableNotExist = 
                                errorCode === '42P01' || 
                                errorMessage.toLowerCase().includes('does not exist')
                              
                              if (!isTableNotExist) {
                                throw error
                              }
                              return
                            }

                            if (data) {
                              setLaserRooms([...laserRooms, data])
                              setNewLaserRoomName('')
                              setNewLaserRoomCapacity(15)
                            }
                          } catch (err) {
                            console.error('Error adding laser room:', err)
                          }
                        }}
                        disabled={!newLaserRoomName}
                        className={`px-4 py-2 rounded-lg transition-colors ${
                          !newLaserRoomName
                            ? isDark
                              ? 'bg-gray-700 text-gray-500 cursor-not-allowed'
                              : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                            : 'bg-blue-600 hover:bg-blue-700 text-white'
                        }`}
                      >
                        Ajouter
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
          </div>
          )}

          {/* ONGLET: Général */}
          {activeTab === 'general' && (
          <div>
          {/* Configuration de l'affichage du texte */}
          <div>
            <h3 className={`text-lg font-semibold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              Affichage des réservations
            </h3>
            <div className="space-y-4">
              {/* Taille de police */}
              <div className={`flex items-center justify-between p-4 rounded-lg ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
                <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  Taille de police
                </label>
                <select
                  value={textSize}
                  onChange={(e) => setTextSize(e.target.value as 'xs' | 'sm' | 'base' | 'lg')}
                  className={`px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-800 border-gray-600 text-white'
                      : 'bg-white border-gray-300 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                >
                  <option value="xs">Très petite (xs)</option>
                  <option value="sm">Petite (sm)</option>
                  <option value="base">Normale (base)</option>
                  <option value="lg">Grande (lg)</option>
                </select>
              </div>

              {/* Gras */}
              <div className={`flex items-center justify-between p-4 rounded-lg ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
                <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  Épaisseur du texte
                </label>
                <select
                  value={textWeight}
                  onChange={(e) => setTextWeight(e.target.value as 'normal' | 'semibold' | 'bold')}
                  className={`px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-800 border-gray-600 text-white'
                      : 'bg-white border-gray-300 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                >
                  <option value="normal">Normal</option>
                  <option value="semibold">Semi-gras</option>
                  <option value="bold">Gras</option>
                </select>
              </div>

              {/* Alignement */}
              <div className={`flex items-center justify-between p-4 rounded-lg ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
                <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  Alignement
                </label>
                <select
                  value={textAlign}
                  onChange={(e) => setTextAlign(e.target.value as 'left' | 'center' | 'right')}
                  className={`px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-800 border-gray-600 text-white'
                      : 'bg-white border-gray-300 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                >
                  <option value="left">Gauche</option>
                  <option value="center">Centre</option>
                  <option value="right">Droite</option>
                </select>
              </div>
            </div>
          </div>
          </div>
          )}

          {/* ONGLET: Tarifs */}
          {activeTab === 'pricing' && (
          <div className="space-y-6">
            {/* Paramètres iCount */}
            <div>
              <h3 className={`text-lg font-semibold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                Facturation iCount
              </h3>
              <div className="space-y-4">
                {/* Toggle envoi auto */}
                <div className={`flex items-center justify-between p-4 rounded-lg ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
                  <div>
                    <label className={`text-sm font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      Envoi automatique des devis
                    </label>
                    <p className={`text-xs mt-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                      Envoyer automatiquement le devis par email à la confirmation de la réservation
                    </p>
                  </div>
                  <button
                    type="button"
                    onClick={() => setIcountAutoSendQuote(!icountAutoSendQuote)}
                    className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                      icountAutoSendQuote ? 'bg-blue-600' : isDark ? 'bg-gray-600' : 'bg-gray-300'
                    }`}
                  >
                    <span
                      className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                        icountAutoSendQuote ? 'translate-x-6' : 'translate-x-1'
                      }`}
                    />
                  </button>
                </div>
              </div>
            </div>

            {/* Info sur le catalogue */}
            <div className={`p-4 rounded-lg ${isDark ? 'bg-gray-700/30 border border-gray-600' : 'bg-blue-50 border border-blue-200'}`}>
              <p className={`text-sm ${isDark ? 'text-gray-300' : 'text-blue-800'}`}>
                Le catalogue de produits et formules iCount est configuré dans la section &quot;Catalogue iCount&quot; des paramètres généraux.
              </p>
            </div>
          </div>
          )}

          {/* Messages d'erreur/succès */}
          {error && (
            <div className={`p-3 rounded-lg bg-red-500/10 border border-red-500/20`}>
              <p className="text-sm text-red-500">{error}</p>
            </div>
          )}
          {success && (
            <div className={`p-3 rounded-lg bg-green-500/10 border border-green-500/20`}>
              <p className="text-sm text-green-500">Paramètres sauvegardés avec succès !</p>
            </div>
          )}
        </div>

        {/* Footer */}
        <div
          className={`flex items-center justify-end gap-3 p-6 border-t ${
            isDark ? 'border-gray-700' : 'border-gray-200'
          }`}
        >
          <button
            onClick={onClose}
            className={`px-4 py-2 rounded-lg transition-colors ${
              isDark
                ? 'text-gray-300 hover:bg-gray-700'
                : 'text-gray-700 hover:bg-gray-100'
            }`}
          >
            Annuler
          </button>
          <button
            onClick={handleSave}
            disabled={loading}
            className="px-6 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 transition-colors"
          >
            {loading ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin" />
                Sauvegarde...
              </>
            ) : (
              <>
                <Save className="w-4 h-4" />
                Enregistrer
              </>
            )}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/emails/components/EmailsTable.tsx">
'use client'

import { useState } from 'react'
import {
  Mail,
  Trash2,
  CheckCircle2,
  XCircle,
  Clock,
  AlertTriangle,
  ChevronLeft,
  ChevronRight,
  Eye
} from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { EmailLog } from '@/lib/supabase/types'

interface EmailsTableProps {
  emails: EmailLog[]
  isDark: boolean
  pagination: {
    total: number
    page: number
    limit: number
    totalPages: number
  }
  onPageChange: (page: number) => void
  onResend: (emailId: string) => void
  onDelete?: (emailId: string) => void
}

export function EmailsTable({
  emails,
  isDark,
  pagination,
  onPageChange,
  onResend,
  onDelete
}: EmailsTableProps) {
  const { t } = useTranslation()
  const [selectedEmail, setSelectedEmail] = useState<EmailLog | null>(null)
  const [resending, setResending] = useState<string | null>(null)

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'sent':
      case 'delivered':
        return <CheckCircle2 className="w-4 h-4 text-green-500" />
      case 'failed':
      case 'bounced':
        return <XCircle className="w-4 h-4 text-red-500" />
      case 'pending':
        return <Clock className="w-4 h-4 text-yellow-500" />
      default:
        return <AlertTriangle className="w-4 h-4 text-gray-500" />
    }
  }

  const getStatusBadge = (status: string) => {
    const baseClass = 'px-2 py-1 rounded-full text-xs font-medium flex items-center gap-1'
    switch (status) {
      case 'sent':
        return `${baseClass} ${isDark ? 'bg-green-500/20 text-green-400' : 'bg-green-100 text-green-700'}`
      case 'delivered':
        return `${baseClass} ${isDark ? 'bg-blue-500/20 text-blue-400' : 'bg-blue-100 text-blue-700'}`
      case 'failed':
        return `${baseClass} ${isDark ? 'bg-red-500/20 text-red-400' : 'bg-red-100 text-red-700'}`
      case 'bounced':
        return `${baseClass} ${isDark ? 'bg-orange-500/20 text-orange-400' : 'bg-orange-100 text-orange-700'}`
      case 'pending':
        return `${baseClass} ${isDark ? 'bg-yellow-500/20 text-yellow-400' : 'bg-yellow-100 text-yellow-700'}`
      default:
        return `${baseClass} ${isDark ? 'bg-gray-500/20 text-gray-400' : 'bg-gray-100 text-gray-700'}`
    }
  }

  const formatDate = (dateString: string) => {
    const date = new Date(dateString)
    return date.toLocaleDateString('fr-FR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
  }

  const handleResend = async (emailId: string) => {
    setResending(emailId)
    await onResend(emailId)
    setResending(null)
  }

  if (emails.length === 0) {
    return (
      <div className={`text-center py-12 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
        <Mail className="w-12 h-12 mx-auto mb-4 opacity-50" />
        <p>{t('admin.emails.no_emails')}</p>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {/* Table */}
      <div className={`rounded-lg border overflow-hidden ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        <table className="w-full">
          <thead>
            <tr className={isDark ? 'bg-gray-900/50' : 'bg-gray-50'}>
              <th className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.emails.table.status')}
              </th>
              <th className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.emails.table.recipient')}
              </th>
              <th className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.emails.table.subject')}
              </th>
              <th className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.emails.table.date')}
              </th>
              <th className={`px-4 py-3 text-right text-xs font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.emails.table.actions')}
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {emails.map((email) => (
              <tr
                key={email.id}
                className={`transition-colors ${
                  isDark ? 'hover:bg-gray-700/50' : 'hover:bg-gray-50'
                }`}
              >
                {/* Status */}
                <td className="px-4 py-3">
                  <span className={getStatusBadge(email.status)}>
                    {getStatusIcon(email.status)}
                    {t(`admin.emails.status.${email.status}`)}
                  </span>
                </td>

                {/* Recipient */}
                <td className="px-4 py-3">
                  <div>
                    <p className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                      {email.recipient_name || '-'}
                    </p>
                    <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                      {email.recipient_email}
                    </p>
                  </div>
                </td>

                {/* Subject */}
                <td className="px-4 py-3">
                  <p className={`${isDark ? 'text-white' : 'text-gray-900'} max-w-xs truncate`}>
                    {email.subject}
                  </p>
                  {email.template_code && (
                    <p className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      Template: {email.template_code}
                    </p>
                  )}
                </td>

                {/* Date */}
                <td className="px-4 py-3">
                  <p className={`text-sm ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
                    {formatDate(email.created_at)}
                  </p>
                  {email.sent_at && email.sent_at !== email.created_at && (
                    <p className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.emails.table.sent_at')}: {formatDate(email.sent_at)}
                    </p>
                  )}
                </td>

                {/* Actions */}
                <td className="px-4 py-3">
                  <div className="flex items-center justify-end gap-2">
                    {/* View details */}
                    <button
                      onClick={() => setSelectedEmail(email)}
                      className={`p-1.5 rounded transition-colors ${
                        isDark
                          ? 'hover:bg-gray-600 text-gray-400 hover:text-white'
                          : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
                      }`}
                      title={t('admin.emails.view_details')}
                    >
                      <Eye className="w-4 h-4" />
                    </button>

                    {/* Delete (super_admin only) */}
                    {onDelete && (
                      <button
                        onClick={() => onDelete(email.id)}
                        className={`p-1.5 rounded transition-colors ${
                          isDark
                            ? 'hover:bg-red-600/50 text-red-400 hover:text-red-300'
                            : 'hover:bg-red-100 text-red-500 hover:text-red-700'
                        }`}
                        title={t('admin.emails.delete')}
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    )}
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Pagination */}
      {pagination.totalPages > 1 && (
        <div className="flex items-center justify-between">
          <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
            {t('admin.emails.pagination.showing', {
              from: (pagination.page - 1) * pagination.limit + 1,
              to: Math.min(pagination.page * pagination.limit, pagination.total),
              total: pagination.total
            })}
          </p>

          <div className="flex items-center gap-2">
            <button
              onClick={() => onPageChange(pagination.page - 1)}
              disabled={pagination.page === 1}
              className={`p-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-white disabled:bg-gray-800 disabled:text-gray-600'
                  : 'bg-gray-100 hover:bg-gray-200 text-gray-700 disabled:bg-gray-50 disabled:text-gray-400'
              }`}
            >
              <ChevronLeft className="w-4 h-4" />
            </button>

            <span className={`px-3 py-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {pagination.page} / {pagination.totalPages}
            </span>

            <button
              onClick={() => onPageChange(pagination.page + 1)}
              disabled={pagination.page === pagination.totalPages}
              className={`p-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-white disabled:bg-gray-800 disabled:text-gray-600'
                  : 'bg-gray-100 hover:bg-gray-200 text-gray-700 disabled:bg-gray-50 disabled:text-gray-400'
              }`}
            >
              <ChevronRight className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}

      {/* Email details modal */}
      {selectedEmail && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => setSelectedEmail(null)}
          />
          <div className={`relative w-full max-w-lg rounded-xl p-6 ${
            isDark ? 'bg-gray-800' : 'bg-white'
          }`}>
            <h3 className={`text-lg font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {t('admin.emails.details_title')}
            </h3>

            <div className="space-y-3">
              <div>
                <label className={`text-xs uppercase ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                  {t('admin.emails.table.status')}
                </label>
                <p className={`mt-1 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  <span className={getStatusBadge(selectedEmail.status)}>
                    {getStatusIcon(selectedEmail.status)}
                    {t(`admin.emails.status.${selectedEmail.status}`)}
                  </span>
                </p>
              </div>

              <div>
                <label className={`text-xs uppercase ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                  {t('admin.emails.table.recipient')}
                </label>
                <p className={`mt-1 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  {selectedEmail.recipient_name} &lt;{selectedEmail.recipient_email}&gt;
                </p>
              </div>

              <div>
                <label className={`text-xs uppercase ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                  {t('admin.emails.table.subject')}
                </label>
                <p className={`mt-1 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  {selectedEmail.subject}
                </p>
              </div>

              {selectedEmail.body_html && (
                <div>
                  <label className={`text-xs uppercase ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                    {t('admin.emails.preview')}
                  </label>
                  <div className="mt-2 rounded-lg overflow-hidden border border-gray-600">
                    <iframe
                      srcDoc={selectedEmail.body_html}
                      className="w-full h-80 bg-white"
                      title="Email preview"
                    />
                  </div>
                </div>
              )}

              {selectedEmail.error_message && (
                <div>
                  <label className={`text-xs uppercase text-red-500`}>
                    {t('admin.emails.error')}
                  </label>
                  <p className={`mt-1 text-sm text-red-400`}>
                    {selectedEmail.error_message}
                  </p>
                </div>
              )}

              <div className="grid grid-cols-2 gap-3">
                <div>
                  <label className={`text-xs uppercase ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                    {t('admin.emails.created_at')}
                  </label>
                  <p className={`mt-1 text-sm ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
                    {formatDate(selectedEmail.created_at)}
                  </p>
                </div>
                {selectedEmail.sent_at && (
                  <div>
                    <label className={`text-xs uppercase ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.emails.sent_at')}
                    </label>
                    <p className={`mt-1 text-sm ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
                      {formatDate(selectedEmail.sent_at)}
                    </p>
                  </div>
                )}
              </div>
            </div>

            <div className="mt-6 flex justify-end">
              <button
                onClick={() => setSelectedEmail(null)}
                className={`px-4 py-2 rounded-lg ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-white'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                {t('admin.common.close')}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/logs/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Loader2, AlertCircle, FileText, Calendar, Search } from 'lucide-react'
import { useAuth } from '@/hooks/useAuth'
import { useBranches } from '@/hooks/useBranches'
import { useLogs } from '@/hooks/useLogs'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { LogsTable } from './components/LogsTable'
import { createClient } from '@/lib/supabase/client'

export default function LogsPage() {
  const router = useRouter()
  const { t } = useTranslation()
  const { user, loading: authLoading } = useAuth()
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()

  // Theme state
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')

  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'

  // Get user role for logs hook
  const userRole = user?.role || 'agent'

  // Logs hook - pass branchId only for non-super_admin
  const { logs, loading: logsLoading, error, stats, deleteLogs, refresh } = useLogs(
    userRole === 'super_admin' ? null : selectedBranch?.id || null,
    userRole
  )

  // Date filters
  const [dateFrom, setDateFrom] = useState<string>('')
  const [dateTo, setDateTo] = useState<string>('')
  const [searchTerm, setSearchTerm] = useState('')

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  // Check permissions - only super_admin and branch_admin can view logs
  if (user && user.role !== 'super_admin' && user.role !== 'branch_admin') {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <div className="text-center">
          <AlertCircle className="w-16 h-16 text-red-500 mx-auto mb-4" />
          <h1 className={`text-2xl font-bold mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {t('admin.logs.access_denied')}
          </h1>
          <p className={isDark ? 'text-gray-400' : 'text-gray-600'}>
            {t('admin.logs.access_denied_message')}
          </p>
        </div>
      </div>
    )
  }

  // Loading state
  if (authLoading || branchesLoading || !user || !selectedBranch) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  // Filter logs by search term
  const filteredLogs = searchTerm
    ? logs.filter(log =>
        log.user_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        log.target_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        log.action_type.toLowerCase().includes(searchTerm.toLowerCase())
      )
    : logs

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={handleSignOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sub-header with title */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
              isDark ? 'bg-cyan-500/20' : 'bg-cyan-100'
            }`}>
              <FileText className={`w-6 h-6 ${isDark ? 'text-cyan-400' : 'text-cyan-600'}`} />
            </div>
            <div>
              <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.logs.title')}
              </h1>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                {t('admin.logs.subtitle')}
              </p>
            </div>
          </div>

          {/* Stats badges */}
          <div className="flex items-center gap-4">
            <div className={`px-3 py-2 rounded-lg ${isDark ? 'bg-gray-700' : 'bg-gray-100'}`}>
              <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.logs.stats.today')}
              </div>
              <div className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {stats.today}
              </div>
            </div>
            <div className={`px-3 py-2 rounded-lg ${isDark ? 'bg-gray-700' : 'bg-gray-100'}`}>
              <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.logs.stats.this_week')}
              </div>
              <div className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {stats.thisWeek}
              </div>
            </div>
            <div className={`px-3 py-2 rounded-lg ${isDark ? 'bg-gray-700' : 'bg-gray-100'}`}>
              <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.logs.stats.total')}
              </div>
              <div className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {stats.total}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Search and date filters */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-3`}>
        <div className="flex items-center gap-4">
          {/* Search */}
          <div className="flex-1 max-w-md relative">
            <Search className={`absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
            <input
              type="text"
              placeholder={t('admin.logs.search_placeholder')}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className={`w-full pl-10 pr-4 py-2 rounded-lg border text-sm ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-400'
                  : 'bg-gray-50 border-gray-200 text-gray-900 placeholder-gray-500'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
            />
          </div>

          {/* Date filters */}
          <div className="flex items-center gap-2">
            <Calendar className={`w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
            <input
              type="date"
              value={dateFrom}
              onChange={(e) => setDateFrom(e.target.value)}
              className={`px-3 py-2 rounded-lg border text-sm ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white'
                  : 'bg-gray-50 border-gray-200 text-gray-900'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
            />
            <span className={isDark ? 'text-gray-500' : 'text-gray-400'}>-</span>
            <input
              type="date"
              value={dateTo}
              onChange={(e) => setDateTo(e.target.value)}
              className={`px-3 py-2 rounded-lg border text-sm ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white'
                  : 'bg-gray-50 border-gray-200 text-gray-900'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
            />
          </div>
        </div>
      </div>

      {/* Main content */}
      <div className="p-6 space-y-6">
        {/* Error */}
        {error && (
          <div className={`p-4 rounded-lg border flex items-start gap-2 ${
            isDark
              ? 'bg-red-500/10 border-red-500/50 text-red-400'
              : 'bg-red-50 border-red-200 text-red-600'
          }`}>
            <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
            <span>{error}</span>
          </div>
        )}

        {/* Loading */}
        {logsLoading && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 animate-spin text-blue-500" />
          </div>
        )}

        {/* Table */}
        {!logsLoading && (
          <LogsTable
            logs={filteredLogs}
            isDark={isDark}
            currentUserRole={user.role || 'agent'}
            onDeleteLogs={user.role === 'super_admin' ? deleteLogs : undefined}
          />
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/permissions/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Loader2, AlertCircle, Lock, Crown } from 'lucide-react'
import Link from 'next/link'
import { useAuth } from '@/hooks/useAuth'
import { usePermissions } from '@/hooks/usePermissions'
import { useBranches } from '@/hooks/useBranches'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { PermissionsTable } from './components/PermissionsTable'
import { createClient } from '@/lib/supabase/client'

export default function PermissionsPage() {
  const router = useRouter()
  const { t } = useTranslation()
  const { user, loading: authLoading } = useAuth()
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()
  const { permissions, loading: permissionsLoading, error, savePermissions } = usePermissions()

  // Theme state (synced with localStorage)
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')

  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  // Check permissions - only super_admin can access
  if (user && user.role !== 'super_admin') {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <div className="text-center">
          <AlertCircle className="w-16 h-16 text-red-500 mx-auto mb-4" />
          <h1 className={`text-2xl font-bold mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {t('admin.permissions.access_denied')}
          </h1>
          <p className={isDark ? 'text-gray-400' : 'text-gray-600'}>
            {t('admin.permissions.access_denied_message')}
          </p>
        </div>
      </div>
    )
  }

  // Loading state
  if (authLoading || branchesLoading || !user || !selectedBranch) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header with navigation */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={handleSignOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sub-header with title */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
              isDark ? 'bg-red-500/20' : 'bg-red-100'
            }`}>
              <Lock className={`w-6 h-6 ${isDark ? 'text-red-400' : 'text-red-600'}`} />
            </div>
            <div>
              <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.permissions.title')}
              </h1>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                {t('admin.permissions.subtitle')}
              </p>
            </div>
          </div>
          {/* Bouton Roles - accessible depuis la page permissions */}
          <Link
            href="/admin/roles"
            className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-yellow-600 hover:bg-yellow-700 text-white transition-colors"
          >
            <Crown className="w-5 h-5" />
            Roles
          </Link>
        </div>
      </div>

      {/* Main content */}
      <div className="p-6 space-y-6">
        {/* Error */}
        {error && (
          <div className={`p-4 rounded-lg border flex items-start gap-2 ${
            isDark
              ? 'bg-red-500/10 border-red-500/50 text-red-400'
              : 'bg-red-50 border-red-200 text-red-600'
          }`}>
            <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
            <span>{error}</span>
          </div>
        )}

        {/* Loading */}
        {permissionsLoading && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 animate-spin text-blue-500" />
          </div>
        )}

        {/* Permissions Table */}
        {!permissionsLoading && (
          <PermissionsTable
            permissions={permissions}
            isDark={isDark}
            onSavePermissions={savePermissions}
          />
        )}

        {/* Legend */}
        <div className={`p-4 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
          <h3 className={`text-sm font-medium mb-3 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
            {t('admin.permissions.legend_title')}
          </h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div className="flex items-center gap-2">
              <span className={`px-2 py-1 rounded text-xs font-medium ${
                isDark ? 'bg-red-500/20 text-red-400' : 'bg-red-100 text-red-800'
              }`}>
                {t('admin.roles.super_admin')}
              </span>
              <span className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                {t('admin.permissions.legend_super_admin')}
              </span>
            </div>
            <div className="flex items-center gap-2">
              <span className={`px-2 py-1 rounded text-xs font-medium ${
                isDark ? 'bg-purple-500/20 text-purple-400' : 'bg-purple-100 text-purple-800'
              }`}>
                {t('admin.roles.branch_admin')}
              </span>
              <span className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                {t('admin.permissions.legend_branch_admin')}
              </span>
            </div>
            <div className="flex items-center gap-2">
              <span className={`px-2 py-1 rounded text-xs font-medium ${
                isDark ? 'bg-blue-500/20 text-blue-400' : 'bg-blue-100 text-blue-800'
              }`}>
                {t('admin.roles.agent')}
              </span>
              <span className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                {t('admin.permissions.legend_agent')}
              </span>
            </div>
            <div className="flex items-center gap-2">
              <Lock className={`w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
              <span className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                {t('admin.permissions.legend_locked')}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/roles/components/RolesTable.tsx">
'use client'

import { Shield, Users, UserCog, Crown, User, Lock, Pencil, Trash2 } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { Role } from '@/lib/supabase/types'

interface RolesTableProps {
  roles: Role[]
  isDark: boolean
  userLevel: number
  onEdit: (role: Role) => void
  onDelete: (role: Role) => void
}

// Icon props type
type IconProps = { className?: string; style?: React.CSSProperties }

// Icon mapping
const ICON_MAP: Record<string, React.ComponentType<IconProps>> = {
  Shield: Shield,
  UserCog: UserCog,
  Users: Users,
  Crown: Crown,
  User: User,
  Lock: Lock
}

function getIconComponent(iconName: string): React.ComponentType<IconProps> {
  return ICON_MAP[iconName] || User
}

export function RolesTable({ roles, isDark, userLevel, onEdit, onDelete }: RolesTableProps) {
  const { t } = useTranslation()

  // Sort roles by level
  const sortedRoles = [...roles].sort((a, b) => a.level - b.level)

  // Check if user can manage a role
  const canManage = (role: Role) => {
    if (role.is_system) return false
    return userLevel < role.level
  }

  if (sortedRoles.length === 0) {
    return (
      <div className={`text-center py-12 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
        {t('admin.roles.no_roles')}
      </div>
    )
  }

  return (
    <div className={`rounded-xl border overflow-hidden ${
      isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
    }`}>
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead>
            <tr className={isDark ? 'bg-gray-700/50' : 'bg-gray-50'}>
              <th className={`px-6 py-4 text-left text-sm font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.roles.table.role')}
              </th>
              <th className={`px-6 py-4 text-left text-sm font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.roles.table.slug')}
              </th>
              <th className={`px-6 py-4 text-center text-sm font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.roles.table.level')}
              </th>
              <th className={`px-6 py-4 text-left text-sm font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.roles.table.description')}
              </th>
              <th className={`px-6 py-4 text-center text-sm font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.roles.table.type')}
              </th>
              <th className={`px-6 py-4 text-right text-sm font-medium uppercase tracking-wider ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`}>
                {t('admin.roles.table.actions')}
              </th>
            </tr>
          </thead>
          <tbody className={`divide-y ${isDark ? 'divide-gray-700' : 'divide-gray-200'}`}>
            {sortedRoles.map(role => {
              const Icon = getIconComponent(role.icon)
              const manageable = canManage(role)

              return (
                <tr
                  key={role.id}
                  className={isDark ? 'hover:bg-gray-700/50' : 'hover:bg-gray-50'}
                >
                  <td className="px-6 py-4">
                    <div className="flex items-center gap-3">
                      <div
                        className="w-10 h-10 rounded-lg flex items-center justify-center"
                        style={{
                          backgroundColor: `${role.color}20`,
                        }}
                      >
                        <Icon className="w-5 h-5" style={{ color: role.color }} />
                      </div>
                      <div>
                        <div
                          className="font-medium"
                          style={{ color: role.color }}
                        >
                          {role.display_name}
                        </div>
                      </div>
                    </div>
                  </td>
                  <td className={`px-6 py-4 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                    <code className={`px-2 py-1 rounded text-sm ${
                      isDark ? 'bg-gray-700' : 'bg-gray-100'
                    }`}>
                      {role.name}
                    </code>
                  </td>
                  <td className="px-6 py-4 text-center">
                    <span className={`inline-flex items-center justify-center w-8 h-8 rounded-full text-sm font-bold ${
                      role.level === 1
                        ? 'bg-red-500/20 text-red-400'
                        : role.level <= 3
                        ? 'bg-orange-500/20 text-orange-400'
                        : role.level <= 5
                        ? 'bg-yellow-500/20 text-yellow-400'
                        : 'bg-blue-500/20 text-blue-400'
                    }`}>
                      {role.level}
                    </span>
                  </td>
                  <td className={`px-6 py-4 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                    {role.description || '-'}
                  </td>
                  <td className="px-6 py-4 text-center">
                    {role.is_system ? (
                      <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${
                        isDark ? 'bg-red-500/20 text-red-400' : 'bg-red-100 text-red-700'
                      }`}>
                        <Lock className="w-3 h-3" />
                        {t('admin.roles.system')}
                      </span>
                    ) : (
                      <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${
                        isDark ? 'bg-green-500/20 text-green-400' : 'bg-green-100 text-green-700'
                      }`}>
                        {t('admin.roles.custom')}
                      </span>
                    )}
                  </td>
                  <td className="px-6 py-4 text-right">
                    <div className="flex items-center justify-end gap-2">
                      <button
                        onClick={() => onEdit(role)}
                        disabled={!manageable}
                        className={`p-2 rounded-lg transition-colors ${
                          manageable
                            ? isDark
                              ? 'hover:bg-gray-700 text-gray-400 hover:text-blue-400'
                              : 'hover:bg-gray-100 text-gray-500 hover:text-blue-600'
                            : 'opacity-30 cursor-not-allowed'
                        }`}
                        title={manageable ? t('admin.common.edit') : t('admin.roles.cannot_edit')}
                      >
                        <Pencil className="w-4 h-4" />
                      </button>
                      <button
                        onClick={() => onDelete(role)}
                        disabled={!manageable}
                        className={`p-2 rounded-lg transition-colors ${
                          manageable
                            ? isDark
                              ? 'hover:bg-gray-700 text-gray-400 hover:text-red-400'
                              : 'hover:bg-gray-100 text-gray-500 hover:text-red-600'
                            : 'opacity-30 cursor-not-allowed'
                        }`}
                        title={manageable ? t('admin.common.delete') : t('admin.roles.cannot_delete')}
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                  </td>
                </tr>
              )
            })}
          </tbody>
        </table>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/settings/components/CredentialsSection.tsx">
'use client'

import { useState, useEffect } from 'react'
import {
  Loader2,
  AlertCircle,
  Eye,
  EyeOff,
  CheckCircle2,
  XCircle,
  RefreshCw,
  CreditCard,
  Save,
  Trash2
} from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import { useBranches } from '@/hooks/useBranches'

interface CredentialsSectionProps {
  isDark: boolean
}

interface PaymentCredentials {
  id?: string
  branch_id: string
  provider: string
  cid: string
  username: string
  password: string
  is_active: boolean
  last_connection_test?: string
  last_connection_status?: boolean
  last_connection_error?: string
}

export function CredentialsSection({ isDark }: CredentialsSectionProps) {
  const { t } = useTranslation()
  const { branches, selectedBranch } = useBranches()

  const [credentials, setCredentials] = useState<PaymentCredentials | null>(null)
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [testing, setTesting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [successMessage, setSuccessMessage] = useState<string | null>(null)
  const [showPassword, setShowPassword] = useState(false)
  const [connectionStatus, setConnectionStatus] = useState<'unknown' | 'connected' | 'error'>('unknown')

  // Form state
  const [formData, setFormData] = useState({
    cid: '',
    username: '',
    password: ''
  })

  // Fetch credentials for selected branch
  const fetchCredentials = async () => {
    if (!selectedBranch) return

    setLoading(true)
    setError(null)

    try {
      const response = await fetch(`/api/payment-credentials?branch_id=${selectedBranch.id}`)

      if (!response.ok) {
        throw new Error('Failed to fetch credentials')
      }

      const data = await response.json()

      if (data) {
        setCredentials(data)
        setFormData({
          cid: data.cid || '',
          username: data.username || '',
          password: '' // Don't show masked password in form
        })

        // Set connection status based on last test
        if (data.last_connection_status === true) {
          setConnectionStatus('connected')
        } else if (data.last_connection_status === false) {
          setConnectionStatus('error')
        } else {
          setConnectionStatus('unknown')
        }
      } else {
        setCredentials(null)
        setFormData({ cid: '', username: '', password: '' })
        setConnectionStatus('unknown')
      }
    } catch (err) {
      console.error('Error fetching credentials:', err)
      setError('Failed to load credentials')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchCredentials()
  }, [selectedBranch?.id])

  // Clear messages after 5 seconds
  useEffect(() => {
    if (successMessage) {
      const timer = setTimeout(() => setSuccessMessage(null), 5000)
      return () => clearTimeout(timer)
    }
  }, [successMessage])

  // Test connection
  const handleTestConnection = async () => {
    // Password is REQUIRED for testing - we can't use the masked password from DB
    if (!formData.cid || !formData.username || !formData.password) {
      setError('Please fill in all credentials including password to test connection')
      return
    }

    setTesting(true)
    setError(null)

    try {
      const response = await fetch('/api/payment-credentials/test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          cid: formData.cid,
          username: formData.username,
          password: formData.password, // Always use form password, never the masked one
          branch_id: selectedBranch?.id
        })
      })

      const result = await response.json()

      if (result.success) {
        setConnectionStatus('connected')
        setSuccessMessage(`Connected successfully! Company: ${result.company}, User: ${result.user}`)
      } else {
        setConnectionStatus('error')
        setError(result.message || 'Connection failed')
      }
    } catch (err) {
      console.error('Connection test error:', err)
      setConnectionStatus('error')
      setError('Connection test failed')
    } finally {
      setTesting(false)
    }
  }

  // Save credentials
  const handleSave = async () => {
    if (!selectedBranch) return
    if (!formData.cid || !formData.username) {
      setError('Company ID and Username are required')
      return
    }
    if (!credentials && !formData.password) {
      setError('Password is required for new credentials')
      return
    }

    setSaving(true)
    setError(null)

    try {
      const response = await fetch('/api/payment-credentials', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          branch_id: selectedBranch.id,
          cid: formData.cid,
          username: formData.username,
          password: formData.password || credentials?.password
        })
      })

      if (!response.ok) {
        throw new Error('Failed to save credentials')
      }

      const data = await response.json()
      setCredentials(data)
      setFormData(prev => ({ ...prev, password: '' }))
      setSuccessMessage('Credentials saved successfully')
    } catch (err) {
      console.error('Error saving credentials:', err)
      setError('Failed to save credentials')
    } finally {
      setSaving(false)
    }
  }

  // Delete credentials
  const handleDelete = async () => {
    if (!selectedBranch || !credentials) return

    if (!confirm('Are you sure you want to delete these credentials?')) {
      return
    }

    setSaving(true)
    setError(null)

    try {
      const response = await fetch(`/api/payment-credentials?branch_id=${selectedBranch.id}`, {
        method: 'DELETE'
      })

      if (!response.ok) {
        throw new Error('Failed to delete credentials')
      }

      setCredentials(null)
      setFormData({ cid: '', username: '', password: '' })
      setConnectionStatus('unknown')
      setSuccessMessage('Credentials deleted successfully')
    } catch (err) {
      console.error('Error deleting credentials:', err)
      setError('Failed to delete credentials')
    } finally {
      setSaving(false)
    }
  }

  // Status indicator component
  const StatusIndicator = () => {
    if (connectionStatus === 'connected') {
      return (
        <div className="flex items-center gap-2">
          <div className="w-3 h-3 rounded-full bg-green-500 animate-pulse" />
          <span className="text-green-500 text-sm font-medium">Connected</span>
        </div>
      )
    } else if (connectionStatus === 'error') {
      return (
        <div className="flex items-center gap-2">
          <div className="w-3 h-3 rounded-full bg-red-500" />
          <span className="text-red-500 text-sm font-medium">Connection Error</span>
        </div>
      )
    }
    return (
      <div className="flex items-center gap-2">
        <div className={`w-3 h-3 rounded-full ${isDark ? 'bg-gray-600' : 'bg-gray-400'}`} />
        <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>Not tested</span>
      </div>
    )
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className={`text-xl font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            Payment Provider Credentials
          </h2>
          <p className={`text-sm mt-1 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
            Configure iCount API credentials for {selectedBranch?.name || 'this branch'}
          </p>
        </div>
        <StatusIndicator />
      </div>

      {/* Error message */}
      {error && (
        <div className={`flex items-center gap-2 p-3 rounded-lg ${
          isDark ? 'bg-red-500/10 border border-red-500/20' : 'bg-red-50 border border-red-200'
        }`}>
          <AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0" />
          <p className="text-red-500 text-sm">{error}</p>
        </div>
      )}

      {/* Success message */}
      {successMessage && (
        <div className={`flex items-center gap-2 p-3 rounded-lg ${
          isDark ? 'bg-green-500/10 border border-green-500/20' : 'bg-green-50 border border-green-200'
        }`}>
          <CheckCircle2 className="w-5 h-5 text-green-500 flex-shrink-0" />
          <p className="text-green-500 text-sm">{successMessage}</p>
        </div>
      )}

      {/* Credentials Form */}
      <div className={`rounded-xl border ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        {/* Card Header */}
        <div className={`px-6 py-4 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <div className="flex items-center gap-3">
            <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
              isDark ? 'bg-blue-500/20' : 'bg-blue-100'
            }`}>
              <CreditCard className={`w-5 h-5 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
            </div>
            <div>
              <h3 className={`font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                iCount API
              </h3>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                Israeli payment and invoicing provider
              </p>
            </div>
          </div>
        </div>

        {/* Form Fields */}
        <div className="p-6 space-y-4">
          {/* Company ID */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              Company ID (cid)
            </label>
            <input
              type="text"
              value={formData.cid}
              onChange={(e) => setFormData(prev => ({ ...prev, cid: e.target.value }))}
              placeholder="e.g., activelaser"
              className={`w-full px-4 py-2.5 rounded-lg border transition-colors ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500 focus:border-blue-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400 focus:border-blue-500'
              } focus:outline-none focus:ring-2 focus:ring-blue-500/20`}
            />
          </div>

          {/* Username */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              Username (email)
            </label>
            <input
              type="email"
              value={formData.username}
              onChange={(e) => setFormData(prev => ({ ...prev, username: e.target.value }))}
              placeholder="e.g., contact@activegames.co.il"
              className={`w-full px-4 py-2.5 rounded-lg border transition-colors ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500 focus:border-blue-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400 focus:border-blue-500'
              } focus:outline-none focus:ring-2 focus:ring-blue-500/20`}
            />
          </div>

          {/* Password */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              Password {credentials && <span className="text-gray-500 font-normal">(leave empty to keep current)</span>}
            </label>
            <div className="relative">
              <input
                type={showPassword ? 'text' : 'password'}
                value={formData.password}
                onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
                placeholder={credentials ? '••••••••' : 'Enter password'}
                className={`w-full px-4 py-2.5 pr-12 rounded-lg border transition-colors ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500 focus:border-blue-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400 focus:border-blue-500'
                } focus:outline-none focus:ring-2 focus:ring-blue-500/20`}
              />
              <button
                type="button"
                onClick={() => setShowPassword(!showPassword)}
                className={`absolute right-3 top-1/2 -translate-y-1/2 p-1 rounded ${
                  isDark ? 'hover:bg-gray-600 text-gray-400' : 'hover:bg-gray-100 text-gray-500'
                }`}
              >
                {showPassword ? <EyeOff className="w-5 h-5" /> : <Eye className="w-5 h-5" />}
              </button>
            </div>
          </div>

          {/* Last connection info */}
          {credentials?.last_connection_test && (
            <div className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
              Last tested: {new Date(credentials.last_connection_test).toLocaleString()}
              {credentials.last_connection_error && (
                <span className="text-red-500 ml-2">- {credentials.last_connection_error}</span>
              )}
            </div>
          )}
        </div>

        {/* Actions */}
        <div className={`px-6 py-4 border-t ${isDark ? 'border-gray-700 bg-gray-800/50' : 'border-gray-200 bg-gray-50'} flex items-center justify-between`}>
          <div className="flex items-center gap-3">
            {/* Test Connection Button */}
            <button
              onClick={handleTestConnection}
              disabled={testing || !formData.cid || !formData.username}
              className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-white disabled:bg-gray-800 disabled:text-gray-600'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-800 disabled:bg-gray-100 disabled:text-gray-400'
              } disabled:cursor-not-allowed`}
            >
              {testing ? (
                <Loader2 className="w-4 h-4 animate-spin" />
              ) : (
                <RefreshCw className="w-4 h-4" />
              )}
              Test Connection
            </button>
          </div>

          <div className="flex items-center gap-3">
            {/* Delete Button */}
            {credentials && (
              <button
                onClick={handleDelete}
                disabled={saving}
                className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors ${
                  isDark
                    ? 'bg-red-500/20 hover:bg-red-500/30 text-red-400'
                    : 'bg-red-100 hover:bg-red-200 text-red-600'
                } disabled:opacity-50 disabled:cursor-not-allowed`}
              >
                <Trash2 className="w-4 h-4" />
                Delete
              </button>
            )}

            {/* Save Button */}
            <button
              onClick={handleSave}
              disabled={saving || !formData.cid || !formData.username}
              className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors ${
                isDark
                  ? 'bg-blue-600 hover:bg-blue-700 text-white disabled:bg-gray-700 disabled:text-gray-500'
                  : 'bg-blue-600 hover:bg-blue-700 text-white disabled:bg-gray-300 disabled:text-gray-500'
              } disabled:cursor-not-allowed`}
            >
              {saving ? (
                <Loader2 className="w-4 h-4 animate-spin" />
              ) : (
                <Save className="w-4 h-4" />
              )}
              Save Credentials
            </button>
          </div>
        </div>
      </div>

      {/* Info Box */}
      <div className={`rounded-lg p-4 ${isDark ? 'bg-blue-500/10 border border-blue-500/20' : 'bg-blue-50 border border-blue-200'}`}>
        <h4 className={`font-medium mb-2 ${isDark ? 'text-blue-400' : 'text-blue-700'}`}>
          About iCount Integration
        </h4>
        <ul className={`text-sm space-y-1 ${isDark ? 'text-blue-300/80' : 'text-blue-600'}`}>
          <li>• Credentials are stored securely and encrypted</li>
          <li>• Each branch can have different iCount accounts</li>
          <li>• Used for online payments, invoicing, and client sync</li>
          <li>• Test connection to verify your credentials are valid</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/settings/components/MaintenanceSection.tsx">
'use client'

import { useState } from 'react'
import { Loader2, CheckCircle, AlertCircle, Calculator } from 'lucide-react'

interface MaintenanceSectionProps {
  isDark: boolean
}

export function MaintenanceSection({ isDark }: MaintenanceSectionProps) {
  const [backfillLoading, setBackfillLoading] = useState(false)
  const [backfillResult, setBackfillResult] = useState<{
    success: boolean
    message: string
    updated?: number
    errors?: number
  } | null>(null)

  const runBackfillTotals = async () => {
    setBackfillLoading(true)
    setBackfillResult(null)

    try {
      const response = await fetch('/api/admin/backfill-totals', {
        method: 'POST'
      })
      const data = await response.json()
      setBackfillResult(data)
    } catch (error) {
      setBackfillResult({
        success: false,
        message: `Erreur: ${error}`
      })
    } finally {
      setBackfillLoading(false)
    }
  }

  return (
    <div className="space-y-6">
      <div>
        <h2 className={`text-xl font-semibold mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
          Maintenance
        </h2>
        <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
          Outils de maintenance et migration des données
        </p>
      </div>

      {/* Backfill Total Amount */}
      <div className={`rounded-lg border p-6 ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        <div className="flex items-start gap-4">
          <div className={`w-12 h-12 rounded-lg flex items-center justify-center ${
            isDark ? 'bg-blue-500/20' : 'bg-blue-100'
          }`}>
            <Calculator className={`w-6 h-6 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
          </div>
          <div className="flex-1">
            <h3 className={`font-semibold mb-1 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              Recalculer les montants des commandes
            </h3>
            <p className={`text-sm mb-4 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
              Calcule et stocke le total_amount pour les commandes qui n&apos;en ont pas.
              Nécessaire pour que Clara puisse afficher les statistiques de chiffre d&apos;affaires.
            </p>

            <button
              onClick={runBackfillTotals}
              disabled={backfillLoading}
              className={`px-4 py-2 rounded-lg font-medium transition-colors flex items-center gap-2 ${
                backfillLoading
                  ? 'bg-gray-500 cursor-not-allowed'
                  : isDark
                    ? 'bg-blue-600 hover:bg-blue-700 text-white'
                    : 'bg-blue-500 hover:bg-blue-600 text-white'
              }`}
            >
              {backfillLoading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Calcul en cours...
                </>
              ) : (
                <>
                  <Calculator className="w-4 h-4" />
                  Lancer le calcul
                </>
              )}
            </button>

            {backfillResult && (
              <div className={`mt-4 p-4 rounded-lg flex items-start gap-3 ${
                backfillResult.success
                  ? isDark ? 'bg-green-500/20' : 'bg-green-100'
                  : isDark ? 'bg-red-500/20' : 'bg-red-100'
              }`}>
                {backfillResult.success ? (
                  <CheckCircle className={`w-5 h-5 flex-shrink-0 ${isDark ? 'text-green-400' : 'text-green-600'}`} />
                ) : (
                  <AlertCircle className={`w-5 h-5 flex-shrink-0 ${isDark ? 'text-red-400' : 'text-red-600'}`} />
                )}
                <div>
                  <p className={`font-medium ${
                    backfillResult.success
                      ? isDark ? 'text-green-400' : 'text-green-700'
                      : isDark ? 'text-red-400' : 'text-red-700'
                  }`}>
                    {backfillResult.message}
                  </p>
                  {backfillResult.updated !== undefined && (
                    <p className={`text-sm mt-1 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                      {backfillResult.updated} commande(s) mise(s) à jour
                      {backfillResult.errors ? `, ${backfillResult.errors} erreur(s)` : ''}
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/settings/components/TemplatesSection.tsx">
'use client'

import { useState } from 'react'
import { Mail, ScrollText } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import { EmailTemplatesSection } from './EmailTemplatesSection'
import { TermsConditionsSection } from './TermsConditionsSection'

interface TemplatesSectionProps {
  isDark: boolean
}

type SubTab = 'emails' | 'terms'

export function TemplatesSection({ isDark }: TemplatesSectionProps) {
  const { t } = useTranslation()
  const [activeTab, setActiveTab] = useState<SubTab>('emails')

  const tabs = [
    {
      id: 'emails' as SubTab,
      icon: Mail,
      label: t('admin.settings.templates_tabs.emails'),
    },
    {
      id: 'terms' as SubTab,
      icon: ScrollText,
      label: t('admin.settings.templates_tabs.terms'),
    },
  ]

  return (
    <div className="space-y-6">
      {/* Sub-tabs */}
      <div className={`flex gap-1 p-1 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-gray-100'}`}>
        {tabs.map((tab) => {
          const Icon = tab.icon
          const isActive = activeTab === tab.id
          return (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex items-center gap-2 px-4 py-2 rounded-md font-medium transition-colors ${
                isActive
                  ? isDark
                    ? 'bg-gray-700 text-white'
                    : 'bg-white text-gray-900 shadow-sm'
                  : isDark
                    ? 'text-gray-400 hover:text-white hover:bg-gray-700/50'
                    : 'text-gray-600 hover:text-gray-900 hover:bg-gray-50'
              }`}
            >
              <Icon className="w-4 h-4" />
              {tab.label}
            </button>
          )
        })}
      </div>

      {/* Content */}
      {activeTab === 'emails' && <EmailTemplatesSection isDark={isDark} />}
      {activeTab === 'terms' && <TermsConditionsSection isDark={isDark} />}
    </div>
  )
}
</file>

<file path="src/app/api/admin/backfill-totals/route.ts">
/**
 * API de migration one-shot pour remplir les total_amount des commandes existantes
 * À exécuter une seule fois via: POST /api/admin/backfill-totals
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { calculateBookingPrice } from '@/lib/price-calculator'
import type { ICountProduct, ICountEventFormula, ICountRoom } from '@/hooks/usePricingData'

export async function POST(request: NextRequest) {
  try {
    // Vérifier les permissions admin
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) return errorResponse

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any

    // Récupérer les commandes sans total_amount
    const { data: ordersData, error: ordersError } = await supabase
      .from('orders')
      .select(`
        id,
        branch_id,
        order_type,
        participants_count,
        game_area,
        number_of_games,
        booking_id,
        total_amount
      `)
      .is('total_amount', null)
      .order('created_at', { ascending: false })
      .limit(500)

    const orders = ordersData as Array<{
      id: string
      branch_id: string
      order_type: string
      participants_count: number | null
      game_area: string | null
      number_of_games: number | null
      booking_id: string | null
      total_amount: number | null
    }> | null

    if (ordersError) {
      return NextResponse.json({ success: false, error: ordersError.message }, { status: 500 })
    }

    if (!orders || orders.length === 0) {
      return NextResponse.json({ success: true, message: 'Aucune commande à mettre à jour', updated: 0 })
    }

    // Récupérer les données de pricing par branche
    const branchIds = [...new Set(orders.map(o => o.branch_id))]
    const pricingDataByBranch: Record<string, {
      products: ICountProduct[]
      eventFormulas: ICountEventFormula[]
      rooms: ICountRoom[]
    }> = {}

    for (const branchId of branchIds) {
      const [productsResult, formulasResult, roomsResult] = await Promise.all([
        supabase.from('icount_products').select('*').eq('branch_id', branchId).eq('is_active', true),
        supabase.from('icount_event_formulas').select('*').eq('branch_id', branchId).eq('is_active', true),
        supabase.from('icount_rooms').select('*').eq('branch_id', branchId).eq('is_active', true)
      ])

      pricingDataByBranch[branchId] = {
        products: (productsResult.data || []) as ICountProduct[],
        eventFormulas: (formulasResult.data || []) as ICountEventFormula[],
        rooms: (roomsResult.data || []) as ICountRoom[]
      }
    }

    // Récupérer les bookings associés pour les sessions de jeu
    const bookingIds = orders.filter(o => o.booking_id).map(o => o.booking_id) as string[]
    const { data: bookingsData } = await supabase
      .from('bookings')
      .select(`
        id,
        type,
        discount_type,
        discount_value,
        event_room_id,
        game_sessions (
          game_area,
          start_datetime,
          end_datetime
        )
      `)
      .in('id', bookingIds)

    type BookingWithSessions = {
      id: string
      type: string
      discount_type: string | null
      discount_value: number | null
      event_room_id: string | null
      game_sessions: Array<{
        game_area: string
        start_datetime: string
        end_datetime: string
      }>
    }

    const bookings = bookingsData as BookingWithSessions[] | null
    const bookingsMap = new Map(bookings?.map(b => [b.id, b]) || [])

    // Calculer et mettre à jour chaque commande
    let updated = 0
    let errors = 0
    const results: Array<{ orderId: string; totalAmount: number | null; error?: string }> = []

    for (const order of orders) {
      try {
        const pricingData = pricingDataByBranch[order.branch_id]
        if (!pricingData || pricingData.products.length === 0) {
          results.push({ orderId: order.id, totalAmount: null, error: 'No pricing data' })
          continue
        }

        const booking = order.booking_id ? bookingsMap.get(order.booking_id) : null
        const gameSessions = booking?.game_sessions || []

        // Calculer les paramètres de jeu depuis les sessions
        let laserGames = 0
        let activeDurations: string[] = []

        for (const session of gameSessions) {
          const startTime = new Date(session.start_datetime)
          const endTime = new Date(session.end_datetime)
          const durationMinutes = Math.round((endTime.getTime() - startTime.getTime()) / 60000)

          if (session.game_area === 'LASER') {
            laserGames++
          } else if (session.game_area === 'ACTIVE') {
            activeDurations.push(String(durationMinutes))
          }
        }

        // Déterminer le quick plan pour les événements
        let eventQuickPlan = 'AA'
        const gameArea = order.game_area as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null
        if (order.order_type === 'EVENT') {
          if (gameArea === 'LASER') eventQuickPlan = 'LL'
          else if (gameArea === 'ACTIVE') eventQuickPlan = 'AA'
          else eventQuickPlan = 'AL'
        }

        const priceCalculation = calculateBookingPrice({
          bookingType: order.order_type as 'GAME' | 'EVENT',
          participants: order.participants_count || 0,
          gameArea: gameArea || 'ACTIVE',
          numberOfGames: laserGames || order.number_of_games || 1,
          gameDurations: activeDurations.length > 0 ? activeDurations : ['60'],
          eventQuickPlan,
          eventRoomId: booking?.event_room_id || null,
          discountType: booking?.discount_type as 'percent' | 'fixed' | null | undefined,
          discountValue: booking?.discount_value ?? undefined,
          products: pricingData.products,
          eventFormulas: pricingData.eventFormulas,
          rooms: pricingData.rooms,
        })

        if (priceCalculation.valid && priceCalculation.total > 0) {
          const { error: updateError } = await supabase
            .from('orders')
            .update({ total_amount: priceCalculation.total })
            .eq('id', order.id)

          if (updateError) {
            results.push({ orderId: order.id, totalAmount: null, error: updateError.message })
            errors++
          } else {
            results.push({ orderId: order.id, totalAmount: priceCalculation.total })
            updated++
          }
        } else {
          results.push({ orderId: order.id, totalAmount: null, error: 'Invalid price calculation' })
        }
      } catch (err) {
        results.push({ orderId: order.id, totalAmount: null, error: String(err) })
        errors++
      }
    }

    return NextResponse.json({
      success: true,
      message: `Mise à jour terminée: ${updated} commandes mises à jour, ${errors} erreurs`,
      total: orders.length,
      updated,
      errors,
      results: results.slice(0, 20) // Limiter les détails retournés
    })

  } catch (error) {
    console.error('[Backfill] Error:', error)
    return NextResponse.json({ success: false, error: 'Erreur interne' }, { status: 500 })
  }
}
</file>

<file path="src/app/api/admin/users/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { validateEmail, validateIsraeliPhone, formatIsraeliPhone } from '@/lib/validation'
import { logUserAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import type { UserRole, Profile, ProfileUpdate, Role } from '@/lib/supabase/types'

/**
 * Helper: Récupère le niveau hiérarchique d'un utilisateur
 * Retourne le level du rôle (1 = plus haut, 10 = plus bas)
 */
async function getUserLevel(serviceClient: ReturnType<typeof createServiceRoleClient>, userId: string): Promise<{ level: number; role: Role | null }> {
  // Récupérer le profil avec role_id
  const { data: profile } = await serviceClient
    .from('profiles')
    .select('role, role_id')
    .eq('id', userId)
    .single()

  if (!profile) {
    return { level: 10, role: null }
  }

  // Type explicite pour accéder aux propriétés
  const profileData = profile as { role?: string | null; role_id?: string | null }

  // Récupérer le rôle par role_id ou par name
  let roleData: Role | null = null

  if (profileData.role_id) {
    const { data } = await serviceClient
      .from('roles')
      .select('*')
      .eq('id', profileData.role_id)
      .single<Role>()
    roleData = data
  }

  if (!roleData && profileData.role) {
    const { data } = await serviceClient
      .from('roles')
      .select('*')
      .eq('name', profileData.role)
      .single<Role>()
    roleData = data
  }

  return {
    level: roleData?.level ?? 10,
    role: roleData
  }
}

/**
 * Helper: Vérifie si un utilisateur peut gérer un rôle cible
 * Règle: userLevel doit être < targetLevel (niveau plus bas = plus de pouvoir)
 */
function canManageLevel(userLevel: number, targetLevel: number): boolean {
  return userLevel < targetLevel
}

/**
 * PUT /api/admin/users/[id]
 * Modifie un utilisateur existant
 *
 * Body: {
 *   first_name?: string
 *   last_name?: string
 *   phone?: string
 *   email?: string
 *   password?: string
 *   role_id?: string (UUID du rôle)
 *   branch_ids?: string[]
 * }
 *
 * Permissions (basées sur hiérarchie dynamique):
 * - Un utilisateur peut modifier des utilisateurs avec un rôle de level > son level
 * - Ne peut pas modifier son propre rôle ou branches
 * - Restriction par branches pour level >= 5
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: targetUserId } = await params
    const supabase = await createClient()
    const supabaseAdmin = createServiceRoleClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Non authentifié' },
        { status: 401 }
      )
    }

    // Récupérer le profil de l'utilisateur connecté
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single<Profile>()

    if (profileError || !profile) {
      return NextResponse.json(
        { success: false, error: 'Profil introuvable' },
        { status: 404 }
      )
    }

    // Récupérer le niveau hiérarchique de l'utilisateur connecté
    const { level: userLevel } = await getUserLevel(supabaseAdmin, user.id)
    const userRole = profile.role as UserRole

    // Vérifier que l'utilisateur a le droit de modifier des utilisateurs (level < 8)
    if (userLevel >= 8) {
      return NextResponse.json(
        { success: false, error: 'Permission refusée' },
        { status: 403 }
      )
    }

    // Parser le body pour vérifier les modifications demandées
    const body = await request.json()
    const { first_name, last_name, phone, email, password, role_id, role, branch_ids } = body

    // Si l'utilisateur modifie son propre compte
    const isSelfEdit = targetUserId === user.id
    if (isSelfEdit) {
      // Autoriser uniquement la modification des infos de contact (prénom, nom, téléphone)
      // Interdire la modification du rôle ou des branches
      if (role_id !== undefined || role !== undefined || branch_ids !== undefined) {
        return NextResponse.json(
          { success: false, error: 'Vous ne pouvez pas modifier votre propre rôle ou vos branches' },
          { status: 403 }
        )
      }
    }

    // Récupérer l'utilisateur cible
    const { data: targetProfile, error: targetError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', targetUserId)
      .single<Profile>()

    if (targetError || !targetProfile) {
      return NextResponse.json(
        { success: false, error: 'Utilisateur introuvable' },
        { status: 404 }
      )
    }

    // Récupérer le niveau hiérarchique de l'utilisateur cible
    const { level: targetLevel } = await getUserLevel(supabaseAdmin, targetUserId)

    // Vérifier la hiérarchie: l'utilisateur ne peut modifier que des utilisateurs de niveau > son niveau
    if (!isSelfEdit && !canManageLevel(userLevel, targetLevel)) {
      return NextResponse.json(
        { success: false, error: 'Vous ne pouvez modifier que des utilisateurs avec un niveau hiérarchique inférieur au vôtre' },
        { status: 403 }
      )
    }

    // Si level >= 5 et pas soi-même, vérifier qu'il gère cet utilisateur via les branches
    if (userLevel >= 5 && !isSelfEdit) {
      const { data: adminBranches } = await supabase
        .from('user_branches')
        .select('branch_id')
        .eq('user_id', user.id)
        .returns<Array<{ branch_id: string }>>()

      const { data: targetBranches } = await supabase
        .from('user_branches')
        .select('branch_id')
        .eq('user_id', targetUserId)
        .returns<Array<{ branch_id: string }>>()

      const adminBranchIds = (adminBranches || []).map((b: { branch_id: string }) => b.branch_id)
      const targetBranchIds = (targetBranches || []).map((b: { branch_id: string }) => b.branch_id)

      const hasCommonBranch = targetBranchIds.some(id => adminBranchIds.includes(id))

      if (!hasCommonBranch) {
        return NextResponse.json(
          { success: false, error: 'Vous ne pouvez modifier que les utilisateurs de vos branches' },
          { status: 403 }
        )
      }
    }

    // Préparer les updates
    const updates: ProfileUpdate = {}

    if (first_name !== undefined) {
      if (!first_name.trim()) {
        return NextResponse.json(
          { success: false, error: 'Le prénom ne peut pas être vide' },
          { status: 400 }
        )
      }
      updates.first_name = first_name.trim()
    }

    if (last_name !== undefined) {
      updates.last_name = last_name.trim()
    }

    if (phone !== undefined) {
      if (!validateIsraeliPhone(phone)) {
        return NextResponse.json(
          { success: false, error: 'Format téléphone invalide (05XXXXXXXX)' },
          { status: 400 }
        )
      }
      updates.phone = formatIsraeliPhone(phone)
    }

    // Gérer le changement de rôle (par role_id ou role pour rétrocompatibilité)
    if (role_id !== undefined || role !== undefined) {
      // Récupérer le nouveau rôle cible
      let newTargetRole: Role | null = null

      if (role_id) {
        const { data } = await supabaseAdmin
          .from('roles')
          .select('*')
          .eq('id', role_id)
          .single<Role>()
        newTargetRole = data
      } else if (role) {
        // Rétrocompatibilité: chercher par nom
        const { data } = await supabaseAdmin
          .from('roles')
          .select('*')
          .eq('name', role)
          .single<Role>()
        newTargetRole = data
      }

      if (!newTargetRole) {
        return NextResponse.json(
          { success: false, error: 'Rôle invalide ou introuvable' },
          { status: 400 }
        )
      }

      // Vérifier la hiérarchie: ne peut assigner que des rôles de niveau > son niveau
      if (!canManageLevel(userLevel, newTargetRole.level)) {
        return NextResponse.json(
          { success: false, error: `Vous ne pouvez assigner que des rôles avec un niveau hiérarchique inférieur au vôtre (${userLevel})` },
          { status: 403 }
        )
      }

      // Interdire d'assigner le level 1 (super_admin)
      if (newTargetRole.level === 1) {
        return NextResponse.json(
          { success: false, error: 'Impossible d\'assigner le rôle super_admin' },
          { status: 403 }
        )
      }

      updates.role = newTargetRole.name as UserRole
      updates.role_id = newTargetRole.id
    }

    const authUpdates: { email?: string; password?: string } = {}

    if (email !== undefined && email.trim()) {
      // Vérifier que l'email est valide
      if (!validateEmail(email.trim())) {
        return NextResponse.json(
          { success: false, error: 'Format email invalide' },
          { status: 400 }
        )
      }

      // Vérifier que l'email n'est pas déjà utilisé par un autre utilisateur
      const { data: existingUser } = await supabaseAdmin.auth.admin.getUserById(targetUserId)
      if (existingUser?.user?.email !== email.trim()) {
        // L'email change, vérifier qu'il n'est pas déjà utilisé
        // Note: Supabase vérifie automatiquement l'unicité de l'email
        authUpdates.email = email.trim()
      }
    }

    if (password !== undefined && password.trim()) {
      // Vérifier que le mot de passe a au moins 6 caractères
      if (password.length < 6) {
        return NextResponse.json(
          { success: false, error: 'Le mot de passe doit contenir au moins 6 caractères' },
          { status: 400 }
        )
      }
      authUpdates.password = password
    }

    // Mettre à jour l'utilisateur Auth si nécessaire
    if (Object.keys(authUpdates).length > 0) {
      const { data: updatedAuthUser, error: authUpdateError } = await supabaseAdmin.auth.admin.updateUserById(
        targetUserId,
        authUpdates
      )

      if (authUpdateError) {
        console.error('Error updating auth user:', authUpdateError)
        return NextResponse.json(
          { success: false, error: authUpdateError.message || 'Erreur lors de la mise à jour de l\'identifiant ou du mot de passe' },
          { status: 500 }
        )
      }
    }

    // Mettre à jour le profil
    if (Object.keys(updates).length > 0) {
      const { error: updateError } = await supabase
        .from('profiles')
        // @ts-expect-error - Supabase typage strict ne permet pas les updates partiels dynamiques
        .update(updates)
        .eq('id', targetUserId)

      if (updateError) {
        console.error('Error updating profile:', updateError)
        return NextResponse.json(
          { success: false, error: 'Erreur lors de la mise à jour' },
          { status: 500 }
        )
      }
    }

    // Mettre à jour les branches si fourni
    if (branch_ids !== undefined && Array.isArray(branch_ids)) {
      if (branch_ids.length === 0) {
        return NextResponse.json(
          { success: false, error: 'Au moins une branche doit être assignée' },
          { status: 400 }
        )
      }

      // Si level >= 5, vérifier qu'il n'assigne que ses branches
      if (userLevel >= 5) {
        const { data: adminBranches } = await supabase
          .from('user_branches')
          .select('branch_id')
          .eq('user_id', user.id)

        const adminBranchIds = (adminBranches || []).map((b: { branch_id: string }) => b.branch_id)
        const invalidBranches = branch_ids.filter(id => !adminBranchIds.includes(id))

        if (invalidBranches.length > 0) {
          return NextResponse.json(
            { success: false, error: 'Vous ne pouvez assigner que vos propres branches' },
            { status: 403 }
          )
        }
      }

      // Supprimer les anciennes associations
      await supabase
        .from('user_branches')
        .delete()
        .eq('user_id', targetUserId)

      // Créer les nouvelles associations
      const branchAssignments = branch_ids.map(branchId => ({
        user_id: targetUserId,
        branch_id: branchId,
      }))

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error: branchAssignError } = await (supabase as any)
        .from('user_branches')
        .insert(branchAssignments)

      if (branchAssignError) {
        return NextResponse.json(
          { success: false, error: 'Erreur lors de l\'assignation des branches' },
          { status: 500 }
        )
      }
    }

    // Récupérer l'utilisateur mis à jour
    const { data: updatedProfile } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', targetUserId)
      .single<Profile>()

    const { data: branches } = await supabase
      .from('user_branches')
      .select('branch_id, branches(*)')
      .eq('user_id', targetUserId)

    const userBranches = (branches || []).map((ub: any) => ub.branches).filter(Boolean)

    // Logger la modification de l'utilisateur
    const ipAddress = getClientIpFromHeaders(request.headers)
    const changedFields = [
      ...Object.keys(updates),
      ...Object.keys(authUpdates),
      ...(branch_ids !== undefined ? ['branches'] : [])
    ]

    await logUserAction({
      userId: user.id,
      userRole: userRole,
      userName: `${profile.first_name || ''} ${profile.last_name || ''}`.trim(),
      action: 'updated',
      targetUserId: targetUserId,
      targetUserName: `${updatedProfile?.first_name || targetProfile?.first_name || ''} ${updatedProfile?.last_name || targetProfile?.last_name || ''}`.trim(),
      details: {
        targetUserRole: updatedProfile?.role || targetProfile?.role,
        changedFields,
        emailChanged: authUpdates.email !== undefined,
        passwordChanged: authUpdates.password !== undefined,
        roleChanged: updates.role !== undefined,
        branchesChanged: branch_ids !== undefined
      },
      ipAddress
    })

    return NextResponse.json(
      {
        success: true,
        user: {
          ...(updatedProfile || {}),
          branches: userBranches,
        },
      },
      { status: 200 }
    )
  } catch (error) {
    void error
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/admin/users/[id]
 * Supprime un utilisateur
 *
 * Permissions (basées sur hiérarchie dynamique):
 * - Un utilisateur peut supprimer des utilisateurs avec un rôle de level > son level
 * - Ne peut pas se supprimer soi-même
 * - Restriction par branches pour level >= 5
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: targetUserId } = await params
    const supabase = await createClient()
    const supabaseAdmin = createServiceRoleClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Non authentifié' },
        { status: 401 }
      )
    }

    // Récupérer le profil de l'utilisateur connecté
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single<Profile>()

    if (profileError || !profile) {
      return NextResponse.json(
        { success: false, error: 'Profil introuvable' },
        { status: 404 }
      )
    }

    // Récupérer le niveau hiérarchique de l'utilisateur connecté
    const { level: userLevel } = await getUserLevel(supabaseAdmin, user.id)
    const userRole = profile.role as UserRole

    // Vérifier que l'utilisateur a le droit de supprimer des utilisateurs (level < 8)
    if (userLevel >= 8) {
      return NextResponse.json(
        { success: false, error: 'Permission refusée' },
        { status: 403 }
      )
    }

    // Empêcher la suppression de soi-même
    if (targetUserId === user.id) {
      return NextResponse.json(
        { success: false, error: 'Vous ne pouvez pas supprimer votre propre compte' },
        { status: 403 }
      )
    }

    // Vérifier que l'utilisateur existe
    const { data: targetProfile, error: targetError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', targetUserId)
      .single<Profile>()

    if (targetError || !targetProfile) {
      return NextResponse.json(
        { success: false, error: 'Utilisateur introuvable' },
        { status: 404 }
      )
    }

    // Récupérer le niveau hiérarchique de l'utilisateur cible
    const { level: targetLevel } = await getUserLevel(supabaseAdmin, targetUserId)

    // Vérifier la hiérarchie: l'utilisateur ne peut supprimer que des utilisateurs de niveau > son niveau
    if (!canManageLevel(userLevel, targetLevel)) {
      return NextResponse.json(
        { success: false, error: 'Vous ne pouvez supprimer que des utilisateurs avec un niveau hiérarchique inférieur au vôtre' },
        { status: 403 }
      )
    }

    // Si level >= 5, vérifier qu'il gère cet utilisateur via les branches
    if (userLevel >= 5) {
      const { data: adminBranches } = await supabase
        .from('user_branches')
        .select('branch_id')
        .eq('user_id', user.id)

      const { data: targetBranches } = await supabase
        .from('user_branches')
        .select('branch_id')
        .eq('user_id', targetUserId)

      const adminBranchIds = (adminBranches || []).map((b: { branch_id: string }) => b.branch_id)
      const targetBranchIds = (targetBranches || []).map((b: { branch_id: string }) => b.branch_id)

      const hasCommonBranch = targetBranchIds.some(id => adminBranchIds.includes(id))

      if (!hasCommonBranch) {
        return NextResponse.json(
          { success: false, error: 'Vous ne pouvez supprimer que les utilisateurs de vos branches' },
          { status: 403 }
        )
      }
    }

    // Supprimer les associations user_branches
    await supabase
      .from('user_branches')
      .delete()
      .eq('user_id', targetUserId)

    // Supprimer le profil
    await supabase
      .from('profiles')
      .delete()
      .eq('id', targetUserId)

    // Supprimer le compte Auth
    const { error: deleteAuthError } = await supabaseAdmin.auth.admin.deleteUser(targetUserId)

    if (deleteAuthError) {
      console.error('Error deleting user from Auth:', deleteAuthError)
      // Ne pas retourner d'erreur car le profil est déjà supprimé
    }

    // Logger la suppression de l'utilisateur
    const ipAddress = getClientIpFromHeaders(request.headers)
    await logUserAction({
      userId: user.id,
      userRole: userRole,
      userName: `${profile.first_name || ''} ${profile.last_name || ''}`.trim(),
      action: 'deleted',
      targetUserId: targetUserId,
      targetUserName: `${targetProfile.first_name || ''} ${targetProfile.last_name || ''}`.trim(),
      details: {
        targetUserRole: targetProfile.role,
        deletedUserEmail: 'redacted' // On ne loggue pas l'email supprimé pour RGPD
      },
      ipAddress
    })

    return NextResponse.json(
      {
        success: true,
        message: 'Utilisateur supprimé avec succès',
      },
      { status: 200 }
    )
  } catch (error) {
    console.error('Error in DELETE /api/admin/users/[id]:', error)
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/admin/users/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { validateEmail, validateIsraeliPhone, formatIsraeliPhone } from '@/lib/validation'
import { logUserAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import type { UserWithBranches, UserRole, Role } from '@/lib/supabase/types'

/**
 * Helper: Récupère le niveau hiérarchique d'un utilisateur
 * Retourne le level du rôle (1 = plus haut, 10 = plus bas)
 */
async function getUserLevel(serviceClient: ReturnType<typeof createServiceRoleClient>, userId: string): Promise<{ level: number; role: Role | null }> {
  // Récupérer le profil avec role_id
  const { data: profile } = await serviceClient
    .from('profiles')
    .select('role, role_id')
    .eq('id', userId)
    .single()

  if (!profile) {
    return { level: 10, role: null }
  }

  // Type explicite pour accéder aux propriétés
  const profileData = profile as { role?: string | null; role_id?: string | null }

  // Récupérer le rôle par role_id ou par name
  let roleData: Role | null = null

  if (profileData.role_id) {
    const { data } = await serviceClient
      .from('roles')
      .select('*')
      .eq('id', profileData.role_id)
      .single<Role>()
    roleData = data
  }

  if (!roleData && profileData.role) {
    const { data } = await serviceClient
      .from('roles')
      .select('*')
      .eq('name', profileData.role)
      .single<Role>()
    roleData = data
  }

  return {
    level: roleData?.level ?? 10,
    role: roleData
  }
}

/**
 * Helper: Vérifie si un utilisateur peut gérer un rôle cible
 * Règle: userLevel doit être < targetLevel (niveau plus bas = plus de pouvoir)
 */
function canManageLevel(userLevel: number, targetLevel: number): boolean {
  return userLevel < targetLevel
}

/**
 * GET /api/admin/users
 * Liste tous les utilisateurs avec leurs branches
 *
 * Permissions (basées sur hiérarchie dynamique):
 * - Utilisateurs avec level < 5: Voient TOUS les utilisateurs
 * - Utilisateurs avec level >= 5: Voient uniquement les utilisateurs de leurs branches
 * - Le filtrage dépend aussi de la permission 'users.can_view'
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Non authentifié' },
        { status: 401 }
      )
    }

    // Récupérer le profil de l'utilisateur connecté
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single()

    if (profileError || !profile) {
      return NextResponse.json(
        { success: false, error: 'Profil introuvable' },
        { status: 404 }
      )
    }

    const userProfile = profile as { role: string; role_id?: string | null; id: string; created_by?: string | null }

    // Créer un client service role
    const serviceClient = createServiceRoleClient()

    // Récupérer le niveau hiérarchique de l'utilisateur
    const { level: userLevel, role: userRoleData } = await getUserLevel(serviceClient, user.id)

    // Vérifier que l'utilisateur a un rôle avec permissions suffisantes
    // Les utilisateurs avec level >= 8 (agents par défaut) n'ont pas accès à la liste des utilisateurs
    if (userLevel >= 8) {
      return NextResponse.json(
        { success: false, error: 'Permission refusée' },
        { status: 403 }
      )
    }

    let users: UserWithBranches[] = []

    // Les utilisateurs avec level < 5 (super_admin, superviseurs...) voient tous les utilisateurs
    if (userLevel < 5) {
      // Super admin voit tous les utilisateurs
      const { data: allProfiles, error: usersError } = await supabase
        .from('profiles')
        .select('*')
        .order('created_at', { ascending: false })
        .returns<Array<{ id: string; role: string; created_by?: string | null; first_name?: string; last_name?: string; phone?: string; created_at?: string }>>()

      if (usersError) {
        return NextResponse.json(
          { success: false, error: 'Erreur lors de la récupération des utilisateurs' },
          { status: 500 }
        )
      }

      // Pour chaque utilisateur, récupérer ses branches et son email
      for (const profileData of allProfiles || []) {
        // Récupérer l'email depuis auth.users
        const { data: authUser } = await serviceClient.auth.admin.getUserById(profileData.id)

        const { data: userBranches } = await supabase
          .from('user_branches')
          .select('branch_id, branches(*)')
          .eq('user_id', profileData.id)

        const branches = (userBranches || []).map((ub: any) => ub.branches).filter(Boolean)

        // Récupérer le créateur
        let creator = null
        if (profileData.created_by) {
          const { data: creatorProfile } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', profileData.created_by)
            .single()
          creator = creatorProfile
        }

        users.push({
          ...profileData,
          email: authUser?.user?.email || profileData.id,
          branches,
          creator,
        } as UserWithBranches)
      }
    } else {
      // Utilisateurs avec level >= 5 (branch_admin, etc.) voient seulement les utilisateurs de leurs branches
      // 1. Récupérer les branches de l'utilisateur
      const { data: adminBranches, error: branchesError } = await supabase
        .from('user_branches')
        .select('branch_id')
        .eq('user_id', user.id)

      if (branchesError || !adminBranches || adminBranches.length === 0) {
        // Même sans branches, l'utilisateur doit se voir lui-même
        const { data: authUser } = await serviceClient.auth.admin.getUserById(user.id)

        // Récupérer le créateur si existe
        let creator = null
        if (userProfile.created_by) {
          const { data: creatorProfile } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', userProfile.created_by)
            .single()
          creator = creatorProfile
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const profileObj = profile as any
        users.push({
          ...profileObj,
          email: authUser?.user?.email || user.id,
          branches: [],
          creator,
        } as UserWithBranches)

        return NextResponse.json(
          { success: true, users },
          { status: 200 }
        )
      }

      const branchIds = adminBranches.map((b: { branch_id: string }) => b.branch_id)

      // 2. Récupérer tous les user_branches pour ces branches (sans profiles, car pas de FK directe)
      const { data: userBranchesData, error: userBranchesError } = await supabase
        .from('user_branches')
        .select('user_id, branch_id, branches(*)')
        .in('branch_id', branchIds)
        .returns<Array<{ user_id: string; branch_id: string; branches: any }>>()

      if (userBranchesError) {
        return NextResponse.json(
          { success: false, error: 'Erreur lors de la récupération des utilisateurs' },
          { status: 500 }
        )
      }

      // 3. Extraire les user_ids uniques (y compris le branch_admin lui-même)
      const userIds = Array.from(new Set([
        user.id, // S'assurer que le branch_admin est inclus
        ...(userBranchesData || []).map(ub => ub.user_id)
      ]))

      // 4. Récupérer tous les profiles de ces utilisateurs
      const { data: userProfiles, error: profilesError } = await supabase
        .from('profiles')
        .select('*')
        .in('id', userIds)
        .returns<Array<{ id: string; role: string; created_by?: string | null; first_name?: string; last_name?: string; phone?: string; created_at?: string }>>()

      if (profilesError) {
        return NextResponse.json(
          { success: false, error: 'Erreur lors de la récupération des profils' },
          { status: 500 }
        )
      }

      // 5. Créer un Map pour accéder rapidement aux profiles
      const profilesMap = new Map((userProfiles || []).map(p => [p.id, p]))

      // 6. Grouper par utilisateur
      const userMap = new Map<string, UserWithBranches>()

      // Pour chaque utilisateur, construire l'objet UserWithBranches
      for (const userId of userIds) {
        const userProfile = profilesMap.get(userId)
        if (!userProfile) continue

        // Récupérer l'email depuis auth.users
        const { data: authUser } = await serviceClient.auth.admin.getUserById(userId)
        
        // Récupérer les branches de cet utilisateur depuis userBranchesData
        const userBranches = (userBranchesData || [])
          .filter(ub => ub.user_id === userId)
          .map(ub => ub.branches)
          .filter(Boolean)

        // Récupérer le créateur
        let creator = null
        if (userProfile.created_by) {
          const { data: creatorProfile } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', userProfile.created_by)
            .single()
          creator = creatorProfile
        }

        userMap.set(userId, {
          ...userProfile,
          email: authUser?.user?.email || userId,
          branches: userBranches as any[],
          creator,
        } as UserWithBranches)
      }

      users = Array.from(userMap.values())
    }

    return NextResponse.json(
      {
        success: true,
        users,
      },
      { status: 200 }
    )
  } catch {
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/admin/users
 * Crée un nouvel utilisateur
 *
 * Body: {
 *   email: string
 *   first_name: string
 *   last_name: string
 *   phone: string
 *   role_id: string (UUID du rôle)
 *   branch_ids: string[]
 *   password?: string (optionnel, généré automatiquement si absent)
 * }
 *
 * Permissions (basées sur hiérarchie dynamique):
 * - Un utilisateur peut créer des utilisateurs avec un rôle de level > son level
 * - Restriction par branches: ne peut assigner que ses propres branches (sauf level < 5)
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const supabaseAdmin = createServiceRoleClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Non authentifié' },
        { status: 401 }
      )
    }

    // Récupérer le profil de l'utilisateur connecté
    const { data: profileData, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single()

    if (profileError || !profileData) {
      return NextResponse.json(
        { success: false, error: 'Profil introuvable' },
        { status: 404 }
      )
    }

    // Type explicite pour le profil
    const profile = profileData as { role?: string | null; role_id?: string | null; first_name?: string; last_name?: string }

    // Récupérer le niveau hiérarchique de l'utilisateur connecté
    const { level: userLevel } = await getUserLevel(supabaseAdmin, user.id)

    // Vérifier que l'utilisateur a le droit de créer des utilisateurs (level < 8)
    if (userLevel >= 8) {
      return NextResponse.json(
        { success: false, error: 'Permission refusée' },
        { status: 403 }
      )
    }

    // Parser le body
    const body = await request.json()
    const { email, first_name, last_name, phone, role_id, role, branch_ids, password } = body

    // Support du role_id OU role (rétrocompatibilité)
    const targetRoleId = role_id

    // Validations
    if (!email || !first_name || !last_name || !phone || (!role_id && !role) || !branch_ids || branch_ids.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Tous les champs sont requis (email, first_name, last_name, phone, role_id, branch_ids)' },
        { status: 400 }
      )
    }

    // Valider l'email
    if (!validateEmail(email)) {
      return NextResponse.json(
        { success: false, error: 'Format email invalide' },
        { status: 400 }
      )
    }

    // Valider le téléphone
    if (!validateIsraeliPhone(phone)) {
      return NextResponse.json(
        { success: false, error: 'Format téléphone invalide (05XXXXXXXX)' },
        { status: 400 }
      )
    }

    // Récupérer le rôle cible (par role_id ou par name pour rétrocompatibilité)
    let targetRole: Role | null = null

    if (targetRoleId) {
      const { data } = await supabaseAdmin
        .from('roles')
        .select('*')
        .eq('id', targetRoleId)
        .single<Role>()
      targetRole = data
    } else if (role) {
      // Rétrocompatibilité: chercher par nom
      const { data } = await supabaseAdmin
        .from('roles')
        .select('*')
        .eq('name', role)
        .single<Role>()
      targetRole = data
    }

    if (!targetRole) {
      return NextResponse.json(
        { success: false, error: 'Rôle invalide ou introuvable' },
        { status: 400 }
      )
    }

    // Vérifier la hiérarchie: l'utilisateur ne peut assigner que des rôles de niveau > son niveau
    if (!canManageLevel(userLevel, targetRole.level)) {
      return NextResponse.json(
        { success: false, error: `Vous ne pouvez créer que des utilisateurs avec un niveau hiérarchique inférieur au vôtre (${userLevel})` },
        { status: 403 }
      )
    }

    // Vérifier que l'utilisateur ne peut pas créer de super_admin (level 1)
    if (targetRole.level === 1) {
      return NextResponse.json(
        { success: false, error: 'Impossible de créer un utilisateur avec le rôle super_admin' },
        { status: 403 }
      )
    }

    // Si level >= 5, vérifier qu'il n'assigne que ses propres branches
    if (userLevel >= 5) {
      const { data: adminBranches } = await supabase
        .from('user_branches')
        .select('branch_id')
        .eq('user_id', user.id)

      const adminBranchIds = (adminBranches || []).map((b: { branch_id: string }) => b.branch_id)
      const invalidBranches = branch_ids.filter((id: string) => !adminBranchIds.includes(id))

      if (invalidBranches.length > 0) {
        // Récupérer les noms des branches invalides pour un message plus clair
        const { data: invalidBranchNames } = await supabase
          .from('branches')
          .select('name')
          .in('id', invalidBranches)

        const branchNames = (invalidBranchNames || []).map((b: { name: string }) => b.name).join(', ')

        return NextResponse.json(
          {
            success: false,
            error: `Vous ne pouvez assigner que vos propres branches. Branches non autorisées: ${branchNames || invalidBranches.join(', ')}`
          },
          { status: 403 }
        )
      }
    }

    // Générer un mot de passe temporaire si non fourni
    const userPassword = password || `AG${Math.random().toString(36).slice(2, 10).toUpperCase()}`
    const formattedPhone = formatIsraeliPhone(phone)

    // Créer le compte Supabase Auth avec service role
    const { data: newUser, error: createUserError } = await supabaseAdmin.auth.admin.createUser({
      email: email.trim(),
      password: userPassword,
      email_confirm: true, // Compte directement confirmé, pas besoin d'email de confirmation
    })

    if (createUserError || !newUser.user) {
      return NextResponse.json(
        { success: false, error: createUserError?.message || 'Erreur lors de la création du compte' },
        { status: 500 }
      )
    }

    // Créer le profil avec role et role_id
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: newProfile, error: profileInsertError } = await (supabase as any)
      .from('profiles')
      .insert({
        id: newUser.user.id,
        role: targetRole.name,
        role_id: targetRole.id,
        first_name: first_name.trim(),
        last_name: last_name.trim(),
        phone: formattedPhone,
        created_by: user.id,
      })
      .select()
      .single()

    if (profileInsertError) {
      // Rollback: supprimer le user Auth
      await supabaseAdmin.auth.admin.deleteUser(newUser.user.id)
      return NextResponse.json(
        { success: false, error: 'Erreur lors de la création du profil' },
        { status: 500 }
      )
    }

    // Créer les associations user_branches
    const branchAssignments = branch_ids.map((branchId: string) => ({
      user_id: newUser.user.id,
      branch_id: branchId,
    }))

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { error: branchAssignError } = await (supabase as any)
      .from('user_branches')
      .insert(branchAssignments)

    if (branchAssignError) {
      // Rollback: supprimer profil et user Auth
      await supabase.from('profiles').delete().eq('id', newUser.user.id)
      await supabaseAdmin.auth.admin.deleteUser(newUser.user.id)
      return NextResponse.json(
        { success: false, error: 'Erreur lors de l\'assignation des branches' },
        { status: 500 }
      )
    }

    // Récupérer l'utilisateur complet avec ses branches
    const { data: branches } = await supabase
      .from('user_branches')
      .select('branch_id, branches(*)')
      .eq('user_id', newUser.user.id)

    const userBranches = (branches || []).map((ub: any) => ub.branches).filter(Boolean)

    const createdUser: UserWithBranches = {
      ...(newProfile || {}),
      branches: userBranches,
      creator: profile || null,
    } as UserWithBranches

    // Logger la création de l'utilisateur
    const ipAddress = getClientIpFromHeaders(request.headers)
    await logUserAction({
      userId: user.id,
      userRole: profile.role as UserRole,
      userName: `${(profile as any).first_name || ''} ${(profile as any).last_name || ''}`.trim(),
      action: 'created',
      targetUserId: newUser.user.id,
      targetUserName: `${first_name} ${last_name}`.trim(),
      details: {
        targetUserRole: targetRole.name,
        targetRoleId: targetRole.id,
        email: email.trim(),
        phone: formattedPhone,
        branchIds: branch_ids
      },
      ipAddress
    })

    return NextResponse.json(
      {
        success: true,
        user: createdUser,
        temporaryPassword: userPassword, // Retourner le mot de passe temporaire
      },
      { status: 201 }
    )
  } catch {
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/contact/route.ts">
import { NextRequest, NextResponse } from 'next/server'

const CONTACT_EMAIL = 'contact@activegames.co.il'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { name, email, message } = body

    // Validation
    if (!name || !email || !message) {
      return NextResponse.json(
        { error: 'All fields are required' },
        { status: 400 }
      )
    }

    // Email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(email)) {
      return NextResponse.json(
        { error: 'Invalid email address' },
        { status: 400 }
      )
    }

    // Send email using Brevo
    const brevoApiKey = process.env.BREVO_API_KEY
    if (!brevoApiKey) {
      console.error('BREVO_API_KEY not configured')
      return NextResponse.json(
        { error: 'Email service not configured' },
        { status: 500 }
      )
    }

    const response = await fetch('https://api.brevo.com/v3/smtp/email', {
      method: 'POST',
      headers: {
        'accept': 'application/json',
        'api-key': brevoApiKey,
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        sender: {
          name: 'Active Games Website',
          email: process.env.BREVO_FROM_EMAIL || 'noreply@activegames.co.il',
        },
        to: [
          {
            email: CONTACT_EMAIL,
            name: 'Active Games',
          },
        ],
        replyTo: {
          email: email,
          name: name,
        },
        subject: `[Contact Form] New message from ${name}`,
        htmlContent: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #00F0FF; border-bottom: 2px solid #00F0FF; padding-bottom: 10px;">
              New Contact Form Submission
            </h2>
            <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
              <p><strong>Name:</strong> ${name}</p>
              <p><strong>Email:</strong> <a href="mailto:${email}">${email}</a></p>
              <p><strong>Message:</strong></p>
              <div style="background: white; padding: 15px; border-radius: 4px; white-space: pre-wrap;">
                ${message.replace(/</g, '&lt;').replace(/>/g, '&gt;')}
              </div>
            </div>
            <p style="color: #666; font-size: 12px;">
              This message was sent from the Active Games website contact form.
            </p>
          </div>
        `,
      }),
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}))
      console.error('Brevo API error:', errorData)
      return NextResponse.json(
        { error: 'Failed to send email' },
        { status: 500 }
      )
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Contact form error:', error)
    return NextResponse.json(
      { error: 'An error occurred' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/cron/backup/route.ts">
import { createClient } from '@supabase/supabase-js';
import { NextResponse } from 'next/server';

// Protection: seul Vercel Cron peut appeler cette route
export async function GET(request: Request) {
  try {
    // Vérifier que c'est bien Vercel Cron qui appelle
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('🔄 Début du backup automatique...');

    // Créer le client Supabase avec les droits admin
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    // Liste des tables à sauvegarder
    const tables = [
      'activity_logs',
      'ai_conversations',
      'ai_messages',
      'booking_contacts',
      'booking_slots',
      'bookings',
      'branch_settings',
      'branches',
      'contacts',
      'email_logs',
      'email_settings',
      'email_templates',
      'event_rooms',
      'game_sessions',
      'icount_event_formulas',
      'icount_products',
      'icount_rooms',
      'laser_rooms',
      'orders',
      'payment_credentials',
      'payments',
      'profiles',
      'role_permissions',
      'roles',
      'user_branches'
    ];

    const backupData: any = {
      timestamp: new Date().toISOString(),
      version: '1.0',
      tables: {},
      metadata: {
        project: 'activelaser',
        database: 'zapwlcrjnabrfhoxfgqo'
      }
    };

    let totalRecords = 0;

    // Exporter toutes les tables
    for (const table of tables) {
      try {
        const { data, error, count } = await supabase
          .from(table)
          .select('*', { count: 'exact' });

        if (error) {
          console.error(`❌ Erreur table ${table}:`, error.message);
          backupData.tables[table] = { error: error.message, records: 0 };
          continue;
        }

        backupData.tables[table] = {
          data: data || [],
          records: count || 0
        };

        totalRecords += count || 0;
        console.log(`✅ ${table}: ${count || 0} enregistrements`);
      } catch (err: any) {
        console.error(`❌ Exception table ${table}:`, err.message);
        backupData.tables[table] = { error: err.message, records: 0 };
      }
    }

    // Convertir en JSON
    const backupJSON = JSON.stringify(backupData, null, 2);
    const backupBuffer = Buffer.from(backupJSON);

    console.log(`📊 Total: ${totalRecords} enregistrements`);
    console.log(`📦 Taille: ${(backupBuffer.length / 1024).toFixed(2)} KB`);

    // Uploader dans Supabase Storage
    const filename = `backup_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;

    const { data: uploadData, error: uploadError } = await supabase
      .storage
      .from('backups')
      .upload(filename, backupBuffer, {
        contentType: 'application/json',
        upsert: false
      });

    if (uploadError) {
      console.error('❌ Erreur upload:', uploadError);
      return NextResponse.json({
        success: false,
        error: 'Upload failed',
        details: uploadError.message
      }, { status: 500 });
    }

    console.log(`✅ Backup uploadé: ${filename}`);

    // Nettoyer les vieux backups (garder les 30 derniers)
    const { data: files } = await supabase
      .storage
      .from('backups')
      .list('', {
        limit: 100,
        sortBy: { column: 'created_at', order: 'desc' }
      });

    if (files && files.length > 30) {
      const filesToDelete = files.slice(30).map(f => f.name);

      const { error: deleteError } = await supabase
        .storage
        .from('backups')
        .remove(filesToDelete);

      if (!deleteError) {
        console.log(`🗑️  ${filesToDelete.length} vieux backups supprimés`);
      }
    }

    return NextResponse.json({
      success: true,
      message: 'Backup créé avec succès',
      filename,
      stats: {
        tables: Object.keys(backupData.tables).length,
        totalRecords,
        sizeKB: Math.round(backupBuffer.length / 1024),
        timestamp: backupData.timestamp
      }
    });

  } catch (error: any) {
    console.error('❌ Erreur backup:', error);
    return NextResponse.json({
      success: false,
      error: 'Backup failed',
      details: error.message
    }, { status: 500 });
  }
}

// Désactiver le cache pour les cron jobs
export const dynamic = 'force-dynamic';
export const revalidate = 0;
</file>

<file path="src/app/api/cron/cgv-reminders/route.ts">
/**
 * CRON Job: CGV Reminders
 *
 * Envoie des rappels par email pour les orders admin dont les CGV n'ont pas été validées.
 * À appeler toutes les heures ou une fois par jour.
 *
 * Logique:
 * - Trouve les orders admin (source = 'admin_agenda') avec cgv_token non null et cgv_validated_at null
 * - Envoie un rappel si > 24h depuis le dernier rappel (ou création)
 * - Maximum 3 rappels par order
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { sendEmail } from '@/lib/email-sender'
import type { Branch } from '@/lib/supabase/types'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

// Sécurité: Vercel Cron envoie automatiquement un header d'autorisation
// https://vercel.com/docs/cron-jobs/manage-cron-jobs#securing-cron-jobs

// Délai entre les rappels (24h en millisecondes)
const REMINDER_DELAY_MS = 24 * 60 * 60 * 1000

// Nombre maximum de rappels
const MAX_REMINDERS = 3

/**
 * GET /api/cron/cgv-reminders
 * Appelé par un cron job externe (ex: Vercel Cron, GitHub Actions, etc.)
 */
export async function GET(_request: NextRequest) {
  // Sécurisé automatiquement par Vercel Cron (seuls leurs serveurs peuvent appeler)

  try {
    const now = new Date()
    const reminderThreshold = new Date(now.getTime() - REMINDER_DELAY_MS)

    // Trouver les orders admin qui ont besoin d'un rappel CGV
    const { data: ordersToRemind, error: fetchError } = await supabase
      .from('orders')
      .select(`
        id,
        request_reference,
        customer_first_name,
        customer_last_name,
        customer_email,
        cgv_token,
        cgv_reminder_sent_at,
        cgv_reminder_count,
        requested_date,
        requested_time,
        participants_count,
        branch_id,
        created_at
      `)
      .eq('source', 'admin_agenda')
      .not('cgv_token', 'is', null)
      .is('cgv_validated_at', null)
      .lt('cgv_reminder_count', MAX_REMINDERS)
      .not('customer_email', 'is', null)

    if (fetchError) {
      console.error('[CGV REMINDERS] Error fetching orders:', fetchError)
      return NextResponse.json({ error: 'Failed to fetch orders' }, { status: 500 })
    }

    if (!ordersToRemind || ordersToRemind.length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No orders need CGV reminders',
        sent: 0
      })
    }

    // Filtrer les orders qui ont besoin d'un rappel (> 24h depuis dernier rappel ou création)
    const ordersNeedingReminder = ordersToRemind.filter(order => {
      const lastContact = order.cgv_reminder_sent_at
        ? new Date(order.cgv_reminder_sent_at)
        : new Date(order.created_at)
      return lastContact < reminderThreshold
    })

    if (ordersNeedingReminder.length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No orders are due for reminders yet',
        sent: 0
      })
    }

    // Récupérer toutes les branches nécessaires
    const branchIds = [...new Set(ordersNeedingReminder.map(o => o.branch_id))]
    const { data: branches } = await supabase
      .from('branches')
      .select('*')
      .in('id', branchIds)

    const branchMap = new Map<string, Branch>()
    branches?.forEach(b => branchMap.set(b.id, b as Branch))

    // URL de base pour les liens CGV
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://activegames.co.il'

    let sentCount = 0
    const errors: string[] = []

    // Envoyer les rappels
    for (const order of ordersNeedingReminder) {
      const branch = branchMap.get(order.branch_id)
      if (!branch || !order.customer_email) continue

      const cgvUrl = `${baseUrl}/cgv/${order.cgv_token}`
      const reminderNumber = order.cgv_reminder_count + 1

      // Générer le HTML du rappel (en français par défaut pour simplifier)
      const subject = `[Rappel ${reminderNumber}] Validation CGV - Réservation ${order.request_reference}`

      const html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
        </head>
        <body style="font-family: Arial, sans-serif; background-color: #0a0a1a; margin: 0; padding: 20px;">
          <div style="max-width: 600px; margin: 0 auto; background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%); border-radius: 16px; overflow: hidden; border: 1px solid rgba(0, 240, 255, 0.2);">

            <!-- Header avec logos -->
            <div style="padding: 30px; text-align: center; background: linear-gradient(135deg, #00f0ff20 0%, transparent 100%);">
              <div style="display: inline-block; margin: 0 10px;">
                <img src="${baseUrl}/images/logo-activegames.png" alt="Active Games" style="height: 50px; width: auto;">
              </div>
              <div style="display: inline-block; margin: 0 10px;">
                <img src="${baseUrl}/images/logo_laser_city.png" alt="Laser City" style="height: 50px; width: auto;">
              </div>
            </div>

            <!-- Contenu principal -->
            <div style="padding: 30px;">
              <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; padding: 25px; border: 2px solid #f59e0b; margin-bottom: 25px;">
                <h2 style="color: #92400e; margin: 0 0 15px 0; font-size: 20px;">⚠️ Rappel : Validation CGV en attente</h2>
                <p style="color: #78350f; margin: 0 0 20px 0; font-size: 15px; line-height: 1.6;">
                  Bonjour ${order.customer_first_name},<br><br>
                  Nous vous rappelons que votre réservation nécessite la validation de nos conditions générales de vente pour être finalisée.
                </p>
                <div style="text-align: center;">
                  <a href="${cgvUrl}" target="_blank" style="display: inline-block; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: #ffffff; padding: 14px 35px; border-radius: 8px; text-decoration: none; font-weight: bold; font-size: 16px;">
                    Valider les CGV maintenant
                  </a>
                </div>
              </div>

              <!-- Récapitulatif réservation -->
              <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 20px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <h3 style="color: #00f0ff; margin: 0 0 15px 0; font-size: 16px;">📋 Votre réservation</h3>
                <table style="width: 100%; color: #ffffff; font-size: 14px;">
                  <tr>
                    <td style="padding: 8px 0; color: #888;">Référence :</td>
                    <td style="padding: 8px 0; font-weight: bold;">${order.request_reference}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; color: #888;">Date :</td>
                    <td style="padding: 8px 0;">${new Date(order.requested_date).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; color: #888;">Heure :</td>
                    <td style="padding: 8px 0;">${order.requested_time.slice(0, 5)}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; color: #888;">Participants :</td>
                    <td style="padding: 8px 0;">${order.participants_count} personnes</td>
                  </tr>
                </table>
              </div>
            </div>

            <!-- Footer -->
            <div style="padding: 20px 30px; background: rgba(0, 0, 0, 0.3); text-align: center;">
              <p style="color: #666; font-size: 12px; margin: 0;">
                ${branch.name} • Active Games World<br>
                Ceci est le rappel n°${reminderNumber}
              </p>
            </div>
          </div>
        </body>
        </html>
      `

      try {
        const emailResult = await sendEmail({
          to: order.customer_email,
          toName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
          subject,
          html,
          templateCode: 'cgv_reminder',
          entityType: 'order',
          entityId: order.id,
          branchId: order.branch_id,
          metadata: {
            reminder_number: reminderNumber,
            cgv_token: order.cgv_token,
          }
        })

        if (emailResult.success) {
          // Mettre à jour l'order avec le nouveau compteur de rappels
          await supabase
            .from('orders')
            .update({
              cgv_reminder_sent_at: now.toISOString(),
              cgv_reminder_count: reminderNumber,
            })
            .eq('id', order.id)

          sentCount++
          console.log(`[CGV REMINDERS] Sent reminder ${reminderNumber} to ${order.customer_email} for order ${order.request_reference}`)
        } else {
          errors.push(`Failed to send to ${order.customer_email}: ${emailResult.error}`)
        }
      } catch (err) {
        errors.push(`Exception for ${order.customer_email}: ${err}`)
      }
    }

    return NextResponse.json({
      success: true,
      message: `CGV reminders sent`,
      sent: sentCount,
      total: ordersNeedingReminder.length,
      errors: errors.length > 0 ? errors : undefined,
    })

  } catch (error) {
    console.error('[CGV REMINDERS] Error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="src/app/api/email-templates/[id]/route.ts">
/**
 * API Route: /api/email-templates/[id]
 *
 * GET: Récupérer un template spécifique
 * PUT: Modifier un template
 * DELETE: Supprimer un template (sauf templates système)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyApiPermission } from '@/lib/permissions'
import type { EmailTemplate } from '@/lib/supabase/types'

// GET: Récupérer un template spécifique
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const permCheck = await verifyApiPermission('settings', 'view')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const { id } = await params
  const supabase = await createClient()

  const { data: template, error } = await supabase
    .from('email_templates')
    .select('*')
    .eq('id', id)
    .single<EmailTemplate>()

  if (error || !template) {
    return NextResponse.json(
      { success: false, error: 'Template not found' },
      { status: 404 }
    )
  }

  return NextResponse.json({
    success: true,
    data: template
  })
}

// PUT: Modifier un template
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const permCheck = await verifyApiPermission('settings', 'edit')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const { id } = await params
  const supabase = await createClient()

  // Vérifier que le template existe
  const { data: existing, error: fetchError } = await supabase
    .from('email_templates')
    .select('*')
    .eq('id', id)
    .single<EmailTemplate>()

  if (fetchError || !existing) {
    return NextResponse.json(
      { success: false, error: 'Template not found' },
      { status: 404 }
    )
  }

  try {
    const body = await request.json()
    const {
      name,
      description,
      subject_template,
      body_template,
      is_active,
      branch_id,
      available_variables
    } = body

    // Construire l'objet de mise à jour
    const updateData: Record<string, unknown> = {}

    if (name !== undefined) updateData.name = name
    if (description !== undefined) updateData.description = description
    if (subject_template !== undefined) updateData.subject_template = subject_template
    if (body_template !== undefined) updateData.body_template = body_template
    if (is_active !== undefined) updateData.is_active = is_active
    if (available_variables !== undefined) updateData.available_variables = available_variables

    // branch_id ne peut pas être modifié pour les templates système
    if (branch_id !== undefined && !existing.is_system) {
      updateData.branch_id = branch_id
    }

    // code ne peut pas être modifié
    // is_system ne peut pas être modifié

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: template, error } = await (supabase as any)
      .from('email_templates')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      console.error('Error updating email template:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to update template' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: template
    })

  } catch (error) {
    console.error('Error in PUT /api/email-templates/[id]:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// DELETE: Supprimer un template
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const permCheck = await verifyApiPermission('settings', 'delete')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const { id } = await params
  const supabase = await createClient()

  // Vérifier que le template existe et n'est pas un template système
  const { data: existing, error: fetchError } = await supabase
    .from('email_templates')
    .select('is_system')
    .eq('id', id)
    .single<{ is_system: boolean }>()

  if (fetchError || !existing) {
    return NextResponse.json(
      { success: false, error: 'Template not found' },
      { status: 404 }
    )
  }

  if (existing.is_system) {
    return NextResponse.json(
      { success: false, error: 'Cannot delete system templates' },
      { status: 403 }
    )
  }

  // Supprimer
  const { error: deleteError } = await supabase
    .from('email_templates')
    .delete()
    .eq('id', id)

  if (deleteError) {
    console.error('Error deleting email template:', deleteError)
    return NextResponse.json(
      { success: false, error: 'Failed to delete template' },
      { status: 500 }
    )
  }

  return NextResponse.json({
    success: true,
    message: 'Template deleted'
  })
}
</file>

<file path="src/app/api/email-templates/route.ts">
/**
 * API Route: /api/email-templates
 *
 * GET: Liste des templates d'emails
 * POST: Créer un nouveau template
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyApiPermission } from '@/lib/permissions'
import type { EmailTemplate } from '@/lib/supabase/types'

// GET: Récupérer la liste des templates
export async function GET(request: NextRequest) {
  // Seuls les super_admin peuvent gérer les templates (via settings)
  const permCheck = await verifyApiPermission('settings', 'view')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const supabase = await createClient()
  const searchParams = request.nextUrl.searchParams

  const isActive = searchParams.get('is_active')
  const branchId = searchParams.get('branch_id')

  let query = supabase
    .from('email_templates')
    .select('*')
    .order('name', { ascending: true })

  if (isActive !== null) {
    query = query.eq('is_active', isActive === 'true')
  }

  if (branchId) {
    // Templates globaux (branch_id = null) + templates de la branche spécifique
    query = query.or(`branch_id.is.null,branch_id.eq.${branchId}`)
  }

  const { data: templates, error } = await query

  if (error) {
    console.error('Error fetching email templates:', error)
    return NextResponse.json(
      { success: false, error: 'Failed to fetch templates' },
      { status: 500 }
    )
  }

  return NextResponse.json({
    success: true,
    data: templates || []
  })
}

// POST: Créer un nouveau template
export async function POST(request: NextRequest) {
  const permCheck = await verifyApiPermission('settings', 'create')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const user = permCheck.user!
  const supabase = await createClient()

  try {
    const body = await request.json()
    const {
      code,
      name,
      description,
      subject_template,
      body_template,
      is_active = true,
      branch_id = null,
      available_variables = []
    } = body

    // Validation
    if (!code || !name || !subject_template || !body_template) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: code, name, subject_template, body_template' },
        { status: 400 }
      )
    }

    // Vérifier que le code n'existe pas déjà
    const { data: existing } = await supabase
      .from('email_templates')
      .select('id')
      .eq('code', code)
      .single()

    if (existing) {
      return NextResponse.json(
        { success: false, error: 'A template with this code already exists' },
        { status: 409 }
      )
    }

    // Créer le template
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: template, error } = await (supabase as any)
      .from('email_templates')
      .insert({
        code,
        name,
        description: description || null,
        subject_template,
        body_template,
        is_active,
        is_system: false, // Les templates créés manuellement ne sont jamais système
        branch_id,
        available_variables,
        created_by: user.id
      })
      .select()
      .single()

    if (error) {
      console.error('Error creating email template:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to create template' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: template
    }, { status: 201 })

  } catch (error) {
    console.error('Error in POST /api/email-templates:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/emails/[id]/route.ts">
/**
 * API Route: /api/emails/[id]
 *
 * GET: Récupérer un email spécifique
 * DELETE: Supprimer un email du log
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyApiPermission } from '@/lib/permissions'

// GET: Récupérer un email spécifique
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const permCheck = await verifyApiPermission('orders', 'view')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const user = permCheck.user!
  const { id } = await params
  const supabase = await createClient()

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: email, error } = await (supabase as any)
    .from('email_logs')
    .select('*')
    .eq('id', id)
    .single()

  if (error || !email) {
    return NextResponse.json(
      { success: false, error: 'Email not found' },
      { status: 404 }
    )
  }

  // Vérifier l'accès à la branche
  if (user.role !== 'super_admin' && email.branch_id && !user.branchIds.includes(email.branch_id as string)) {
    return NextResponse.json(
      { success: false, error: 'Access denied' },
      { status: 403 }
    )
  }

  return NextResponse.json({
    success: true,
    data: email
  })
}

// DELETE: Supprimer un email du log
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const permCheck = await verifyApiPermission('orders', 'delete')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const user = permCheck.user!
  const { id } = await params
  const supabase = await createClient()

  // Vérifier que l'email existe et que l'utilisateur y a accès
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: emailToDelete, error: fetchError } = await (supabase as any)
    .from('email_logs')
    .select('branch_id')
    .eq('id', id)
    .single()

  if (fetchError || !emailToDelete) {
    return NextResponse.json(
      { success: false, error: 'Email not found' },
      { status: 404 }
    )
  }

  // Vérifier l'accès à la branche
  if (user.role !== 'super_admin' && emailToDelete.branch_id && !user.branchIds.includes(emailToDelete.branch_id as string)) {
    return NextResponse.json(
      { success: false, error: 'Access denied' },
      { status: 403 }
    )
  }

  // Supprimer
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { error: deleteError } = await (supabase as any)
    .from('email_logs')
    .delete()
    .eq('id', id)

  if (deleteError) {
    console.error('Error deleting email log:', deleteError)
    return NextResponse.json(
      { success: false, error: 'Failed to delete email' },
      { status: 500 }
    )
  }

  return NextResponse.json({
    success: true,
    message: 'Email log deleted'
  })
}
</file>

<file path="src/app/api/icount-formulas/[id]/route.ts">
/**
 * API Route pour gérer une formule iCount spécifique
 * GET: Récupérer une formule
 * PUT: Mettre à jour une formule
 * DELETE: Supprimer une formule
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import type { ICountFormula } from '../route'

interface RouteParams {
  params: Promise<{ id: string }>
}

/**
 * GET /api/icount-formulas/[id]
 * Récupérer une formule par ID
 */
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    const { data: formula, error } = await supabase
      .from('icount_formulas')
      .select('*')
      .eq('id', id)
      .single<ICountFormula>()

    if (error || !formula) {
      return NextResponse.json(
        { success: false, error: 'Formula not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(formula.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    return NextResponse.json({
      success: true,
      data: formula,
    })
  } catch (error) {
    console.error('[API icount-formulas] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/icount-formulas/[id]
 * Mettre à jour une formule
 */
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body = await request.json()
    const {
      code,
      name,
      name_he,
      description,
      booking_type,
      game_area,
      min_participants,
      max_participants,
      priority,
      is_active,
      items,
    } = body

    const supabase = createServiceRoleClient()

    // Vérifier que la formule existe
    const { data: existingFormula, error: fetchError } = await supabase
      .from('icount_formulas')
      .select('*')
      .eq('id', id)
      .single<ICountFormula>()

    if (fetchError || !existingFormula) {
      return NextResponse.json(
        { success: false, error: 'Formula not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingFormula.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Construire l'objet de mise à jour
    const updateData: Record<string, unknown> = {
      updated_at: new Date().toISOString(),
    }

    if (code !== undefined) updateData.code = code
    if (name !== undefined) updateData.name = name
    if (name_he !== undefined) updateData.name_he = name_he
    if (description !== undefined) updateData.description = description
    if (booking_type !== undefined) updateData.booking_type = booking_type
    if (game_area !== undefined) updateData.game_area = game_area
    if (min_participants !== undefined) updateData.min_participants = min_participants
    if (max_participants !== undefined) updateData.max_participants = max_participants
    if (priority !== undefined) updateData.priority = priority
    if (is_active !== undefined) updateData.is_active = is_active
    if (items !== undefined) updateData.items = Array.isArray(items) ? items : []

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: formula, error } = await (supabase as any)
      .from('icount_formulas')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      console.error('[API icount-formulas] Error updating formula:', error)
      if (error.code === '23505') {
        return NextResponse.json(
          { success: false, error: 'Formula code already exists for this branch' },
          { status: 409 }
        )
      }
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: formula,
    })
  } catch (error) {
    console.error('[API icount-formulas] PUT error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/icount-formulas/[id]
 * Supprimer une formule
 */
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // Vérifier que la formule existe
    const { data: existingFormula, error: fetchError } = await supabase
      .from('icount_formulas')
      .select('*')
      .eq('id', id)
      .single<ICountFormula>()

    if (fetchError || !existingFormula) {
      return NextResponse.json(
        { success: false, error: 'Formula not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingFormula.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Hard delete ou soft delete selon le paramètre
    const hardDelete = request.nextUrl.searchParams.get('hard') === 'true'

    if (hardDelete) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_formulas')
        .delete()
        .eq('id', id)

      if (error) {
        console.error('[API icount-formulas] Error deleting formula:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    } else {
      // Soft delete
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_formulas')
        .update({ is_active: false, updated_at: new Date().toISOString() })
        .eq('id', id)

      if (error) {
        console.error('[API icount-formulas] Error deactivating formula:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    }

    return NextResponse.json({
      success: true,
      message: hardDelete ? 'Formula deleted' : 'Formula deactivated',
    })
  } catch (error) {
    console.error('[API icount-formulas] DELETE error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-formulas/route.ts">
/**
 * API Route pour gérer les formules iCount
 * GET: Liste des formules avec filtres
 * POST: Créer une nouvelle formule
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'

export interface FormulaItem {
  product_code: string
  quantity: number | 'participants'
}

export interface ICountFormula {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  description: string | null
  booking_type: 'EVENT' | 'GAME'
  game_area: 'LASER' | 'ACTIVE' | 'BOTH' | null
  min_participants: number
  max_participants: number
  priority: number
  is_active: boolean
  items: FormulaItem[]
  created_at: string
  updated_at: string
}

/**
 * GET /api/icount-formulas
 * Liste les formules pour une branche
 */
export async function GET(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const searchParams = request.nextUrl.searchParams
    const branchId = searchParams.get('branchId') || searchParams.get('branch_id')
    const bookingType = searchParams.get('booking_type')
    const includeInactive = searchParams.get('includeInactive') === 'true'

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branchId is required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    let query = supabase
      .from('icount_formulas')
      .select('*')
      .eq('branch_id', branchId)
      .order('priority', { ascending: false })
      .order('name', { ascending: true })

    if (!includeInactive) {
      query = query.eq('is_active', true)
    }

    if (bookingType) {
      query = query.eq('booking_type', bookingType)
    }

    const { data: formulas, error } = await query.returns<ICountFormula[]>()

    if (error) {
      console.error('[API icount-formulas] Error fetching formulas:', error)
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: formulas || [],
    })
  } catch (error) {
    console.error('[API icount-formulas] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/icount-formulas
 * Créer une nouvelle formule
 */
export async function POST(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const body = await request.json()
    const {
      branch_id,
      code,
      name,
      name_he,
      description,
      booking_type,
      game_area,
      min_participants,
      max_participants,
      priority,
      items,
    } = body

    if (!branch_id || !code || !name || !booking_type || !items) {
      return NextResponse.json(
        { success: false, error: 'branch_id, code, name, booking_type, and items are required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: formula, error } = await (supabase as any)
      .from('icount_formulas')
      .insert({
        branch_id,
        code,
        name,
        name_he: name_he || null,
        description: description || null,
        booking_type,
        game_area: game_area || null,
        min_participants: min_participants || 1,
        max_participants: max_participants || 999,
        priority: priority || 0,
        is_active: true,
        items: Array.isArray(items) ? items : [],
      })
      .select()
      .single()

    if (error) {
      console.error('[API icount-formulas] Error creating formula:', error)
      if (error.code === '23505') {
        return NextResponse.json(
          { success: false, error: 'Formula code already exists for this branch' },
          { status: 409 }
        )
      }
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: formula,
    }, { status: 201 })
  } catch (error) {
    console.error('[API icount-formulas] POST error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-products/[id]/route.ts">
/**
 * API Route pour gérer un produit iCount spécifique
 * GET: Récupérer un produit
 * PUT: Mettre à jour un produit
 * DELETE: Supprimer un produit
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { syncProductToICountBackground } from '@/lib/icount-sync'
import type { ICountProduct } from '../route'

interface RouteParams {
  params: Promise<{ id: string }>
}

/**
 * GET /api/icount-products/[id]
 * Récupérer un produit par ID
 */
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    const { data: product, error } = await supabase
      .from('icount_products')
      .select('*')
      .eq('id', id)
      .single<ICountProduct>()

    if (error || !product) {
      return NextResponse.json(
        { success: false, error: 'Product not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(product.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    return NextResponse.json({
      success: true,
      data: product,
    })
  } catch (error) {
    console.error('[API icount-products] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/icount-products/[id]
 * Mettre à jour un produit
 */
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body = await request.json()
    const { code, name, name_he, name_en, unit_price, is_active, sort_order } = body

    const supabase = createServiceRoleClient()

    // Vérifier que le produit existe
    const { data: existingProduct, error: fetchError } = await supabase
      .from('icount_products')
      .select('*')
      .eq('id', id)
      .single<ICountProduct>()

    if (fetchError || !existingProduct) {
      return NextResponse.json(
        { success: false, error: 'Product not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingProduct.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Construire l'objet de mise à jour
    const updateData: Partial<ICountProduct> & { updated_at: string } = {
      updated_at: new Date().toISOString(),
    }

    if (code !== undefined) updateData.code = code
    if (name !== undefined) updateData.name = name
    if (name_he !== undefined) updateData.name_he = name_he
    if (name_en !== undefined) updateData.name_en = name_en
    if (unit_price !== undefined) updateData.unit_price = parseFloat(unit_price)
    if (is_active !== undefined) updateData.is_active = is_active
    if (sort_order !== undefined) updateData.sort_order = sort_order

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: product, error } = await (supabase as any)
      .from('icount_products')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      console.error('[API icount-products] Error updating product:', error)
      if (error.code === '23505') {
        return NextResponse.json(
          { success: false, error: 'Product code already exists for this branch' },
          { status: 409 }
        )
      }
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    // Sync to iCount in background (non-blocking)
    syncProductToICountBackground(product)

    return NextResponse.json({
      success: true,
      data: product,
    })
  } catch (error) {
    console.error('[API icount-products] PUT error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/icount-products/[id]
 * Supprimer un produit (soft delete via is_active = false)
 */
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // Vérifier que le produit existe
    const { data: existingProduct, error: fetchError } = await supabase
      .from('icount_products')
      .select('*')
      .eq('id', id)
      .single<ICountProduct>()

    if (fetchError || !existingProduct) {
      return NextResponse.json(
        { success: false, error: 'Product not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingProduct.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Hard delete ou soft delete selon le paramètre
    const hardDelete = request.nextUrl.searchParams.get('hard') === 'true'

    if (hardDelete) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_products')
        .delete()
        .eq('id', id)

      if (error) {
        console.error('[API icount-products] Error deleting product:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    } else {
      // Soft delete
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_products')
        .update({ is_active: false, updated_at: new Date().toISOString() })
        .eq('id', id)

      if (error) {
        console.error('[API icount-products] Error deactivating product:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    }

    return NextResponse.json({
      success: true,
      message: hardDelete ? 'Product deleted' : 'Product deactivated',
    })
  } catch (error) {
    console.error('[API icount-products] DELETE error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-products/route.ts">
/**
 * API Route pour gérer les produits iCount
 * GET: Liste des produits avec filtres
 * POST: Créer un nouveau produit
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { syncProductToICountBackground } from '@/lib/icount-sync'

export interface ICountProduct {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  name_en: string | null
  unit_price: number
  is_active: boolean
  sort_order: number
  created_at: string
  updated_at: string
}

/**
 * GET /api/icount-products
 * Liste les produits pour une branche
 */
export async function GET(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const searchParams = request.nextUrl.searchParams
    const branchId = searchParams.get('branchId') || searchParams.get('branch_id')
    const includeInactive = searchParams.get('includeInactive') === 'true'

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branchId is required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    let query = supabase
      .from('icount_products')
      .select('*')
      .eq('branch_id', branchId)
      .order('sort_order', { ascending: true })
      .order('name', { ascending: true })

    if (!includeInactive) {
      query = query.eq('is_active', true)
    }

    const { data: products, error } = await query.returns<ICountProduct[]>()

    if (error) {
      console.error('[API icount-products] Error fetching products:', error)
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: products || [],
    })
  } catch (error) {
    console.error('[API icount-products] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/icount-products
 * Créer un nouveau produit
 */
export async function POST(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const body = await request.json()
    const { branch_id, code, name, name_he, name_en, unit_price, sort_order } = body

    if (!branch_id || !code || !name || unit_price === undefined) {
      return NextResponse.json(
        { success: false, error: 'branch_id, code, name, and unit_price are required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: product, error } = await (supabase as any)
      .from('icount_products')
      .insert({
        branch_id,
        code,
        name,
        name_he: name_he || null,
        name_en: name_en || null,
        unit_price: parseFloat(unit_price),
        sort_order: sort_order || 0,
        is_active: true,
      })
      .select()
      .single()

    if (error) {
      console.error('[API icount-products] Error creating product:', error)
      if (error.code === '23505') {
        return NextResponse.json(
          { success: false, error: 'Product code already exists for this branch' },
          { status: 409 }
        )
      }
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    // Sync to iCount in background (non-blocking)
    syncProductToICountBackground(product)

    return NextResponse.json({
      success: true,
      data: product,
    }, { status: 201 })
  } catch (error) {
    console.error('[API icount-products] POST error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-rooms/[id]/route.ts">
/**
 * API Route pour gérer une salle iCount spécifique
 * GET: Récupérer une salle
 * PUT: Mettre à jour une salle
 * DELETE: Supprimer une salle
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import type { ICountRoom } from '../route'

interface RouteParams {
  params: Promise<{ id: string }>
}

/**
 * GET /api/icount-rooms/[id]
 */
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: room, error } = await (supabase as any)
      .from('icount_rooms')
      .select('*')
      .eq('id', id)
      .single()

    if (error || !room) {
      return NextResponse.json(
        { success: false, error: 'Room not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(room.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    return NextResponse.json({
      success: true,
      data: room,
    })
  } catch (error) {
    console.error('[API icount-rooms] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/icount-rooms/[id]
 */
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body = await request.json()
    const { code, name, name_he, name_en, price, sort_order, is_active } = body

    const supabase = createServiceRoleClient()

    // Vérifier que la salle existe
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: existingRoom, error: fetchError } = await (supabase as any)
      .from('icount_rooms')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !existingRoom) {
      return NextResponse.json(
        { success: false, error: 'Room not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingRoom.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Construire l'objet de mise à jour
    const updateData: Record<string, unknown> = {
      updated_at: new Date().toISOString(),
    }

    if (code !== undefined) updateData.code = code
    if (name !== undefined) updateData.name = name
    if (name_he !== undefined) updateData.name_he = name_he
    if (name_en !== undefined) updateData.name_en = name_en
    if (price !== undefined) updateData.price = price
    if (sort_order !== undefined) updateData.sort_order = sort_order
    if (is_active !== undefined) updateData.is_active = is_active

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: room, error } = await (supabase as any)
      .from('icount_rooms')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      console.error('[API icount-rooms] Error updating room:', error)
      if (error.code === '23505') {
        return NextResponse.json(
          { success: false, error: 'Room code already exists for this branch' },
          { status: 409 }
        )
      }
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: room,
    })
  } catch (error) {
    console.error('[API icount-rooms] PUT error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/icount-rooms/[id]
 */
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // Vérifier que la salle existe
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: existingRoom, error: fetchError } = await (supabase as any)
      .from('icount_rooms')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !existingRoom) {
      return NextResponse.json(
        { success: false, error: 'Room not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingRoom.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Hard delete ou soft delete
    const hardDelete = request.nextUrl.searchParams.get('hard') === 'true'

    if (hardDelete) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_rooms')
        .delete()
        .eq('id', id)

      if (error) {
        console.error('[API icount-rooms] Error deleting room:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    } else {
      // Soft delete
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_rooms')
        .update({ is_active: false, updated_at: new Date().toISOString() })
        .eq('id', id)

      if (error) {
        console.error('[API icount-rooms] Error deactivating room:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    }

    return NextResponse.json({
      success: true,
      message: hardDelete ? 'Room deleted' : 'Room deactivated',
    })
  } catch (error) {
    console.error('[API icount-rooms] DELETE error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-rooms/route.ts">
/**
 * API Route pour gérer les salles iCount
 * GET: Liste des salles
 * POST: Créer une salle
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'

export interface ICountRoom {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  name_en: string | null
  price: number
  is_active: boolean
  sort_order: number
  created_at: string
  updated_at: string
}

/**
 * GET /api/icount-rooms
 * Liste des salles pour une branche
 */
export async function GET(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { searchParams } = new URL(request.url)
    const branchId = searchParams.get('branchId')
    const includeInactive = searchParams.get('includeInactive') === 'true'

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branchId is required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let query = (supabase as any)
      .from('icount_rooms')
      .select('*')
      .eq('branch_id', branchId)
      .order('sort_order', { ascending: true })

    if (!includeInactive) {
      query = query.eq('is_active', true)
    }

    const { data: rooms, error } = await query

    if (error) {
      console.error('[API icount-rooms] Error fetching rooms:', error)
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: rooms || [],
    })
  } catch (error) {
    console.error('[API icount-rooms] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/icount-rooms
 * Créer une nouvelle salle
 */
export async function POST(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const body = await request.json()
    const {
      branch_id,
      code,
      name,
      name_he,
      name_en,
      price,
      sort_order,
      is_active,
    } = body

    if (!branch_id || !code || !name) {
      return NextResponse.json(
        { success: false, error: 'branch_id, code and name are required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: room, error } = await (supabase as any)
      .from('icount_rooms')
      .insert({
        branch_id,
        code,
        name,
        name_he: name_he || null,
        name_en: name_en || null,
        price: price ?? 0,
        sort_order: sort_order ?? 0,
        is_active: is_active ?? true,
      })
      .select()
      .single()

    if (error) {
      console.error('[API icount-rooms] Error creating room:', error)
      if (error.code === '23505') {
        return NextResponse.json(
          { success: false, error: 'Room code already exists for this branch' },
          { status: 409 }
        )
      }
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: room,
    })
  } catch (error) {
    console.error('[API icount-rooms] POST error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/refund/route.ts">
/**
 * API Route pour rembourser un paiement
 * POST: Annuler le document iCount et rembourser la CB associée
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logOrderAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { getPaymentProvider } from '@/lib/payment-provider'
import type { UserRole } from '@/lib/supabase/types'
import type { ICountDocType } from '@/lib/payment-provider/icount/documents'

interface RefundRequest {
  payment_id: string
  reason?: string
}

/**
 * POST /api/orders/[id]/refund
 * Rembourser un paiement spécifique
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id: orderId } = await params
    const body: RefundRequest = await request.json()
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Validation
    if (!body.payment_id) {
      return NextResponse.json(
        { success: false, error: 'Payment ID required' },
        { status: 400 }
      )
    }

    // Récupérer la commande
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', orderId)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied' },
          { status: 403 }
        )
      }
    }

    // Récupérer le paiement
    const { data: payment, error: paymentError } = await supabase
      .from('payments')
      .select('*')
      .eq('id', body.payment_id)
      .eq('order_id', orderId)
      .single()

    if (paymentError || !payment) {
      return NextResponse.json(
        { success: false, error: 'Payment not found' },
        { status: 404 }
      )
    }

    // Vérifier que le paiement n'est pas déjà remboursé
    if (payment.status === 'refunded') {
      return NextResponse.json(
        { success: false, error: 'Payment already refunded' },
        { status: 400 }
      )
    }

    // Vérifier qu'on a un document iCount pour ce paiement
    if (!payment.icount_doctype || !payment.icount_docnum) {
      return NextResponse.json(
        { success: false, error: 'No iCount document associated with this payment. Cannot refund.' },
        { status: 400 }
      )
    }

    // Vérifier que c'était un paiement CB (seuls les CB peuvent être remboursés via iCount)
    if (payment.payment_method !== 'card') {
      return NextResponse.json(
        { success: false, error: 'Only card payments can be refunded via iCount' },
        { status: 400 }
      )
    }

    // Récupérer le provider de paiement
    const provider = await getPaymentProvider(order.branch_id)
    if (!provider) {
      return NextResponse.json(
        { success: false, error: 'Payment provider not configured' },
        { status: 500 }
      )
    }

    // Annuler le document iCount avec remboursement CB
    console.log('[REFUND] Cancelling document with refund:', payment.icount_doctype, payment.icount_docnum)

    const cancelResult = await provider.documents.cancelDocumentWithRefund(
      payment.icount_doctype as ICountDocType,
      payment.icount_docnum,
      body.reason || `Refund requested by ${user.profile.first_name} ${user.profile.last_name}`
    )

    if (!cancelResult.success) {
      console.error('[REFUND] Failed to cancel document:', cancelResult.error)
      return NextResponse.json(
        {
          success: false,
          error: cancelResult.error?.message || 'Failed to process refund',
          errorCode: cancelResult.error?.code,
        },
        { status: 400 }
      )
    }

    console.log('[REFUND] Document cancelled and refund processed')

    // Mettre à jour le paiement comme remboursé
    const { error: updatePaymentError } = await supabase
      .from('payments')
      .update({
        status: 'refunded',
        refunded_at: new Date().toISOString(),
        refund_reason: body.reason,
        refunded_by: user.id,
      })
      .eq('id', body.payment_id)

    if (updatePaymentError) {
      console.error('[REFUND] Error updating payment status:', updatePaymentError)
    }

    // Mettre à jour la commande
    const newPaidAmount = Math.max(0, (order.paid_amount || 0) - payment.amount)
    const totalAmount = order.total_amount || 0

    let newPaymentStatus = 'unpaid'
    if (newPaidAmount >= totalAmount && totalAmount > 0) {
      newPaymentStatus = 'fully_paid'
    } else if (newPaidAmount > 0) {
      newPaymentStatus = 'deposit_paid'
    }

    const { error: updateOrderError } = await supabase
      .from('orders')
      .update({
        paid_amount: newPaidAmount,
        payment_status: newPaymentStatus,
      })
      .eq('id', orderId)

    if (updateOrderError) {
      console.error('[REFUND] Error updating order:', updateOrderError)
    }

    // Logger l'action
    await logOrderAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'updated',
      orderId,
      orderRef: order.request_reference,
      branchId: order.branch_id,
      details: {
        refundProcessed: true,
        paymentId: body.payment_id,
        amount: payment.amount,
        reason: body.reason,
        newPaymentStatus,
        totalPaid: newPaidAmount,
      },
      ipAddress,
    })

    return NextResponse.json({
      success: true,
      refund: {
        paymentId: body.payment_id,
        amount: payment.amount,
        status: 'refunded',
      },
      order: {
        id: orderId,
        paymentStatus: newPaymentStatus,
        paidAmount: newPaidAmount,
      },
    })

  } catch (error) {
    console.error('[REFUND] Error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/payment-credentials/test/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import { ICountClient } from '@/lib/payment-provider'

// Create a raw Supabase client
function createRawServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
  return createSupabaseClient(supabaseUrl, supabaseServiceKey, {
    auth: { autoRefreshToken: false, persistSession: false }
  })
}

// Helper to check if user is super_admin
async function checkSuperAdmin(userId: string): Promise<boolean> {
  const serviceClient = createRawServiceClient()
  const { data } = await serviceClient
    .from('profiles')
    .select('role')
    .eq('id', userId)
    .single()
  return data?.role === 'super_admin'
}

// POST - Test iCount API connection
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!(await checkSuperAdmin(user.id))) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const body = await request.json()
    const { cid, username, password, branch_id } = body

    if (!cid || !username || !password) {
      return NextResponse.json({ error: 'Missing credentials' }, { status: 400 })
    }

    // Use the ICountClient from the payment-provider lib
    const client = new ICountClient({
      cid: cid,
      user: username,
      pass: password
    })

    const result = await client.testConnection()

    // Update connection status in database if branch_id provided
    if (branch_id) {
      const serviceClient = createRawServiceClient()
      await serviceClient
        .from('payment_credentials')
        .update({
          last_connection_test: new Date().toISOString(),
          last_connection_status: result.success,
          last_connection_error: result.success ? null : (result.error?.message || 'Connection failed')
        })
        .eq('branch_id', branch_id)
        .eq('provider', 'icount')
    }

    if (result.success) {
      return NextResponse.json({
        success: true,
        message: 'Connection successful'
      })
    } else {
      return NextResponse.json({
        success: false,
        message: result.error?.message || 'Connection failed'
      })
    }
  } catch (error) {
    console.error('Error testing iCount connection:', error)
    return NextResponse.json({
      success: false,
      message: error instanceof Error ? error.message : 'Connection test failed'
    })
  }
}
</file>

<file path="src/app/api/payment-credentials/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createClient as createSupabaseClient } from '@supabase/supabase-js'

// Create a raw Supabase client that doesn't have typed tables
// This is needed because payment_credentials table isn't in the generated types yet
function createRawServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
  return createSupabaseClient(supabaseUrl, supabaseServiceKey, {
    auth: { autoRefreshToken: false, persistSession: false }
  })
}

// Helper to check if user is super_admin
async function checkSuperAdmin(userId: string): Promise<boolean> {
  const serviceClient = createRawServiceClient()
  const { data } = await serviceClient
    .from('profiles')
    .select('role')
    .eq('id', userId)
    .single()
  return data?.role === 'super_admin'
}

// GET - Fetch credentials for a branch
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!(await checkSuperAdmin(user.id))) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { searchParams } = new URL(request.url)
    const branchId = searchParams.get('branch_id')

    if (!branchId) {
      return NextResponse.json({ error: 'branch_id is required' }, { status: 400 })
    }

    const serviceClient = createRawServiceClient()
    const { data, error } = await serviceClient
      .from('payment_credentials')
      .select('*')
      .eq('branch_id', branchId)
      .eq('provider', 'icount')
      .single()

    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows found
      throw error
    }

    // Mask password in response
    if (data) {
      return NextResponse.json({
        ...data,
        password: '••••••••' // Never return actual password
      })
    }

    return NextResponse.json(null)
  } catch (error) {
    console.error('Error fetching payment credentials:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// POST - Create or update credentials
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!(await checkSuperAdmin(user.id))) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const body = await request.json()
    const { branch_id, cid, username, password } = body

    if (!branch_id || !cid || !username || !password) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
    }

    const serviceClient = createRawServiceClient()

    // Check if credentials already exist
    const { data: existing } = await serviceClient
      .from('payment_credentials')
      .select('id')
      .eq('branch_id', branch_id)
      .eq('provider', 'icount')
      .single()

    let result
    if (existing) {
      // Update existing
      const { data, error } = await serviceClient
        .from('payment_credentials')
        .update({
          cid,
          username,
          password,
          updated_by: user.id,
          updated_at: new Date().toISOString()
        })
        .eq('id', existing.id)
        .select()
        .single()

      if (error) throw error
      result = data
    } else {
      // Create new
      const { data, error } = await serviceClient
        .from('payment_credentials')
        .insert({
          branch_id,
          provider: 'icount',
          cid,
          username,
          password,
          created_by: user.id,
          updated_by: user.id
        })
        .select()
        .single()

      if (error) throw error
      result = data
    }

    return NextResponse.json({
      ...result,
      password: '••••••••'
    })
  } catch (error) {
    console.error('Error saving payment credentials:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// DELETE - Remove credentials
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!(await checkSuperAdmin(user.id))) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { searchParams } = new URL(request.url)
    const branchId = searchParams.get('branch_id')

    if (!branchId) {
      return NextResponse.json({ error: 'branch_id is required' }, { status: 400 })
    }

    const serviceClient = createRawServiceClient()

    const { data: existing } = await serviceClient
      .from('payment_credentials')
      .select('id')
      .eq('branch_id', branchId)
      .eq('provider', 'icount')
      .single()

    if (!existing) {
      return NextResponse.json({ error: 'Credentials not found' }, { status: 404 })
    }

    const { error } = await serviceClient
      .from('payment_credentials')
      .delete()
      .eq('id', existing.id)

    if (error) throw error

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting payment credentials:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="src/app/api/payments/test-connection/route.ts">
/**
 * API Route: Test Payment Provider Connection
 * POST /api/payments/test-connection
 *
 * Tests the connection to iCount API with provided credentials
 */

import { NextRequest, NextResponse } from 'next/server'

const ICOUNT_API_BASE_URL = 'https://api.icount.co.il/api/v3.php'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { cid, user, pass } = body

    if (!cid || !user || !pass) {
      return NextResponse.json(
        { success: false, error: 'Missing credentials (cid, user, pass required)' },
        { status: 400 }
      )
    }

    console.log('[iCount Test] Attempting login with cid:', cid, 'user:', user)

    // Test login to iCount
    const loginResponse = await fetch(`${ICOUNT_API_BASE_URL}/auth/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        cid,
        user,
        pass,
      }),
    })

    const loginData = await loginResponse.json()

    console.log('[iCount Test] Login response:', JSON.stringify(loginData, null, 2))

    if (loginData.status && loginData.sid) {
      // Login successful, logout to clean up
      try {
        await fetch(`${ICOUNT_API_BASE_URL}/auth/logout`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            sid: loginData.sid,
          }),
        })
      } catch (logoutError) {
        // Ignore logout errors
        console.log('[iCount Test] Logout error (ignored):', logoutError)
      }

      return NextResponse.json({
        success: true,
        message: 'Connection successful',
        data: { valid: true }
      })
    }

    // Login failed
    return NextResponse.json({
      success: false,
      error: loginData.error_description || loginData.reason || 'Login failed',
      details: loginData.error_details || [],
      data: { valid: false }
    })

  } catch (error) {
    console.error('[iCount Test] Error:', error)
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Connection test failed',
        data: { valid: false }
      },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/public/calculate-deposit/route.ts">
/**
 * API publique pour calculer le montant de l'acompte
 *
 * RÈGLES D'ACOMPTE:
 * - GAME: Prix d'1 joueur sur 6 (arrondi supérieur)
 * - EVENT: Prix de la salle uniquement
 *
 * IMPORTANT: Utilise la même logique de calcul que le reste de l'app
 * (price-calculator.ts) pour avoir une seule source de vérité
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { calculateBookingPrice } from '@/lib/price-calculator'
import type { ICountProduct, ICountEventFormula, ICountRoom } from '@/hooks/usePricingData'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

interface CalculateDepositRequest {
  branch_id: string
  order_type: 'GAME' | 'EVENT'
  participants_count: number
  // GAME params
  game_area?: 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null
  number_of_games?: number
  game_durations?: string[]
  custom_game_areas?: ('ACTIVE' | 'LASER')[]
  custom_game_durations?: string[]
  // EVENT params
  event_type?: string | null // event_active, event_laser, event_mix
  event_quick_plan?: string  // AA, LL, AL, LA, etc.
  event_room_id?: string | null
  // Locale for display
  locale?: 'he' | 'en' | 'fr'
}

/**
 * Convert event_type to quick_plan for price calculation
 */
function eventTypeToQuickPlan(eventType: string | null | undefined): string {
  if (!eventType) return 'AA' // Default to ACTIVE

  if (eventType === 'event_laser') return 'LL'
  if (eventType === 'event_mix') return 'AL'
  return 'AA' // event_active or default
}

/**
 * POST /api/public/calculate-deposit
 * Calculer le montant de l'acompte pour une réservation
 */
export async function POST(request: NextRequest) {
  try {
    const body: CalculateDepositRequest = await request.json()

    const {
      branch_id,
      order_type,
      participants_count,
      game_area,
      number_of_games = 2,
      game_durations = [],
      custom_game_areas = [],
      custom_game_durations = [],
      event_type,
      event_quick_plan,
      event_room_id,
      locale = 'en'
    } = body

    console.log('[CALC-DEPOSIT] Request:', {
      branch_id,
      order_type,
      participants_count,
      game_area,
      number_of_games,
      event_type,
      event_quick_plan
    })

    // Validation de base
    if (!branch_id || !order_type || !participants_count) {
      console.log('[CALC-DEPOSIT] Missing required fields')
      return NextResponse.json(
        { success: false, error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Load pricing data (same as usePricingData hook)
    const [productsRes, formulasRes, roomsRes] = await Promise.all([
      supabase
        .from('icount_products')
        .select('id, code, name, name_he, unit_price')
        .eq('branch_id', branch_id)
        .eq('is_active', true),
      supabase
        .from('icount_event_formulas')
        .select('id, name, game_type, min_participants, max_participants, price_per_person, room_id, product_id')
        .eq('branch_id', branch_id)
        .eq('is_active', true),
      supabase
        .from('icount_rooms')
        .select('id, name, name_he, price')
        .eq('branch_id', branch_id)
        .eq('is_active', true)
    ])

    if (productsRes.error || formulasRes.error || roomsRes.error) {
      console.error('[CALC-DEPOSIT] Error loading pricing data:', {
        products: productsRes.error,
        formulas: formulasRes.error,
        rooms: roomsRes.error
      })
      return NextResponse.json(
        { success: false, error: 'Failed to load pricing data' },
        { status: 500 }
      )
    }

    const products = (productsRes.data || []) as ICountProduct[]
    const eventFormulas = (formulasRes.data || []) as ICountEventFormula[]
    const rooms = (roomsRes.data || []) as ICountRoom[]

    console.log('[CALC-DEPOSIT] Loaded pricing data:', {
      productsCount: products.length,
      formulasCount: eventFormulas.length,
      roomsCount: rooms.length
    })

    // Build game durations for ACTIVE
    let gameDurations = game_durations
    if (gameDurations.length === 0 && game_area === 'ACTIVE') {
      // Default: each game is 30 minutes
      gameDurations = Array(number_of_games).fill('30')
    }

    // Handle MIX (Sur Mesure) - convert to CUSTOM with 1 Laser + 30min Active
    let effectiveGameArea: 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null | undefined = game_area
    let effectiveCustomGameAreas = custom_game_areas
    let effectiveCustomGameDurations = custom_game_durations

    if (game_area === 'MIX') {
      // MIX = 1 partie Laser + 30min Active (default sur mesure)
      effectiveGameArea = 'CUSTOM'
      effectiveCustomGameAreas = ['LASER', 'ACTIVE']
      effectiveCustomGameDurations = ['0', '30'] // Laser doesn't use duration, Active uses 30min
      console.log('[CALC-DEPOSIT] MIX converted to CUSTOM:', {
        areas: effectiveCustomGameAreas,
        durations: effectiveCustomGameDurations
      })
    }

    // Calculate price using the same function as the rest of the app
    const priceResult = calculateBookingPrice({
      bookingType: order_type,
      participants: participants_count,
      gameArea: effectiveGameArea,
      numberOfGames: number_of_games,
      gameDurations,
      customGameAreas: effectiveCustomGameAreas.length > 0 ? effectiveCustomGameAreas : undefined,
      customGameDurations: effectiveCustomGameDurations.length > 0 ? effectiveCustomGameDurations : undefined,
      eventQuickPlan: event_quick_plan || eventTypeToQuickPlan(event_type),
      eventRoomId: event_room_id,
      products,
      eventFormulas,
      rooms,
      locale: locale as 'he' | 'en' | 'fr'
    })

    console.log('[CALC-DEPOSIT] Price calculation result:', priceResult)

    if (!priceResult.valid) {
      return NextResponse.json(
        { success: false, error: priceResult.breakdown || 'Price calculation failed' },
        { status: 400 }
      )
    }

    // Calculate deposit amount based on rules
    let depositAmount = 0
    let explanation = ''

    if (order_type === 'GAME') {
      // GAME: deposit = price of 1 player per 6 participants (minimum 1)
      const depositPlayers = Math.max(1, Math.ceil(participants_count / 6))
      depositAmount = priceResult.details.unitPrice * depositPlayers
      explanation = `Deposit: ${depositPlayers} player(s) out of ${participants_count}`
    } else if (order_type === 'EVENT') {
      // EVENT: deposit = room price only
      depositAmount = priceResult.details.roomPrice || 0
      if (depositAmount > 0) {
        explanation = `Deposit: Room rental (${priceResult.details.roomName})`
      } else {
        explanation = 'No deposit required'
      }
    }

    // Round up deposit
    depositAmount = Math.ceil(depositAmount)

    return NextResponse.json({
      success: true,
      deposit: {
        amount: depositAmount,
        total: priceResult.total,
        unitPrice: priceResult.details.unitPrice,
        roomPrice: priceResult.details.roomPrice || 0,
        roomName: priceResult.details.roomName || null,
        breakdown: priceResult.breakdown,
        explanation
      }
    })

  } catch (error) {
    console.error('[CALC-DEPOSIT] Error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/public/pay-deposit/route.ts">
/**
 * API publique pour payer l'acompte d'une réservation
 *
 * Cette API est appelée APRÈS la création de la commande (via /api/orders)
 * Elle effectue le débit immédiat de l'acompte via iCount
 *
 * FLUX:
 * 1. Frontend crée la commande (order_id retourné)
 * 2. Frontend appelle cette API avec les infos CB
 * 3. Cette API débite la carte via iCount
 * 4. Si succès: met à jour order avec payment_status
 * 5. Si échec: retourne erreur (la commande reste valide mais non payée)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { getPaymentProvider } from '@/lib/payment-provider'
import type { CreditCardInfo } from '@/lib/payment-provider/icount/credit-card'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

interface PayDepositRequest {
  order_id: string
  amount: number
  card_info: {
    cc_number: string
    cc_validity: string // Format MMYY
    cc_cvv: string
    cc_holder_id: string
    cc_holder_name?: string
  }
}

/**
 * POST /api/public/pay-deposit
 * Payer l'acompte d'une commande existante
 */
export async function POST(request: NextRequest) {
  try {
    const body: PayDepositRequest = await request.json()

    const { order_id, amount, card_info } = body

    // Validation de base
    if (!order_id || !amount || !card_info) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields' },
        { status: 400 }
      )
    }

    if (!card_info.cc_number || !card_info.cc_validity || !card_info.cc_cvv || !card_info.cc_holder_id) {
      return NextResponse.json(
        { success: false, error: 'Incomplete card information' },
        { status: 400 }
      )
    }

    if (amount < 5) {
      return NextResponse.json(
        { success: false, error: 'Minimum payment amount is 5₪' },
        { status: 400 }
      )
    }

    // Récupérer la commande
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', order_id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    // Vérifier que la commande peut être payée
    if (order.status === 'closed' || order.status === 'cancelled') {
      return NextResponse.json(
        { success: false, error: 'This order cannot receive payments' },
        { status: 400 }
      )
    }

    // Vérifier que l'acompte n'a pas déjà été payé
    if (order.payment_status === 'deposit_paid' || order.payment_status === 'fully_paid') {
      return NextResponse.json(
        { success: false, error: 'Deposit already paid' },
        { status: 400 }
      )
    }

    // Récupérer le provider de paiement pour cette branche
    const provider = await getPaymentProvider(order.branch_id)
    if (!provider) {
      return NextResponse.json(
        { success: false, error: 'Payment service not configured for this branch' },
        { status: 500 }
      )
    }

    // Préparer les infos carte
    const cardInfoForPayment: CreditCardInfo = {
      cc_number: card_info.cc_number.replace(/\s/g, ''),
      cc_validity: card_info.cc_validity.replace(/[^0-9]/g, ''),
      cc_cvv: card_info.cc_cvv,
      cc_holder_id: card_info.cc_holder_id.replace(/[^0-9]/g, ''),
      cc_holder_name: card_info.cc_holder_name,
    }

    // Effectuer le paiement via iCount
    console.log('[PAY-DEPOSIT] Billing card for order:', order_id, 'amount:', amount)

    const billResult = await provider.creditCard.billCard({
      customClientId: order.contact_id || undefined,
      email: order.customer_email || undefined,
      clientName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
      cardInfo: cardInfoForPayment,
      amount,
      currencyCode: 'ILS',
      description: `Acompte réservation ${order.request_reference}`,
      isTest: false, // Production
    })

    console.log('[PAY-DEPOSIT] Bill result:', JSON.stringify(billResult, null, 2))

    if (!billResult.success || !billResult.data) {
      console.log('[PAY-DEPOSIT] Payment failed:', billResult.error)
      return NextResponse.json(
        {
          success: false,
          error: billResult.error?.message || 'Payment failed',
          errorCode: billResult.error?.code,
        },
        { status: 400 }
      )
    }

    // Paiement réussi - créer le document iCount (invrec)
    console.log('[PAY-DEPOSIT] Creating iCount document for payment')

    // Parser la validité pour extraire mois/année
    const validity = card_info.cc_validity.replace(/[^0-9]/g, '')
    const expMonth = parseInt(validity.slice(0, 2), 10)
    const expYear = 2000 + parseInt(validity.slice(2, 4), 10)

    const docResult = await provider.documents.createInvoiceReceipt({
      custom_client_id: order.contact_id || undefined,
      client_name: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
      email: order.customer_email || undefined,
      phone: order.customer_phone || undefined,
      items: [{
        description: `Acompte réservation ${order.request_reference}`,
        quantity: 1,
        unitprice_incvat: amount,
      }],
      cc: {
        sum: amount,
        card_type: billResult.data.cc_type,
        card_number: billResult.data.cc_last4,
        confirmation_code: billResult.data.confirmation_code,
        exp_month: expMonth,
        exp_year: expYear,
        holder_id: card_info.cc_holder_id,
        holder_name: card_info.cc_holder_name || `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
        num_of_payments: 1,
      },
      sanity_string: `dep_${order_id.slice(0, 20)}`,
      doc_lang: 'he',
    })

    let icountDoctype: string | null = null
    let icountDocnum: number | null = null
    let icountDocUrl: string | null = null

    if (docResult.success && docResult.data) {
      console.log('[PAY-DEPOSIT] iCount document created:', docResult.data.doctype, docResult.data.docnum)
      icountDoctype = docResult.data.doctype
      icountDocnum = docResult.data.docnum
      icountDocUrl = docResult.data.doc_url || null
    } else {
      // Log l'erreur mais on continue - le paiement a été effectué
      console.error('[PAY-DEPOSIT] Failed to create iCount document:', docResult.error)
    }

    // Créer l'enregistrement de paiement
    const paymentData = {
      order_id,
      booking_id: order.booking_id,
      contact_id: order.contact_id,
      branch_id: order.branch_id,
      amount,
      currency: 'ILS',
      payment_type: 'deposit',
      payment_method: 'card',
      status: 'completed',
      icount_transaction_id: billResult.data.transaction_id,
      icount_confirmation_code: billResult.data.confirmation_code,
      icount_doctype: icountDoctype,
      icount_docnum: icountDocnum,
      icount_doc_url: icountDocUrl,
      cc_last4: billResult.data.cc_last4,
      cc_type: billResult.data.cc_type,
      notes: 'Online deposit payment',
      processed_by: null, // Paiement automatique
    }

    const { data: payment, error: paymentError } = await supabase
      .from('payments')
      .insert(paymentData)
      .select()
      .single()

    if (paymentError) {
      // Le paiement a été effectué mais on n'arrive pas à l'enregistrer
      // C'est grave - on log et on continue quand même
      console.error('[PAY-DEPOSIT] Error recording payment:', paymentError)
    }

    // Mettre à jour la commande
    const updateData = {
      paid_amount: (order.paid_amount || 0) + amount,
      deposit_amount: amount,
      payment_status: 'deposit_paid',
      payment_method: 'card',
      paid_at: new Date().toISOString(),
      icount_transaction_id: billResult.data.transaction_id,
      icount_confirmation_code: billResult.data.confirmation_code,
      cc_last4: billResult.data.cc_last4,
      cc_type: billResult.data.cc_type,
    }

    const { error: updateError } = await supabase
      .from('orders')
      .update(updateData)
      .eq('id', order_id)

    if (updateError) {
      console.error('[PAY-DEPOSIT] Error updating order:', updateError)
    }

    // Retourner le succès
    return NextResponse.json({
      success: true,
      payment: {
        id: payment?.id,
        amount,
        confirmationCode: billResult.data.confirmation_code,
        ccLast4: billResult.data.cc_last4,
        ccType: billResult.data.cc_type,
        icountDocnum,
        icountDocUrl,
      },
      order: {
        id: order_id,
        reference: order.request_reference,
        paymentStatus: 'deposit_paid',
      },
    })

  } catch (error) {
    console.error('[PAY-DEPOSIT] Error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/terms/route.ts">
/**
 * API Route pour récupérer les Conditions Générales
 * GET /api/terms?lang=en|he|fr
 * Returns { game: string, event: string } avec le HTML des CGV
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

// Client Supabase public (pas besoin d'auth pour lire les CGV)
const getSupabase = () => {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const lang = searchParams.get('lang') || 'en'

    // Valider la langue
    const validLangs = ['en', 'he', 'fr']
    const langCode = validLangs.includes(lang) ? lang : 'en'

    const supabase = getSupabase()

    // Récupérer les templates CGV pour games et events
    const gameCode = `terms_game_${langCode}`
    const eventCode = `terms_event_${langCode}`

    const { data: templates, error } = await supabase
      .from('email_templates')
      .select('code, body_template')
      .in('code', [gameCode, eventCode])
      .eq('is_active', true)

    if (error) {
      console.error('Error fetching terms:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch terms' },
        { status: 500 }
      )
    }

    // Organiser les résultats
    const result: { game: string | null; event: string | null } = {
      game: null,
      event: null
    }

    for (const template of templates || []) {
      if (template.code === gameCode) {
        result.game = template.body_template
      } else if (template.code === eventCode) {
        result.event = template.body_template
      }
    }

    return NextResponse.json(result)

  } catch (error) {
    console.error('Error in terms API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/webhooks/brevo/route.ts">
/**
 * Brevo Webhook Handler
 * Receives webhook events from Brevo to update email delivery status
 *
 * Brevo events:
 * - request: Email submitted to Brevo
 * - delivered: Email delivered to recipient's mail server
 * - soft_bounce: Temporary delivery failure
 * - hard_bounce: Permanent delivery failure
 * - complaint: Recipient marked email as spam
 * - unique_opened: Email opened (first time)
 * - opened: Email opened
 * - click: Link clicked in email
 * - invalid_email: Email address invalid
 * - deferred: Delivery deferred
 * - blocked: Email blocked
 * - error: Sending error
 * - unsubscribed: Recipient unsubscribed
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient as createSupabaseClient } from '@supabase/supabase-js'

// Brevo webhook event types
type BrevoEventType =
  | 'request'
  | 'delivered'
  | 'soft_bounce'
  | 'hard_bounce'
  | 'complaint'
  | 'unique_opened'
  | 'opened'
  | 'click'
  | 'invalid_email'
  | 'deferred'
  | 'blocked'
  | 'error'
  | 'unsubscribed'

interface BrevoWebhookPayload {
  event: BrevoEventType
  email: string
  id: number // Campaign ID
  date: string // ISO date string
  ts: number // Unix timestamp
  'message-id': string // Brevo message ID
  ts_event: number
  subject?: string
  tag?: string
  sending_ip?: string
  ts_epoch?: number
  template_id?: number
  // Bounce specific
  reason?: string
  // Click specific
  link?: string
  // Error specific
  error_code?: string
}

// Map Brevo events to our email_logs status
function mapBrevoEventToStatus(event: BrevoEventType): 'pending' | 'sent' | 'delivered' | 'failed' | 'bounced' | null {
  switch (event) {
    case 'request':
      return 'sent'
    case 'delivered':
      return 'delivered'
    case 'soft_bounce':
    case 'hard_bounce':
    case 'complaint':
    case 'blocked':
      return 'bounced'
    case 'invalid_email':
    case 'error':
      return 'failed'
    case 'unique_opened':
    case 'opened':
    case 'click':
    case 'deferred':
    case 'unsubscribed':
      // These events don't change the delivery status
      return null
    default:
      return null
  }
}

// Get admin Supabase client
const getAdminSupabase = () => {
  return createSupabaseClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

export async function POST(request: NextRequest) {
  try {
    const payload = await request.json() as BrevoWebhookPayload

    console.log('[BREVO WEBHOOK] Received event:', payload.event)
    console.log('[BREVO WEBHOOK] Message ID:', payload['message-id'])
    console.log('[BREVO WEBHOOK] Email:', payload.email)

    // Validate required fields
    if (!payload.event || !payload['message-id']) {
      console.error('[BREVO WEBHOOK] Missing required fields')
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    const supabase = getAdminSupabase()
    const messageId = payload['message-id']

    // Find the email log by Brevo message ID (stored in metadata)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: emailLogs, error: findError } = await (supabase as any)
      .from('email_logs')
      .select('id, status, metadata')
      .eq('metadata->>brevo_message_id', messageId)

    if (findError) {
      console.error('[BREVO WEBHOOK] Error finding email log:', findError)
      // Return 200 to acknowledge receipt (Brevo will retry on non-200)
      return NextResponse.json({ received: true, processed: false })
    }

    if (!emailLogs || emailLogs.length === 0) {
      console.log('[BREVO WEBHOOK] No email log found for message ID:', messageId)
      // Return 200 to acknowledge receipt
      return NextResponse.json({ received: true, processed: false })
    }

    const emailLog = emailLogs[0]
    const newStatus = mapBrevoEventToStatus(payload.event)

    // Prepare update data
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateData: Record<string, any> = {
      metadata: {
        ...(emailLog.metadata || {}),
        brevo_last_event: payload.event,
        brevo_last_event_date: payload.date,
      }
    }

    // Update status if applicable
    if (newStatus) {
      updateData.status = newStatus

      // Add error message for failures
      if (newStatus === 'failed' || newStatus === 'bounced') {
        updateData.error_message = payload.reason || `Brevo event: ${payload.event}`
      }
    }

    // Add delivered timestamp
    if (newStatus === 'delivered') {
      updateData.metadata = {
        ...updateData.metadata,
        delivered_at: payload.date,
      }
    }

    // Update the email log
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { error: updateError } = await (supabase as any)
      .from('email_logs')
      .update(updateData)
      .eq('id', emailLog.id)

    if (updateError) {
      console.error('[BREVO WEBHOOK] Error updating email log:', updateError)
      return NextResponse.json({ received: true, processed: false })
    }

    console.log('[BREVO WEBHOOK] Updated email log:', emailLog.id, 'status:', newStatus || '(unchanged)')

    return NextResponse.json({
      received: true,
      processed: true,
      emailLogId: emailLog.id,
      newStatus: newStatus || 'unchanged'
    })

  } catch (error) {
    console.error('[BREVO WEBHOOK] Error processing webhook:', error)
    // Return 200 to acknowledge receipt (prevent Brevo retries)
    return NextResponse.json({ received: true, processed: false, error: 'Internal error' })
  }
}

// Brevo may also send GET requests to verify webhook URL
export async function GET() {
  return NextResponse.json({ status: 'ok', service: 'brevo-webhook' })
}
</file>

<file path="src/components/Clara/index.ts">
export { ClaraAssistant } from './ClaraAssistant'
export { ClaraButton } from './ClaraButton'
export { ClaraProvider, useClara } from './ClaraProvider'
</file>

<file path="src/components/ContactSection.tsx">
'use client'

import { useState } from 'react'
import { motion } from 'framer-motion'
import Image from 'next/image'
import { Send, Check, AlertCircle, Loader2 } from 'lucide-react'

interface ContactSectionProps {
  translations: {
    contact: {
      title: string
      subtitle: string
      form: {
        name: string
        email: string
        message: string
        send: string
      }
      info: {
        phone: string
        email: string
      }
    }
  }
}

type FormStatus = 'idle' | 'loading' | 'success' | 'error'

export default function ContactSection({ translations }: ContactSectionProps) {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: '',
  })
  const [status, setStatus] = useState<FormStatus>('idle')
  const [errorMessage, setErrorMessage] = useState('')

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setStatus('loading')
    setErrorMessage('')

    try {
      const response = await fetch('/api/contact', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      })

      if (response.ok) {
        setStatus('success')
        setFormData({ name: '', email: '', message: '' })
        // Reset to idle after 5 seconds
        setTimeout(() => setStatus('idle'), 5000)
      } else {
        const data = await response.json()
        setErrorMessage(data.error || 'An error occurred')
        setStatus('error')
      }
    } catch {
      setErrorMessage('Network error. Please try again.')
      setStatus('error')
    }
  }

  return (
    <section id="contact" className="py-10 md:py-16 relative overflow-hidden" style={{
      background: 'linear-gradient(135deg, rgba(0, 240, 255, 0.7) 0%, rgba(0, 240, 255, 0.6) 25%, rgba(0, 200, 255, 0.7) 50%, rgba(0, 240, 255, 0.6) 75%, rgba(0, 240, 255, 0.8) 100%)'
    }}>
      {/* Wave separator from previous section */}
      <div className="absolute top-0 left-0 right-0" style={{ transform: 'translateY(-100%)' }}>
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style={{ width: '100%', height: '60px', display: 'block' }}>
          <path d="M0,60 Q300,20 600,60 T1200,60 L1200,120 L0,120 Z" fill="rgba(0, 240, 255, 0.7)" />
        </svg>
      </div>
      
      {/* Background decorative elements */}
      <div className="absolute inset-0 opacity-95">
        <div className="absolute top-0 right-1/4 w-[700px] h-[700px] bg-primary/60 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '4s', animationDelay: '1s' }} />
        <div className="absolute bottom-0 left-1/4 w-[700px] h-[700px] bg-primary/50 rounded-full blur-[250px] animate-pulse" style={{ animationDuration: '5s' }} />
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[900px] h-[900px] bg-primary/40 rounded-full blur-[350px]" />
      </div>
      
      <div className="container mx-auto px-4 relative z-10">
        {/* Section Header */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          className="text-center mb-6"
        >
          <h2 className="section-title">{translations.contact.title}</h2>
          <p className="text-white max-w-2xl mx-auto text-lg" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
            {translations.contact.subtitle}
          </p>
        </motion.div>

        <div className="max-w-6xl mx-auto">
          {/* Contact Form */}
          <motion.div
            initial={{ opacity: 0, y: 30 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true }}
            className="max-w-2xl mx-auto"
          >
            <form onSubmit={handleSubmit} className="space-y-6">
              {/* Name */}
              <div>
                <label htmlFor="name" className="block text-white mb-2 text-sm" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
                  {translations.contact.form.name}
                </label>
                <input
                  type="text"
                  id="name"
                  value={formData.name}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  className="form-input backdrop-blur-sm border-primary/30"
                  required
                  style={{ fontFamily: 'Poppins, sans-serif', backgroundColor: 'rgba(50, 50, 70, 0.7)' }}
                />
              </div>

              {/* Email */}
              <div>
                <label htmlFor="email" className="block text-white mb-2 text-sm" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
                  {translations.contact.form.email}
                </label>
                <input
                  type="email"
                  id="email"
                  value={formData.email}
                  onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                  className="form-input backdrop-blur-sm border-primary/30"
                  required
                  style={{ fontFamily: 'Poppins, sans-serif', backgroundColor: 'rgba(50, 50, 70, 0.7)' }}
                />
              </div>

              {/* Message */}
              <div>
                <label htmlFor="message" className="block text-white mb-2 text-sm" style={{ fontFamily: 'Poppins, sans-serif', textShadow: '0 2px 4px rgba(0,0,0,0.3)' }}>
                  {translations.contact.form.message}
                </label>
                <textarea
                  id="message"
                  value={formData.message}
                  onChange={(e) => setFormData({ ...formData, message: e.target.value })}
                  rows={5}
                  className="form-input backdrop-blur-sm border-primary/30 resize-none"
                  required
                  style={{ fontFamily: 'Poppins, sans-serif', backgroundColor: 'rgba(50, 50, 70, 0.7)' }}
                />
              </div>

              {/* Submit Button */}
              <div className="flex flex-col items-center gap-3">
                <button
                  type="submit"
                  disabled={status === 'loading'}
                  className="glow-button w-auto px-8 flex items-center justify-center gap-2 text-dark font-semibold disabled:opacity-50 disabled:cursor-not-allowed"
                  style={{ fontFamily: 'Poppins, sans-serif' }}
                >
                  {status === 'loading' ? (
                    <Loader2 size={18} className="animate-spin" />
                  ) : status === 'success' ? (
                    <Check size={18} />
                  ) : (
                    <Send size={18} />
                  )}
                  {status === 'loading' ? 'Sending...' : status === 'success' ? 'Sent!' : translations.contact.form.send}
                </button>

                {status === 'success' && (
                  <motion.p
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="text-green-300 text-sm flex items-center gap-2"
                  >
                    <Check size={16} />
                    Message sent successfully!
                  </motion.p>
                )}

                {status === 'error' && (
                  <motion.p
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="text-red-300 text-sm flex items-center gap-2"
                  >
                    <AlertCircle size={16} />
                    {errorMessage}
                  </motion.p>
                )}
              </div>
            </form>
          </motion.div>
        </div>
      </div>
    </section>
  )
}
</file>

<file path="src/contexts/LanguageContext.tsx">
'use client'

import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, ReactNode } from 'react'
import {
  Locale,
  locales,
  defaultLocale,
  defaultAdminLocale,
  getTranslations,
  getDirection,
  languageNames,
  languageFlags,
  PUBLIC_LOCALE_KEY,
  ADMIN_LOCALE_KEY,
} from '@/i18n'

// Type pour les traductions (structure flexible pour supporter les JSON imbriqués)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type Translations = Record<string, any>

interface LanguageContextType {
  locale: Locale
  setLocale: (locale: Locale) => void
  t: (key: string, params?: Record<string, string | number>) => string
  tArray: (key: string) => string[]
  direction: 'ltr' | 'rtl'
  isRTL: boolean
  languageNames: Record<Locale, string>
  languageFlags: Record<Locale, string>
  availableLocales: readonly Locale[]
}

const LanguageContext = createContext<LanguageContextType | null>(null)

interface LanguageProviderProps {
  children: ReactNode
  isAdmin?: boolean // Pour distinguer site public vs CRM
  initialLocale?: Locale
}

export function LanguageProvider({ children, isAdmin = false, initialLocale }: LanguageProviderProps) {
  const storageKey = isAdmin ? ADMIN_LOCALE_KEY : PUBLIC_LOCALE_KEY
  const defaultLang = isAdmin ? defaultAdminLocale : defaultLocale

  const [locale, setLocaleState] = useState<Locale>(initialLocale || defaultLang)
  const [translations, setTranslations] = useState<Translations>(() => getTranslations(initialLocale || defaultLang))
  const [isInitialized, setIsInitialized] = useState(false)

  // Charger la langue depuis localStorage au montage
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedLocale = localStorage.getItem(storageKey) as Locale | null
      if (savedLocale && locales.includes(savedLocale)) {
        setLocaleState(savedLocale)
        setTranslations(getTranslations(savedLocale))
      }
      setIsInitialized(true)
    }
  }, [storageKey])

  // Mettre à jour les attributs HTML quand la langue change
  useEffect(() => {
    if (typeof window !== 'undefined' && isInitialized) {
      const dir = getDirection(locale)
      document.documentElement.dir = dir
      document.documentElement.lang = locale
    }
  }, [locale, isInitialized])

  // Fonction pour changer de langue
  const setLocale = useCallback((newLocale: Locale) => {
    if (locales.includes(newLocale)) {
      setLocaleState(newLocale)
      setTranslations(getTranslations(newLocale))
      if (typeof window !== 'undefined') {
        localStorage.setItem(storageKey, newLocale)
      }
    }
  }, [storageKey])

  // Fonction de traduction avec support des clés nested (ex: "admin.sidebar.agenda")
  const t = useCallback((key: string, params?: Record<string, string | number>): string => {
    const keys = key.split('.')
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let value: any = translations

    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = value[k]
      } else {
        // Clé non trouvée, retourner la clé elle-même
        return key
      }
    }

    if (typeof value !== 'string') {
      return key
    }

    // Remplacer les paramètres {{param}}
    if (params) {
      let result = value
      for (const [paramKey, paramValue] of Object.entries(params)) {
        result = result.replace(new RegExp(`{{${paramKey}}}`, 'g'), String(paramValue))
      }
      return result
    }

    return value
  }, [translations])

  // Fonction pour récupérer des tableaux de traductions
  const tArray = useCallback((key: string): string[] => {
    const keys = key.split('.')
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let value: any = translations

    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = value[k]
      } else {
        return []
      }
    }

    if (Array.isArray(value)) {
      return value
    }
    return []
  }, [translations])

  const direction = useMemo(() => getDirection(locale), [locale])
  const isRTL = useMemo(() => direction === 'rtl', [direction])

  const contextValue = useMemo<LanguageContextType>(() => ({
    locale,
    setLocale,
    t,
    tArray,
    direction,
    isRTL,
    languageNames,
    languageFlags,
    availableLocales: locales,
  }), [locale, setLocale, t, tArray, direction, isRTL])

  return (
    <LanguageContext.Provider value={contextValue}>
      {children}
    </LanguageContext.Provider>
  )
}

// Hook personnalisé pour utiliser les traductions
export function useTranslation() {
  const context = useContext(LanguageContext)
  if (!context) {
    throw new Error('useTranslation must be used within a LanguageProvider')
  }
  return context
}

// Hook pour accéder seulement à la fonction t (optimisation)
export function useT() {
  const { t } = useTranslation()
  return t
}
</file>

<file path="src/hooks/useBranches.ts">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { getClient } from '@/lib/supabase/client'
import type { Branch, BranchSettings, EventRoom, LaserRoom } from '@/lib/supabase/types'

interface BranchWithDetails extends Branch {
  settings: BranchSettings | null
  rooms: EventRoom[]
  laserRooms: LaserRoom[]
}

export function useBranches() {
  const [branches, setBranches] = useState<BranchWithDetails[]>([])
  // Ne pas charger depuis localStorage au début - on le fera après avoir chargé les branches autorisées
  const [selectedBranchId, setSelectedBranchId] = useState<string | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  // Persister la branche sélectionnée dans localStorage
  useEffect(() => {
    if (selectedBranchId) {
      localStorage.setItem('selectedBranchId', selectedBranchId)
    }
  }, [selectedBranchId])

  // Charger les branches avec leurs détails
  const fetchBranches = useCallback(async () => {
    const supabase = getClient()
    setLoading(true)
    setError(null)

    try {
      // Récupérer l'utilisateur et ses branches autorisées
      const { data: { user: authUser } } = await supabase.auth.getUser()
      
      if (!authUser) {
        setBranches([])
        setLoading(false)
        return
      }

      // Récupérer le rôle de l'utilisateur
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('id', authUser.id)
        .single<{ role: string }>()

      if (profileError) {
        throw profileError
      }

      let branchesData: Branch[] = []

      if (profile?.role === 'super_admin') {
        // Super admin voit toutes les branches
        const { data, error: branchesError } = await supabase
          .from('branches')
          .select('*')
          .eq('is_active', true)
          .order('name')
          .returns<Branch[]>()

        if (branchesError) throw branchesError
        branchesData = data || []
      } else {
        // Branch admin et agent voient uniquement leurs branches assignées
        const { data: userBranches, error: userBranchesError } = await supabase
          .from('user_branches')
          .select('branch_id')
          .eq('user_id', authUser.id)
          .returns<Array<{ branch_id: string }>>()

        if (userBranchesError) {
          throw userBranchesError
        }

        if (userBranches && userBranches.length > 0) {
          const branchIds = userBranches.map((ub: { branch_id: string }) => ub.branch_id)
          const { data, error: branchesError } = await supabase
            .from('branches')
            .select('*')
            .in('id', branchIds)
            .eq('is_active', true)
            .order('name')
            .returns<Branch[]>()

          if (branchesError) throw branchesError
          branchesData = data || []
        }
      }

      if (!branchesData || branchesData.length === 0) {
        setBranches([])
        setLoading(false)
        return
      }

      // Charger TOUTES les données en parallèle (3 requêtes au total au lieu de 3 par branche)
      const branchIds = branchesData.map(b => b.id)

      const [settingsResult, roomsResult, laserRoomsResult] = await Promise.all([
        supabase
          .from('branch_settings')
          .select('*')
          .in('branch_id', branchIds)
          .returns<BranchSettings[]>(),
        supabase
          .from('event_rooms')
          .select('*')
          .in('branch_id', branchIds)
          .eq('is_active', true)
          .order('sort_order')
          .returns<EventRoom[]>(),
        supabase
          .from('laser_rooms')
          .select('*')
          .in('branch_id', branchIds)
          .eq('is_active', true)
          .order('sort_order')
          .returns<LaserRoom[]>()
      ])

      const allSettings = settingsResult.data || []
      const allRooms = roomsResult.data || []
      const allLaserRooms = laserRoomsResult.data || []

      // Mapper les données par branche (en mémoire, rapide)
      const branchesWithDetails: BranchWithDetails[] = branchesData.map(branch => ({
        ...branch,
        settings: allSettings.find(s => s.branch_id === branch.id) || null,
        rooms: allRooms.filter(r => r.branch_id === branch.id),
        laserRooms: allLaserRooms.filter(lr => lr.branch_id === branch.id),
      }))

      setBranches(branchesWithDetails)

      // Sélectionner automatiquement la branche appropriée
      setSelectedBranchId(prev => {
        if (branchesWithDetails.length === 0) {
          return null
        }

        // Si une seule branche (branch_admin avec 1 branche), la sélectionner
        if (branchesWithDetails.length === 1) {
          return branchesWithDetails[0].id
        }

        // Si une branche était déjà sélectionnée, vérifier qu'elle est toujours autorisée
        if (prev) {
          const isStillAuthorized = branchesWithDetails.some(b => b.id === prev)
          if (isStillAuthorized) {
            return prev // Garder la sélection actuelle si elle est toujours valide
          }
          // Sinon, la branche n'est plus autorisée (changement de rôle/permissions), réinitialiser
        }

        // Vérifier si on a une branche sauvegardée dans localStorage qui est autorisée
        if (typeof window !== 'undefined') {
          const saved = localStorage.getItem('selectedBranchId')
          if (saved && branchesWithDetails.some(b => b.id === saved)) {
            return saved // Utiliser la branche sauvegardée si elle est autorisée
          }
        }

        // Sinon, chercher Rishon LeZion en priorité (pour super_admin)
        const rishonBranch = branchesWithDetails.find(
          b => b.slug === 'rishon-lezion' || 
               b.name.toLowerCase().includes('rishon') ||
               b.name.toLowerCase().includes('rly')
        )
        
        // Si Rishon trouvé, l'utiliser, sinon première branche
        return rishonBranch?.id || branchesWithDetails[0].id
      })
    } catch (err) {
      console.error('Error fetching branches:', err)
      setError('Erreur lors du chargement des agences')
    } finally {
      setLoading(false)
    }
  }, []) // Plus de dépendance sur selectedBranchId

  useEffect(() => {
    fetchBranches()
  }, [fetchBranches])

  // Branche actuellement sélectionnée
  const selectedBranch = branches.find(b => b.id === selectedBranchId) || null

  // Changer de branche
  const selectBranch = useCallback((branchId: string) => {
    setSelectedBranchId(branchId)
  }, [])

  return {
    branches,
    selectedBranch,
    selectedBranchId,
    selectBranch,
    loading,
    error,
    refresh: fetchBranches,
  }
}
</file>

<file path="src/hooks/useEmails.ts">
/**
 * Hook pour gérer les emails (historique et envoi)
 */

import { useState, useEffect, useCallback } from 'react'
import type { EmailLog, EmailLogWithRelations } from '@/lib/supabase/types'

interface EmailFilters {
  status?: string
  branchId?: string
  entityType?: string
  search?: string
  dateFrom?: string
  dateTo?: string
}

interface EmailsResponse {
  success: boolean
  data: EmailLog[]
  pagination: {
    total: number
    page: number
    limit: number
    totalPages: number
  }
  error?: string
}

interface UseEmailsReturn {
  emails: EmailLog[]
  loading: boolean
  error: string | null
  pagination: {
    total: number
    page: number
    limit: number
    totalPages: number
  }
  filters: EmailFilters
  setFilters: (filters: EmailFilters) => void
  setPage: (page: number) => void
  refresh: () => Promise<void>
  resendEmail: (emailLogId: string) => Promise<{ success: boolean; error?: string }>
  sendConfirmation: (bookingId: string) => Promise<{ success: boolean; error?: string }>
  deleteEmail: (emailLogId: string) => Promise<{ success: boolean; error?: string }>
  stats: {
    total: number
    sent: number
    failed: number
    pending: number
  }
}

export function useEmails(initialBranchId?: string): UseEmailsReturn {
  const [emails, setEmails] = useState<EmailLog[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [pagination, setPagination] = useState({
    total: 0,
    page: 1,
    limit: 20,
    totalPages: 0
  })
  const [filters, setFilters] = useState<EmailFilters>({
    branchId: initialBranchId
  })

  // Calculate stats from emails
  const stats = {
    total: pagination.total,
    sent: emails.filter(e => e.status === 'sent' || e.status === 'delivered').length,
    failed: emails.filter(e => e.status === 'failed' || e.status === 'bounced').length,
    pending: emails.filter(e => e.status === 'pending').length
  }

  // Fetch emails
  const fetchEmails = useCallback(async () => {
    setLoading(true)
    setError(null)

    try {
      const params = new URLSearchParams()
      params.set('page', pagination.page.toString())
      params.set('limit', pagination.limit.toString())

      if (filters.status) params.set('status', filters.status)
      if (filters.branchId) params.set('branch_id', filters.branchId)
      if (filters.entityType) params.set('entity_type', filters.entityType)
      if (filters.search) params.set('search', filters.search)
      if (filters.dateFrom) params.set('date_from', filters.dateFrom)
      if (filters.dateTo) params.set('date_to', filters.dateTo)

      const response = await fetch(`/api/emails?${params.toString()}`)
      const data: EmailsResponse = await response.json()

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch emails')
      }

      setEmails(data.data)
      setPagination(data.pagination)

    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch emails'
      setError(message)
      console.error('Error fetching emails:', err)
    } finally {
      setLoading(false)
    }
  }, [pagination.page, pagination.limit, filters])

  // Initial fetch and when filters change
  useEffect(() => {
    fetchEmails()
  }, [fetchEmails])

  // Resend an email
  const resendEmail = async (emailLogId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch('/api/emails', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'resend', emailLogId })
      })

      const data = await response.json()

      if (!data.success) {
        return { success: false, error: data.error }
      }

      // Refresh the list
      await fetchEmails()

      return { success: true }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to resend email'
      return { success: false, error: message }
    }
  }

  // Send confirmation email for a booking
  const sendConfirmation = async (bookingId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch('/api/emails', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'send_confirmation', bookingId })
      })

      const data = await response.json()

      if (!data.success) {
        return { success: false, error: data.error }
      }

      // Refresh the list
      await fetchEmails()

      return { success: true }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to send email'
      return { success: false, error: message }
    }
  }

  // Delete an email log
  const deleteEmail = async (emailLogId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/emails/${emailLogId}`, {
        method: 'DELETE'
      })

      const data = await response.json()

      if (!data.success) {
        return { success: false, error: data.error }
      }

      // Refresh the list
      await fetchEmails()

      return { success: true }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to delete email'
      return { success: false, error: message }
    }
  }

  // Update filters (reset to page 1)
  const updateFilters = (newFilters: EmailFilters) => {
    setFilters(newFilters)
    setPagination(prev => ({ ...prev, page: 1 }))
  }

  // Set page
  const setPage = (page: number) => {
    setPagination(prev => ({ ...prev, page }))
  }

  return {
    emails,
    loading,
    error,
    pagination,
    filters,
    setFilters: updateFilters,
    setPage,
    refresh: fetchEmails,
    resendEmail,
    sendConfirmation,
    deleteEmail,
    stats
  }
}
</file>

<file path="src/hooks/useEmailTemplates.ts">
/**
 * Hook pour gérer les templates d'emails
 */

import { useState, useEffect, useCallback } from 'react'
import type { EmailTemplate } from '@/lib/supabase/types'

interface UseEmailTemplatesReturn {
  templates: EmailTemplate[]
  loading: boolean
  error: string | null
  refresh: () => Promise<void>
  createTemplate: (data: Partial<EmailTemplate>) => Promise<{ success: boolean; data?: EmailTemplate; error?: string }>
  updateTemplate: (id: string, data: Partial<EmailTemplate>) => Promise<{ success: boolean; error?: string }>
  deleteTemplate: (id: string) => Promise<{ success: boolean; error?: string }>
  getTemplate: (id: string) => Promise<{ success: boolean; data?: EmailTemplate; error?: string }>
}

export function useEmailTemplates(): UseEmailTemplatesReturn {
  const [templates, setTemplates] = useState<EmailTemplate[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Fetch templates
  const fetchTemplates = useCallback(async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/email-templates')
      const data = await response.json()

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch templates')
      }

      setTemplates(data.data)

    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch templates'
      setError(message)
      console.error('Error fetching templates:', err)
    } finally {
      setLoading(false)
    }
  }, [])

  // Initial fetch
  useEffect(() => {
    fetchTemplates()
  }, [fetchTemplates])

  // Create template
  const createTemplate = async (data: Partial<EmailTemplate>): Promise<{ success: boolean; data?: EmailTemplate; error?: string }> => {
    try {
      const response = await fetch('/api/email-templates', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      const result = await response.json()

      if (!result.success) {
        return { success: false, error: result.error }
      }

      await fetchTemplates()
      return { success: true, data: result.data }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create template'
      return { success: false, error: message }
    }
  }

  // Update template
  const updateTemplate = async (id: string, data: Partial<EmailTemplate>): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/email-templates/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      const result = await response.json()

      if (!result.success) {
        return { success: false, error: result.error }
      }

      await fetchTemplates()
      return { success: true }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to update template'
      return { success: false, error: message }
    }
  }

  // Delete template
  const deleteTemplate = async (id: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/email-templates/${id}`, {
        method: 'DELETE'
      })

      const result = await response.json()

      if (!result.success) {
        return { success: false, error: result.error }
      }

      await fetchTemplates()
      return { success: true }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to delete template'
      return { success: false, error: message }
    }
  }

  // Get single template
  const getTemplate = async (id: string): Promise<{ success: boolean; data?: EmailTemplate; error?: string }> => {
    try {
      const response = await fetch(`/api/email-templates/${id}`)
      const result = await response.json()

      if (!result.success) {
        return { success: false, error: result.error }
      }

      return { success: true, data: result.data }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to get template'
      return { success: false, error: message }
    }
  }

  return {
    templates,
    loading,
    error,
    refresh: fetchTemplates,
    createTemplate,
    updateTemplate,
    deleteTemplate,
    getTemplate
  }
}
</file>

<file path="src/hooks/useInactivityTimeout.ts">
'use client'

import { useEffect, useRef, useCallback } from 'react'
import { useRouter, usePathname } from 'next/navigation'
import { getClient } from '@/lib/supabase/client'

const INACTIVITY_TIMEOUT = 5 * 60 * 1000 // 5 minutes en millisecondes
const LAST_ACTIVITY_KEY = 'last_activity_timestamp'

export function useInactivityTimeout() {
  const router = useRouter()
  const pathname = usePathname()
  const timeoutRef = useRef<NodeJS.Timeout | null>(null)
  const isLoggingOutRef = useRef(false)
  const isLoginPage = pathname === '/admin/login'

  const logout = useCallback(async () => {
    // Éviter les appels multiples
    if (isLoggingOutRef.current) return
    isLoggingOutRef.current = true

    const supabase = getClient()

    // Nettoyer le timestamp
    localStorage.removeItem(LAST_ACTIVITY_KEY)

    // Logger la déconnexion pour inactivité
    try {
      await fetch('/api/auth/log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'logout_inactivity' })
      })
    } catch (e) {
      console.error('Failed to log inactivity logout:', e)
    }

    await supabase.auth.signOut()
    router.push('/admin/login')
  }, [router])

  const updateLastActivity = useCallback(() => {
    localStorage.setItem(LAST_ACTIVITY_KEY, Date.now().toString())
  }, [])

  const checkInactivity = useCallback(() => {
    const lastActivity = localStorage.getItem(LAST_ACTIVITY_KEY)
    if (lastActivity) {
      const elapsed = Date.now() - parseInt(lastActivity, 10)
      if (elapsed > INACTIVITY_TIMEOUT) {
        // Plus de 5 minutes d'inactivité - déconnecter
        logout()
        return true
      }
    }
    return false
  }, [logout])

  const resetTimer = useCallback(() => {
    // Mettre à jour le timestamp de dernière activité
    updateLastActivity()

    // Clear existing timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }

    // Set new timeout
    timeoutRef.current = setTimeout(() => {
      logout()
    }, INACTIVITY_TIMEOUT)
  }, [logout, updateLastActivity])

  useEffect(() => {
    // Skip sur la page login
    if (isLoginPage) return

    // Vérifier immédiatement si la session a expiré (fermeture navigateur, etc.)
    if (checkInactivity()) {
      return // Déjà en cours de déconnexion
    }

    // Events qui indiquent une activité utilisateur
    const events = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart', 'click']

    // Reset timer on any activity
    const handleActivity = () => {
      resetTimer()
    }

    // Add event listeners
    events.forEach(event => {
      document.addEventListener(event, handleActivity, { passive: true })
    })

    // Start initial timer
    resetTimer()

    // Handle visibility change (tab switch, browser minimize)
    const handleVisibilityChange = () => {
      if (!document.hidden) {
        // Tab redevient visible - vérifier si on a dépassé le timeout
        if (!checkInactivity()) {
          resetTimer()
        }
      }
    }
    document.addEventListener('visibilitychange', handleVisibilityChange)

    // Cleanup
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
      events.forEach(event => {
        document.removeEventListener(event, handleActivity)
      })
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [resetTimer, checkInactivity, isLoginPage])
}
</file>

<file path="src/hooks/useLaserRooms.ts">
'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { getClient } from '@/lib/supabase/client'
import type { LaserRoom } from '@/lib/supabase/types'
import type { PostgrestError } from '@supabase/supabase-js'

export function useLaserRooms(branchId: string | null) {
  const [laserRooms, setLaserRooms] = useState<LaserRoom[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const lastBranchIdRef = useRef<string | null>(null)

  // Charger les laser rooms
  const fetchLaserRooms = useCallback(async () => {
    if (!branchId) {
      setLaserRooms([])
      setLoading(false)
      return
    }

    const supabase = getClient()
    setLoading(true)
    setError(null)

    try {
      const { data, error: fetchError } = await supabase
        .from('laser_rooms')
        .select('*')
        .eq('branch_id', branchId)
        .eq('is_active', true)
        .order('sort_order')
        .returns<LaserRoom[]>()

      // Si la table n'existe pas encore (migration non exécutée), retourner un tableau vide
      if (fetchError) {
        // Code 42P01 = table does not exist
        const errorCode = fetchError.code || ''
        const errorMessage = String(fetchError.message || '')
        
        // Vérifier si l'erreur est un objet vide
        const isEmptyError = (
          !errorMessage || 
          errorMessage === '{}' || 
          errorMessage === '[object Object]' ||
          (typeof fetchError === 'object' && fetchError !== null && Object.keys(fetchError).length === 0)
        )
        
        // Vérifier si c'est une erreur de table inexistante
        const isTableNotExist = 
          isEmptyError ||
          errorCode === '42P01' || 
          errorMessage.toLowerCase().includes('does not exist') || 
          errorMessage.toLowerCase().includes('n\'existe pas') || 
          (errorMessage.toLowerCase().includes('relation') && errorMessage.toLowerCase().includes('does not exist')) ||
          (errorMessage.toLowerCase().includes('table') && errorMessage.toLowerCase().includes('not found'))
        
        if (isTableNotExist) {
          // Ne pas logger, juste retourner un tableau vide silencieusement
          setLaserRooms([])
          setError(null) // Pas d'erreur, juste pas de données
          setLoading(false)
          return
        } else {
          throw fetchError
        }
      } else {
        setLaserRooms(data || [])
        setError(null)
      }
    } catch (err) {
      // Vérifier si c'est une erreur de table inexistante
      const errorObj = err as PostgrestError
      const errorCode = String(errorObj?.code || '')
      const errorMessage = String(errorObj?.message || '')
      
      // Si l'erreur est un objet vide ou une chaîne vide, considérer que c'est probablement une table inexistante
      const isEmptyError = (
        !errorMessage || 
        errorMessage === '{}' || 
        errorMessage === '[object Object]' || 
        (typeof err === 'object' && err !== null && Object.keys(err).length === 0) ||
        (errorObj && typeof errorObj === 'object' && Object.keys(errorObj).length === 0)
      )
      
      // Vérifier si c'est une erreur de table inexistante
      const isTableNotExist = 
        isEmptyError ||
        errorCode === '42P01' || 
        errorMessage.toLowerCase().includes('does not exist') || 
        errorMessage.toLowerCase().includes('n\'existe pas') || 
        (errorMessage.toLowerCase().includes('relation') && errorMessage.toLowerCase().includes('does not exist')) ||
        (errorMessage.toLowerCase().includes('table') && errorMessage.toLowerCase().includes('not found')) ||
        (errorMessage.toLowerCase().includes('relation') && errorMessage.toLowerCase().includes('does not exist'))
      
      if (isTableNotExist) {
        // Ne pas logger d'erreur si c'est juste que la table n'existe pas encore
        // Juste retourner un tableau vide silencieusement
        setLaserRooms([])
        setError(null)
      } else {
        // Logger seulement les vraies erreurs (pas les tables inexistantes)
        // Mais seulement si le message d'erreur n'est pas vide et n'est pas un objet vide
        if (errorMessage && errorMessage !== '{}' && errorMessage !== '[object Object]' && !isEmptyError) {
          console.error('Error fetching laser rooms:', err)
          setError(errorMessage || 'Erreur lors du chargement des salles laser')
        } else {
          // Si c'est un objet vide, traiter comme table inexistante (ne pas logger)
          setLaserRooms([])
          setError(null)
          setLoading(false)
          return
        }
        setLaserRooms([])
      }
    } finally {
      setLoading(false)
    }
  }, [branchId])

  // Charger quand branchId change (pas à chaque recréation de fetchLaserRooms)
  useEffect(() => {
    // Éviter les appels redondants si branchId n'a pas changé
    if (branchId === lastBranchIdRef.current) {
      return
    }
    lastBranchIdRef.current = branchId
    fetchLaserRooms()
  }, [branchId, fetchLaserRooms])

  // Vérifier disponibilité d'une laser room sur un créneau
  const checkLaserRoomAvailability = useCallback(async (
    roomId: string,
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string
  ): Promise<boolean> => {
    if (!branchId) return false

    const supabase = getClient()
    try {
      // Chercher les game_sessions qui utilisent cette salle sur ce créneau
      type SessionResult = { id: string; booking_id: string }
      const { data, error } = await supabase
        .from('game_sessions')
        .select('id, booking_id')
        .eq('laser_room_id', roomId)
        .eq('game_area', 'LASER')
        .lt('start_datetime', endDateTime.toISOString())
        .gt('end_datetime', startDateTime.toISOString())
        .returns<SessionResult[]>()

      if (error) throw error

      // Si excludeBookingId est fourni, filtrer ce booking
      if (excludeBookingId && data) {
        const { data: bookingSessions } = await supabase
          .from('game_sessions')
          .select('id')
          .eq('booking_id', excludeBookingId)
          .returns<Array<{ id: string }>>()

        if (bookingSessions) {
          const sessionIds = bookingSessions.map((s) => s.id)
          const filtered = data.filter((s) => !sessionIds.includes(s.id))
          return filtered.length === 0
        }
      }

      return !data || data.length === 0
    } catch (err) {
      console.error('Error checking laser room availability:', err)
      return false
    }
  }, [branchId])

  // Calculer contrainte vests sur un créneau
  const calculateVestsUsage = useCallback(async (
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string,
    targetBranchId?: string | null
  ): Promise<number> => {
    const branchIdToUse = targetBranchId || branchId
    if (!branchIdToUse) return 0

    const supabase = getClient()
    try {
      // Chercher toutes les game_sessions LASER qui chevauchent ce créneau
      // IMPORTANT : Filtrer SEULEMENT les sessions avec game_area = 'LASER'
      // Les sessions ACTIVE ne doivent PAS être prises en compte ici
      // Les grilles ACTIVE et LASER sont complètement indépendantes
      type SessionResult = { id: string; booking_id: string }
      const { data: sessions, error } = await supabase
        .from('game_sessions')
        .select('id, booking_id')
        .eq('game_area', 'LASER') // FILTRE CRITIQUE : Seulement LASER, pas ACTIVE
        .lt('start_datetime', endDateTime.toISOString())
        .gt('end_datetime', startDateTime.toISOString())
        .returns<SessionResult[]>()

      if (error) throw error

      if (!sessions || sessions.length === 0) return 0

      // Si excludeBookingId est fourni, exclure TOUTES les sessions de ce booking
      // IMPORTANT : Cela permet de modifier une réservation sans qu'elle se bloque elle-même
      let filteredSessions = sessions
      if (excludeBookingId && typeof excludeBookingId === 'string' && excludeBookingId.trim() !== '') {
        // Filtrer toutes les sessions qui appartiennent au booking à exclure
        filteredSessions = sessions.filter((s) => s.booking_id !== excludeBookingId)
      }

      if (filteredSessions.length === 0) return 0

      // Charger les bookings pour obtenir participants_count ET branch_id
      // IMPORTANT : On compte participants_count du booking entier, mais SEULEMENT pour les bookings
      // qui ont des sessions LASER sur ce créneau ET qui appartiennent à la branche cible
      const bookingIds = [...new Set(filteredSessions.map((s) => s.booking_id))]
      const { data: bookings } = await supabase
        .from('bookings')
        .select('id, participants_count, branch_id')
        .in('id', bookingIds)
        .eq('branch_id', branchIdToUse) // FILTRE CRITIQUE : Seulement les bookings de la branche cible
        .returns<Array<{ id: string; participants_count: number; branch_id: string }>>()

      if (!bookings) return 0

      // Calculer le total des participants UNIQUEMENT pour les bookings avec sessions LASER de cette branche
      // IMPORTANT : Si un booking a à la fois des sessions ACTIVE et LASER (booking mixte),
      // on compte quand même le total car tous les participants peuvent utiliser les vestes LASER
      // Les grilles ACTIVE et LASER sont indépendantes : un participant peut jouer ACTIVE
      // et ne pas utiliser de veste LASER, ou vice versa
      const totalParticipants = bookings.reduce((sum, booking) => {
        return sum + booking.participants_count
      }, 0)

      return totalParticipants
    } catch (err) {
      console.error('Error calculating vests usage:', {
        error: err,
        message: err instanceof Error ? err.message : 'Unknown error',
        branchId: branchIdToUse,
        startDateTime: startDateTime.toISOString(),
        endDateTime: endDateTime.toISOString(),
        excludeBookingId
      })
      return 0
    }
  }, [branchId])

  return {
    laserRooms,
    loading,
    error,
    refresh: fetchLaserRooms,
    checkLaserRoomAvailability,
    calculateVestsUsage,
  }
}
</file>

<file path="src/hooks/useOrders.ts">
'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { useRealtimeRefresh } from './useRealtimeSubscription'
import type { Order, OrderStatus, OrderWithRelations } from '@/lib/supabase/types'

interface OrdersStats {
  total: number
  pending: number
  auto_confirmed: number
  manually_confirmed: number
  cancelled: number
}

export function useOrders(branchId: string | null) {
  const [orders, setOrders] = useState<OrderWithRelations[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [pendingCount, setPendingCount] = useState(0)
  const [stats, setStats] = useState<OrdersStats>({
    total: 0,
    pending: 0,
    auto_confirmed: 0,
    manually_confirmed: 0,
    cancelled: 0
  })

  // Charger les commandes
  const fetchOrders = useCallback(async (statusFilter?: OrderStatus) => {
    if (!branchId) {
      setOrders([])
      setLoading(false)
      return
    }

    setLoading(true)
    setError(null)

    try {
      let url = `/api/orders?branch_id=${branchId}`
      if (statusFilter) {
        url += `&status=${statusFilter}`
      }

      const response = await fetch(url)
      const data = await response.json()

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch orders')
      }

      setOrders(data.orders || [])
      setPendingCount(data.pending_count || 0)

      // Calculer les stats
      const allOrders = data.orders || []
      setStats({
        total: allOrders.length,
        pending: allOrders.filter((o: Order) => o.status === 'pending').length,
        auto_confirmed: allOrders.filter((o: Order) => o.status === 'auto_confirmed').length,
        manually_confirmed: allOrders.filter((o: Order) => o.status === 'manually_confirmed').length,
        cancelled: allOrders.filter((o: Order) => o.status === 'cancelled').length,
      })

    } catch (err) {
      console.error('Error fetching orders:', err)
      setError('Erreur lors du chargement des commandes')
    } finally {
      setLoading(false)
    }
  }, [branchId])

  useEffect(() => {
    fetchOrders()
  }, [fetchOrders])

  // Realtime: écouter les changements sur orders
  // Mise à jour instantanée quand une commande est créée/modifiée
  useRealtimeRefresh('orders', branchId, fetchOrders)

  // Annuler une commande
  const cancelOrder = useCallback(async (orderId: string): Promise<boolean> => {
    setError(null)
    try {
      const response = await fetch(`/api/orders/${orderId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'cancel' })
      })

      const data = await response.json()
      if (!data.success) {
        throw new Error(data.error || 'Failed to cancel order')
      }

      await fetchOrders()
      return true
    } catch (err) {
      console.error('Error cancelling order:', err)
      setError('Erreur lors de l\'annulation')
      return false
    }
  }, [fetchOrders])

  // Supprimer une commande
  const deleteOrder = useCallback(async (orderId: string): Promise<boolean> => {
    setError(null)
    try {
      const response = await fetch(`/api/orders/${orderId}`, {
        method: 'DELETE'
      })

      const data = await response.json()
      if (!data.success) {
        throw new Error(data.error || 'Failed to delete order')
      }

      await fetchOrders()
      return true
    } catch (err) {
      console.error('Error deleting order:', err)
      setError('Erreur lors de la suppression')
      return false
    }
  }, [fetchOrders])

  return {
    orders,
    loading,
    error,
    pendingCount,
    stats,
    fetchOrders,
    cancelOrder,
    deleteOrder,
    refresh: fetchOrders
  }
}

// Hook pour obtenir juste le count des pending (pour le badge)
export function usePendingOrdersCount(branchId: string | null) {
  const [count, setCount] = useState(0)
  const lastBranchIdRef = useRef<string | null>(null)
  const isFetchingRef = useRef(false)

  const fetchCount = useCallback(async () => {
    if (!branchId) {
      setCount(0)
      return
    }

    // Éviter les appels concurrents
    if (isFetchingRef.current) {
      return
    }

    isFetchingRef.current = true
    try {
      const response = await fetch(`/api/orders?branch_id=${branchId}&status=pending`)
      const data = await response.json()
      setCount(data.pending_count || data.orders?.length || 0)
    } catch (err) {
      console.error('Error fetching pending count:', err)
    } finally {
      isFetchingRef.current = false
    }
  }, [branchId])

  // Fetch quand branchId change (avec déduplication)
  useEffect(() => {
    if (branchId === lastBranchIdRef.current) {
      return
    }
    lastBranchIdRef.current = branchId
    fetchCount()
  }, [branchId, fetchCount])

  // Realtime: mise à jour instantanée du badge
  // Remplace le polling de 30 secondes
  useRealtimeRefresh('orders', branchId, fetchCount)

  return count
}
</file>

<file path="src/hooks/usePermissions.ts">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRealtimeRefresh } from './useRealtimeSubscription'
import type { RolePermission, UserRole, ResourceType, PermissionSet, PermissionsByResource } from '@/lib/supabase/types'

interface UsePermissionsReturn {
  permissions: RolePermission[]
  loading: boolean
  error: string | null
  permissionsByRole: Record<UserRole, PermissionsByResource>
  updatePermission: (rolePermissionId: string, updates: Partial<PermissionSet>) => Promise<boolean>
  savePermissions: (changes: Array<{ id: string; updates: Partial<PermissionSet> }>) => Promise<boolean>
  refresh: () => Promise<void>
}

// Resource display order
const RESOURCE_ORDER: ResourceType[] = ['agenda', 'orders', 'clients', 'users', 'logs', 'settings', 'permissions']

export function usePermissions(): UsePermissionsReturn {
  const [permissions, setPermissions] = useState<RolePermission[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [permissionsByRole, setPermissionsByRole] = useState<Record<UserRole, PermissionsByResource>>({} as Record<UserRole, PermissionsByResource>)

  const fetchPermissions = useCallback(async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/permissions')
      const data = await response.json()

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch permissions')
      }

      const perms = data.permissions || []
      setPermissions(perms)

      // Organize permissions by role - dynamically from the permissions data
      const byRole: Record<UserRole, PermissionsByResource> = {} as Record<UserRole, PermissionsByResource>

      // Extract unique roles from permissions data (supports dynamic roles)
      const uniqueRoles = [...new Set(perms.map((p: RolePermission) => p.role))] as UserRole[]

      for (const role of uniqueRoles) {
        byRole[role] = {} as PermissionsByResource
        for (const resource of RESOURCE_ORDER) {
          const perm = perms.find((p: RolePermission) => p.role === role && p.resource === resource)
          byRole[role][resource] = perm ? {
            can_view: perm.can_view,
            can_create: perm.can_create,
            can_edit: perm.can_edit,
            can_delete: perm.can_delete
          } : {
            can_view: false,
            can_create: false,
            can_edit: false,
            can_delete: false
          }
        }
      }

      setPermissionsByRole(byRole)
    } catch (err) {
      console.error('Error fetching permissions:', err)
      setError('Erreur lors du chargement des permissions')
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    fetchPermissions()
  }, [fetchPermissions])

  // Realtime updates for permissions
  useRealtimeRefresh('role_permissions', null, fetchPermissions)

  // Update a single permission
  const updatePermission = useCallback(async (
    rolePermissionId: string,
    updates: Partial<PermissionSet>
  ): Promise<boolean> => {
    setError(null)
    try {
      const response = await fetch('/api/permissions', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: rolePermissionId, ...updates })
      })

      const data = await response.json()
      if (!data.success) {
        throw new Error(data.error || 'Failed to update permission')
      }

      await fetchPermissions()
      return true
    } catch (err) {
      console.error('Error updating permission:', err)
      setError('Erreur lors de la mise à jour de la permission')
      return false
    }
  }, [fetchPermissions])

  // Save multiple permissions at once (batch save)
  const savePermissions = useCallback(async (
    changes: Array<{ id: string; updates: Partial<PermissionSet> }>
  ): Promise<boolean> => {
    setError(null)
    try {
      // Process all changes sequentially
      for (const change of changes) {
        const response = await fetch('/api/permissions', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: change.id, ...change.updates })
        })

        const data = await response.json()
        if (!data.success) {
          throw new Error(data.error || 'Failed to update permission')
        }
      }

      await fetchPermissions()
      return true
    } catch (err) {
      console.error('Error saving permissions:', err)
      setError('Erreur lors de l\'enregistrement des permissions')
      return false
    }
  }, [fetchPermissions])

  return {
    permissions,
    loading,
    error,
    permissionsByRole,
    updatePermission,
    savePermissions,
    refresh: fetchPermissions
  }
}

// Export constants for use in components
export { RESOURCE_ORDER }
</file>

<file path="src/hooks/usePricingData.ts">
'use client'

import { useState, useEffect } from 'react'
import { createClient } from '@/lib/supabase/client'

export interface ICountProduct {
  id: string
  code: string
  name: string
  name_he?: string
  unit_price: number
}

export interface ICountEventFormula {
  id: string
  name: string
  game_type: 'LASER' | 'ACTIVE' | 'BOTH'
  min_participants: number
  max_participants: number
  price_per_person: number
  room_id?: string
  product_id?: string
}

export interface ICountRoom {
  id: string
  name: string
  name_he?: string
  price: number
}

export interface PricingData {
  products: ICountProduct[]
  eventFormulas: ICountEventFormula[]
  rooms: ICountRoom[]
  loading: boolean
  error: string | null
}

/**
 * Hook to load pricing data (products, event formulas, rooms) for a branch
 */
export function usePricingData(branchId: string): PricingData {
  const [products, setProducts] = useState<ICountProduct[]>([])
  const [eventFormulas, setEventFormulas] = useState<ICountEventFormula[]>([])
  const [rooms, setRooms] = useState<ICountRoom[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!branchId) {
      setLoading(false)
      return
    }

    const loadPricingData = async () => {
      setLoading(true)
      setError(null)

      const supabase = createClient()

      try {
        // Load all data in parallel
        const [productsRes, formulasRes, roomsRes] = await Promise.all([
          supabase
            .from('icount_products')
            .select('id, code, name, name_he, unit_price')
            .eq('branch_id', branchId)
            .eq('is_active', true),
          supabase
            .from('icount_event_formulas')
            .select('id, name, game_type, min_participants, max_participants, price_per_person, room_id, product_id')
            .eq('branch_id', branchId)
            .eq('is_active', true),
          supabase
            .from('icount_rooms')
            .select('id, name, name_he, price')
            .eq('branch_id', branchId)
            .eq('is_active', true)
        ])

        if (productsRes.error) throw productsRes.error
        if (formulasRes.error) throw formulasRes.error
        if (roomsRes.error) throw roomsRes.error

        setProducts(productsRes.data || [])
        setEventFormulas(formulasRes.data || [])
        setRooms(roomsRes.data || [])
      } catch (err) {
        console.error('[usePricingData] Error loading pricing data:', err)
        setError(err instanceof Error ? err.message : 'Failed to load pricing data')
      } finally {
        setLoading(false)
      }
    }

    loadPricingData()
  }, [branchId])

  return { products, eventFormulas, rooms, loading, error }
}
</file>

<file path="src/hooks/useRealtimeSubscription.ts">
'use client'

import { useEffect, useRef, useCallback } from 'react'
import { getClient } from '@/lib/supabase/client'
import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js'

type TableName = 'bookings' | 'orders' | 'contacts' | 'game_sessions' | 'booking_slots' | 'activity_logs' | 'role_permissions'
type EventType = 'INSERT' | 'UPDATE' | 'DELETE' | '*'

interface SubscriptionConfig {
  table: TableName
  event?: EventType
  filter?: string // ex: "branch_id=eq.xxx"
  onInsert?: (payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => void
  onUpdate?: (payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => void
  onDelete?: (payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => void
  onChange?: (payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => void
}

// Compteur global pour générer des IDs uniques
let channelCounter = 0

/**
 * Hook pour s'abonner aux changements en temps réel sur une table Supabase
 */
export function useRealtimeSubscription(
  config: SubscriptionConfig,
  enabled: boolean = true
) {
  const channelRef = useRef<RealtimeChannel | null>(null)
  const isSubscribingRef = useRef(false)

  const { table, event = '*', filter, onInsert, onUpdate, onDelete, onChange } = config

  useEffect(() => {
    // Ne pas s'abonner si désactivé ou déjà en cours
    if (!enabled || isSubscribingRef.current) {
      return
    }

    const supabase = getClient()

    // Cleanup synchrone du canal précédent
    if (channelRef.current) {
      supabase.removeChannel(channelRef.current)
      channelRef.current = null
    }

    isSubscribingRef.current = true

    // Générer un nom de channel unique avec compteur
    const channelId = ++channelCounter
    const channelName = `rt_${table}_${filter || 'all'}_${channelId}`

    // Configuration pour l'écoute des changements
    const channelConfig: {
      event: 'INSERT' | 'UPDATE' | 'DELETE' | '*'
      schema: string
      table: string
      filter?: string
    } = {
      event,
      schema: 'public',
      table,
    }

    if (filter) {
      channelConfig.filter = filter
    }

    const channel = supabase
      .channel(channelName)
      .on(
        // @ts-expect-error - Supabase types are overly strict for postgres_changes
        'postgres_changes',
        channelConfig,
        (payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => {
          if (onChange) {
            onChange(payload)
          }

          switch (payload.eventType) {
            case 'INSERT':
              if (onInsert) onInsert(payload)
              break
            case 'UPDATE':
              if (onUpdate) onUpdate(payload)
              break
            case 'DELETE':
              if (onDelete) onDelete(payload)
              break
          }
        }
      )
      .subscribe((status, err) => {
        isSubscribingRef.current = false
        if (status === 'SUBSCRIBED') {
          console.log(`[Realtime] Subscribed to ${table}${filter ? ` with filter ${filter}` : ''}`)
        } else if (status === 'CHANNEL_ERROR') {
          console.error(`[Realtime] Error subscribing to ${table}`, err)
        } else if (status === 'TIMED_OUT') {
          console.error(`[Realtime] Timeout subscribing to ${table}`)
        }
      })

    channelRef.current = channel

    // Cleanup au démontage ou changement de dépendances
    return () => {
      isSubscribingRef.current = false
      if (channelRef.current) {
        supabase.removeChannel(channelRef.current)
        channelRef.current = null
      }
    }
  }, [enabled, table, event, filter, onChange, onInsert, onUpdate, onDelete])

  const unsubscribe = useCallback(() => {
    if (channelRef.current) {
      const supabase = getClient()
      supabase.removeChannel(channelRef.current)
      channelRef.current = null
    }
  }, [])

  return { unsubscribe }
}

/**
 * Hook simplifié pour rafraîchir automatiquement les données quand une table change
 */
export function useRealtimeRefresh(
  table: TableName,
  branchId: string | null,
  onRefresh: () => void | Promise<void>,
  additionalTables?: TableName[]
) {
  const onRefreshRef = useRef(onRefresh)

  useEffect(() => {
    onRefreshRef.current = onRefresh
  }, [onRefresh])

  // Callback stable pour onChange
  const handleChange = useCallback(() => {
    console.log(`[Realtime] Change detected in ${table}, refreshing...`)
    onRefreshRef.current()
  }, [table])

  // Subscription principale
  useRealtimeSubscription(
    {
      table,
      filter: branchId ? `branch_id=eq.${branchId}` : undefined,
      onChange: handleChange
    },
    !!branchId
  )

  // Subscriptions additionnelles (ex: game_sessions pour bookings)
  useEffect(() => {
    if (!branchId || !additionalTables?.length) return

    const supabase = getClient()
    const channels: RealtimeChannel[] = []

    additionalTables.forEach((additionalTable, index) => {
      const channelId = ++channelCounter
      const channelName = `rt_${additionalTable}_related_${channelId}`

      const channel = supabase
        .channel(channelName)
        .on(
          'postgres_changes' as const,
          {
            event: '*' as const,
            schema: 'public' as const,
            table: additionalTable,
          },
          () => {
            console.log(`[Realtime] Change detected in ${additionalTable}, refreshing ${table}...`)
            onRefreshRef.current()
          }
        )
        .subscribe()

      channels.push(channel)
    })

    return () => {
      channels.forEach(channel => {
        supabase.removeChannel(channel)
      })
    }
  }, [branchId, additionalTables, table])
}
</file>

<file path="src/hooks/useSessionPersistence.ts">
'use client'

/**
 * Hook pour maintenir la session active
 *
 * Ce hook garantit que :
 * - La session ne expire pas pendant l'utilisation
 * - Le token est rafraîchi silencieusement en arrière-plan
 * - L'utilisateur reste connecté tant qu'il utilise l'app
 */

import { useEffect, useRef, useCallback } from 'react'
import { getClient } from '@/lib/supabase/client'

// Intervalle de rafraîchissement du token (toutes les 10 minutes)
const REFRESH_INTERVAL = 10 * 60 * 1000 // 10 minutes

// Intervalle de vérification de session (toutes les 30 secondes)
const CHECK_INTERVAL = 30 * 1000 // 30 secondes

export function useSessionPersistence() {
  const lastActivityRef = useRef(Date.now())
  const refreshTimerRef = useRef<NodeJS.Timeout | null>(null)
  const checkTimerRef = useRef<NodeJS.Timeout | null>(null)

  // Met à jour le timestamp de dernière activité
  const updateActivity = useCallback(() => {
    lastActivityRef.current = Date.now()
  }, [])

  // Rafraîchit le token silencieusement
  const refreshSession = useCallback(async () => {
    const supabase = getClient()

    try {
      const { data: { session }, error } = await supabase.auth.refreshSession()

      if (error) {
        console.warn('Session refresh failed:', error.message)
        // Ne pas déconnecter immédiatement - essayer à nouveau plus tard
        return false
      }

      if (session) {
        return true
      }
    } catch (e) {
      console.warn('Session refresh exception:', e)
    }

    return false
  }, [])

  // Vérifie si la session est toujours valide
  const checkSession = useCallback(async () => {
    const supabase = getClient()

    try {
      const { data: { session } } = await supabase.auth.getSession()

      if (!session) {
        // Essayer de rafraîchir
        await refreshSession()
      }
    } catch (e) {
      console.warn('Session check failed:', e)
    }
  }, [refreshSession])

  // Configurer les listeners d'activité utilisateur
  useEffect(() => {
    if (typeof window === 'undefined') return

    const events = ['mousedown', 'keydown', 'touchstart', 'scroll']

    // Throttle les mises à jour d'activité (max 1 par seconde)
    let lastUpdate = 0
    const throttledUpdate = () => {
      const now = Date.now()
      if (now - lastUpdate > 1000) {
        lastUpdate = now
        updateActivity()
      }
    }

    events.forEach(event => {
      window.addEventListener(event, throttledUpdate, { passive: true })
    })

    return () => {
      events.forEach(event => {
        window.removeEventListener(event, throttledUpdate)
      })
    }
  }, [updateActivity])

  // Configurer le rafraîchissement périodique du token
  useEffect(() => {
    // Rafraîchir le token toutes les 10 minutes
    refreshTimerRef.current = setInterval(async () => {
      // Seulement si l'utilisateur a été actif dans les 30 dernières minutes
      const timeSinceActivity = Date.now() - lastActivityRef.current
      if (timeSinceActivity < 30 * 60 * 1000) {
        await refreshSession()
      }
    }, REFRESH_INTERVAL)

    // Vérifier la session toutes les 30 secondes
    checkTimerRef.current = setInterval(async () => {
      await checkSession()
    }, CHECK_INTERVAL)

    // Premier refresh immédiat
    refreshSession()

    return () => {
      if (refreshTimerRef.current) {
        clearInterval(refreshTimerRef.current)
      }
      if (checkTimerRef.current) {
        clearInterval(checkTimerRef.current)
      }
    }
  }, [refreshSession, checkSession])

  // Gérer la visibilité de la page (quand l'utilisateur revient sur l'onglet)
  useEffect(() => {
    if (typeof window === 'undefined') return

    const handleVisibilityChange = async () => {
      if (document.visibilityState === 'visible') {
        // L'utilisateur est revenu - vérifier et rafraîchir la session
        updateActivity()
        await checkSession()
        await refreshSession()
      }
    }

    document.addEventListener('visibilitychange', handleVisibilityChange)

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [updateActivity, checkSession, refreshSession])

  // Gérer le focus de la fenêtre
  useEffect(() => {
    if (typeof window === 'undefined') return

    const handleFocus = async () => {
      updateActivity()
      await checkSession()
    }

    window.addEventListener('focus', handleFocus)

    return () => {
      window.removeEventListener('focus', handleFocus)
    }
  }, [updateActivity, checkSession])

  return {
    updateActivity,
    refreshSession,
    checkSession,
  }
}
</file>

<file path="src/hooks/useUserPermissions.ts">
'use client'

import { useState, useEffect, useCallback } from 'react'
import type { UserRole, ResourceType, PermissionSet } from '@/lib/supabase/types'

// Re-export UserRole pour faciliter l'import
export type { UserRole } from '@/lib/supabase/types'

interface UseUserPermissionsReturn {
  permissions: Record<ResourceType, PermissionSet>
  loading: boolean
  error: string | null
  hasPermission: (resource: ResourceType, action: keyof PermissionSet) => boolean
  refresh: () => Promise<void>
}

const DEFAULT_PERMISSIONS: Record<ResourceType, PermissionSet> = {
  agenda: { can_view: false, can_create: false, can_edit: false, can_delete: false },
  orders: { can_view: false, can_create: false, can_edit: false, can_delete: false },
  clients: { can_view: false, can_create: false, can_edit: false, can_delete: false },
  users: { can_view: false, can_create: false, can_edit: false, can_delete: false },
  logs: { can_view: false, can_create: false, can_edit: false, can_delete: false },
  settings: { can_view: false, can_create: false, can_edit: false, can_delete: false },
  permissions: { can_view: false, can_create: false, can_edit: false, can_delete: false },
}

/**
 * Hook pour récupérer les permissions de l'utilisateur connecté
 * basé sur son rôle. Utilisé pour cacher/afficher les éléments UI.
 */
export function useUserPermissions(userRole: UserRole | null): UseUserPermissionsReturn {
  const [permissions, setPermissions] = useState<Record<ResourceType, PermissionSet>>(DEFAULT_PERMISSIONS)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchPermissions = useCallback(async () => {
    if (!userRole) {
      setPermissions(DEFAULT_PERMISSIONS)
      setLoading(false)
      return
    }

    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/permissions')
      const data = await response.json()

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch permissions')
      }

      const perms = data.permissions || []

      // Filtrer les permissions pour le rôle de l'utilisateur
      const userPerms: Record<ResourceType, PermissionSet> = { ...DEFAULT_PERMISSIONS }

      for (const perm of perms) {
        if (perm.role === userRole) {
          userPerms[perm.resource as ResourceType] = {
            can_view: perm.can_view,
            can_create: perm.can_create,
            can_edit: perm.can_edit,
            can_delete: perm.can_delete
          }
        }
      }

      setPermissions(userPerms)
    } catch (err) {
      console.error('Error fetching user permissions:', err)
      setError('Erreur lors du chargement des permissions')
      // En cas d'erreur, on garde les permissions par défaut (tout à false sauf pour super_admin)
      if (userRole === 'super_admin') {
        // Super admin a toujours tous les droits
        const superAdminPerms: Record<ResourceType, PermissionSet> = {
          agenda: { can_view: true, can_create: true, can_edit: true, can_delete: true },
          orders: { can_view: true, can_create: true, can_edit: true, can_delete: true },
          clients: { can_view: true, can_create: true, can_edit: true, can_delete: true },
          users: { can_view: true, can_create: true, can_edit: true, can_delete: true },
          logs: { can_view: true, can_create: true, can_edit: true, can_delete: true },
          settings: { can_view: true, can_create: true, can_edit: true, can_delete: true },
          permissions: { can_view: true, can_create: true, can_edit: true, can_delete: true },
        }
        setPermissions(superAdminPerms)
      }
    } finally {
      setLoading(false)
    }
  }, [userRole])

  useEffect(() => {
    fetchPermissions()
  }, [fetchPermissions])

  /**
   * Vérifie si l'utilisateur a une permission spécifique
   */
  const hasPermission = useCallback((resource: ResourceType, action: keyof PermissionSet): boolean => {
    return permissions[resource]?.[action] || false
  }, [permissions])

  return {
    permissions,
    loading,
    error,
    hasPermission,
    refresh: fetchPermissions
  }
}
</file>

<file path="src/lib/clara/supabase-schema.ts">
/**
 * Documentation complète de la base de données Supabase pour Clara
 * Ce fichier sert de "carte" pour que Clara puisse naviguer dans la base de données
 */

export const SUPABASE_SCHEMA_DOCUMENTATION = `
# CARTE DE LA BASE DE DONNÉES SUPABASE - ACTIVELASER

## 🏢 STRUCTURE MULTI-BRANCHES

L'application gère plusieurs branches (agences) d'un centre de jeux.
Chaque branche a ses propres réglages, salles, tarifs et équipes.

---

## 📋 TABLES PRINCIPALES

### 1. BRANCHES (branches)
Centre de jeux/agence. Toutes les données sont liées à une branche.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| slug | string | Identifiant court (ex: "tel-aviv") |
| name | string | Nom de la branche |
| address | string | Adresse physique |
| phone | string | Téléphone |
| timezone | string | Fuseau horaire |
| is_active | boolean | Branche active ou non |

### 2. BRANCH_SETTINGS (branch_settings)
Configuration détaillée de chaque branche.
| Colonne | Type | Description |
|---------|------|-------------|
| branch_id | uuid | FK vers branches |
| max_concurrent_players | int | Joueurs max simultanés |
| slot_duration_minutes | int | Durée d'un créneau |
| game_duration_minutes | int | Durée d'une partie |
| laser_total_vests | int | Nombre total de gilets laser |
| laser_enabled | boolean | Laser game activé |
| opening_hours | json | Horaires d'ouverture |

---

## 👤 UTILISATEURS & PERMISSIONS

### 3. PROFILES (profiles)
Utilisateurs de l'application (staff).
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID (même que auth.users) |
| first_name | string | Prénom |
| last_name | string | Nom |
| phone | string | Téléphone |
| role | string | Rôle (super_admin, branch_admin, agent) |
| role_id | uuid | FK vers roles |

### 4. ROLES (roles)
Définition des rôles avec hiérarchie.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| name | string | Slug (ex: "branch_admin") |
| display_name | string | Nom affiché |
| level | int | Niveau hiérarchique (1=plus haut) |
| is_system | boolean | Rôle système non modifiable |

### 5. USER_BRANCHES (user_branches)
Association utilisateurs ↔ branches.
| Colonne | Type | Description |
|---------|------|-------------|
| user_id | uuid | FK vers profiles |
| branch_id | uuid | FK vers branches |

### 6. ROLE_PERMISSIONS (role_permissions)
Permissions par rôle et ressource.
| Colonne | Type | Description |
|---------|------|-------------|
| role_id | uuid | FK vers roles |
| resource | string | agenda, orders, clients, users, logs, settings |
| can_view | boolean | Peut voir |
| can_create | boolean | Peut créer |
| can_edit | boolean | Peut modifier |
| can_delete | boolean | Peut supprimer |

---

## 📦 COMMANDES & RÉSERVATIONS

### 7. ORDERS (orders)
Commandes en ligne (demandes de réservation).
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id | uuid | FK vers branches |
| request_reference | string | Référence unique (ex: "ORD-2024-001") |
| order_type | string | GAME ou EVENT |
| status | string | pending, auto_confirmed, manually_confirmed, cancelled, closed |
| customer_first_name | string | Prénom client |
| customer_last_name | string | Nom client |
| customer_phone | string | Téléphone |
| customer_email | string | Email |
| requested_date | date | Date demandée |
| requested_time | time | Heure demandée |
| participants_count | int | Nombre de participants |
| game_area | string | ACTIVE, LASER, MIX, CUSTOM |
| total_amount | decimal | Montant total calculé |
| paid_amount | decimal | Montant payé |
| payment_status | string | unpaid, deposit_paid, fully_paid |
| booking_id | uuid | FK vers bookings (si confirmée) |
| contact_id | uuid | FK vers contacts |
| terms_accepted | boolean | CGV acceptées |
| cgv_validated_at | timestamp | Date validation CGV |
| processed_by | uuid | Traité par (user_id) |
| created_at | timestamp | Date création |

**STATUTS ORDER:**
- pending: En attente de traitement
- auto_confirmed: Confirmée automatiquement
- manually_confirmed: Confirmée manuellement
- cancelled: Annulée
- closed: Terminée/Clôturée

### 8. BOOKINGS (bookings)
Réservations confirmées dans l'agenda.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id | uuid | FK vers branches |
| type | string | GAME ou EVENT |
| status | string | DRAFT, CONFIRMED, CANCELLED |
| reference_code | string | Code référence |
| start_datetime | timestamp | Début réservation |
| end_datetime | timestamp | Fin réservation |
| participants_count | int | Nombre participants |
| event_room_id | uuid | FK vers event_rooms |
| customer_first_name | string | Prénom |
| customer_last_name | string | Nom |
| customer_phone | string | Téléphone |
| customer_email | string | Email |
| total_price | decimal | Prix total |
| discount_type | string | percent ou fixed |
| discount_value | decimal | Valeur réduction |
| primary_contact_id | uuid | FK vers contacts |
| icount_offer_id | int | ID devis iCount |

### 9. GAME_SESSIONS (game_sessions)
Sessions de jeu dans une réservation.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| booking_id | uuid | FK vers bookings |
| game_area | string | ACTIVE, LASER, MIX |
| start_datetime | timestamp | Début session |
| end_datetime | timestamp | Fin session |
| laser_room_id | uuid | FK vers laser_rooms |
| session_order | int | Ordre de la session |

### 10. BOOKING_SLOTS (booking_slots)
Créneaux réservés pour vérifier la disponibilité.
| Colonne | Type | Description |
|---------|------|-------------|
| booking_id | uuid | FK vers bookings |
| branch_id | uuid | FK vers branches |
| slot_start | timestamp | Début créneau |
| slot_end | timestamp | Fin créneau |
| participants_count | int | Participants |
| slot_type | string | Type de créneau |

---

## 👥 CONTACTS & CLIENTS

### 11. CONTACTS (contacts)
Base de données clients.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id_main | uuid | Branche principale |
| first_name | string | Prénom |
| last_name | string | Nom |
| phone | string | Téléphone (unique) |
| email | string | Email |
| client_type | string | individual ou company |
| company_name | string | Nom entreprise |
| status | string | active ou archived |
| source | string | admin_agenda, public_booking, website |
| icount_client_id | int | ID client iCount |
| notes_client | string | Notes |

### 12. BOOKING_CONTACTS (booking_contacts)
Lien réservation ↔ contacts.
| Colonne | Type | Description |
|---------|------|-------------|
| booking_id | uuid | FK vers bookings |
| contact_id | uuid | FK vers contacts |
| is_primary | boolean | Contact principal |

---

## 🏠 SALLES

### 13. EVENT_ROOMS (event_rooms)
Salles d'événements/anniversaires.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id | uuid | FK vers branches |
| slug | string | Identifiant |
| name | string | Nom de la salle |
| capacity | int | Capacité max |
| is_active | boolean | Active |

### 14. LASER_ROOMS (laser_rooms)
Arènes laser game.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id | uuid | FK vers branches |
| slug | string | Identifiant |
| name | string | Nom |
| capacity | int | Capacité |

---

## 💰 TARIFICATION (iCount)

### 15. ICOUNT_PRODUCTS (icount_products)
Produits/tarifs synchronisés avec iCount.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id | uuid | FK vers branches |
| code | string | Code produit |
| name | string | Nom |
| unit_price | decimal | Prix unitaire |
| price_type | string | per_person, flat, per_game |
| category | string | game, room, event_tariff, other |
| is_active | boolean | Actif |

### 16. ICOUNT_EVENT_FORMULAS (icount_event_formulas)
Formules événements avec tarifs par tranche.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id | uuid | FK vers branches |
| name | string | Nom formule |
| game_type | string | LASER, ACTIVE, BOTH |
| min_participants | int | Participants min |
| max_participants | int | Participants max |
| price_per_person | decimal | Prix/personne |
| room_id | uuid | Salle associée |

### 17. ICOUNT_ROOMS (icount_rooms)
Prix des salles pour facturation.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| branch_id | uuid | FK vers branches |
| name | string | Nom |
| price | decimal | Prix |

---

## 💳 PAIEMENTS

### 18. PAYMENTS (payments)
Enregistrement des paiements.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| order_id | uuid | FK vers orders |
| booking_id | uuid | FK vers bookings |
| contact_id | uuid | FK vers contacts |
| branch_id | uuid | FK vers branches |
| amount | decimal | Montant |
| currency | string | Devise (ILS) |
| payment_type | string | full, deposit, balance, refund |
| payment_method | string | card, cash, transfer, check |
| status | string | Statut paiement |
| icount_transaction_id | string | ID transaction iCount |

### 19. PAYMENT_CREDENTIALS (payment_credentials)
Configuration paiement par branche.
| Colonne | Type | Description |
|---------|------|-------------|
| branch_id | uuid | FK vers branches |
| provider | string | Fournisseur (icount) |
| credentials | json | Identifiants chiffrés |

---

## 📧 EMAILS

### 20. EMAIL_TEMPLATES (email_templates)
Templates d'emails.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| code | string | Code unique (ex: "booking_confirmation") |
| name | string | Nom |
| subject_template | string | Sujet avec variables |
| body_template | string | Corps HTML |
| is_system | boolean | Template système |
| branch_id | uuid | FK vers branches (null = global) |

### 21. EMAIL_LOGS (email_logs)
Historique des emails envoyés.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| recipient_email | string | Email destinataire |
| subject | string | Sujet |
| status | string | pending, sent, delivered, failed |
| entity_type | string | booking, order, contact |
| entity_id | uuid | ID de l'entité |
| template_code | string | Code template utilisé |

---

## 📊 LOGS & ACTIVITÉ

### 22. ACTIVITY_LOGS (activity_logs)
Journal d'activité des utilisateurs.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| user_id | uuid | FK vers profiles |
| user_name | string | Nom utilisateur |
| user_role | string | Rôle au moment de l'action |
| action_type | string | Type action (voir ci-dessous) |
| target_type | string | booking, order, contact, user, etc. |
| target_id | uuid | ID cible |
| target_name | string | Nom cible |
| branch_id | uuid | FK vers branches |
| details | json | Détails supplémentaires |
| ip_address | string | IP |
| created_at | timestamp | Date |

**TYPES D'ACTIONS:**
- booking_created, booking_updated, booking_cancelled, booking_deleted
- order_created, order_updated, order_confirmed, order_cancelled
- contact_created, contact_updated, contact_archived
- user_created, user_updated, user_login
- settings_updated, permission_changed

---

## 🤖 CONVERSATIONS IA

### 23. AI_CONVERSATIONS (ai_conversations)
Conversations avec Clara.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| user_id | uuid | FK vers profiles |
| branch_id | uuid | FK vers branches |
| is_active | boolean | Conversation active |
| created_at | timestamp | Création |
| updated_at | timestamp | Dernière mise à jour |

### 24. AI_MESSAGES (ai_messages)
Messages dans les conversations.
| Colonne | Type | Description |
|---------|------|-------------|
| id | uuid | ID unique |
| conversation_id | uuid | FK vers ai_conversations |
| role | string | user ou assistant |
| content | string | Contenu du message |
| metadata | json | Données supplémentaires |
| created_at | timestamp | Date |

---

## 🔗 RELATIONS CLÉS

\`\`\`
branches
├── branch_settings (1:1)
├── event_rooms (1:N)
├── laser_rooms (1:N)
├── icount_products (1:N)
├── icount_event_formulas (1:N)
├── orders (1:N)
├── bookings (1:N)
└── contacts (1:N via branch_id_main)

orders
├── → branches
├── → contacts
├── → bookings (après confirmation)
└── payments (1:N)

bookings
├── → branches
├── → event_rooms
├── game_sessions (1:N)
├── booking_slots (1:N)
├── booking_contacts (N:N avec contacts)
└── payments (1:N)

profiles
├── user_branches (N:N avec branches)
├── → roles
└── activity_logs (1:N)
\`\`\`

---

## 📈 REQUÊTES UTILES POUR STATISTIQUES

### CA du mois
\`\`\`sql
SELECT SUM(total_amount) as ca_total, SUM(paid_amount) as ca_encaisse
FROM orders
WHERE created_at >= date_trunc('month', now())
AND status NOT IN ('cancelled')
\`\`\`

### Commandes par statut
\`\`\`sql
SELECT status, COUNT(*) as count
FROM orders
WHERE created_at >= date_trunc('month', now())
GROUP BY status
\`\`\`

### Clients actifs ce mois
\`\`\`sql
SELECT COUNT(DISTINCT contact_id) as clients_actifs
FROM orders
WHERE created_at >= date_trunc('month', now())
\`\`\`

### Réservations par type
\`\`\`sql
SELECT order_type, COUNT(*) as count, SUM(total_amount) as ca
FROM orders
WHERE status NOT IN ('cancelled')
GROUP BY order_type
\`\`\`

---

## ⚠️ POINTS D'ATTENTION

1. **total_amount sur orders**: Calculé automatiquement via price-calculator
2. **payment_status vs paid_amount**: Vérifier la cohérence
3. **Commandes pending +7j**: Signaler les commandes non traitées
4. **Commandes payées non fermées**: Proposer de les clôturer
5. **CGV non validées**: Suivre cgv_validated_at
`

/**
 * Résumé court pour le system prompt de Clara
 */
export const CLARA_SCHEMA_SUMMARY = `
Tu as accès à ces tables Supabase:

COMMANDES: orders (statuts: pending/confirmed/cancelled/closed, payment_status: unpaid/deposit_paid/fully_paid)
RÉSERVATIONS: bookings, game_sessions, booking_slots
CLIENTS: contacts, booking_contacts
BRANCHES: branches, branch_settings
SALLES: event_rooms, laser_rooms
TARIFS: icount_products, icount_event_formulas, icount_rooms
PAIEMENTS: payments
UTILISATEURS: profiles, roles, user_branches, role_permissions
LOGS: activity_logs, email_logs
EMAILS: email_templates

Colonnes clés orders: id, request_reference, total_amount, paid_amount, payment_status, status, order_type, customer_first_name, customer_phone, created_at
Colonnes clés bookings: id, reference_code, type, status, start_datetime, participants_count, total_price, customer_first_name
Colonnes clés contacts: id, first_name, last_name, phone, email, client_type, company_name
`
</file>

<file path="src/lib/payment-provider/icount/client.ts">
/**
 * iCount API Client
 * Gestion de l'authentification et des requetes vers l'API iCount v3
 */

import type { ProviderCredentials, ProviderResult } from '../types'

const ICOUNT_API_BASE_URL = 'https://api.icount.co.il/api/v3.php'

interface ICountSession {
  sid: string
  createdAt: number
  expiresAt: number
}

interface ICountApiResponse {
  status: boolean
  reason?: string
  error_description?: string
  error_details?: string[]
  [key: string]: unknown
}

export class ICountClient {
  private credentials: ProviderCredentials
  private session: ICountSession | null = null
  private sessionTTL = 30 * 60 * 1000 // 30 minutes

  constructor(credentials: ProviderCredentials) {
    this.credentials = credentials
  }

  /**
   * Obtenir un session ID valide
   */
  private async getSessionId(): Promise<string | null> {
    // Verifier si la session est encore valide
    if (this.session && Date.now() < this.session.expiresAt) {
      return this.session.sid
    }

    // Sinon, se reconnecter
    const loginResult = await this.login()
    if (loginResult.success && loginResult.data?.sid) {
      this.session = {
        sid: loginResult.data.sid,
        createdAt: Date.now(),
        expiresAt: Date.now() + this.sessionTTL,
      }
      return this.session.sid
    }

    return null
  }

  /**
   * Login pour obtenir un session ID
   */
  async login(): Promise<ProviderResult<{ sid: string }>> {
    try {
      const response = await fetch(`${ICOUNT_API_BASE_URL}/auth/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          cid: this.credentials.cid,
          user: this.credentials.user,
          pass: this.credentials.pass,
        }),
      })

      const data: ICountApiResponse = await response.json()

      if (data.status && data.sid) {
        return {
          success: true,
          data: { sid: data.sid as string },
        }
      }

      return {
        success: false,
        error: {
          code: data.reason || 'login_failed',
          message: data.error_description || 'Login failed',
          details: data.error_details,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'network_error',
          message: error instanceof Error ? error.message : 'Network error',
        },
      }
    }
  }

  /**
   * Logout pour fermer la session
   */
  async logout(): Promise<ProviderResult<void>> {
    if (!this.session) {
      return { success: true }
    }

    try {
      await fetch(`${ICOUNT_API_BASE_URL}/auth/logout`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sid: this.session.sid,
        }),
      })

      this.session = null
      return { success: true }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'logout_error',
          message: error instanceof Error ? error.message : 'Logout error',
        },
      }
    }
  }

  /**
   * Test de connexion avec les credentials
   */
  async testConnection(): Promise<ProviderResult<{ valid: boolean }>> {
    const loginResult = await this.login()

    if (loginResult.success) {
      // Deconnexion immediate apres le test
      await this.logout()
      return {
        success: true,
        data: { valid: true },
      }
    }

    return {
      success: false,
      data: { valid: false },
      error: loginResult.error,
    }
  }

  /**
   * Effectuer une requete vers l'API iCount
   * @param module - Module API (client, doc, cc, paypage, etc.)
   * @param method - Methode API (create, update, bill, etc.)
   * @param params - Parametres de la requete
   * @param useSession - Utiliser le session ID (true par defaut)
   */
  async request<T extends ICountApiResponse>(
    module: string,
    method: string,
    params: Record<string, unknown> = {},
    useSession = true
  ): Promise<ProviderResult<T>> {
    try {
      const requestParams: Record<string, unknown> = { ...params }

      if (useSession) {
        const sid = await this.getSessionId()
        if (sid) {
          requestParams.sid = sid
        } else {
          // Fallback sur credentials directes
          requestParams.cid = this.credentials.cid
          requestParams.user = this.credentials.user
          requestParams.pass = this.credentials.pass
        }
      } else {
        // Pas de session, utiliser credentials directes
        requestParams.cid = this.credentials.cid
        requestParams.user = this.credentials.user
        requestParams.pass = this.credentials.pass
      }

      const url = `${ICOUNT_API_BASE_URL}/${module}/${method}`

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestParams),
      })

      const data: T = await response.json()

      if (data.status) {
        return {
          success: true,
          data,
        }
      }

      // Gerer l'expiration de session
      if (data.reason === 'session_expired' || data.reason === 'invalid_session') {
        this.session = null
        // Retry une fois avec nouvelle session
        const retryParams = { ...params }
        const newSid = await this.getSessionId()
        if (newSid) {
          retryParams.sid = newSid
          const retryResponse = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(retryParams),
          })
          const retryData: T = await retryResponse.json()
          if (retryData.status) {
            return { success: true, data: retryData }
          }
        }
      }

      return {
        success: false,
        error: {
          code: data.reason || 'api_error',
          message: data.error_description || 'API request failed',
          details: data.error_details,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'network_error',
          message: error instanceof Error ? error.message : 'Network error',
        },
      }
    }
  }

  /**
   * Getter pour les credentials (lecture seule)
   */
  getCredentials(): Readonly<ProviderCredentials> {
    return { ...this.credentials }
  }
}
</file>

<file path="src/lib/payment-provider/icount/clients.ts">
/**
 * iCount Clients Module
 * Synchronisation des clients ActiveLaser vers iCount
 */

import type { ICountClient } from './client'
import type {
  ClientData,
  ProviderResult,
  SyncClientResult,
} from '../types'

interface ICountClientResponse {
  status: boolean
  reason?: string
  error_description?: string
  error_details?: string[]
  client_id?: number
  // Info client
  client_name?: string
  first_name?: string
  last_name?: string
  email?: string
  phone?: string
  mobile?: string
  vat_id?: string
  bus_country?: string
  bus_city?: string
  bus_street?: string
  bus_no?: string
  bus_zip?: number
  [key: string]: unknown
}

export class ICountClientsModule {
  constructor(private client: ICountClient) {}

  /**
   * Synchroniser un client vers iCount (create_or_update)
   * Utilise custom_client_id = UUID ActiveLaser pour retrouver le client
   */
  async syncClient(data: ClientData): Promise<ProviderResult<SyncClientResult>> {
    const params: Record<string, unknown> = {
      custom_client_id: data.id, // UUID ActiveLaser
      client_name: data.name,
    }

    if (data.firstName) params.first_name = data.firstName
    if (data.lastName) params.last_name = data.lastName
    if (data.email) params.email = data.email
    if (data.phone) params.phone = data.phone
    if (data.mobile) params.mobile = data.mobile
    if (data.vatId) params.vat_id = data.vatId

    // Adresse
    if (data.address) {
      if (data.address.country) params.bus_country = data.address.country
      if (data.address.city) params.bus_city = data.address.city
      if (data.address.street) params.bus_street = data.address.street
      if (data.address.streetNumber) params.bus_no = data.address.streetNumber
      if (data.address.zip) params.bus_zip = data.address.zip
    }

    const result = await this.client.request<ICountClientResponse>(
      'client',
      'create_or_update',
      params
    )

    if (result.success && result.data?.client_id) {
      return {
        success: true,
        data: {
          providerId: result.data.client_id.toString(),
          action: result.data.reason === 'client_created' ? 'created' : 'updated',
        },
      }
    }

    return {
      success: false,
      error: result.error,
    }
  }

  /**
   * Recuperer un client par son ID iCount
   */
  async getClient(providerId: string): Promise<ProviderResult<ClientData>> {
    const result = await this.client.request<ICountClientResponse>(
      'client',
      'info',
      {
        client_id: parseInt(providerId, 10),
      }
    )

    if (result.success && result.data) {
      const data = result.data
      return {
        success: true,
        data: {
          id: providerId,
          name: data.client_name || '',
          firstName: data.first_name,
          lastName: data.last_name,
          email: data.email,
          phone: data.phone,
          mobile: data.mobile,
          vatId: data.vat_id,
          address: {
            country: data.bus_country,
            city: data.bus_city,
            street: data.bus_street,
            streetNumber: data.bus_no,
            zip: data.bus_zip?.toString(),
          },
        },
      }
    }

    return {
      success: false,
      error: result.error,
    }
  }

  /**
   * Recuperer un client par custom_client_id (UUID ActiveLaser)
   */
  async getClientByCustomId(customId: string): Promise<ProviderResult<ClientData & { providerId: string }>> {
    const result = await this.client.request<ICountClientResponse>(
      'client',
      'info',
      {
        custom_client_id: customId,
      }
    )

    if (result.success && result.data?.client_id !== undefined && result.data.client_id !== null) {
      const data = result.data
      const clientId = data.client_id!
      return {
        success: true,
        data: {
          id: customId,
          providerId: clientId.toString(),
          name: data.client_name || '',
          firstName: data.first_name,
          lastName: data.last_name,
          email: data.email,
          phone: data.phone,
          mobile: data.mobile,
          vatId: data.vat_id,
          address: {
            country: data.bus_country,
            city: data.bus_city,
            street: data.bus_street,
            streetNumber: data.bus_no,
            zip: data.bus_zip?.toString(),
          },
        },
      }
    }

    return {
      success: false,
      error: result.error,
    }
  }
}
</file>

<file path="src/lib/payment-provider/icount/credit-card.ts">
/**
 * iCount Credit Card Module
 * Gestion des paiements par carte de crédit, tokenisation et pré-autorisation
 */

import { ICountClient } from './client'
import type { ProviderResult } from '../types'

// Types pour les opérations de carte de crédit
export interface CreditCardInfo {
  cc_number: string      // Numéro de carte
  cc_validity: string    // Format MMYY ou YYYY-MM
  cc_cvv: string         // CVV (3-4 chiffres)
  cc_holder_id: string   // ID du titulaire (Teudat Zehut en Israël)
  cc_holder_name?: string // Nom du titulaire
}

export interface StoredCardInfo {
  token_id: number
  cc_last4: string
  cc_type: string
  cc_validity: string
  cc_holder_name?: string
}

export interface J5PreapprovalResult {
  confirmation_code: string
  transaction_id: string
  cc_last4: string
  cc_type: string
}

export interface BillResult {
  transaction_id: string
  confirmation_code: string
  cc_last4: string
  cc_type: string
  amount: number
  currency: string
}

export interface StoreCardParams {
  clientId?: number        // Client iCount ID
  customClientId?: string  // ID client externe (notre contact_id)
  email?: string
  clientName?: string
  cardInfo: CreditCardInfo
}

export interface J5PreapprovalParams {
  cardInfo: CreditCardInfo
  amount: number           // Montant à pré-autoriser (minimum 5₪)
  currencyCode?: string    // Default: ILS
}

export interface BillCardParams {
  // Identification client
  clientId?: number
  customClientId?: string
  email?: string
  clientName?: string
  // Carte (token OU données directes)
  tokenId?: number         // Utiliser un token stocké
  cardInfo?: CreditCardInfo // OU données carte directes
  // Montant
  amount: number
  currencyCode?: string    // Default: ILS
  // Options
  useJ5IfAvailable?: boolean // Utiliser une pré-autorisation existante
  numPayments?: number       // Nombre de paiements (pour paiements échelonnés)
  firstPayment?: number      // Montant du premier paiement
  description?: string       // Description du paiement
  isTest?: boolean           // Mode test (ne contacte pas le processeur)
}

export interface GetTokenParams {
  clientId?: number
  customClientId?: string
  email?: string
  tokenId?: number
}

// Interface pour les réponses iCount
interface ICountCCResponse {
  status: boolean
  reason?: string
  error_description?: string
  error_details?: string[]
  // Store card response
  cc_token_id?: number
  // J5 response
  confirmation_code?: string
  transaction_id?: string
  // Bill response
  cc_last4?: string
  cc_type?: string
  cc_validity?: string
  sum?: number
  currency?: string
  currency_code?: string
  // Token info response
  tokens?: Array<{
    cc_token_id: number
    cc_last4: string
    cc_type: string
    cc_validity: string
    cc_holder_name?: string
  }>
  // Index signature for compatibility with ICountApiResponse
  [key: string]: unknown
}

export class ICountCreditCardModule {
  constructor(private client: ICountClient) {}

  /**
   * Stocker les informations d'une carte de crédit (tokenisation)
   * Retourne un token réutilisable pour les paiements futurs
   */
  async storeCard(params: StoreCardParams): Promise<ProviderResult<StoredCardInfo>> {
    const result = await this.client.request<ICountCCResponse>('cc', 'store_card_info', {
      client_id: params.clientId,
      custom_client_id: params.customClientId,
      email: params.email,
      client_name: params.clientName,
      cc_number: params.cardInfo.cc_number,
      cc_validity: params.cardInfo.cc_validity,
      cc_cvv: params.cardInfo.cc_cvv,
      cc_holder_id: params.cardInfo.cc_holder_id,
      cc_holder_name: params.cardInfo.cc_holder_name,
    })

    if (!result.success || !result.data) {
      return {
        success: false,
        error: result.error || { code: 'store_failed', message: 'Failed to store card' },
      }
    }

    const data = result.data
    if (!data.cc_token_id) {
      return {
        success: false,
        error: { code: 'no_token', message: 'No token returned' },
      }
    }

    return {
      success: true,
      data: {
        token_id: data.cc_token_id,
        cc_last4: data.cc_last4 || params.cardInfo.cc_number.slice(-4),
        cc_type: data.cc_type || 'unknown',
        cc_validity: data.cc_validity || params.cardInfo.cc_validity,
        cc_holder_name: params.cardInfo.cc_holder_name,
      },
    }
  }

  /**
   * Créer une pré-autorisation J5 (empreinte carte)
   * La carte est vérifiée et le montant est "réservé" sans être débité
   */
  async createJ5Preapproval(params: J5PreapprovalParams): Promise<ProviderResult<J5PreapprovalResult>> {
    if (params.amount < 5) {
      return {
        success: false,
        error: { code: 'amount_too_low', message: 'Minimum amount for J5 is 5 ILS' },
      }
    }

    // Format cc_validity: même format que pour bill (MMYY)
    // Note: L'API J5 retourne "bad_cc_validity" - à investiguer avec le support iCount
    const formattedValidity = params.cardInfo.cc_validity.replace('/', '')

    console.log('[ICOUNT J5] Validity:', formattedValidity)

    const result = await this.client.request<ICountCCResponse>('cc', 'j5', {
      cc_number: params.cardInfo.cc_number,
      cc_validity: formattedValidity,
      cc_cvv: params.cardInfo.cc_cvv,
      cc_holder_id: params.cardInfo.cc_holder_id,
      sum: params.amount,
      currency_code: params.currencyCode || 'ILS',
    })

    if (!result.success || !result.data) {
      return {
        success: false,
        error: result.error || { code: 'j5_failed', message: 'J5 preapproval failed' },
      }
    }

    const data = result.data
    if (!data.confirmation_code) {
      return {
        success: false,
        error: { code: 'no_confirmation', message: 'No confirmation code returned' },
      }
    }

    return {
      success: true,
      data: {
        confirmation_code: data.confirmation_code,
        transaction_id: data.transaction_id || '',
        cc_last4: data.cc_last4 || params.cardInfo.cc_number.slice(-4),
        cc_type: data.cc_type || 'unknown',
      },
    }
  }

  /**
   * Débiter une carte de crédit
   * Peut utiliser un token stocké ou les données carte directes
   * Peut utiliser une pré-autorisation J5 existante
   */
  async billCard(params: BillCardParams): Promise<ProviderResult<BillResult>> {
    if (!params.tokenId && !params.cardInfo) {
      return {
        success: false,
        error: { code: 'missing_card', message: 'Either tokenId or cardInfo is required' },
      }
    }

    const requestParams: Record<string, unknown> = {
      sum: params.amount,
      currency_code: params.currencyCode || 'ILS',
      payment_description: params.description,
      is_test: params.isTest,
    }

    // Identification client
    if (params.clientId) requestParams.client_id = params.clientId
    if (params.customClientId) requestParams.custom_client_id = params.customClientId
    if (params.email) requestParams.email = params.email
    if (params.clientName) requestParams.client_name = params.clientName

    // Carte
    if (params.tokenId) {
      requestParams.cc_token_id = params.tokenId
    } else if (params.cardInfo) {
      requestParams.cc_number = params.cardInfo.cc_number
      requestParams.cc_validity = params.cardInfo.cc_validity
      requestParams.cc_cvv = params.cardInfo.cc_cvv
      requestParams.cc_holder_id = params.cardInfo.cc_holder_id
      requestParams.cc_holder_name = params.cardInfo.cc_holder_name
    }

    // Options
    if (params.useJ5IfAvailable) {
      requestParams.use_j5_if_available = true
    }
    if (params.numPayments && params.numPayments > 1) {
      requestParams.num_of_payments = params.numPayments
      if (params.firstPayment) {
        requestParams.first_payment = params.firstPayment
      }
    }

    const result = await this.client.request<ICountCCResponse>('cc', 'bill', requestParams)

    if (!result.success || !result.data) {
      return {
        success: false,
        error: result.error || { code: 'bill_failed', message: 'Card billing failed' },
      }
    }

    const data = result.data
    if (!data.confirmation_code) {
      return {
        success: false,
        error: { code: 'no_confirmation', message: 'No confirmation code returned' },
      }
    }

    return {
      success: true,
      data: {
        transaction_id: data.transaction_id || '',
        confirmation_code: data.confirmation_code,
        cc_last4: data.cc_last4 || '',
        cc_type: data.cc_type || 'unknown',
        amount: data.sum || params.amount,
        currency: data.currency_code || params.currencyCode || 'ILS',
      },
    }
  }

  /**
   * Récupérer les informations d'un token de carte stockée
   */
  async getTokenInfo(params: GetTokenParams): Promise<ProviderResult<StoredCardInfo[]>> {
    const result = await this.client.request<ICountCCResponse>('cc', 'get_token_info', {
      client_id: params.clientId,
      custom_client_id: params.customClientId,
      email: params.email,
      cc_token_id: params.tokenId,
    })

    if (!result.success || !result.data) {
      return {
        success: false,
        error: result.error || { code: 'get_token_failed', message: 'Failed to get token info' },
      }
    }

    const data = result.data
    const tokens = data.tokens || []

    return {
      success: true,
      data: tokens.map(t => ({
        token_id: t.cc_token_id,
        cc_last4: t.cc_last4,
        cc_type: t.cc_type,
        cc_validity: t.cc_validity,
        cc_holder_name: t.cc_holder_name,
      })),
    }
  }

  /**
   * Valider une carte (vérifie que les infos sont correctes sans débiter)
   */
  async validateCard(cardInfo: CreditCardInfo): Promise<ProviderResult<{ valid: boolean; cc_type?: string }>> {
    const result = await this.client.request<ICountCCResponse>('cc', 'validate_card_cvv', {
      cc_number: cardInfo.cc_number,
      cc_validity: cardInfo.cc_validity,
      cc_cvv: cardInfo.cc_cvv,
      cc_holder_id: cardInfo.cc_holder_id,
    })

    if (!result.success) {
      return {
        success: true,
        data: { valid: false },
      }
    }

    return {
      success: true,
      data: {
        valid: true,
        cc_type: result.data?.cc_type,
      },
    }
  }

  /**
   * Détecter le type de carte à partir du numéro
   */
  async detectCardType(ccNumber: string): Promise<ProviderResult<{ cc_type: string }>> {
    const result = await this.client.request<ICountCCResponse>('cc', 'detect_cc_type', {
      cc_number: ccNumber,
    })

    if (!result.success || !result.data) {
      return {
        success: false,
        error: result.error || { code: 'detect_failed', message: 'Failed to detect card type' },
      }
    }

    return {
      success: true,
      data: {
        cc_type: result.data.cc_type || 'unknown',
      },
    }
  }
}
</file>

<file path="src/lib/payment-provider/types.ts">
/**
 * Payment Provider Abstraction Layer - Types
 * Interface generique pour les providers de paiement (iCount, Stripe, etc.)
 * ActiveLaser est la source de verite - le provider est interchangeable
 */

// ============================================
// TYPES DE BASE
// ============================================

export interface ProviderCredentials {
  cid: string
  user: string
  pass: string
}

export interface ProviderConfig {
  name: string
  credentials: ProviderCredentials
  apiUrl: string
  enabled: boolean
}

export interface ProviderResult<T = unknown> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: unknown
  }
}

// ============================================
// CLIENT (CONTACT) TYPES
// ============================================

export interface ClientData {
  /** ID interne ActiveLaser */
  id: string
  /** ID custom pour le provider */
  customId?: string
  name: string
  firstName?: string
  lastName?: string
  email?: string
  phone?: string
  mobile?: string
  vatId?: string
  address?: {
    country?: string
    city?: string
    street?: string
    streetNumber?: string
    zip?: string
  }
}

export interface SyncClientResult {
  providerId: string
  action: 'created' | 'updated'
}

// ============================================
// PRODUCT TYPES
// ============================================

export interface ProductData {
  /** ID interne ActiveLaser */
  id: string
  code: string
  name: string
  description?: string
  /** Prix TTC */
  priceIncludingVat: number
  currency: string
  vatRate: number
}

export interface SyncProductResult {
  providerId: string
  sku?: string
  action: 'created' | 'updated'
}

// ============================================
// BILLING TYPES
// ============================================

export interface CardData {
  number: string
  validity: string  // Format MMYY ou YYYY-MM
  cvv: string
  holderId: string
  holderName?: string
}

export interface TokenizedCard {
  tokenId: string
  last4: string
  cardType?: string
  expiry?: string
  holderName?: string
}

export interface ChargeRequest {
  /** Montant a debiter */
  amount: number
  currency: string
  /** Description du paiement */
  description?: string
  /** Client provider ID */
  clientId?: string
  /** Utiliser une carte tokenisee */
  tokenId?: string
  /** OU utiliser les details de carte */
  card?: CardData
  /** Utiliser la pre-autorisation J5 si disponible */
  useJ5IfAvailable?: boolean
}

export interface ChargeResult {
  transactionId: string
  confirmationCode: string
  amount: number
  currency: string
  cardLast4?: string
  cardType?: string
}

export interface PreAuthRequest {
  /** Montant a pre-autoriser (garantie) */
  amount: number
  currency: string
  card: CardData
}

export interface PreAuthResult {
  preAuthId: string
  confirmationCode: string
  amount: number
  currency: string
  cardLast4?: string
  cardType?: string
  /** Date d'expiration de la pre-autorisation */
  expiresAt?: Date
}

export interface CapturePreAuthRequest {
  preAuthId: string
  /** Montant a capturer (peut etre inferieur au montant pre-autorise) */
  amount: number
}

export interface CapturePreAuthResult {
  transactionId: string
  confirmationCode: string
  amount: number
}

export interface ReleasePreAuthRequest {
  preAuthId: string
}

// ============================================
// CARD STORAGE (TOKENIZATION) TYPES
// ============================================

export interface StoreCardRequest {
  clientId: string
  card: CardData
}

export interface StoreCardResult {
  tokenId: string
  last4: string
  cardType?: string
  expiry?: string
  holderName?: string
}

export interface GetStoredCardsResult {
  cards: TokenizedCard[]
}

export interface DeleteCardRequest {
  tokenId: string
  clientId?: string
}

// ============================================
// PAYPAGE (PAYMENT LINK) TYPES
// ============================================

export interface PaymentLinkItem {
  description: string
  /** Prix unitaire TTC */
  unitPriceIncludingVat: number
  quantity: number
  sku?: string
}

export interface GeneratePaymentLinkRequest {
  /** ID de la paypage configuree dans le provider */
  paypageId: string
  /** Items a payer */
  items: PaymentLinkItem[]
  /** Total (optionnel - calcule si non fourni) */
  sum?: number
  currency: string
  /** Infos client pour pre-remplir le formulaire */
  client?: {
    name?: string
    email?: string
    phone?: string
    vatId?: string
  }
  /** URL de retour succes */
  successUrl?: string
  /** URL de retour echec */
  failureUrl?: string
  /** URL de retour annulation */
  cancelUrl?: string
  /** URL pour les notifications IPN (webhook) */
  ipnUrl?: string
  /** Langue de la page */
  lang?: 'he' | 'en' | 'auto'
  /** Nombre max de paiements (installments) */
  maxPayments?: number
}

export interface GeneratePaymentLinkResult {
  /** URL de paiement */
  paymentUrl: string
  /** ID unique de la vente */
  saleId: string
  /** Session ID de la vente */
  saleSessionId?: string
}

// ============================================
// DOCUMENT TYPES
// ============================================

export type DocumentType =
  | 'invoice'     // Facture
  | 'receipt'     // Recu
  | 'invrec'      // Facture-Recu
  | 'deal'        // Transaction
  | 'order'       // Bon de commande
  | 'offer'       // Devis

export interface DocumentItem {
  description: string
  unitPrice: number
  quantity: number
  sku?: string
  taxExempt?: boolean
}

export interface CreditCardPaymentInfo {
  sum: number
  cardNumber: string  // 4 derniers chiffres
  cardType: string
  confirmationCode: string
  numPayments?: number
  holderName?: string
  holderId?: string
  expMonth?: number
  expYear?: number
}

export interface CreateDocumentRequest {
  docType: DocumentType
  clientId?: string
  clientName?: string
  clientEmail?: string
  clientVatId?: string
  items: DocumentItem[]
  currency: string
  /** Paiement par carte */
  creditCard?: CreditCardPaymentInfo
  /** Paiement en especes */
  cash?: { sum: number }
  /** Virement bancaire */
  bankTransfer?: { sum: number; date: string; account?: number }
  /** Envoyer par email */
  sendEmail?: boolean
  /** Langue du document */
  lang?: 'he' | 'en'
  /** Commentaires */
  comments?: string
}

export interface CreateDocumentResult {
  docType: string
  docNum: number
  clientId?: string
  /** URL du document original */
  docUrl?: string
  /** URL de la copie */
  docCopyUrl?: string
  /** URL du PDF */
  pdfUrl?: string
}

export interface GetDocumentRequest {
  docType: DocumentType
  docNum: number
  getPdfLink?: boolean
}

export interface DocumentInfo {
  docType: string
  docNum: number
  date: string
  clientId?: string
  clientName?: string
  totalAmount: number
  totalWithVat: number
  vatAmount: number
  currency: string
  status: 'open' | 'closed' | 'cancelled'
  docUrl?: string
  pdfUrl?: string
  items?: DocumentItem[]
}

// ============================================
// WEBHOOK TYPES
// ============================================

export interface WebhookPayload {
  /** Type d'evenement */
  eventType: 'payment_success' | 'payment_failed' | 'refund' | 'document_created'
  /** ID unique du provider pour cette transaction */
  transactionId: string
  /** Montant */
  amount: number
  currency: string
  /** Infos client */
  clientEmail?: string
  clientName?: string
  /** Infos carte */
  cardLast4?: string
  cardType?: string
  /** Infos document cree */
  docType?: string
  docNum?: number
  docUrl?: string
  /** Donnees brutes du provider */
  rawPayload: Record<string, unknown>
}

// ============================================
// PROVIDER INTERFACE
// ============================================

export interface PaymentProvider {
  /** Nom du provider */
  readonly name: string

  /** Test de connexion */
  testConnection(): Promise<ProviderResult<{ valid: boolean }>>

  // --- Clients ---
  syncClient(data: ClientData): Promise<ProviderResult<SyncClientResult>>
  getClient(providerId: string): Promise<ProviderResult<ClientData>>

  // --- Products ---
  syncProduct(data: ProductData): Promise<ProviderResult<SyncProductResult>>

  // --- Billing ---
  chargeCard(request: ChargeRequest): Promise<ProviderResult<ChargeResult>>
  preAuthorize(request: PreAuthRequest): Promise<ProviderResult<PreAuthResult>>
  capturePreAuth(request: CapturePreAuthRequest): Promise<ProviderResult<CapturePreAuthResult>>
  releasePreAuth(request: ReleasePreAuthRequest): Promise<ProviderResult<void>>

  // --- Card Storage ---
  storeCard(request: StoreCardRequest): Promise<ProviderResult<StoreCardResult>>
  getStoredCards(clientId: string): Promise<ProviderResult<GetStoredCardsResult>>
  deleteCard(request: DeleteCardRequest): Promise<ProviderResult<void>>

  // --- PayPage ---
  generatePaymentLink(request: GeneratePaymentLinkRequest): Promise<ProviderResult<GeneratePaymentLinkResult>>

  // --- Documents ---
  createDocument(request: CreateDocumentRequest): Promise<ProviderResult<CreateDocumentResult>>
  getDocument(request: GetDocumentRequest): Promise<ProviderResult<DocumentInfo>>
  sendDocumentByEmail(docType: DocumentType, docNum: number, email?: string): Promise<ProviderResult<void>>

  // --- Webhooks ---
  parseWebhookPayload(rawBody: string | Record<string, unknown>): Promise<ProviderResult<WebhookPayload>>
  validateWebhookOrigin(headers: Record<string, string>, body: string): Promise<boolean>
}

// ============================================
// FACTORY TYPE
// ============================================

export type CreateProviderFn = (config: ProviderConfig) => PaymentProvider
</file>

<file path="src/lib/activity-logger.ts">
/**
 * Activity Logger - Server-side utility for logging user actions
 *
 * This module provides functions to log user actions to the activity_logs table.
 * It should be used in API routes to track all significant user actions.
 *
 * @example
 * // In an API route
 * import { logActivity } from '@/lib/activity-logger'
 *
 * await logActivity({
 *   userId: user.id,
 *   userRole: user.role,
 *   userName: user.full_name,
 *   actionType: 'booking_created',
 *   targetType: 'booking',
 *   targetId: booking.id,
 *   targetName: booking.reference_code,
 *   branchId: booking.branch_id,
 *   details: { participants: booking.participants_count }
 * })
 */

import { createServiceRoleClient } from '@/lib/supabase/service-role'
import type { ActionType, TargetType, UserRole, Json, ActivityLogInsert } from '@/lib/supabase/types'

export interface LogActivityParams {
  // Who performed the action
  userId: string | null
  userRole: UserRole
  userName: string

  // What action was performed
  actionType: ActionType

  // What entity was affected (optional for some actions like login/logout)
  targetType?: TargetType
  targetId?: string
  targetName?: string

  // Context
  branchId?: string | null

  // Additional details (JSON)
  details?: Record<string, unknown>

  // IP address (optional)
  ipAddress?: string
}

/**
 * Log a user activity to the database
 * This function should be called from API routes after successful actions
 */
export async function logActivity(params: LogActivityParams): Promise<void> {
  const {
    userId,
    userRole,
    userName,
    actionType,
    targetType,
    targetId,
    targetName,
    branchId,
    details = {},
    ipAddress,
  } = params

  try {
    const supabase = createServiceRoleClient()

    const logEntry: ActivityLogInsert = {
      user_id: userId,
      user_role: userRole,
      user_name: userName,
      action_type: actionType,
      target_type: targetType || null,
      target_id: targetId || null,
      target_name: targetName || null,
      branch_id: branchId || null,
      details: details as Json,
      ip_address: ipAddress || null,
    }

    // @ts-expect-error - Supabase SSR typing limitation with insert
    const { error } = await supabase.from('activity_logs').insert(logEntry)

    if (error) {
      // Log error but don't throw - we don't want logging failures to break the app
      console.error('[ActivityLogger] Failed to log activity:', error)
    }
  } catch (error) {
    // Fail silently - logging should never break the main flow
    console.error('[ActivityLogger] Error:', error)
  }
}

/**
 * Helper to get the IP address from Next.js request headers
 */
export function getClientIpFromHeaders(headers: Headers): string | undefined {
  // Try different headers in order of reliability
  const forwardedFor = headers.get('x-forwarded-for')
  if (forwardedFor) {
    // x-forwarded-for can contain multiple IPs, take the first one
    return forwardedFor.split(',')[0].trim()
  }

  const realIp = headers.get('x-real-ip')
  if (realIp) {
    return realIp
  }

  return undefined
}

/**
 * Convenience function to log booking-related actions
 */
export async function logBookingAction(params: {
  userId: string | null
  userRole: UserRole
  userName: string
  action: 'created' | 'updated' | 'cancelled' | 'deleted'
  bookingId: string
  bookingRef: string
  branchId?: string | null
  details?: Record<string, unknown>
  ipAddress?: string
}): Promise<void> {
  const actionTypeMap: Record<string, ActionType> = {
    created: 'booking_created',
    updated: 'booking_updated',
    cancelled: 'booking_cancelled',
    deleted: 'booking_deleted',
  }

  await logActivity({
    userId: params.userId,
    userRole: params.userRole,
    userName: params.userName,
    actionType: actionTypeMap[params.action],
    targetType: 'booking',
    targetId: params.bookingId,
    targetName: params.bookingRef,
    branchId: params.branchId,
    details: params.details,
    ipAddress: params.ipAddress,
  })
}

/**
 * Convenience function to log order-related actions
 */
export async function logOrderAction(params: {
  userId: string | null
  userRole: UserRole
  userName: string
  action: 'created' | 'updated' | 'confirmed' | 'cancelled' | 'deleted'
  orderId: string
  orderRef: string
  branchId?: string | null
  details?: Record<string, unknown>
  ipAddress?: string
}): Promise<void> {
  const actionTypeMap: Record<string, ActionType> = {
    created: 'order_created',
    updated: 'order_updated',
    confirmed: 'order_confirmed',
    cancelled: 'order_cancelled',
    deleted: 'order_deleted',
  }

  await logActivity({
    userId: params.userId,
    userRole: params.userRole,
    userName: params.userName,
    actionType: actionTypeMap[params.action],
    targetType: 'order',
    targetId: params.orderId,
    targetName: params.orderRef,
    branchId: params.branchId,
    details: params.details,
    ipAddress: params.ipAddress,
  })
}

/**
 * Convenience function to log contact-related actions
 */
export async function logContactAction(params: {
  userId: string | null
  userRole: UserRole
  userName: string
  action: 'created' | 'updated' | 'archived' | 'deleted'
  contactId: string
  contactName: string
  branchId?: string | null
  details?: Record<string, unknown>
  ipAddress?: string
}): Promise<void> {
  const actionTypeMap: Record<string, ActionType> = {
    created: 'contact_created',
    updated: 'contact_updated',
    archived: 'contact_archived',
    deleted: 'contact_deleted',
  }

  await logActivity({
    userId: params.userId,
    userRole: params.userRole,
    userName: params.userName,
    actionType: actionTypeMap[params.action],
    targetType: 'contact',
    targetId: params.contactId,
    targetName: params.contactName,
    branchId: params.branchId,
    details: params.details,
    ipAddress: params.ipAddress,
  })
}

/**
 * Convenience function to log user-related actions
 */
export async function logUserAction(params: {
  userId: string | null
  userRole: UserRole
  userName: string
  action: 'created' | 'updated' | 'deleted' | 'login' | 'logout'
  targetUserId?: string
  targetUserName?: string
  branchId?: string | null
  details?: Record<string, unknown>
  ipAddress?: string
}): Promise<void> {
  const actionTypeMap: Record<string, ActionType> = {
    created: 'user_created',
    updated: 'user_updated',
    deleted: 'user_deleted',
    login: 'user_login',
    logout: 'user_logout',
  }

  await logActivity({
    userId: params.userId,
    userRole: params.userRole,
    userName: params.userName,
    actionType: actionTypeMap[params.action],
    targetType: 'user',
    targetId: params.targetUserId,
    targetName: params.targetUserName,
    branchId: params.branchId,
    details: params.details,
    ipAddress: params.ipAddress,
  })
}

/**
 * Convenience function to log permission changes
 */
export async function logPermissionChange(params: {
  userId: string | null
  userRole: UserRole
  userName: string
  targetRole: UserRole
  resource: string
  changes: Record<string, boolean>
  ipAddress?: string
}): Promise<void> {
  await logActivity({
    userId: params.userId,
    userRole: params.userRole,
    userName: params.userName,
    actionType: 'permission_changed',
    targetType: 'settings',
    targetName: `${params.targetRole}:${params.resource}`,
    details: {
      role: params.targetRole,
      resource: params.resource,
      changes: params.changes,
    },
    ipAddress: params.ipAddress,
  })
}

/**
 * Convenience function to log log deletions
 */
export async function logLogDeletion(params: {
  userId: string | null
  userRole: UserRole
  userName: string
  deletedLogIds: string[]
  ipAddress?: string
}): Promise<void> {
  await logActivity({
    userId: params.userId,
    userRole: params.userRole,
    userName: params.userName,
    actionType: 'log_deleted',
    targetType: 'log',
    details: {
      deleted_count: params.deletedLogIds.length,
      deleted_ids: params.deletedLogIds,
    },
    ipAddress: params.ipAddress,
  })
}

/**
 * Convenience function to log email sent actions
 */
export async function logEmailSent(params: {
  recipientEmail: string
  recipientName?: string
  subject: string
  templateCode?: string
  entityType?: 'booking' | 'order' | 'contact'
  entityId?: string
  branchId?: string | null
}): Promise<void> {
  await logActivity({
    userId: null,
    userRole: 'system',
    userName: 'System',
    actionType: 'email_sent',
    targetType: 'email',
    targetId: params.entityId,
    targetName: params.recipientEmail,
    branchId: params.branchId,
    details: {
      recipient_email: params.recipientEmail,
      recipient_name: params.recipientName,
      subject: params.subject,
      template_code: params.templateCode,
      entity_type: params.entityType,
      entity_id: params.entityId,
    },
  })
}
</file>

<file path="src/lib/booking-validation.ts">
/**
 * Validation des prix AVANT création de booking
 *
 * Ce module garantit qu'un booking ne peut PAS être créé
 * si aucune formule de prix valide n'existe.
 *
 * Appelé par:
 * - /api/orders (commandes site public)
 * - /api/bookings (réservations admin)
 */

import type { SupabaseClient } from '@supabase/supabase-js'

// Types pour les résultats de validation
export interface PriceValidationResult {
  valid: boolean
  error?: string
  errorKey?: string // Clé pour traduction frontend
  formula?: EventFormula
  unitPrice?: number
  roomPrice?: number
  productCode?: string
}

interface EventFormula {
  id: string
  branch_id: string
  name: string
  game_type: 'LASER' | 'ACTIVE' | 'BOTH'
  min_participants: number
  max_participants: number
  price_per_person: number
  room_id: string | null
  product_id: string | null
  is_active: boolean
  priority: number
}

interface ICountProduct {
  id: string
  branch_id: string
  code: string
  name: string
  unit_price: number
  is_active: boolean
}

interface GameSession {
  game_area: 'ACTIVE' | 'LASER'
  start_datetime?: string
  end_datetime?: string
}

/**
 * Valide qu'un prix peut être calculé pour un booking
 * DOIT être appelé AVANT de créer le booking
 */
export async function validateBookingPrice(
  supabase: SupabaseClient,
  type: 'GAME' | 'EVENT',
  branchId: string,
  participantsCount: number,
  gameSessions?: GameSession[]
): Promise<PriceValidationResult> {

  if (type === 'EVENT') {
    return validateEventPrice(supabase, branchId, participantsCount, gameSessions)
  } else {
    return validateGamePrice(supabase, branchId, participantsCount, gameSessions)
  }
}

/**
 * Validation prix EVENT
 * Vérifie: formule existe + produit iCount lié existe
 */
async function validateEventPrice(
  supabase: SupabaseClient,
  branchId: string,
  participantsCount: number,
  gameSessions?: GameSession[]
): Promise<PriceValidationResult> {

  // 1. Récupérer toutes les formules EVENT de la branche
  const { data: eventFormulas, error: formulasError } = await supabase
    .from('icount_event_formulas')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)
    .order('priority', { ascending: false })

  if (formulasError) {
    console.error('[VALIDATION] Erreur lecture formules:', formulasError)
    return {
      valid: false,
      error: 'Erreur lors de la lecture des formules de prix',
      errorKey: 'errors.priceValidation.readError'
    }
  }

  if (!eventFormulas || eventFormulas.length === 0) {
    return {
      valid: false,
      error: 'Aucune formule de prix EVENT configurée pour cette branche',
      errorKey: 'errors.priceValidation.noEventFormulas'
    }
  }

  // 2. Déterminer le type de jeu (LASER, ACTIVE, ou BOTH)
  const hasLaser = gameSessions?.some(s => s.game_area === 'LASER') || false
  const hasActive = gameSessions?.some(s => s.game_area === 'ACTIVE') || false

  let bookingGameType: 'LASER' | 'ACTIVE' | 'BOTH'
  if (hasLaser && hasActive) {
    bookingGameType = 'BOTH'
  } else if (hasActive) {
    bookingGameType = 'ACTIVE'
  } else {
    bookingGameType = 'LASER' // Par défaut
  }

  // 3. Trouver une formule qui correspond
  const matchingFormula = eventFormulas.find((f: EventFormula) => {
    // Vérifier le nombre de participants
    if (participantsCount < f.min_participants) return false
    if (participantsCount > f.max_participants) return false

    // Vérifier le type de jeu
    if (f.game_type === 'BOTH') {
      return true // Formule BOTH accepte tout
    }
    return f.game_type === bookingGameType
  })

  if (!matchingFormula) {
    // Calculer les limites pour le message d'erreur
    const minParticipants = Math.min(...eventFormulas.map((f: EventFormula) => f.min_participants))
    const maxParticipants = Math.max(...eventFormulas.map((f: EventFormula) => f.max_participants))

    return {
      valid: false,
      error: `Nombre de participants invalide (${participantsCount}). Accepté: ${minParticipants} à ${maxParticipants} participants.`,
      errorKey: 'errors.priceValidation.invalidParticipants'
    }
  }

  // 4. Vérifier que le produit iCount lié existe
  const { data: products } = await supabase
    .from('icount_products')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)

  if (!products || products.length === 0) {
    return {
      valid: false,
      error: 'Aucun produit iCount configuré pour cette branche',
      errorKey: 'errors.priceValidation.noProducts'
    }
  }

  // Chercher le produit lié à la formule
  let eventProduct: ICountProduct | undefined

  // 1. Par product_id direct (méthode préférée)
  if (matchingFormula.product_id) {
    eventProduct = products.find((p: ICountProduct) => p.id === matchingFormula.product_id)
  }

  // 2. Par code tier (fallback)
  if (!eventProduct) {
    const tierCode = `event_${matchingFormula.game_type.toLowerCase()}_${matchingFormula.min_participants}_${matchingFormula.max_participants}`
    eventProduct = products.find((p: ICountProduct) => p.code === tierCode)
  }

  // 3. Par code legacy (ancien système)
  if (!eventProduct) {
    const legacyCode = `event_${matchingFormula.game_type.toLowerCase()}_${matchingFormula.price_per_person}`
    eventProduct = products.find((p: ICountProduct) => p.code === legacyCode)
  }

  if (!eventProduct) {
    return {
      valid: false,
      error: `Produit iCount non trouvé pour la formule "${matchingFormula.name}". Synchronisez les produits iCount.`,
      errorKey: 'errors.priceValidation.productNotFound'
    }
  }

  // 5. Vérifier le produit salle si nécessaire
  let roomPrice = 0
  if (matchingFormula.room_id) {
    const { data: room } = await supabase
      .from('icount_rooms')
      .select('price, name, name_he')
      .eq('id', matchingFormula.room_id)
      .single()

    if (room && room.price > 0) {
      const roomProductCode = `room_event_${room.price}`
      const roomProduct = products.find((p: ICountProduct) => p.code === roomProductCode)

      if (!roomProduct) {
        return {
          valid: false,
          error: `Produit salle non trouvé (${room.name_he || room.name}). Créez le produit "${roomProductCode}" dans iCount.`,
          errorKey: 'errors.priceValidation.roomProductNotFound'
        }
      }
      roomPrice = roomProduct.unit_price
    }
  }

  // Validation réussie
  return {
    valid: true,
    formula: matchingFormula,
    unitPrice: eventProduct.unit_price,
    roomPrice,
    productCode: eventProduct.code
  }
}

/**
 * Validation prix GAME
 * Vérifie: produits laser_X ou active_X existent
 */
async function validateGamePrice(
  supabase: SupabaseClient,
  branchId: string,
  participantsCount: number,
  gameSessions?: GameSession[]
): Promise<PriceValidationResult> {

  if (!gameSessions || gameSessions.length === 0) {
    return {
      valid: false,
      error: 'Aucune session de jeu définie',
      errorKey: 'errors.priceValidation.noGameSessions'
    }
  }

  // Récupérer les produits de la branche
  const { data: products, error: productsError } = await supabase
    .from('icount_products')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)

  if (productsError) {
    console.error('[VALIDATION] Erreur lecture produits:', productsError)
    return {
      valid: false,
      error: 'Erreur lors de la lecture des produits',
      errorKey: 'errors.priceValidation.readError'
    }
  }

  if (!products || products.length === 0) {
    return {
      valid: false,
      error: 'Aucun produit iCount configuré pour cette branche',
      errorKey: 'errors.priceValidation.noProducts'
    }
  }

  // Vérifier les sessions LASER
  const laserSessions = gameSessions.filter(s => s.game_area === 'LASER')
  if (laserSessions.length > 0) {
    const laserCode = `laser_${Math.min(laserSessions.length, 4)}`
    const laserProduct = products.find((p: ICountProduct) => p.code === laserCode)

    if (!laserProduct) {
      return {
        valid: false,
        error: `Produit "${laserCode}" non trouvé. Créez-le dans la configuration iCount.`,
        errorKey: 'errors.priceValidation.laserProductNotFound'
      }
    }
  }

  // Vérifier les sessions ACTIVE
  const activeSessions = gameSessions.filter(s => s.game_area === 'ACTIVE')
  if (activeSessions.length > 0) {
    // Calculer la durée totale des sessions ACTIVE
    let totalMinutes = 0
    for (const session of activeSessions) {
      if (session.start_datetime && session.end_datetime) {
        const start = new Date(session.start_datetime)
        const end = new Date(session.end_datetime)
        totalMinutes += Math.round((end.getTime() - start.getTime()) / 60000)
      }
    }

    // Trouver le produit active_X le plus proche
    const durationOptions = [30, 60, 90, 120]
    const closestDuration = durationOptions.reduce((prev, curr) =>
      Math.abs(curr - totalMinutes) < Math.abs(prev - totalMinutes) ? curr : prev
    )

    const activeCode = `active_${closestDuration}`
    const activeProduct = products.find((p: ICountProduct) => p.code === activeCode)

    if (!activeProduct) {
      return {
        valid: false,
        error: `Produit "${activeCode}" non trouvé. Créez-le dans la configuration iCount.`,
        errorKey: 'errors.priceValidation.activeProductNotFound'
      }
    }
  }

  // Validation réussie
  return {
    valid: true
  }
}
</file>

<file path="src/lib/cache.ts">
/**
 * Système de cache intelligent pour ActiveLaser
 *
 * Stratégie :
 * - Cache les bookings J à J+45 (les plus utilisés)
 * - Cache les contacts avec bookings futurs
 * - Nettoyage automatique des données passées
 * - Affichage instantané au démarrage, sync en arrière-plan
 */

import type { BookingWithSlots } from '@/hooks/useBookings'
import type { Contact } from '@/lib/supabase/types'

// Clés de cache
const CACHE_KEYS = {
  BOOKINGS: 'activelaser_bookings_cache',
  CONTACTS: 'activelaser_contacts_cache',
  BRANCH_CONFIG: 'activelaser_branch_config',
  LAST_SYNC: 'activelaser_last_sync',
  VERSION: 'activelaser_cache_version',
}

// Version du cache (incrémenter si structure change)
const CACHE_VERSION = '1.0'

// Durée de validité du cache (en ms)
const CACHE_TTL = {
  BOOKINGS: 5 * 60 * 1000,      // 5 minutes
  CONTACTS: 10 * 60 * 1000,     // 10 minutes
  BRANCH_CONFIG: 60 * 60 * 1000, // 1 heure
}

interface CacheEntry<T> {
  data: T
  timestamp: number
  branchId: string
}

interface BookingsCache {
  [dateKey: string]: BookingWithSlots[] // dateKey = "YYYY-MM-DD"
}

/**
 * Vérifie si le cache est valide (version + TTL)
 */
function isCacheValid(timestamp: number, ttl: number): boolean {
  return Date.now() - timestamp < ttl
}

/**
 * Vérifie la version du cache et le nettoie si obsolète
 */
function checkCacheVersion(): void {
  if (typeof window === 'undefined') return

  const storedVersion = localStorage.getItem(CACHE_KEYS.VERSION)
  if (storedVersion !== CACHE_VERSION) {
    // Nettoyer tout le cache si version différente
    clearAllCache()
    localStorage.setItem(CACHE_KEYS.VERSION, CACHE_VERSION)
  }
}

/**
 * Nettoie tout le cache
 */
export function clearAllCache(): void {
  if (typeof window === 'undefined') return

  Object.values(CACHE_KEYS).forEach(key => {
    localStorage.removeItem(key)
  })
}

/**
 * Nettoie les bookings passés du cache
 */
export function cleanOldBookings(): void {
  if (typeof window === 'undefined') return

  try {
    const cached = localStorage.getItem(CACHE_KEYS.BOOKINGS)
    if (!cached) return

    const entry: CacheEntry<BookingsCache> = JSON.parse(cached)
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const todayStr = today.toISOString().split('T')[0]

    // Filtrer pour ne garder que les dates >= aujourd'hui
    const cleanedData: BookingsCache = {}
    Object.entries(entry.data).forEach(([dateKey, bookings]) => {
      if (dateKey >= todayStr) {
        cleanedData[dateKey] = bookings
      }
    })

    entry.data = cleanedData
    localStorage.setItem(CACHE_KEYS.BOOKINGS, JSON.stringify(entry))
  } catch (e) {
    console.warn('Error cleaning old bookings cache:', e)
  }
}

// ============================================
// BOOKINGS CACHE
// ============================================

/**
 * Récupère les bookings depuis le cache pour une date donnée
 */
export function getCachedBookings(branchId: string, date: string): BookingWithSlots[] | null {
  if (typeof window === 'undefined') return null

  checkCacheVersion()

  try {
    const cached = localStorage.getItem(CACHE_KEYS.BOOKINGS)
    if (!cached) return null

    const entry: CacheEntry<BookingsCache> = JSON.parse(cached)

    // Vérifier branche et validité
    if (entry.branchId !== branchId) return null
    if (!isCacheValid(entry.timestamp, CACHE_TTL.BOOKINGS)) return null

    return entry.data[date] || null
  } catch (e) {
    console.warn('Error reading bookings cache:', e)
    return null
  }
}

/**
 * Sauvegarde les bookings dans le cache
 */
export function setCachedBookings(branchId: string, date: string, bookings: BookingWithSlots[]): void {
  if (typeof window === 'undefined') return

  try {
    let entry: CacheEntry<BookingsCache>
    const cached = localStorage.getItem(CACHE_KEYS.BOOKINGS)

    if (cached) {
      entry = JSON.parse(cached)
      // Si branche différente, reset le cache
      if (entry.branchId !== branchId) {
        entry = { data: {}, timestamp: Date.now(), branchId }
      }
    } else {
      entry = { data: {}, timestamp: Date.now(), branchId }
    }

    entry.data[date] = bookings
    entry.timestamp = Date.now()

    localStorage.setItem(CACHE_KEYS.BOOKINGS, JSON.stringify(entry))
  } catch (e) {
    console.warn('Error writing bookings cache:', e)
  }
}

/**
 * Met à jour un booking spécifique dans le cache
 */
export function updateCachedBooking(branchId: string, booking: BookingWithSlots): void {
  if (typeof window === 'undefined') return

  try {
    const cached = localStorage.getItem(CACHE_KEYS.BOOKINGS)
    if (!cached) return

    const entry: CacheEntry<BookingsCache> = JSON.parse(cached)
    if (entry.branchId !== branchId) return

    const bookingDate = new Date(booking.start_datetime).toISOString().split('T')[0]

    if (entry.data[bookingDate]) {
      const index = entry.data[bookingDate].findIndex(b => b.id === booking.id)
      if (index >= 0) {
        entry.data[bookingDate][index] = booking
      } else {
        entry.data[bookingDate].push(booking)
      }
      localStorage.setItem(CACHE_KEYS.BOOKINGS, JSON.stringify(entry))
    }
  } catch (e) {
    console.warn('Error updating booking cache:', e)
  }
}

/**
 * Supprime un booking du cache
 */
export function removeCachedBooking(branchId: string, bookingId: string, date: string): void {
  if (typeof window === 'undefined') return

  try {
    const cached = localStorage.getItem(CACHE_KEYS.BOOKINGS)
    if (!cached) return

    const entry: CacheEntry<BookingsCache> = JSON.parse(cached)
    if (entry.branchId !== branchId) return

    if (entry.data[date]) {
      entry.data[date] = entry.data[date].filter(b => b.id !== bookingId)
      localStorage.setItem(CACHE_KEYS.BOOKINGS, JSON.stringify(entry))
    }
  } catch (e) {
    console.warn('Error removing booking from cache:', e)
  }
}

/**
 * Invalide le cache des bookings pour forcer un refresh
 */
export function invalidateBookingsCache(): void {
  if (typeof window === 'undefined') return
  localStorage.removeItem(CACHE_KEYS.BOOKINGS)
}

// ============================================
// CONTACTS CACHE (contacts avec bookings futurs)
// ============================================

/**
 * Récupère les contacts actifs depuis le cache
 */
export function getCachedContacts(branchId: string): Contact[] | null {
  if (typeof window === 'undefined') return null

  try {
    const cached = localStorage.getItem(CACHE_KEYS.CONTACTS)
    if (!cached) return null

    const entry: CacheEntry<Contact[]> = JSON.parse(cached)

    if (entry.branchId !== branchId) return null
    if (!isCacheValid(entry.timestamp, CACHE_TTL.CONTACTS)) return null

    return entry.data
  } catch (e) {
    console.warn('Error reading contacts cache:', e)
    return null
  }
}

/**
 * Sauvegarde les contacts dans le cache
 */
export function setCachedContacts(branchId: string, contacts: Contact[]): void {
  if (typeof window === 'undefined') return

  try {
    const entry: CacheEntry<Contact[]> = {
      data: contacts,
      timestamp: Date.now(),
      branchId,
    }
    localStorage.setItem(CACHE_KEYS.CONTACTS, JSON.stringify(entry))
  } catch (e) {
    console.warn('Error writing contacts cache:', e)
  }
}

/**
 * Invalide le cache des contacts
 */
export function invalidateContactsCache(): void {
  if (typeof window === 'undefined') return
  localStorage.removeItem(CACHE_KEYS.CONTACTS)
}

// ============================================
// BRANCH CONFIG CACHE
// ============================================

interface BranchConfig {
  rooms: unknown[]
  settings: unknown
  laserRooms: unknown[]
}

/**
 * Récupère la config de branche depuis le cache
 */
export function getCachedBranchConfig(branchId: string): BranchConfig | null {
  if (typeof window === 'undefined') return null

  try {
    const cached = localStorage.getItem(CACHE_KEYS.BRANCH_CONFIG)
    if (!cached) return null

    const entry: CacheEntry<BranchConfig> = JSON.parse(cached)

    if (entry.branchId !== branchId) return null
    if (!isCacheValid(entry.timestamp, CACHE_TTL.BRANCH_CONFIG)) return null

    return entry.data
  } catch (e) {
    console.warn('Error reading branch config cache:', e)
    return null
  }
}

/**
 * Sauvegarde la config de branche dans le cache
 */
export function setCachedBranchConfig(branchId: string, config: BranchConfig): void {
  if (typeof window === 'undefined') return

  try {
    const entry: CacheEntry<BranchConfig> = {
      data: config,
      timestamp: Date.now(),
      branchId,
    }
    localStorage.setItem(CACHE_KEYS.BRANCH_CONFIG, JSON.stringify(entry))
  } catch (e) {
    console.warn('Error writing branch config cache:', e)
  }
}

// ============================================
// PREFETCH (charger les prochaines semaines)
// ============================================

/**
 * Génère les dates des X prochains jours
 */
export function getUpcomingDates(days: number = 45): string[] {
  const dates: string[] = []
  const today = new Date()

  for (let i = 0; i < days; i++) {
    const date = new Date(today)
    date.setDate(date.getDate() + i)
    dates.push(date.toISOString().split('T')[0])
  }

  return dates
}

/**
 * Vérifie quelles dates manquent dans le cache
 */
export function getMissingDates(branchId: string, dates: string[]): string[] {
  if (typeof window === 'undefined') return dates

  try {
    const cached = localStorage.getItem(CACHE_KEYS.BOOKINGS)
    if (!cached) return dates

    const entry: CacheEntry<BookingsCache> = JSON.parse(cached)
    if (entry.branchId !== branchId) return dates

    return dates.filter(date => !entry.data[date])
  } catch (e) {
    return dates
  }
}

// ============================================
// LAST SYNC TRACKING
// ============================================

/**
 * Récupère le timestamp de la dernière sync
 */
export function getLastSyncTime(branchId: string): number | null {
  if (typeof window === 'undefined') return null

  try {
    const cached = localStorage.getItem(CACHE_KEYS.LAST_SYNC)
    if (!cached) return null

    const data = JSON.parse(cached)
    return data[branchId] || null
  } catch (e) {
    return null
  }
}

/**
 * Met à jour le timestamp de sync
 */
export function setLastSyncTime(branchId: string): void {
  if (typeof window === 'undefined') return

  try {
    let data: Record<string, number> = {}
    const cached = localStorage.getItem(CACHE_KEYS.LAST_SYNC)
    if (cached) {
      data = JSON.parse(cached)
    }
    data[branchId] = Date.now()
    localStorage.setItem(CACHE_KEYS.LAST_SYNC, JSON.stringify(data))
  } catch (e) {
    console.warn('Error setting last sync time:', e)
  }
}

// Nettoyage automatique au chargement du module (côté client)
if (typeof window !== 'undefined') {
  // Nettoyer les vieux bookings au démarrage
  setTimeout(() => {
    cleanOldBookings()
  }, 1000)
}
</file>

<file path="supabase/.temp/cli-latest">
v2.72.7
</file>

<file path="supabase/.temp/gotrue-version">
v2.185.0
</file>

<file path="supabase/.temp/pooler-url">
postgresql://postgres.zapwlcrjnabrfhoxfgqo@aws-1-eu-west-1.pooler.supabase.com:5432/postgres
</file>

<file path="supabase/.temp/postgres-version">
17.6.1.063
</file>

<file path="supabase/.temp/project-ref">
zapwlcrjnabrfhoxfgqo
</file>

<file path="supabase/.temp/rest-version">
v14.1
</file>

<file path="supabase/.temp/storage-migration">
buckets-objects-grants-postgres
</file>

<file path="supabase/.temp/storage-version">
v1.33.0
</file>

<file path=".env.example">
# Variables d'environnement Supabase

# URL du projet Supabase
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co

# Clé publique (anon key) - pour les opérations côté client
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key

# Clé de service (service_role key) - pour les opérations admin/server
# ⚠️ GARDEZ CETTE CLÉ SECRÈTE - Ne la commitez JAMAIS dans git
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key

# Brevo API Key pour l'envoi d'emails
BREVO_API_KEY=xkeysib-your_api_key

# Adresse email d'envoi (From)
BREVO_FROM_EMAIL=no-reply@yourdomain.com
BREVO_FROM_NAME=YourAppName
</file>

<file path="RAPPORT_SAUVEGARDE_SIMPLE.md">
# RAPPORT DE SAUVEGARDE - ACTIVELASER (VERSION SIMPLE)

## ✅ QUESTION 1: Si je save Supabase tous les jours, je peux récupérer clients/commandes/agenda ?

**RÉPONSE: OUI**

Supabase contient:
- ✅ Tous les clients
- ✅ Toutes les commandes
- ✅ Tous les paiements
- ✅ Tout l'agenda (réservations)
- ✅ Historique emails
- ✅ Logs d'activité

---

## 📁 QUESTION 2: Images/Vidéos - Où sont-elles EXACTEMENT ?

### Localisation ACTUELLE

**Sur ta machine locale (dev):**
```
/Users/jeremy/Desktop/claude/activelaser/public/
├── images/ (4 images, ~3 MB)
└── videos/ (13 vidéos, ~160 MB)
```

**Sur GitHub:**
- ✅ OUI - Ces fichiers sont dans le repo Git
- ⚠️ SAUF si tu as ajouté `public/` dans `.gitignore` (à vérifier)

**Sur Vercel (production):**
- ✅ OUI - Vercel déploie tout ce qui est sur GitHub
- Les fichiers `/public` deviennent accessibles sur ton site

**Sur Supabase:**
- ❌ NON - Aucune image/vidéo n'est sur Supabase Storage
- Le code n'utilise PAS Supabase Storage

### Donc concrètement:

```
Images/Vidéos
├── Local (dev): /activelaser/public/ ✅
├── GitHub: Oui (dans le repo) ✅
├── Vercel: Oui (déployé automatiquement) ✅
└── Supabase: Non ❌
```

---

## 💾 PLAN DE BACKUP COMPLET

### 1. SUPABASE (Données)
**Fréquence:** Tous les jours

**Méthode A - Dashboard Supabase:**
1. https://supabase.com/dashboard
2. Ton projet → Database → Backups
3. Télécharger le backup

**Méthode B - Export SQL:**
```bash
supabase db dump --project-id zapwlcrjnabrfhoxfgqo > backup_$(date +%Y%m%d).sql
```

**Contient:**
- Clients, commandes, agenda, paiements, emails, logs

---

### 2. GITHUB (Code + Images/Vidéos)
**Fréquence:** À chaque modification

```bash
git add .
git commit -m "backup"
git push origin main
```

**Contient:**
- Code source
- Fichiers `/public` (images/vidéos)
- Migrations SQL

---

### 3. VERCEL (Variables d'environnement)
**Fréquence:** Après chaque changement de config

Les variables d'environnement sont sur Vercel Dashboard:
1. https://vercel.com
2. Ton projet → Settings → Environment Variables

**Contient:**
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SUPABASE_SERVICE_ROLE_KEY`
- `BREVO_API_KEY`
- `ANTHROPIC_API_KEY`

**⚠️ IMPORTANT:** Faire une capture d'écran ou copier dans un fichier sécurisé

---

## 🔄 RESTAURATION COMPLÈTE

### Scénario: Tout recréer ailleurs

**Étape 1 - Base de données:**
1. Créer nouveau projet Supabase
2. Importer le backup SQL

**Étape 2 - Code + Images:**
```bash
git clone https://github.com/TON-REPO/activelaser.git
cd activelaser
npm install
```
→ Les images/vidéos sont déjà dans `/public` via Git

**Étape 3 - Déploiement:**
1. Créer nouveau projet Vercel
2. Connecter le repo GitHub
3. Ajouter les variables d'environnement
4. Déployer

**Résultat:** Tout est restauré

---

## 📊 TABLEAU RÉCAPITULATIF

| Type de donnée | Supabase | GitHub | Vercel | Backup nécessaire |
|----------------|----------|--------|--------|-------------------|
| Clients/Commandes | ✅ | ❌ | ❌ | Export Supabase |
| Agenda (réservations) | ✅ | ❌ | ❌ | Export Supabase |
| Images/Vidéos | ❌ | ✅ | ✅ | Git push |
| Code source | ❌ | ✅ | ✅ | Git push |
| Migrations SQL | ❌ | ✅ | ✅ | Git push |
| Variables env | ❌ | ❌ | ✅ | Screenshot Vercel |

---

## ⚡ CHECKLIST BACKUP RAPIDE

### Tous les jours:
```bash
# 1. Backup Supabase (automatique si activé)
# Ou manuel via dashboard

# 2. Push code sur GitHub
cd /activelaser
git add .
git commit -m "daily backup"
git push
```

### Une fois par mois:
- [ ] Export manuel Supabase → Télécharger le fichier SQL
- [ ] Screenshot des variables Vercel
- [ ] Vérifier que GitHub a bien les vidéos

---

## 🎯 RÉPONSE FINALE À TES QUESTIONS

### Q: Supabase = clients + commandes + agenda ?
**R: OUI** ✅

### Q: Images/vidéos sur Supabase ?
**R: NON** ❌

### Q: Images/vidéos où alors ?
**R: GitHub + Vercel (pas Supabase)** ✅

### Q: Si GitHub + Supabase sauvegardés, je peux tout recréer ?
**R: OUI** ✅ (+ les variables d'environnement Vercel)

---

## 🔐 LES 3 BACKUPS ESSENTIELS

1. **Supabase** → Données (clients, commandes, agenda)
2. **GitHub** → Code + Images/Vidéos
3. **Vercel variables** → Clés API (screenshot)

**Avec ces 3 = tu peux recréer le projet à 100%**

---

**Date:** 22 janvier 2026
</file>

<file path="src/app/admin/clients/components/ClientModal.tsx">
'use client'

import { useState, useEffect } from 'react'
import { X, Loader2, User, Phone, Mail, MessageSquare, Save, AlertCircle, Building2 } from 'lucide-react'
import { useContacts } from '@/hooks/useContacts'
import type { Contact, ClientType } from '@/lib/supabase/types'
import { validateEmail, validateIsraeliPhone, formatIsraeliPhone, VALIDATION_MESSAGES } from '@/lib/validation'

interface ClientModalProps {
  isOpen: boolean
  onClose: () => void
  contact: Contact | null // null = création, non-null = édition
  branchId: string
  onSave: (updatedContact?: Contact) => void | Promise<void>
  isDark: boolean
}

export function ClientModal({
  isOpen,
  onClose,
  contact,
  branchId,
  onSave,
  isDark,
}: ClientModalProps) {
  const { createContact, updateContact } = useContacts(branchId)

  const [firstName, setFirstName] = useState('')
  const [lastName, setLastName] = useState('')
  const [phone, setPhone] = useState('')
  const [email, setEmail] = useState('')
  const [notesClient, setNotesClient] = useState('')
  const [preferredLocale, setPreferredLocale] = useState<'he' | 'fr' | 'en'>('he')
  const [isCompany, setIsCompany] = useState(false)
  const [companyName, setCompanyName] = useState('')
  const [vatId, setVatId] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [validationErrors, setValidationErrors] = useState<{ phone?: string; email?: string }>({})

  // Initialiser les champs quand le modal s'ouvre ou que le contact change
  useEffect(() => {
    if (isOpen) {
      if (contact) {
        // Mode édition
        setFirstName(contact.first_name || '')
        setLastName(contact.last_name || '')
        setPhone(contact.phone || '')
        setEmail(contact.email || '')
        setNotesClient(contact.notes_client || '')
        setPreferredLocale(contact.preferred_locale || 'he')
        setIsCompany(contact.client_type === 'company')
        setCompanyName(contact.company_name || '')
        setVatId(contact.vat_id || '')
      } else {
        // Mode création
        setFirstName('')
        setLastName('')
        setPhone('')
        setEmail('')
        setNotesClient('')
        setPreferredLocale('he')
        setIsCompany(false)
        setCompanyName('')
        setVatId('')
      }
      setError(null)
      setValidationErrors({})
    }
  }, [isOpen, contact])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    // Validations
    if (!firstName.trim()) {
      setError('First name is required')
      return
    }

    if (!phone.trim()) {
      setError('Phone is required')
      return
    }

    // Validation format téléphone
    if (!validateIsraeliPhone(phone)) {
      setError(VALIDATION_MESSAGES.phone.israeliFormat)
      return
    }

    // Validation format email si renseigné
    if (email.trim() && !validateEmail(email)) {
      setError(VALIDATION_MESSAGES.email.invalid)
      return
    }

    // Validation entreprise
    if (isCompany) {
      if (!companyName.trim()) {
        setError('Company name is required for companies')
        return
      }
      if (!vatId.trim()) {
        setError('VAT ID is required for companies')
        return
      }
    }

    setLoading(true)

    try {
      const formattedPhone = formatIsraeliPhone(phone)
      const clientType: ClientType = isCompany ? 'company' : 'individual'

      if (contact) {
        // Mise à jour
        const updated = await updateContact(contact.id, {
          first_name: firstName.trim(),
          last_name: lastName.trim() || null,
          phone: formattedPhone,
          email: email.trim() || null,
          notes_client: notesClient.trim() || null,
          preferred_locale: preferredLocale,
          client_type: clientType,
          company_name: isCompany ? companyName.trim() : null,
          vat_id: isCompany ? vatId.trim() : null,
        })

        if (updated) {
          await onSave(updated)
          onClose()
        } else {
          setError('Error updating contact')
        }
      } else {
        // Création
        const newContact = await createContact({
          branch_id_main: branchId,
          first_name: firstName.trim(),
          last_name: lastName.trim() || null,
          phone: formattedPhone,
          email: email.trim() || null,
          notes_client: notesClient.trim() || null,
          preferred_locale: preferredLocale,
          source: 'admin_agenda',
          client_type: clientType,
          company_name: isCompany ? companyName.trim() : null,
          vat_id: isCompany ? vatId.trim() : null,
        })

        if (newContact) {
          await onSave(newContact)
          onClose()
        } else {
          setError('Error creating contact')
        }
      }
    } catch (err) {
      console.error('Error saving contact:', err)
      setError('An error occurred')
    } finally {
      setLoading(false)
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
      <div
        className={`relative w-full max-w-2xl mx-4 rounded-2xl shadow-2xl max-h-[90vh] overflow-y-auto ${
          isDark ? 'bg-gray-800' : 'bg-white'
        }`}
      >
        {/* Header */}
        <div className={`flex items-center justify-between p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <h2 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {contact ? 'Edit Contact' : 'New Contact'}
          </h2>
          <button
            onClick={onClose}
            disabled={loading}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'hover:bg-gray-700 text-gray-400 hover:text-white'
                : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
            } disabled:opacity-50`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {/* Erreur */}
          {error && (
            <div className={`p-4 rounded-lg border ${
              isDark
                ? 'bg-red-500/10 border-red-500/50 text-red-400'
                : 'bg-red-50 border-red-200 text-red-600'
            }`}>
              {error}
            </div>
          )}

          {/* Company Checkbox */}
          <div className={`flex items-center gap-3 p-3 rounded-lg border ${
            isDark ? 'border-gray-700 bg-gray-700/50' : 'border-gray-200 bg-gray-50'
          }`}>
            <input
              type="checkbox"
              id="isCompany"
              checked={isCompany}
              onChange={(e) => setIsCompany(e.target.checked)}
              className="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            />
            <label htmlFor="isCompany" className={`flex items-center gap-2 cursor-pointer ${isDark ? 'text-white' : 'text-gray-900'}`}>
              <Building2 className="w-5 h-5" />
              <span className="font-medium">Company</span>
              <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                (check if this is a business client)
              </span>
            </label>
          </div>

          {/* Company Fields (conditional) */}
          {isCompany && (
            <div className={`grid grid-cols-2 gap-4 p-4 rounded-lg border ${
              isDark ? 'border-blue-500/30 bg-blue-500/10' : 'border-blue-200 bg-blue-50'
            }`}>
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  <Building2 className="w-4 h-4 inline mr-1" />
                  Company Name *
                </label>
                <input
                  type="text"
                  value={companyName}
                  onChange={(e) => setCompanyName(e.target.value)}
                  className={`w-full px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                      : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                  } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                  placeholder="Company Ltd."
                />
              </div>
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  VAT ID *
                </label>
                <input
                  type="text"
                  value={vatId}
                  onChange={(e) => setVatId(e.target.value)}
                  className={`w-full px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                      : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                  } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                  placeholder="51XXXXXXX"
                />
              </div>
            </div>
          )}

          {/* Prénom et Nom */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                <User className="w-4 h-4 inline mr-1" />
                {isCompany ? 'Contact First Name *' : 'First Name *'}
              </label>
              <input
                type="text"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                placeholder="First name"
              />
            </div>
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {isCompany ? 'Contact Last Name' : 'Last Name'}
              </label>
              <input
                type="text"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                className={`w-full px-3 py-2 rounded-lg border ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                placeholder="Last name (optional)"
              />
            </div>
          </div>

          {/* Téléphone et Email */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                <Phone className="w-4 h-4 inline mr-1" />
                Phone *
              </label>
              <input
                type="tel"
                value={phone}
                onChange={(e) => {
                  const newPhone = e.target.value
                  setPhone(newPhone)
                  // Validation en temps réel
                  if (newPhone.trim() && !validateIsraeliPhone(newPhone)) {
                    setValidationErrors({ ...validationErrors, phone: VALIDATION_MESSAGES.phone.israeliFormat })
                  } else {
                    const { phone: _, ...rest } = validationErrors
                    setValidationErrors(rest)
                  }
                }}
                required
                className={`w-full px-3 py-2 rounded-lg border ${
                  validationErrors.phone
                    ? 'border-red-500'
                    : isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                placeholder="05XXXXXXXX"
              />
              {validationErrors.phone && (
                <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                  <AlertCircle className="w-4 h-4" />
                  <span>{validationErrors.phone}</span>
                </div>
              )}
            </div>
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                <Mail className="w-4 h-4 inline mr-1" />
                Email
              </label>
              <input
                type="email"
                value={email}
                onChange={(e) => {
                  const newEmail = e.target.value
                  setEmail(newEmail)
                  // Validation en temps réel
                  if (newEmail.trim() && !validateEmail(newEmail)) {
                    setValidationErrors({ ...validationErrors, email: VALIDATION_MESSAGES.email.invalid })
                  } else {
                    const { email: _, ...rest } = validationErrors
                    setValidationErrors(rest)
                  }
                }}
                className={`w-full px-3 py-2 rounded-lg border ${
                  validationErrors.email
                    ? 'border-red-500'
                    : isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                } focus:outline-none focus:ring-2 focus:ring-blue-500`}
                placeholder="email@example.com"
              />
              {validationErrors.email && (
                <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                  <AlertCircle className="w-4 h-4" />
                  <span>{validationErrors.email}</span>
                </div>
              )}
            </div>
          </div>

          {/* Langue préférée pour les emails */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <Mail className="w-4 h-4 inline mr-1" />
              Email Language
            </label>
            <div className="flex items-center gap-2">
              {([
                { code: 'he', flag: '🇮🇱', label: 'עברית (Hebrew)' },
                { code: 'fr', flag: '🇫🇷', label: 'Français (French)' },
                { code: 'en', flag: '🇬🇧', label: 'English' }
              ] as const).map(({ code, flag, label }) => (
                <button
                  key={code}
                  type="button"
                  onClick={() => setPreferredLocale(code)}
                  title={label}
                  className={`flex items-center gap-2 px-3 py-2 rounded-lg border transition-all ${
                    preferredLocale === code
                      ? isDark
                        ? 'bg-blue-600/30 border-blue-500 ring-2 ring-blue-500'
                        : 'bg-blue-100 border-blue-500 ring-2 ring-blue-500'
                      : isDark
                        ? 'bg-gray-700 border-gray-600 hover:bg-gray-600'
                        : 'bg-gray-50 border-gray-300 hover:bg-gray-100'
                  }`}
                >
                  <span className="text-xl">{flag}</span>
                  <span className={`text-sm ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {code === 'he' ? 'עברית' : code === 'fr' ? 'Français' : 'English'}
                  </span>
                </button>
              ))}
            </div>
            <p className={`mt-1 text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
              All emails (confirmations, reminders) will be sent in this language
            </p>
          </div>

          {/* Notes client */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <MessageSquare className="w-4 h-4 inline mr-1" />
              Client Notes (preferences, allergies, etc.)
            </label>
            <textarea
              value={notesClient}
              onChange={(e) => setNotesClient(e.target.value)}
              rows={4}
              className={`w-full px-3 py-2 rounded-lg border resize-none ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              } focus:outline-none focus:ring-2 focus:ring-blue-500`}
              placeholder="Global notes about the client (preferences, allergies, etc.)"
            />
          </div>

          {/* Footer */}
          <div className={`flex items-center justify-end gap-3 pt-4 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className={`px-4 py-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              } disabled:opacity-50`}
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className="px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  {contact ? 'Saving...' : 'Creating...'}
                </>
              ) : (
                <>
                  <Save className="w-4 h-4" />
                  {contact ? 'Save' : 'Create Contact'}
                </>
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/clients/page.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import { Search, Edit2, Archive, User, Phone, Mail, Loader2, Eye, ChevronLeft, ChevronRight, Plus, Download, ArrowUpDown, ArrowUp, ArrowDown, Users as UsersIcon, GitMerge, Settings, X } from 'lucide-react'
import { useContacts, type SearchContactsResult } from '@/hooks/useContacts'
import { useBranches } from '@/hooks/useBranches'
import { useAuth } from '@/hooks/useAuth'
import { useUserPermissions } from '@/hooks/useUserPermissions'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { ContactDetailsModal } from '../components/ContactDetailsModal'
import { ClientModal } from './components/ClientModal'
import { MergeContactsModal } from './components/MergeContactsModal'
import { ConfirmationModal } from '../components/ConfirmationModal'
import { CustomSelect } from '../components/CustomSelect'
import { createClient } from '@/lib/supabase/client'
import type { Contact } from '@/lib/supabase/types'

export default function ClientsPage() {
  const router = useRouter()
  const { t, locale } = useTranslation()
  const { user, loading: authLoading, signOut } = useAuth()
  const { hasPermission, loading: permissionsLoading } = useUserPermissions(user?.role || null)

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()
  const { searchContacts, archiveContact, unarchiveContact } = useContacts(selectedBranch?.id || null)

  const [searchQuery, setSearchQuery] = useState('')
  const [includeArchived, setIncludeArchived] = useState(false)
  const [contacts, setContacts] = useState<Contact[]>([])
  const [loading, setLoading] = useState(false)
  const [page, setPage] = useState(1)
  const [totalPages, setTotalPages] = useState(1)
  const [total, setTotal] = useState(0)
  const [selectedContact, setSelectedContact] = useState<Contact | null>(null)
  const [showDetailsModal, setShowDetailsModal] = useState(false)
  const [showClientModal, setShowClientModal] = useState(false)
  const [editingContact, setEditingContact] = useState<Contact | null>(null)
  const [sortField, setSortField] = useState<'name' | 'created_at' | 'last_activity'>('created_at')
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc')
  const [duplicatesToMerge, setDuplicatesToMerge] = useState<Contact[]>([])
  const [showMergeModal, setShowMergeModal] = useState(false)
  
  // Modal de confirmation
  const [confirmationModal, setConfirmationModal] = useState<{
    isOpen: boolean
    title: string
    message: string
    type?: 'warning' | 'info' | 'success'
    onConfirm: () => void
  }>({
    isOpen: false,
    title: '',
    message: '',
    type: 'warning',
    onConfirm: () => {},
  })
  
  // Filtres avancés
  const [filterStatus, setFilterStatus] = useState<'all' | 'active' | 'archived'>('all')
  const [filterSource, setFilterSource] = useState<'all' | 'admin_agenda' | 'public_booking'>('all')
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false)

  const pageSize = 20

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  // Rechercher les contacts
  const performSearch = useCallback(async () => {
    const branchToUse = selectedBranch || (branches.length > 0 ? branches[0] : null)
    if (!branchToUse?.id) return

    setLoading(true)
    try {
      const branchToUse = selectedBranch || (branches.length > 0 ? branches[0] : null)
      if (!branchToUse) return
      
      const result: SearchContactsResult = await searchContacts({
        query: searchQuery.trim() || undefined,
        branchId: branchToUse.id,
        includeArchived: filterStatus === 'all' ? includeArchived : filterStatus === 'archived',
        status: filterStatus === 'all' ? undefined : filterStatus,
        source: filterSource === 'all' ? undefined : filterSource,
        page,
        pageSize,
      })

      // Appliquer le tri côté client
      let sortedContacts = [...result.contacts]
      if (sortField === 'name') {
        sortedContacts.sort((a, b) => {
          const nameA = `${a.first_name || ''} ${a.last_name || ''}`.trim().toLowerCase() || a.phone
          const nameB = `${b.first_name || ''} ${b.last_name || ''}`.trim().toLowerCase() || b.phone
          return sortDirection === 'asc' 
            ? nameA.localeCompare(nameB)
            : nameB.localeCompare(nameA)
        })
      } else if (sortField === 'created_at') {
        sortedContacts.sort((a, b) => {
          const dateA = new Date(a.created_at).getTime()
          const dateB = new Date(b.created_at).getTime()
          return sortDirection === 'asc' ? dateA - dateB : dateB - dateA
        })
      }

      setContacts(sortedContacts)
      setTotalPages(result.totalPages)
      setTotal(result.total)
    } catch (error) {
      console.error('Error searching contacts:', error)
    } finally {
      setLoading(false)
    }
  }, [searchQuery, includeArchived, page, selectedBranch?.id, branches, sortField, sortDirection, filterStatus, filterSource])

  useEffect(() => {
    const branchToUse = selectedBranch || (branches.length > 0 ? branches[0] : null)
    if (branchToUse?.id) {
      performSearch()
    }
  }, [performSearch, selectedBranch?.id, branches])

  // Gérer l'archivage
  const handleArchive = (contact: Contact) => {
    setConfirmationModal({
      isOpen: true,
      title: t('admin.clients.archive_title'),
      message: t('admin.clients.archive_message'),
      type: 'warning',
      onConfirm: async () => {
        const success = await archiveContact(contact.id)
        if (success) {
          await performSearch()
        }
      },
    })
  }

  // Gérer la restauration
  const handleUnarchive = async (contact: Contact) => {
    const success = await unarchiveContact(contact.id)
    if (success) {
      await performSearch()
    }
  }

  // Ouvrir les détails
  const handleViewDetails = (contact: Contact) => {
    setSelectedContact(contact)
    setShowDetailsModal(true)
  }

  // Export CSV
  const handleExportCSV = () => {
    const headers = [
      t('admin.common.first_name') || 'First Name',
      t('admin.common.last_name') || 'Last Name',
      t('admin.clients.table.phone'),
      t('admin.clients.table.email'),
      t('admin.clients.table.notes'),
      t('admin.clients.table.source'),
      t('admin.clients.table.status'),
      t('admin.clients.table.created'),
      t('admin.common.updated_at') || 'Updated'
    ]
    const rows = contacts.map(contact => [
      contact.first_name || '',
      contact.last_name || '',
      contact.phone || '',
      contact.email || '',
      contact.notes_client || '',
      contact.source === 'admin_agenda' ? t('admin.clients.source.agenda') : t('admin.clients.source.public'),
      contact.status === 'active' ? t('admin.clients.status.active') : t('admin.clients.status.archived'),
      new Date(contact.created_at).toLocaleDateString(getDateLocale()),
      new Date(contact.updated_at).toLocaleDateString(getDateLocale()),
    ])

    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n')

    const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' })
    const link = document.createElement('a')
    const url = URL.createObjectURL(blob)
    link.setAttribute('href', url)
    link.setAttribute('download', `clients_${selectedBranch?.name || 'export'}_${new Date().toISOString().split('T')[0]}.csv`)
    link.style.visibility = 'hidden'
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }

  // Tri
  const handleSort = (field: 'name' | 'created_at' | 'last_activity') => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')
    } else {
      setSortField(field)
      setSortDirection('desc')
    }
  }

  const getSortIcon = (field: 'name' | 'created_at' | 'last_activity') => {
    if (sortField !== field) return <ArrowUpDown className="w-3 h-3 ml-1 opacity-50" />
    return sortDirection === 'asc' ? <ArrowUp className="w-3 h-3 ml-1" /> : <ArrowDown className="w-3 h-3 ml-1" />
  }

  // Ouvrir modal création/édition
  const handleOpenEditModal = (contact: Contact | null = null) => {
    setEditingContact(contact)
    setShowClientModal(true)
  }

  // Fermer modal et rafraîchir
  const handleCloseClientModal = () => {
    setShowClientModal(false)
    setEditingContact(null)
    performSearch()
  }

  const getDisplayName = (contact: Contact) => {
    const parts = [contact.first_name, contact.last_name].filter(Boolean)
    return parts.length > 0 ? parts.join(' ') : contact.phone
  }

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  // Gérer le thème (synchronisé avec localStorage)
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')
  
  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'

  // Calculer effectiveSelectedBranch avec fallback
  const effectiveSelectedBranch = selectedBranch || (branches.length > 0 ? branches[0] : null)

  // Permissions pour la ressource 'clients'
  const canCreateClient = hasPermission('clients', 'can_create')
  const canEditClient = hasPermission('clients', 'can_edit')
  const canDeleteClient = hasPermission('clients', 'can_delete')

  if (authLoading || branchesLoading || permissionsLoading || !user || !effectiveSelectedBranch) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header avec navigation */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={effectiveSelectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={handleSignOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sous-header avec titre et actions */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <h1 className={`text-2xl font-bold ${
              isDark ? 'text-white' : 'text-gray-900'
            }`}>{t('admin.clients.title')}</h1>
            <span className={`px-3 py-1 text-sm rounded-full ${
              isDark
                ? 'bg-blue-600/20 text-blue-400'
                : 'bg-blue-100 text-blue-700'
            }`}>
              {effectiveSelectedBranch.name}
            </span>
          </div>
          <div className="flex items-center gap-3">
            <button
              onClick={() => {
                const duplicates: Contact[] = []
                const seen = new Set<string>()
                contacts.forEach(contact => {
                  const key = contact.phone || contact.email || ''
                  if (key && seen.has(key)) {
                    const first = contacts.find(c => (c.phone === key || c.email === key) && !duplicates.includes(c))
                    if (first && !duplicates.includes(first)) duplicates.push(first)
                    if (!duplicates.includes(contact)) duplicates.push(contact)
                  } else if (key) seen.add(key)
                })
                if (duplicates.length >= 2) {
                  setDuplicatesToMerge(duplicates)
                  setShowMergeModal(true)
                } else {
                  setConfirmationModal({
                    isOpen: true,
                    title: t('admin.clients.duplicate_not_found'),
                    message: t('admin.clients.duplicate_not_found_message'),
                    type: 'info',
                    onConfirm: () => {
                      setConfirmationModal({ ...confirmationModal, isOpen: false })
                    },
                  })
                }
              }}
              disabled={contacts.length < 2}
              className="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition-colors flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <GitMerge className="w-4 h-4" />
              {t('admin.clients.detect_duplicates')}
            </button>
            <button
              onClick={handleExportCSV}
              disabled={contacts.length === 0}
              className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-white'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              <Download className="w-4 h-4" />
              {t('admin.clients.export_csv')}
            </button>
            <button
              onClick={() => handleOpenEditModal(null)}
              disabled={!canCreateClient}
              className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 ${
                canCreateClient
                  ? 'bg-blue-600 hover:bg-blue-700 text-white'
                  : 'bg-gray-500 text-gray-300 cursor-not-allowed opacity-50'
              }`}
              title={!canCreateClient ? t('admin.common.no_permission') : undefined}
            >
              <Plus className="w-4 h-4" />
              {t('admin.clients.new_contact')}
            </button>
          </div>
        </div>
      </div>

      {/* Recherche et filtres */}
      <div className={`px-6 py-4 border-b ${
        isDark ? 'bg-gray-800/50 border-gray-700' : 'bg-gray-50 border-gray-200'
      }`}>
        <div className="flex items-center gap-4">
          <div className="flex-1 relative">
            <Search className={`absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 ${
              isDark ? 'text-gray-400' : 'text-gray-500'
            }`} />
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => {
                setSearchQuery(e.target.value)
                setPage(1)
              }}
              placeholder={t('admin.clients.search_placeholder')}
              className={`w-full pl-10 pr-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                  : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              }`}
            />
          </div>
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={includeArchived}
              onChange={(e) => {
                setIncludeArchived(e.target.checked)
                setPage(1)
              }}
              className={`w-4 h-4 rounded text-blue-600 focus:ring-blue-500 ${
                isDark
                  ? 'border-gray-600 bg-gray-700'
                  : 'border-gray-300 bg-white'
              }`}
            />
            <span className={`text-sm ${
              isDark ? 'text-gray-300' : 'text-gray-700'
            }`}>{t('admin.clients.include_archived')}</span>
          </label>
          <button
            onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
            className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 ${
              isDark
                ? 'bg-gray-700 hover:bg-gray-600 text-white'
                : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
            }`}
          >
            <Settings className="w-4 h-4" />
            <span className="hidden sm:inline">{t('admin.clients.advanced_filters')}</span>
          </button>
        </div>
      </div>

      {/* Filtres avancés */}
      {showAdvancedFilters && (
        <div className={`px-6 py-4 border-b ${
          isDark ? 'bg-gray-800/30 border-gray-700' : 'bg-gray-50/50 border-gray-200'
        }`}>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Statut */}
            <div>
              <label className={`block text-sm mb-2 ${
                isDark ? 'text-gray-300' : 'text-gray-700'
              }`}>{t('admin.clients.table.status')}</label>
              <CustomSelect
                value={filterStatus}
                onChange={(value) => {
                  setFilterStatus(value as 'all' | 'active' | 'archived')
                  setPage(1)
                }}
                options={[
                  { value: 'all', label: t('admin.clients.status.all') },
                  { value: 'active', label: t('admin.clients.status.active') },
                  { value: 'archived', label: t('admin.clients.status.archived') },
                ]}
                placeholder="Sélectionner un statut"
                isDark={isDark}
              />
            </div>

            {/* Source */}
            <div>
              <label className={`block text-sm mb-2 ${
                isDark ? 'text-gray-300' : 'text-gray-700'
              }`}>{t('admin.clients.table.source')}</label>
              <CustomSelect
                value={filterSource}
                onChange={(value) => {
                  setFilterSource(value as 'all' | 'admin_agenda' | 'public_booking')
                  setPage(1)
                }}
                options={[
                  { value: 'all', label: t('admin.clients.source.all') },
                  { value: 'admin_agenda', label: t('admin.clients.source.admin_agenda') },
                  { value: 'public_booking', label: t('admin.clients.source.public_booking') },
                ]}
                placeholder="Sélectionner une source"
                isDark={isDark}
              />
            </div>
          </div>
          {(filterStatus !== 'all' || filterSource !== 'all') && (
            <button
              onClick={() => {
                setFilterStatus('all')
                setFilterSource('all')
                setPage(1)
              }}
              className={`mt-4 px-4 py-2 rounded-lg transition-colors flex items-center gap-2 ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-white'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              <X className="w-4 h-4" />
              {t('admin.clients.reset_filters')}
            </button>
          )}
        </div>
      )}

      {/* Tableau */}
      <div className="px-6 py-4">
        {loading ? (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 animate-spin text-blue-400" />
          </div>
        ) : contacts.length === 0 ? (
          <div className={`text-center py-12 ${
            isDark ? 'text-gray-400' : 'text-gray-600'
          }`}>
            {t('admin.clients.no_contacts')}
          </div>
        ) : (
          <>
            <div className={`rounded-lg border overflow-hidden ${
              isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
            }`}>
              <table className="w-full">
                <thead className={isDark ? 'bg-gray-700/50' : 'bg-gray-50'}>
                  <tr>
                    <th
                      className={`px-4 py-3 text-left text-sm font-medium cursor-pointer transition-colors ${
                        isDark
                          ? 'text-gray-300 hover:bg-gray-700'
                          : 'text-gray-700 hover:bg-gray-100'
                      }`}
                      onClick={() => handleSort('name')}
                    >
                      <div className="flex items-center">
                        {t('admin.clients.table.name')}
                        {getSortIcon('name')}
                      </div>
                    </th>
                    <th className={`px-4 py-3 text-left text-sm font-medium ${
                      isDark ? 'text-gray-300' : 'text-gray-700'
                    }`}>{t('admin.clients.table.phone')}</th>
                    <th className={`px-4 py-3 text-left text-sm font-medium ${
                      isDark ? 'text-gray-300' : 'text-gray-700'
                    }`}>{t('admin.clients.table.email')}</th>
                    <th className={`px-4 py-3 text-left text-sm font-medium ${
                      isDark ? 'text-gray-300' : 'text-gray-700'
                    }`}>{t('admin.clients.table.notes')}</th>
                    <th className={`px-4 py-3 text-left text-sm font-medium ${
                      isDark ? 'text-gray-300' : 'text-gray-700'
                    }`}>{t('admin.clients.table.source')}</th>
                    <th className={`px-4 py-3 text-left text-sm font-medium ${
                      isDark ? 'text-gray-300' : 'text-gray-700'
                    }`}>{t('admin.clients.table.status')}</th>
                    <th
                      className={`px-4 py-3 text-left text-sm font-medium cursor-pointer transition-colors ${
                        isDark
                          ? 'text-gray-300 hover:bg-gray-700'
                          : 'text-gray-700 hover:bg-gray-100'
                      }`}
                      onClick={() => handleSort('created_at')}
                    >
                      <div className="flex items-center">
                        {t('admin.clients.table.created')}
                        {getSortIcon('created_at')}
                      </div>
                    </th>
                    <th className={`px-4 py-3 text-right text-sm font-medium ${
                      isDark ? 'text-gray-300' : 'text-gray-700'
                    }`}>{t('admin.clients.table.actions')}</th>
                  </tr>
                </thead>
                <tbody className={`divide-y ${
                  isDark ? 'divide-gray-700' : 'divide-gray-200'
                }`}>
                  {contacts.map((contact) => (
                    <tr key={contact.id} className={`transition-colors ${
                      isDark ? 'hover:bg-gray-700/30' : 'hover:bg-gray-50'
                    }`}>
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-2">
                          <div className="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center">
                            <User className="w-4 h-4 text-white" />
                          </div>
                          <span className={`font-medium ${
                            isDark ? 'text-white' : 'text-gray-900'
                          }`}>{getDisplayName(contact)}</span>
                        </div>
                      </td>
                      <td className={`px-4 py-3 ${
                        isDark ? 'text-gray-300' : 'text-gray-700'
                      }`}>{contact.phone}</td>
                      <td className={`px-4 py-3 ${
                        isDark ? 'text-gray-300' : 'text-gray-700'
                      }`}>{contact.email || '-'}</td>
                      <td className={`px-4 py-3 max-w-xs ${
                        isDark ? 'text-gray-300' : 'text-gray-700'
                      }`}>
                        {contact.notes_client ? (
                          <div className="truncate" title={contact.notes_client}>
                            {contact.notes_client}
                          </div>
                        ) : (
                          <span className="text-gray-400">-</span>
                        )}
                      </td>
                      <td className="px-4 py-3">
                        <span className={`px-2 py-1 text-xs rounded-full ${
                          isDark
                            ? 'bg-gray-700 text-gray-300'
                            : 'bg-gray-200 text-gray-700'
                        }`}>
                          {contact.source === 'admin_agenda' ? t('admin.clients.source.agenda') : t('admin.clients.source.public')}
                        </span>
                      </td>
                      <td className="px-4 py-3">
                        {contact.status === 'archived' ? (
                          <span className="px-2 py-1 text-xs rounded-full bg-yellow-600/20 text-yellow-400">
                            {t('admin.clients.status.archived')}
                          </span>
                        ) : (
                          <span className="px-2 py-1 text-xs rounded-full bg-green-600/20 text-green-400">
                            {t('admin.clients.status.active')}
                          </span>
                        )}
                      </td>
                      <td className={`px-4 py-3 text-sm ${
                        isDark ? 'text-gray-400' : 'text-gray-600'
                      }`}>
                        {new Date(contact.created_at).toLocaleDateString(getDateLocale(), {
                          day: 'numeric',
                          month: 'short',
                          year: 'numeric',
                        })}
                      </td>
                      <td className="px-4 py-3">
                        <div className="flex items-center justify-end gap-2">
                          <button
                            onClick={() => handleViewDetails(contact)}
                            className={`p-2 rounded-lg transition-colors ${
                              isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'
                            }`}
                            title={t('admin.clients.actions.view')}
                          >
                            <Eye className="w-4 h-4 text-blue-400" />
                          </button>
                          <button
                            onClick={() => handleOpenEditModal(contact)}
                            disabled={!canEditClient}
                            className={`p-2 rounded-lg transition-colors ${
                              canEditClient
                                ? isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'
                                : 'cursor-not-allowed opacity-30'
                            }`}
                            title={!canEditClient ? t('admin.common.no_permission') : t('admin.clients.actions.edit')}
                          >
                            <Edit2 className={`w-4 h-4 ${
                              isDark ? 'text-gray-400' : 'text-gray-600'
                            }`} />
                          </button>
                          {contact.status === 'archived' ? (
                            <button
                              onClick={() => handleUnarchive(contact)}
                              disabled={!canDeleteClient}
                              className={`p-2 rounded-lg transition-colors ${
                                canDeleteClient
                                  ? isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'
                                  : 'cursor-not-allowed opacity-30'
                              }`}
                              title={!canDeleteClient ? t('admin.common.no_permission') : t('admin.clients.actions.unarchive')}
                            >
                              <Archive className={`w-4 h-4 ${canDeleteClient ? 'text-green-400' : 'text-gray-500'}`} />
                            </button>
                          ) : (
                            <button
                              onClick={() => handleArchive(contact)}
                              disabled={!canDeleteClient}
                              className={`p-2 rounded-lg transition-colors ${
                                canDeleteClient
                                  ? isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'
                                  : 'cursor-not-allowed opacity-30'
                              }`}
                              title={!canDeleteClient ? t('admin.common.no_permission') : t('admin.clients.actions.archive')}
                            >
                              <Archive className={`w-4 h-4 ${canDeleteClient ? 'text-yellow-400' : 'text-gray-500'}`} />
                            </button>
                          )}
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-between mt-4">
                <div className={`text-sm ${
                  isDark ? 'text-gray-400' : 'text-gray-600'
                }`}>
                  {t('admin.clients.pagination').replace('{{page}}', String(page)).replace('{{totalPages}}', String(totalPages)).replace('{{total}}', String(total)).replace('{{plural}}', total !== 1 ? 's' : '')}
                </div>
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => setPage(p => Math.max(1, p - 1))}
                    disabled={page === 1}
                    className={`px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors ${
                      isDark
                        ? 'bg-gray-800 hover:bg-gray-700 text-white'
                        : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                    }`}
                  >
                    <ChevronLeft className="w-4 h-4" />
                  </button>
                  <button
                    onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                    disabled={page === totalPages}
                    className={`px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors ${
                      isDark
                        ? 'bg-gray-800 hover:bg-gray-700 text-white'
                        : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                    }`}
                  >
                    <ChevronRight className="w-4 h-4" />
                  </button>
                </div>
              </div>
            )}
          </>
        )}
      </div>

      {/* Modal détails du contact - Composant partagé */}
      {showDetailsModal && selectedContact && (
        <ContactDetailsModal
          contactId={selectedContact.id}
          onClose={() => setShowDetailsModal(false)}
          isDark={isDark}
        />
      )}

      {/* Modal création/édition client */}
      {showClientModal && selectedBranch && (
        <ClientModal
          isOpen={showClientModal}
          onClose={handleCloseClientModal}
          contact={editingContact}
          branchId={selectedBranch.id}
          onSave={() => performSearch()}
          isDark={isDark}
        />
      )}

      {/* Modal fusion contacts */}
      {showMergeModal && effectiveSelectedBranch && duplicatesToMerge.length >= 2 && (
        <MergeContactsModal
          isOpen={showMergeModal}
          onClose={() => {
            setShowMergeModal(false)
            setDuplicatesToMerge([])
          }}
          contacts={duplicatesToMerge}
          onMergeComplete={performSearch}
          branchId={effectiveSelectedBranch.id}
          isDark={isDark}
        />
      )}

      {/* Modal de confirmation */}
      <ConfirmationModal
        isOpen={confirmationModal.isOpen}
        onClose={() => setConfirmationModal({ ...confirmationModal, isOpen: false })}
        onConfirm={confirmationModal.onConfirm}
        title={confirmationModal.title}
        message={confirmationModal.message}
        type={confirmationModal.type}
        isDark={isDark}
      />
    </div>
  )
}
</file>

<file path="src/app/admin/components/GridSettingsPopup.tsx">
'use client'

import { useTranslation } from '@/contexts/LanguageContext'

interface GridWidths {
  active: number
  laser: number
  rooms: number
}

interface GridSettingsPopupProps {
  isOpen: boolean
  onClose: () => void
  gridWidths: GridWidths
  setGridWidths: (widths: GridWidths) => void
  rowHeight: number
  setRowHeight: (height: number) => void
  visibleHoursStart: number
  setVisibleHoursStart: (hour: number) => void
  visibleHoursEnd: number
  setVisibleHoursEnd: (hour: number) => void
  selectedBranchId: string | null
  isDark: boolean
}

export function GridSettingsPopup({
  isOpen,
  onClose,
  gridWidths,
  setGridWidths,
  rowHeight,
  setRowHeight,
  visibleHoursStart,
  setVisibleHoursStart,
  visibleHoursEnd,
  setVisibleHoursEnd,
  selectedBranchId,
  isDark,
}: GridSettingsPopupProps) {
  const { t } = useTranslation()

  if (!isOpen) return null

  const saveSettings = (updates: Partial<{
    gridWidths: GridWidths
    rowHeight: number
    visibleHoursStart: number
    visibleHoursEnd: number
  }>) => {
    if (selectedBranchId) {
      localStorage.setItem(`gridSettings_${selectedBranchId}`, JSON.stringify({
        gridWidths: updates.gridWidths ?? gridWidths,
        rowHeight: updates.rowHeight ?? rowHeight,
        visibleHoursStart: updates.visibleHoursStart ?? visibleHoursStart,
        visibleHoursEnd: updates.visibleHoursEnd ?? visibleHoursEnd
      }))
    }
  }

  const handleWidthChange = (key: keyof GridWidths, value: number) => {
    const newWidths = { ...gridWidths, [key]: value }
    setGridWidths(newWidths)
    saveSettings({ gridWidths: newWidths })
  }

  const handleRowHeightChange = (value: number) => {
    setRowHeight(value)
    saveSettings({ rowHeight: value })
  }

  const handleVisibleHoursStartChange = (value: number) => {
    // S'assurer que start < end
    const newStart = Math.min(value, visibleHoursEnd - 1)
    setVisibleHoursStart(newStart)
    saveSettings({ visibleHoursStart: newStart })
  }

  const handleVisibleHoursEndChange = (value: number) => {
    // S'assurer que end > start
    const newEnd = Math.max(value, visibleHoursStart + 1)
    setVisibleHoursEnd(newEnd)
    saveSettings({ visibleHoursEnd: newEnd })
  }

  const handleReset = () => {
    const defaultWidths = { active: 100, laser: 100, rooms: 100 }
    const defaultRowHeight = 20
    const defaultVisibleHoursStart = 10
    const defaultVisibleHoursEnd = 23
    setGridWidths(defaultWidths)
    setRowHeight(defaultRowHeight)
    setVisibleHoursStart(defaultVisibleHoursStart)
    setVisibleHoursEnd(defaultVisibleHoursEnd)
    saveSettings({
      gridWidths: defaultWidths,
      rowHeight: defaultRowHeight,
      visibleHoursStart: defaultVisibleHoursStart,
      visibleHoursEnd: defaultVisibleHoursEnd
    })
  }

  // Générer les options d'heures (0-23)
  const hourOptions = Array.from({ length: 24 }, (_, i) => i)

  return (
    <>
      {/* Zone cliquable transparente pour fermer */}
      <div
        className="fixed inset-0 z-40"
        onClick={onClose}
      />
      <div className="fixed top-20 left-4 z-50 w-80">
        <div className={`rounded-xl shadow-2xl border-2 ${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-300'}`}>
          <div className="p-4">
            <div className="flex items-center justify-between mb-4">
              <h3 className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.agenda.settings.settings_title')}
              </h3>
              <button
                onClick={(e) => {
                  e.stopPropagation()
                  onClose()
                }}
                className={`p-1 rounded-lg ${isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'}`}
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>

            {/* Largeur ACTIVE */}
            <div className="mb-3">
              <label className={`block text-xs font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.agenda.settings.active_width')}: {gridWidths.active}%
              </label>
              <input
                type="range"
                min="5"
                max="500"
                step="5"
                value={gridWidths.active}
                onChange={(e) => handleWidthChange('active', parseInt(e.target.value))}
                className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className={`flex justify-between text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                <span>5%</span>
                <span>100% ({t('admin.agenda.settings.normal')})</span>
                <span>500%</span>
              </div>
            </div>

            {/* Largeur LASER */}
            <div className="mb-3">
              <label className={`block text-xs font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.agenda.settings.laser_width')}: {gridWidths.laser}%
              </label>
              <input
                type="range"
                min="5"
                max="800"
                step="5"
                value={gridWidths.laser}
                onChange={(e) => handleWidthChange('laser', parseInt(e.target.value))}
                className="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className={`flex justify-between text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                <span>5%</span>
                <span>100% ({t('admin.agenda.settings.normal')})</span>
                <span>800%</span>
              </div>
            </div>

            {/* Largeur ROOMS */}
            <div className="mb-3">
              <label className={`block text-xs font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.agenda.settings.rooms_width')}: {gridWidths.rooms}%
              </label>
              <input
                type="range"
                min="5"
                max="500"
                step="5"
                value={gridWidths.rooms}
                onChange={(e) => handleWidthChange('rooms', parseInt(e.target.value))}
                className="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className={`flex justify-between text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                <span>5%</span>
                <span>100% ({t('admin.agenda.settings.normal')})</span>
                <span>500%</span>
              </div>
            </div>

            {/* Hauteur des lignes */}
            <div className="mb-4">
              <label className={`block text-xs font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.agenda.settings.row_height')}: {rowHeight}px
              </label>
              <input
                type="range"
                min="10"
                max="50"
                value={rowHeight}
                onChange={(e) => handleRowHeightChange(parseInt(e.target.value))}
                className="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
              />
            </div>

            {/* Séparateur */}
            <div className={`border-t my-4 ${isDark ? 'border-gray-700' : 'border-gray-200'}`} />

            {/* Heures visibles */}
            <div className="mb-4">
              <label className={`block text-xs font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.agenda.settings.visible_hours') || 'Heures visibles'}
              </label>
              <div className="flex items-center gap-2">
                <select
                  value={visibleHoursStart}
                  onChange={(e) => handleVisibleHoursStartChange(parseInt(e.target.value))}
                  className={`flex-1 px-2 py-1 text-sm rounded border ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-white border-gray-300 text-gray-900'
                  }`}
                >
                  {hourOptions.map((h) => (
                    <option key={h} value={h} disabled={h >= visibleHoursEnd}>
                      {String(h).padStart(2, '0')}:00
                    </option>
                  ))}
                </select>
                <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>→</span>
                <select
                  value={visibleHoursEnd}
                  onChange={(e) => handleVisibleHoursEndChange(parseInt(e.target.value))}
                  className={`flex-1 px-2 py-1 text-sm rounded border ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-white border-gray-300 text-gray-900'
                  }`}
                >
                  {hourOptions.map((h) => (
                    <option key={h} value={h} disabled={h <= visibleHoursStart}>
                      {String(h).padStart(2, '0')}:45
                    </option>
                  ))}
                </select>
              </div>
              <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                {t('admin.agenda.settings.visible_hours_hint') || 'Extension automatique si réservation hors plage'}
              </p>
            </div>

            {/* Bouton Réinitialiser */}
            <button
              onClick={handleReset}
              className={`w-full px-3 py-2 rounded-lg text-sm ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              {t('admin.agenda.settings.reset')}
            </button>
          </div>
        </div>
      </div>
    </>
  )
}
</file>

<file path="src/app/admin/data-management/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Trash2, AlertTriangle, Loader2, CheckCircle, Database, Users, Calendar, FileText, Mail, ChevronDown, ChevronUp } from 'lucide-react'
import { useAuth } from '@/hooks/useAuth'
import { useBranches } from '@/hooks/useBranches'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'

interface DataCounts {
  logs: number
  emails: number
  orders: number
  bookings: number
  game_sessions: number
  booking_slots: number
  contacts: number
}

interface DeletionGroup {
  id: 'logs' | 'reservations' | 'contacts'
  label: string
  description: string
  icon: React.ReactNode
  tables: string[]
  color: string
  requiresReservationsDeletion?: boolean
}

export default function DataManagementPage() {
  const router = useRouter()
  const { t } = useTranslation()
  const { user, loading: authLoading, signOut } = useAuth()
  const { branches, loading: branchesLoading, selectedBranch, selectBranch } = useBranches()

  const [theme, setTheme] = useState<'light' | 'dark'>('dark')
  const [counts, setCounts] = useState<DataCounts | null>(null)
  const [loadingCounts, setLoadingCounts] = useState(true)
  const [selectedBranches, setSelectedBranches] = useState<string[]>([])
  const [showBranchSelector, setShowBranchSelector] = useState(false)

  // Deletion state
  const [deletingGroup, setDeletingGroup] = useState<string | null>(null)
  const [showPasswordModal, setShowPasswordModal] = useState(false)
  const [pendingDeletion, setPendingDeletion] = useState<DeletionGroup | null>(null)
  const [password, setPassword] = useState('')
  const [passwordError, setPasswordError] = useState<string | null>(null)
  const [deletionSuccess, setDeletionSuccess] = useState<string | null>(null)
  const [selectedGroups, setSelectedGroups] = useState<Set<string>>(new Set())

  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
      if (savedTheme) setTheme(savedTheme)
    }
  }, [])

  // Redirect non super_admin users
  useEffect(() => {
    if (!authLoading && user && user.role !== 'super_admin') {
      router.push('/admin')
    }
  }, [user, authLoading, router])

  // Load counts when branches are selected
  useEffect(() => {
    if (selectedBranches.length > 0) {
      fetchCounts()
    } else {
      setCounts(null)
    }
  }, [selectedBranches])

  // Initialize selectedBranches with all branches
  useEffect(() => {
    if (branches.length > 0 && selectedBranches.length === 0) {
      setSelectedBranches(branches.map(b => b.id))
    }
  }, [branches])

  const fetchCounts = async () => {
    setLoadingCounts(true)
    try {
      const response = await fetch('/api/admin/data-management/counts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ branchIds: selectedBranches })
      })
      const data = await response.json()
      if (data.success) {
        setCounts(data.counts)
      }
    } catch (error) {
      console.error('Error fetching counts:', error)
    } finally {
      setLoadingCounts(false)
    }
  }

  const handleToggleTheme = () => {
    const newTheme = theme === 'dark' ? 'light' : 'dark'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const handleBranchSelect = (branchId: string) => {
    selectBranch(branchId)
  }

  const toggleBranchSelection = (branchId: string) => {
    setSelectedBranches(prev =>
      prev.includes(branchId)
        ? prev.filter(id => id !== branchId)
        : [...prev, branchId]
    )
  }

  const selectAllBranches = () => {
    setSelectedBranches(branches.map(b => b.id))
  }

  const deselectAllBranches = () => {
    setSelectedBranches([])
  }

  const deletionGroups: DeletionGroup[] = [
    {
      id: 'logs',
      label: 'Logs & Emails',
      description: 'Historique des activités et emails envoyés',
      icon: <FileText className="w-6 h-6" />,
      tables: ['activity_logs', 'email_logs'],
      color: 'yellow'
    },
    {
      id: 'reservations',
      label: 'Réservations',
      description: 'Commandes, réservations, sessions et créneaux',
      icon: <Calendar className="w-6 h-6" />,
      tables: ['orders', 'bookings', 'game_sessions', 'booking_slots'],
      color: 'orange'
    },
    {
      id: 'contacts',
      label: 'Contacts',
      description: 'Tous les contacts clients',
      icon: <Users className="w-6 h-6" />,
      tables: ['contacts'],
      color: 'red',
      requiresReservationsDeletion: true
    }
  ]

  const handleDeleteClick = (group: DeletionGroup) => {
    // Check if contacts deletion requires reservations to be deleted first
    if (group.requiresReservationsDeletion && counts) {
      const hasReservations = (counts.orders + counts.bookings + counts.game_sessions + counts.booking_slots) > 0
      if (hasReservations) {
        alert('Vous devez d\'abord supprimer toutes les réservations avant de supprimer les contacts.')
        return
      }
    }

    setPendingDeletion(group)
    setShowPasswordModal(true)
    setPassword('')
    setPasswordError(null)
  }

  const handleConfirmDeletion = async () => {
    if (!pendingDeletion || !password) return

    setPasswordError(null)
    setDeletingGroup(pendingDeletion.id)

    try {
      const response = await fetch('/api/admin/data-management/delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          group: pendingDeletion.id,
          branchIds: selectedBranches,
          password
        })
      })

      const data = await response.json()

      if (!data.success) {
        setPasswordError(data.error || 'Erreur lors de la suppression')
        setDeletingGroup(null)
        return
      }

      // Calculer le total supprimé
      const deleted = data.deleted || {}
      const totalDeleted = Object.values(deleted).reduce((sum: number, val) => sum + (val as number), 0)

      // Success
      setShowPasswordModal(false)
      setPendingDeletion(null)
      setPassword('')
      setDeletionSuccess(`${pendingDeletion.label} supprimés avec succès (${totalDeleted} éléments)`)

      // Refresh counts
      await fetchCounts()

      // Hide success message after 3 seconds
      setTimeout(() => setDeletionSuccess(null), 3000)

    } catch (error) {
      console.error('Error deleting data:', error)
      setPasswordError('Erreur de connexion au serveur')
    } finally {
      setDeletingGroup(null)
    }
  }

  const isDark = theme === 'dark'

  if (authLoading || branchesLoading || !user) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  if (user.role !== 'super_admin') {
    return null
  }

  const getGroupCount = (group: DeletionGroup): number => {
    if (!counts) return 0
    switch (group.id) {
      case 'logs':
        return counts.logs + counts.emails
      case 'reservations':
        return counts.orders + counts.bookings + counts.game_sessions + counts.booking_slots
      case 'contacts':
        return counts.contacts
      default:
        return 0
    }
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch}
        onBranchSelect={handleBranchSelect}
        onSignOut={signOut}
        theme={theme}
        onToggleTheme={handleToggleTheme}
      />

      <div className="max-w-4xl mx-auto px-4 py-8">
        {/* Header */}
        <div className="mb-8">
          <div className="flex items-center gap-3 mb-2">
            <div className={`p-3 rounded-xl ${isDark ? 'bg-red-900/30' : 'bg-red-100'}`}>
              <Database className={`w-8 h-8 ${isDark ? 'text-red-400' : 'text-red-600'}`} />
            </div>
            <div>
              <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                Gestion des données
              </h1>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                Zone de suppression massive - Super Admin uniquement
              </p>
            </div>
          </div>
        </div>

        {/* Warning Banner */}
        <div className={`mb-6 p-4 rounded-xl border-2 ${
          isDark ? 'bg-red-900/20 border-red-800' : 'bg-red-50 border-red-200'
        }`}>
          <div className="flex items-start gap-3">
            <AlertTriangle className={`w-6 h-6 flex-shrink-0 ${isDark ? 'text-red-400' : 'text-red-600'}`} />
            <div>
              <h3 className={`font-semibold ${isDark ? 'text-red-400' : 'text-red-700'}`}>
                Attention - Actions irréversibles
              </h3>
              <p className={`text-sm mt-1 ${isDark ? 'text-red-300' : 'text-red-600'}`}>
                Les suppressions sont définitives. Assurez-vous d'avoir une sauvegarde avant de procéder.
              </p>
            </div>
          </div>
        </div>

        {/* Success Message */}
        {deletionSuccess && (
          <div className={`mb-6 p-4 rounded-xl flex items-center gap-3 ${
            isDark ? 'bg-green-900/30 text-green-400' : 'bg-green-100 text-green-700'
          }`}>
            <CheckCircle className="w-5 h-5" />
            {deletionSuccess}
          </div>
        )}

        {/* Branch Selector */}
        <div className={`mb-6 p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-white'} shadow`}>
          <button
            onClick={() => setShowBranchSelector(!showBranchSelector)}
            className={`w-full flex items-center justify-between ${isDark ? 'text-white' : 'text-gray-900'}`}
          >
            <div className="flex items-center gap-2">
              <span className="font-medium">Branches sélectionnées:</span>
              <span className={`px-2 py-0.5 rounded text-sm ${
                isDark ? 'bg-blue-900/50 text-blue-300' : 'bg-blue-100 text-blue-700'
              }`}>
                {selectedBranches.length} / {branches.length}
              </span>
            </div>
            {showBranchSelector ? <ChevronUp className="w-5 h-5" /> : <ChevronDown className="w-5 h-5" />}
          </button>

          {showBranchSelector && (
            <div className="mt-4 space-y-2">
              <div className="flex gap-2 mb-3">
                <button
                  onClick={selectAllBranches}
                  className={`px-3 py-1 rounded text-sm ${
                    isDark ? 'bg-gray-700 hover:bg-gray-600 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  }`}
                >
                  Tout sélectionner
                </button>
                <button
                  onClick={deselectAllBranches}
                  className={`px-3 py-1 rounded text-sm ${
                    isDark ? 'bg-gray-700 hover:bg-gray-600 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  }`}
                >
                  Tout désélectionner
                </button>
              </div>
              {branches.map(branch => (
                <label
                  key={branch.id}
                  className={`flex items-center gap-3 p-2 rounded cursor-pointer ${
                    isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'
                  }`}
                >
                  <input
                    type="checkbox"
                    checked={selectedBranches.includes(branch.id)}
                    onChange={() => toggleBranchSelection(branch.id)}
                    className="w-4 h-4 rounded border-gray-300"
                  />
                  <span className={isDark ? 'text-gray-300' : 'text-gray-700'}>{branch.name}</span>
                </label>
              ))}
            </div>
          )}
        </div>

        {/* Deletion Groups */}
        {selectedBranches.length === 0 ? (
          <div className={`text-center py-12 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
            Sélectionnez au moins une branche pour voir les données
          </div>
        ) : loadingCounts ? (
          <div className="flex items-center justify-center py-12">
            <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
          </div>
        ) : (
          <div className="space-y-4">
            {deletionGroups.map(group => {
              const count = getGroupCount(group)
              const isDisabled = count === 0 || (group.requiresReservationsDeletion && counts &&
                (counts.orders + counts.bookings + counts.game_sessions + counts.booking_slots) > 0)

              return (
                <div
                  key={group.id}
                  className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-white'} shadow`}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-4">
                      <div className={`p-3 rounded-xl ${
                        group.color === 'yellow'
                          ? isDark ? 'bg-yellow-900/30 text-yellow-400' : 'bg-yellow-100 text-yellow-600'
                          : group.color === 'orange'
                            ? isDark ? 'bg-orange-900/30 text-orange-400' : 'bg-orange-100 text-orange-600'
                            : isDark ? 'bg-red-900/30 text-red-400' : 'bg-red-100 text-red-600'
                      }`}>
                        {group.icon}
                      </div>
                      <div>
                        <h3 className={`font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                          {group.label}
                        </h3>
                        <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                          {group.description}
                        </p>
                        <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                          Tables: {group.tables.join(', ')}
                        </p>
                      </div>
                    </div>

                    <div className="flex items-center gap-4">
                      <div className={`text-right ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                        <span className="text-2xl font-bold">{count.toLocaleString()}</span>
                        <span className="text-sm ml-1">éléments</span>
                      </div>
                      <button
                        onClick={() => handleDeleteClick(group)}
                        disabled={isDisabled || deletingGroup === group.id}
                        className={`px-4 py-2 rounded-lg font-medium flex items-center gap-2 transition-colors ${
                          isDisabled
                            ? 'bg-gray-400 cursor-not-allowed opacity-50 text-white'
                            : deletingGroup === group.id
                              ? 'bg-red-400 cursor-wait text-white'
                              : 'bg-red-600 hover:bg-red-700 text-white'
                        }`}
                      >
                        {deletingGroup === group.id ? (
                          <Loader2 className="w-4 h-4 animate-spin" />
                        ) : (
                          <Trash2 className="w-4 h-4" />
                        )}
                        Supprimer
                      </button>
                    </div>
                  </div>

                  {group.requiresReservationsDeletion && counts &&
                    (counts.orders + counts.bookings + counts.game_sessions + counts.booking_slots) > 0 && (
                    <p className={`mt-2 text-sm ${isDark ? 'text-orange-400' : 'text-orange-600'}`}>
                      ⚠️ Supprimez d'abord les réservations pour pouvoir supprimer les contacts
                    </p>
                  )}
                </div>
              )
            })}
          </div>
        )}

        {/* Counts Details */}
        {counts && selectedBranches.length > 0 && (
          <div className={`mt-6 p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-white'} shadow`}>
            <h3 className={`font-semibold mb-3 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              Détail des données
            </h3>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
              <div className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                <span className="font-medium">Logs:</span> {counts.logs.toLocaleString()}
              </div>
              <div className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                <span className="font-medium">Emails:</span> {counts.emails.toLocaleString()}
              </div>
              <div className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                <span className="font-medium">Orders:</span> {counts.orders.toLocaleString()}
              </div>
              <div className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                <span className="font-medium">Bookings:</span> {counts.bookings.toLocaleString()}
              </div>
              <div className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                <span className="font-medium">Sessions:</span> {counts.game_sessions.toLocaleString()}
              </div>
              <div className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                <span className="font-medium">Slots:</span> {counts.booking_slots.toLocaleString()}
              </div>
              <div className={isDark ? 'text-gray-400' : 'text-gray-600'}>
                <span className="font-medium">Contacts:</span> {counts.contacts.toLocaleString()}
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Password Confirmation Modal */}
      {showPasswordModal && pendingDeletion && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
          <div className={`w-full max-w-md mx-4 p-6 rounded-2xl shadow-2xl ${
            isDark ? 'bg-gray-900' : 'bg-white'
          }`}>
            <div className="flex items-center gap-3 mb-4">
              <div className={`p-3 rounded-xl bg-red-900/30`}>
                <AlertTriangle className="w-6 h-6 text-red-400" />
              </div>
              <div>
                <h3 className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  Confirmer la suppression
                </h3>
                <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                  {pendingDeletion.label}
                </p>
              </div>
            </div>

            <p className={`mb-4 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              Vous êtes sur le point de supprimer définitivement <strong>{getGroupCount(pendingDeletion).toLocaleString()}</strong> éléments.
              Cette action est irréversible.
            </p>

            <div className="mb-4">
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                Entrez votre mot de passe pour confirmer
              </label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Mot de passe"
                className={`w-full px-4 py-2 rounded-lg border ${
                  passwordError
                    ? 'border-red-500'
                    : isDark ? 'border-gray-700 bg-gray-800 text-white' : 'border-gray-300 bg-white text-gray-900'
                }`}
                autoFocus
              />
              {passwordError && (
                <p className="mt-1 text-sm text-red-500">{passwordError}</p>
              )}
            </div>

            <div className="flex gap-3">
              <button
                onClick={() => {
                  setShowPasswordModal(false)
                  setPendingDeletion(null)
                  setPassword('')
                  setPasswordError(null)
                }}
                className={`flex-1 py-2 px-4 rounded-lg font-medium ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                    : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                }`}
              >
                Annuler
              </button>
              <button
                onClick={handleConfirmDeletion}
                disabled={!password || deletingGroup !== null}
                className={`flex-1 py-2 px-4 rounded-lg font-medium flex items-center justify-center gap-2 ${
                  !password
                    ? 'bg-gray-400 cursor-not-allowed text-white'
                    : 'bg-red-600 hover:bg-red-700 text-white'
                }`}
              >
                {deletingGroup ? (
                  <Loader2 className="w-4 h-4 animate-spin" />
                ) : (
                  <Trash2 className="w-4 h-4" />
                )}
                Supprimer définitivement
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/login/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { getClient } from '@/lib/supabase/client'
import { Loader2, Lock as LockIcon, Mail, AlertCircle, Globe, ChevronDown } from 'lucide-react'
import Image from 'next/image'
import { useTranslation } from '@/contexts/LanguageContext'
import type { Locale } from '@/i18n'

const languageFlags: Record<Locale, { flag: string; label: string }> = {
  fr: { flag: '🇫🇷', label: 'Français' },
  en: { flag: '🇬🇧', label: 'English' },
  he: { flag: '🇮🇱', label: 'עברית' }
}

export default function LoginPage() {
  const router = useRouter()
  const { t, locale, setLocale } = useTranslation()
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const [showLanguageMenu, setShowLanguageMenu] = useState(false)
  const [rememberMe, setRememberMe] = useState(false)

  // Charger les identifiants sauvegardés au montage
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedEmail = localStorage.getItem('remembered_email')
      const savedPassword = localStorage.getItem('remembered_password')
      if (savedEmail && savedPassword) {
        setEmail(savedEmail)
        setPassword(savedPassword)
        setRememberMe(true)
      }
    }
  }, [])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)
    setLoading(true)

    try {
      const supabase = getClient()
      const { error: authError } = await supabase.auth.signInWithPassword({
        email,
        password
      })

      if (authError) {
        if (authError.message.includes('Invalid login credentials')) {
          setError(t('admin.login.error_invalid'))
        } else if (authError.message.includes('Email not confirmed')) {
          setError(t('admin.login.error_generic'))
        } else {
          setError(authError.message)
        }
        setLoading(false)
        return
      }

      // Sauvegarder ou supprimer les identifiants selon "Se souvenir de moi"
      if (rememberMe) {
        localStorage.setItem('remembered_email', email)
        localStorage.setItem('remembered_password', password)
      } else {
        localStorage.removeItem('remembered_email')
        localStorage.removeItem('remembered_password')
      }

      // Connexion réussie - redirection vers admin
      // Note: ne pas setLoading(false) ici car on redirige
      router.push('/admin')
    } catch (err) {
      console.error('Login error:', err)
      setError(t('admin.login.error_generic'))
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 px-4 relative">
      {/* Language Selector - Top Right */}
      <div className="absolute top-4 right-4">
        <div className="relative">
          <button
            onClick={() => setShowLanguageMenu(!showLanguageMenu)}
            className="flex items-center gap-2 px-3 py-2 rounded-lg bg-gray-800 hover:bg-gray-700 text-gray-300 transition-colors"
          >
            <Globe className="w-4 h-4" />
            <span>{languageFlags[locale].flag}</span>
            <ChevronDown className={`w-3 h-3 transition-transform ${showLanguageMenu ? 'rotate-180' : ''}`} />
          </button>

          {showLanguageMenu && (
            <div className="absolute right-0 top-full mt-2 w-40 rounded-lg shadow-xl z-50 overflow-hidden bg-gray-800 border border-gray-700">
              {(Object.keys(languageFlags) as Locale[]).map((lang) => (
                <button
                  key={lang}
                  onClick={() => {
                    setLocale(lang)
                    setShowLanguageMenu(false)
                  }}
                  className={`w-full px-4 py-2 text-left flex items-center gap-3 transition-colors ${
                    locale === lang
                      ? 'bg-blue-600/20 text-blue-400'
                      : 'text-gray-300 hover:bg-gray-700'
                  }`}
                >
                  <span className="text-lg">{languageFlags[lang].flag}</span>
                  <span>{languageFlags[lang].label}</span>
                </button>
              ))}
            </div>
          )}
        </div>
      </div>

      <div className="w-full max-w-md">
        {/* Logo/Title */}
        <div className="text-center mb-8">
          <div className="flex justify-center items-center gap-6 mb-6">
            <Image
              src="/images/logo-activegames.png"
              alt="Active Games"
              width={160}
              height={60}
              className="h-16 w-auto object-contain"
              priority
            />
            <Image
              src="/images/logo_laser_city.png"
              alt="Laser City"
              width={160}
              height={60}
              className="h-16 w-auto object-contain"
              priority
            />
          </div>
          <p className="text-gray-400 mt-2">{t('admin.login.subtitle')}</p>
        </div>

        {/* Login Form */}
        <form onSubmit={handleSubmit} className="bg-gray-800 rounded-xl p-8 shadow-xl border border-gray-700">
          {/* Error Message */}
          {error && (
            <div className="mb-6 p-4 bg-red-500/10 border border-red-500/50 rounded-lg flex items-center gap-3">
              <AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0" />
              <p className="text-red-400 text-sm">{error}</p>
            </div>
          )}

          {/* Email Field */}
          <div className="mb-4">
            <label htmlFor="email" className="block text-sm font-medium text-gray-300 mb-2">
              {t('admin.login.email')}
            </label>
            <div className="relative">
              <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
              <input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                autoComplete="email"
                placeholder={t('admin.login.email_placeholder')}
                className="w-full pl-11 pr-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-colors"
              />
            </div>
          </div>

          {/* Password Field */}
          <div className="mb-4">
            <label htmlFor="password" className="block text-sm font-medium text-gray-300 mb-2">
              {t('admin.login.password')}
            </label>
            <div className="relative">
              <LockIcon className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
              <input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                autoComplete="current-password"
                placeholder="••••••••"
                className="w-full pl-11 pr-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-colors"
              />
            </div>
          </div>

          {/* Remember Me Checkbox */}
          <div className="mb-6">
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={rememberMe}
                onChange={(e) => setRememberMe(e.target.checked)}
                className="w-4 h-4 rounded border-gray-600 bg-gray-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-gray-800"
              />
              <span className="text-sm text-gray-300">{t('admin.login.remember_me')}</span>
            </label>
          </div>

          {/* Submit Button */}
          <button
            type="submit"
            disabled={loading}
            className="w-full py-3 px-4 bg-cyan-600 hover:bg-cyan-700 disabled:bg-cyan-800 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors flex items-center justify-center gap-2"
          >
            {loading ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin" />
                {t('admin.login.logging_in')}
              </>
            ) : (
              t('admin.login.submit')
            )}
          </button>
        </form>

        {/* Footer */}
        <p className="text-center text-gray-500 text-sm mt-6">
          Active Games World &copy; {new Date().getFullYear()}
        </p>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/permissions/components/PermissionsTable.tsx">
'use client'

import { useState, useEffect, useCallback, useMemo } from 'react'
import { Check, X, Loader2, Save, Shield, Users, UserCog, Crown, User, Lock } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import { useRoles } from '@/hooks/useRoles'
import type { RolePermission, UserRole, ResourceType, PermissionSet, Role } from '@/lib/supabase/types'

interface PermissionsTableProps {
  permissions: RolePermission[]
  isDark: boolean
  onSavePermissions: (changes: Array<{ id: string; updates: Partial<PermissionSet> }>) => Promise<boolean>
}

// Resource display order
const RESOURCE_ORDER: ResourceType[] = ['agenda', 'orders', 'clients', 'users', 'logs', 'settings', 'permissions']

// Permission columns
const PERMISSION_COLUMNS: (keyof PermissionSet)[] = ['can_view', 'can_create', 'can_edit', 'can_delete']

// Icon props type
type IconProps = { className?: string; style?: React.CSSProperties }

// Icon mapping for role icons
const ICON_MAP: Record<string, React.ComponentType<IconProps>> = {
  Shield: Shield,
  UserCog: UserCog,
  Users: Users,
  Crown: Crown,
  User: User,
  Lock: Lock
}

// Get icon component from icon name
function getIconComponent(iconName: string): React.ComponentType<IconProps> {
  return ICON_MAP[iconName] || User
}

// Generate styling from role color
function getRoleStyles(color: string, isDark: boolean) {
  // Convert hex color to RGB for opacity variants
  const hex = color.replace('#', '')
  const r = parseInt(hex.substring(0, 2), 16)
  const g = parseInt(hex.substring(2, 4), 16)
  const b = parseInt(hex.substring(4, 6), 16)

  return {
    bgColor: `bg-[${color}]/20`,
    textColor: isDark ? `text-[${color}]` : `text-[${color}]`,
    borderColor: `border-[${color}]/50`,
    style: {
      '--role-color': color,
      '--role-bg': `rgba(${r}, ${g}, ${b}, 0.2)`,
      '--role-border': `rgba(${r}, ${g}, ${b}, 0.5)`,
    } as React.CSSProperties
  }
}

export function PermissionsTable({ permissions, isDark, onSavePermissions }: PermissionsTableProps) {
  const { t } = useTranslation()
  const { roles, loading: rolesLoading, isSystemRole } = useRoles()
  const [saving, setSaving] = useState(false)
  const [selectedRoleId, setSelectedRoleId] = useState<string | null>(null)

  // Local state for pending changes
  const [localPermissions, setLocalPermissions] = useState<Map<string, RolePermission>>(new Map())
  const [pendingChanges, setPendingChanges] = useState<Map<string, Partial<PermissionSet>>>(new Map())

  // Sort roles by level (ascending = highest authority first)
  const sortedRoles = useMemo(() => {
    return [...roles].sort((a, b) => a.level - b.level)
  }, [roles])

  // Select first non-system role by default (or first role)
  useEffect(() => {
    if (!selectedRoleId && sortedRoles.length > 0) {
      // Prefer first non-system role, otherwise take first role
      const defaultRole = sortedRoles.find(r => !r.is_system) || sortedRoles[0]
      setSelectedRoleId(defaultRole.id)
    }
  }, [sortedRoles, selectedRoleId])

  // Get selected role object
  const selectedRole = useMemo(() => {
    return roles.find(r => r.id === selectedRoleId) || null
  }, [roles, selectedRoleId])

  // Initialize local permissions from props
  useEffect(() => {
    console.log('[PermissionsTable] Received permissions:', permissions.length, 'items')
    console.log('[PermissionsTable] Unique roles in permissions:', [...new Set(permissions.map(p => p.role))])
    const permMap = new Map<string, RolePermission>()
    permissions.forEach(p => permMap.set(p.id, { ...p }))
    setLocalPermissions(permMap)
    setPendingChanges(new Map())
  }, [permissions])

  // Get permission for a specific role and resource
  const getPermission = useCallback((roleName: UserRole, resource: ResourceType): RolePermission | undefined => {
    const found = Array.from(localPermissions.values()).find(p => p.role === roleName && p.resource === resource)
    if (!found) {
      console.log('[PermissionsTable] Permission NOT FOUND for role:', roleName, 'resource:', resource)
    }
    return found
  }, [localPermissions])

  // Get all permissions for the selected role
  const getPermissionsForRole = useCallback((roleName: UserRole): RolePermission[] => {
    return RESOURCE_ORDER.map(resource => getPermission(roleName, resource)).filter((p): p is RolePermission => p !== undefined)
  }, [getPermission])

  // Handle toggle (local only, no API call)
  const handleToggle = (perm: RolePermission, column: keyof PermissionSet) => {
    // Don't allow editing system role permissions (super_admin)
    if (isSystemRole(perm.role)) return

    const newValue = !perm[column]

    // Update local state
    setLocalPermissions(prev => {
      const updated = new Map(prev)
      const current = updated.get(perm.id)
      if (current) {
        updated.set(perm.id, { ...current, [column]: newValue })
      }
      return updated
    })

    // Track changes
    setPendingChanges(prev => {
      const updated = new Map(prev)
      const existing = updated.get(perm.id) || {}

      // Get original value from permissions prop
      const original = permissions.find(p => p.id === perm.id)
      if (original && original[column] === newValue) {
        // If back to original, remove from pending
        delete existing[column]
        if (Object.keys(existing).length === 0) {
          updated.delete(perm.id)
        } else {
          updated.set(perm.id, existing)
        }
      } else {
        updated.set(perm.id, { ...existing, [column]: newValue })
      }
      return updated
    })
  }

  // Save all pending changes
  const handleSave = async () => {
    if (pendingChanges.size === 0) return

    setSaving(true)
    const changes = Array.from(pendingChanges.entries()).map(([id, updates]) => ({ id, updates }))
    const success = await onSavePermissions(changes)

    if (success) {
      setPendingChanges(new Map())
    }
    setSaving(false)
  }

  const hasChanges = pendingChanges.size > 0
  const isSelectedSystemRole = selectedRole?.is_system === true

  // Loading state
  if (rolesLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
      </div>
    )
  }

  // No roles
  if (sortedRoles.length === 0) {
    return (
      <div className={`text-center py-12 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
        {t('admin.permissions.no_roles')}
      </div>
    )
  }

  // Get icon for selected role
  const RoleIcon = selectedRole ? getIconComponent(selectedRole.icon) : User
  const roleStyles = selectedRole ? getRoleStyles(selectedRole.color, isDark) : null

  return (
    <div className="space-y-6">
      {/* Role Selector Tabs */}
      <div className="flex flex-wrap gap-3">
        {sortedRoles.map(role => {
          const Icon = getIconComponent(role.icon)
          const isSelected = selectedRoleId === role.id
          const isLocked = role.is_system
          const styles = getRoleStyles(role.color, isDark)

          return (
            <button
              key={role.id}
              onClick={() => setSelectedRoleId(role.id)}
              style={isSelected ? styles.style : undefined}
              className={`
                flex items-center gap-3 px-5 py-3 rounded-xl border-2 transition-all
                ${isSelected
                  ? isDark
                    ? 'border-[color:var(--role-border)]'
                    : 'border-[color:var(--role-border)]'
                  : isDark
                    ? 'bg-gray-800 border-gray-700 text-gray-400 hover:bg-gray-750 hover:border-gray-600'
                    : 'bg-white border-gray-200 text-gray-600 hover:bg-gray-50 hover:border-gray-300'
                }
              `}
            >
              <Icon
                className="w-5 h-5"
                style={isSelected ? { color: role.color } : undefined}
              />
              <div className="text-left">
                <div
                  className={`font-medium ${isSelected ? '' : isDark ? 'text-gray-300' : 'text-gray-700'}`}
                  style={isSelected ? { color: role.color } : undefined}
                >
                  {role.display_name}
                </div>
                <div className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                  {isLocked ? t('admin.permissions.locked') : `Level ${role.level}`}
                </div>
              </div>
            </button>
          )
        })}
      </div>

      {/* Selected Role Header */}
      {selectedRole && roleStyles && (
        <div
          className="flex items-center gap-4 p-4 rounded-xl border"
          style={{
            ...roleStyles.style,
            backgroundColor: `rgba(${parseInt(selectedRole.color.slice(1, 3), 16)}, ${parseInt(selectedRole.color.slice(3, 5), 16)}, ${parseInt(selectedRole.color.slice(5, 7), 16)}, 0.1)`,
            borderColor: `rgba(${parseInt(selectedRole.color.slice(1, 3), 16)}, ${parseInt(selectedRole.color.slice(3, 5), 16)}, ${parseInt(selectedRole.color.slice(5, 7), 16)}, 0.3)`
          }}
        >
          <div
            className="w-12 h-12 rounded-lg flex items-center justify-center"
            style={{
              backgroundColor: `rgba(${parseInt(selectedRole.color.slice(1, 3), 16)}, ${parseInt(selectedRole.color.slice(3, 5), 16)}, ${parseInt(selectedRole.color.slice(5, 7), 16)}, 0.2)`
            }}
          >
            <RoleIcon className="w-6 h-6" style={{ color: selectedRole.color }} />
          </div>
          <div>
            <h2 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {selectedRole.display_name}
            </h2>
            <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
              {selectedRole.description || t(`admin.permissions.role_description_${selectedRole.name}`, { fallback: `Level ${selectedRole.level}` })}
            </p>
          </div>
          {isSelectedSystemRole && (
            <div className={`ml-auto px-3 py-1 rounded-full text-xs font-medium ${
              isDark ? 'bg-red-500/30 text-red-300' : 'bg-red-100 text-red-700'
            }`}>
              {t('admin.permissions.all_permissions_locked')}
            </div>
          )}
        </div>
      )}

      {/* Permissions Grid */}
      <div className={`rounded-xl border overflow-hidden ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead>
              <tr className={isDark ? 'bg-gray-700/50' : 'bg-gray-50'}>
                <th className={`px-6 py-4 text-left text-sm font-medium uppercase tracking-wider ${
                  isDark ? 'text-gray-400' : 'text-gray-500'
                }`}>
                  {t('admin.permissions.table.resource')}
                </th>
                {PERMISSION_COLUMNS.map(col => (
                  <th key={col} className={`px-4 py-4 text-center text-sm font-medium uppercase tracking-wider ${
                    isDark ? 'text-gray-400' : 'text-gray-500'
                  }`}>
                    {t(`admin.permissions.table.${col}`)}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className={`divide-y ${isDark ? 'divide-gray-700' : 'divide-gray-200'}`}>
              {RESOURCE_ORDER.map(resource => {
                const perm = selectedRole ? getPermission(selectedRole.name, resource) : undefined

                return (
                  <tr
                    key={resource}
                    className={isDark ? 'hover:bg-gray-700/50' : 'hover:bg-gray-50'}
                  >
                    <td className={`px-6 py-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                      <div className="flex items-center gap-3">
                        <span className={`w-3 h-3 rounded-full ${getResourceColor(resource)}`} />
                        <span className="font-medium">
                          {t(`admin.permissions.resources.${resource}`)}
                        </span>
                      </div>
                    </td>
                    {PERMISSION_COLUMNS.map(col => {
                      if (!perm) {
                        return (
                          <td key={col} className={`px-4 py-4 text-center ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                            -
                          </td>
                        )
                      }

                      const isEnabled = perm[col]
                      const hasChange = pendingChanges.get(perm.id)?.[col] !== undefined

                      return (
                        <td key={col} className="px-4 py-4 text-center">
                          <button
                            onClick={() => handleToggle(perm, col)}
                            disabled={isSelectedSystemRole}
                            className={`
                              w-10 h-10 rounded-lg flex items-center justify-center mx-auto transition-all
                              ${isSelectedSystemRole ? 'cursor-not-allowed opacity-50' : 'cursor-pointer hover:scale-110'}
                              ${hasChange ? 'ring-2 ring-blue-500 ring-offset-2 ' + (isDark ? 'ring-offset-gray-800' : 'ring-offset-white') : ''}
                              ${isEnabled
                                ? isDark
                                  ? 'bg-green-500/20 text-green-400'
                                  : 'bg-green-100 text-green-600'
                                : isDark
                                  ? 'bg-gray-700 text-gray-500'
                                  : 'bg-gray-100 text-gray-400'
                              }
                            `}
                            title={isSelectedSystemRole ? t('admin.permissions.super_admin_locked') : ''}
                          >
                            {isEnabled ? (
                              <Check className="w-5 h-5" />
                            ) : (
                              <X className="w-5 h-5" />
                            )}
                          </button>
                        </td>
                      )
                    })}
                  </tr>
                )
              })}
            </tbody>
          </table>
        </div>
      </div>

      {/* Save button */}
      <div className="flex justify-end">
        <button
          onClick={handleSave}
          disabled={!hasChanges || saving || isSelectedSystemRole}
          className={`
            flex items-center gap-2 px-6 py-3 rounded-lg font-medium transition-all
            ${hasChanges && !isSelectedSystemRole
              ? 'bg-blue-600 hover:bg-blue-700 text-white cursor-pointer'
              : isDark
                ? 'bg-gray-700 text-gray-500 cursor-not-allowed'
                : 'bg-gray-200 text-gray-400 cursor-not-allowed'
            }
          `}
        >
          {saving ? (
            <Loader2 className="w-5 h-5 animate-spin" />
          ) : (
            <Save className="w-5 h-5" />
          )}
          {t('admin.permissions.save')}
          {hasChanges && (
            <span className="bg-white/20 px-2 py-0.5 rounded-full text-sm">
              {pendingChanges.size}
            </span>
          )}
        </button>
      </div>
    </div>
  )
}

// Helper function for resource colors
function getResourceColor(resource: ResourceType): string {
  const colors: Record<ResourceType, string> = {
    agenda: 'bg-blue-500',
    orders: 'bg-orange-500',
    clients: 'bg-green-500',
    users: 'bg-purple-500',
    logs: 'bg-yellow-500',
    settings: 'bg-pink-500',
    permissions: 'bg-red-500'
  }
  return colors[resource] || 'bg-gray-500'
}
</file>

<file path="src/app/admin/roles/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Plus, Loader2, AlertCircle, Crown, Trash2 } from 'lucide-react'
import { useAuth } from '@/hooks/useAuth'
import { useRoles } from '@/hooks/useRoles'
import { useBranches } from '@/hooks/useBranches'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { RolesTable } from './components/RolesTable'
import { RoleModal } from './components/RoleModal'
import type { Role } from '@/lib/supabase/types'
import { createClient } from '@/lib/supabase/client'

export default function RolesPage() {
  const router = useRouter()
  const { t } = useTranslation()
  const { user, loading: authLoading } = useAuth()
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()
  const { roles, loading: rolesLoading, error, refresh: refreshRoles, getRoleLevel } = useRoles()

  const [showCreateModal, setShowCreateModal] = useState(false)
  const [showEditModal, setShowEditModal] = useState(false)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const [selectedRole, setSelectedRole] = useState<Role | null>(null)
  const [deleteUserCount, setDeleteUserCount] = useState(0)

  // Theme state
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')

  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  // Get user level for hierarchy checks
  const userLevel = user?.role ? getRoleLevel(user.role) : 10

  const handleEdit = (role: Role) => {
    setSelectedRole(role)
    setShowEditModal(true)
  }

  const handleDelete = async (role: Role) => {
    // Toujours afficher la confirmation en deux étapes
    // Premier appel pour vérifier si des utilisateurs ont ce rôle
    try {
      const response = await fetch(`/api/roles/${role.id}?check_only=true`, {
        method: 'DELETE',
      })
      const data = await response.json()

      // Toujours afficher le popup de confirmation
      setSelectedRole(role)
      setDeleteUserCount(data.users_count || 0)
      setShowDeleteConfirm(true)
    } catch {
      alert('Erreur de connexion')
    }
  }

  const handleConfirmDelete = async () => {
    if (!selectedRole) return

    try {
      const response = await fetch(`/api/roles/${selectedRole.id}?force_remove=true`, {
        method: 'DELETE',
      })
      const data = await response.json()

      if (data.success) {
        refreshRoles()
        setShowDeleteConfirm(false)
        setSelectedRole(null)
        setDeleteUserCount(0)
      } else {
        alert(data.error || 'Erreur lors de la suppression')
      }
    } catch {
      alert('Erreur de connexion')
    }
  }

  const handleCreateRole = async (roleData: Partial<Role>): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch('/api/roles', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(roleData),
      })
      const data = await response.json()

      if (data.success) {
        refreshRoles()
        setShowCreateModal(false)
        return { success: true }
      } else {
        return { success: false, error: data.error }
      }
    } catch {
      return { success: false, error: 'Erreur de connexion' }
    }
  }

  const handleUpdateRole = async (roleId: string, roleData: Partial<Role>) => {
    try {
      const response = await fetch(`/api/roles/${roleId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(roleData),
      })
      const data = await response.json()

      if (data.success) {
        refreshRoles()
        setShowEditModal(false)
        setSelectedRole(null)
        return { success: true }
      } else {
        return { success: false, error: data.error }
      }
    } catch {
      return { success: false, error: 'Erreur de connexion' }
    }
  }

  // Check permissions - only level < 5 can manage roles
  if (user && userLevel >= 5) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <div className="text-center">
          <AlertCircle className="w-16 h-16 text-red-500 mx-auto mb-4" />
          <h1 className={`text-2xl font-bold mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {t('admin.roles.access_denied')}
          </h1>
          <p className={isDark ? 'text-gray-400' : 'text-gray-600'}>
            {t('admin.roles.access_denied_message')}
          </p>
        </div>
      </div>
    )
  }

  // Loading state
  if (authLoading || branchesLoading || !user || !selectedBranch) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={handleSignOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sub-header */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
              isDark ? 'bg-yellow-500/20' : 'bg-yellow-100'
            }`}>
              <Crown className={`w-6 h-6 ${isDark ? 'text-yellow-400' : 'text-yellow-600'}`} />
            </div>
            <div>
              <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.roles.title')}
              </h1>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                {t('admin.roles.subtitle')}
              </p>
            </div>
          </div>
          <button
            onClick={() => setShowCreateModal(true)}
            className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white transition-colors"
          >
            <Plus className="w-5 h-5" />
            {t('admin.roles.create')}
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="p-6 space-y-6">
        {/* Error */}
        {error && (
          <div className={`p-4 rounded-lg border flex items-start gap-2 ${
            isDark
              ? 'bg-red-500/10 border-red-500/50 text-red-400'
              : 'bg-red-50 border-red-200 text-red-600'
          }`}>
            <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
            <span>{error}</span>
          </div>
        )}

        {/* Loading */}
        {rolesLoading && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 animate-spin text-blue-500" />
          </div>
        )}

        {/* Table */}
        {!rolesLoading && (
          <RolesTable
            roles={roles}
            isDark={isDark}
            userLevel={userLevel}
            onEdit={handleEdit}
            onDelete={handleDelete}
          />
        )}
      </div>

      {/* Modals */}
      <RoleModal
        isOpen={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onSubmit={handleCreateRole}
        userLevel={userLevel}
        isDark={isDark}
        mode="create"
      />

      <RoleModal
        isOpen={showEditModal}
        onClose={() => {
          setShowEditModal(false)
          setSelectedRole(null)
        }}
        onSubmit={(data) => selectedRole ? handleUpdateRole(selectedRole.id, data) : Promise.resolve({ success: false, error: 'No role selected' })}
        role={selectedRole}
        userLevel={userLevel}
        isDark={isDark}
        mode="edit"
      />

      {/* Delete Confirmation Modal */}
      {showDeleteConfirm && selectedRole && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
          <div className={`w-full max-w-md rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className={`p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
              <div className="flex items-center gap-3">
                <div className="w-12 h-12 rounded-full bg-red-100 dark:bg-red-900/30 flex items-center justify-center">
                  <Trash2 className="w-6 h-6 text-red-600 dark:text-red-400" />
                </div>
                <div>
                  <h2 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {t('admin.roles.delete_title') || 'Supprimer le rôle'}
                  </h2>
                  <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                    {selectedRole.display_name}
                  </p>
                </div>
              </div>
            </div>

            <div className="p-6">
              <div className={`p-4 rounded-lg ${isDark ? 'bg-yellow-900/20 border border-yellow-700' : 'bg-yellow-50 border border-yellow-200'}`}>
                <div className="flex items-start gap-2">
                  <AlertCircle className="w-5 h-5 text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-0.5" />
                  <div className="flex-1">
                    <p className={`text-sm font-medium ${isDark ? 'text-yellow-300' : 'text-yellow-800'}`}>
                      {t('admin.roles.delete_warning') || 'Attention'}
                    </p>
                    <p className={`text-sm mt-1 ${isDark ? 'text-yellow-400' : 'text-yellow-700'}`}>
                      {deleteUserCount} {t('admin.roles.users_will_lose_access') || `utilisateur(s) vont perdre leur accès au système. Ils seront mis "sans rôle" jusqu'à réassignation.`}
                    </p>
                  </div>
                </div>
              </div>
            </div>

            <div className={`flex items-center justify-end gap-3 p-6 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
              <button
                onClick={() => {
                  setShowDeleteConfirm(false)
                  setSelectedRole(null)
                  setDeleteUserCount(0)
                }}
                className={`px-4 py-2 rounded-lg transition-colors ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                    : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                }`}
              >
                {t('admin.common.cancel')}
              </button>
              <button
                onClick={handleConfirmDelete}
                className="px-6 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white transition-colors"
              >
                {t('admin.roles.confirm_delete') || 'Supprimer quand même'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/settings/components/EmailTemplatesSection.tsx">
'use client'

import { useState } from 'react'
import {
  Loader2,
  AlertCircle,
  Plus,
  Edit2,
  Trash2,
  CheckCircle2,
  XCircle,
  Eye,
  Code,
  Lock
} from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import { useEmailTemplates } from '@/hooks/useEmailTemplates'
import type { EmailTemplate } from '@/lib/supabase/types'

interface EmailTemplatesSectionProps {
  isDark: boolean
}

export function EmailTemplatesSection({ isDark }: EmailTemplatesSectionProps) {
  const { t } = useTranslation()
  const { templates, loading, error, createTemplate, updateTemplate, deleteTemplate, refresh } = useEmailTemplates()

  // Filtrer les templates de termes et conditions (gérés dans leur propre section)
  const emailTemplates = templates.filter(t => !t.code.startsWith('terms_'))

  const [editingTemplate, setEditingTemplate] = useState<EmailTemplate | null>(null)
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [previewTemplate, setPreviewTemplate] = useState<EmailTemplate | null>(null)
  const [saving, setSaving] = useState(false)

  // Form state
  const [formData, setFormData] = useState({
    code: '',
    name: '',
    description: '',
    subject_template: '',
    body_template: '',
    is_active: true
  })

  const handleEdit = (template: EmailTemplate) => {
    setEditingTemplate(template)
    setFormData({
      code: template.code,
      name: template.name,
      description: template.description || '',
      subject_template: template.subject_template,
      body_template: template.body_template,
      is_active: template.is_active
    })
  }

  const handleCreate = () => {
    setFormData({
      code: '',
      name: '',
      description: '',
      subject_template: '',
      body_template: '',
      is_active: true
    })
    setShowCreateModal(true)
  }

  const handleSave = async () => {
    setSaving(true)

    try {
      if (editingTemplate) {
        // Update existing
        const result = await updateTemplate(editingTemplate.id, {
          name: formData.name,
          description: formData.description || null,
          subject_template: formData.subject_template,
          body_template: formData.body_template,
          is_active: formData.is_active
        })

        if (!result.success) {
          alert(result.error || t('admin.settings.email_templates.save_error'))
          return
        }

        setEditingTemplate(null)
      } else {
        // Create new
        const result = await createTemplate({
          code: formData.code,
          name: formData.name,
          description: formData.description || null,
          subject_template: formData.subject_template,
          body_template: formData.body_template,
          is_active: formData.is_active
        })

        if (!result.success) {
          alert(result.error || t('admin.settings.email_templates.save_error'))
          return
        }

        setShowCreateModal(false)
      }
    } finally {
      setSaving(false)
    }
  }

  const handleDelete = async (template: EmailTemplate) => {
    if (template.is_system) {
      alert(t('admin.settings.email_templates.cannot_delete_system'))
      return
    }

    if (confirm(t('admin.settings.email_templates.delete_confirm', { name: template.name }))) {
      const result = await deleteTemplate(template.id)
      if (!result.success) {
        alert(result.error || t('admin.settings.email_templates.delete_error'))
      }
    }
  }

  const handleToggleActive = async (template: EmailTemplate) => {
    const result = await updateTemplate(template.id, {
      is_active: !template.is_active
    })

    if (!result.success) {
      alert(result.error || t('admin.settings.email_templates.toggle_error'))
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className="w-8 h-8 animate-spin text-orange-500" />
      </div>
    )
  }

  if (error) {
    return (
      <div className={`p-4 rounded-lg border flex items-start gap-2 ${
        isDark
          ? 'bg-red-500/10 border-red-500/50 text-red-400'
          : 'bg-red-50 border-red-200 text-red-600'
      }`}>
        <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
        <span>{error}</span>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {t('admin.settings.email_templates.title')}
          </h2>
          <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
            {t('admin.settings.email_templates.subtitle')}
          </p>
        </div>

        <button
          onClick={handleCreate}
          className="flex items-center gap-2 px-4 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded-lg transition-colors"
        >
          <Plus className="w-4 h-4" />
          {t('admin.settings.email_templates.create')}
        </button>
      </div>

      {/* Templates list */}
      <div className={`rounded-lg border overflow-hidden ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        {emailTemplates.length === 0 ? (
          <div className={`text-center py-12 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
            <Code className="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p>{t('admin.settings.email_templates.no_templates')}</p>
          </div>
        ) : (
          <div className="divide-y divide-gray-700">
            {emailTemplates.map((template) => (
              <div
                key={template.id}
                className={`p-4 flex items-center justify-between ${
                  isDark ? 'hover:bg-gray-700/50' : 'hover:bg-gray-50'
                } transition-colors`}
              >
                <div className="flex items-center gap-4">
                  {/* Status indicator */}
                  <div className={`w-2 h-2 rounded-full ${
                    template.is_active ? 'bg-green-500' : 'bg-gray-500'
                  }`} />

                  <div>
                    <div className="flex items-center gap-2">
                      <h3 className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                        {template.name}
                      </h3>
                      {template.is_system && (
                        <span className={`flex items-center gap-1 px-2 py-0.5 rounded text-xs ${
                          isDark ? 'bg-blue-500/20 text-blue-400' : 'bg-blue-100 text-blue-700'
                        }`}>
                          <Lock className="w-3 h-3" />
                          {t('admin.settings.email_templates.system')}
                        </span>
                      )}
                    </div>
                    <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                      <code className={`px-1 rounded ${isDark ? 'bg-gray-700' : 'bg-gray-100'}`}>
                        {template.code}
                      </code>
                      {template.description && ` - ${template.description}`}
                    </p>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  {/* Toggle active */}
                  <button
                    onClick={() => handleToggleActive(template)}
                    className={`p-2 rounded transition-colors ${
                      template.is_active
                        ? isDark
                          ? 'text-green-400 hover:bg-green-500/20'
                          : 'text-green-600 hover:bg-green-100'
                        : isDark
                          ? 'text-gray-500 hover:bg-gray-600'
                          : 'text-gray-400 hover:bg-gray-100'
                    }`}
                    title={template.is_active ? t('admin.settings.email_templates.deactivate') : t('admin.settings.email_templates.activate')}
                  >
                    {template.is_active ? (
                      <CheckCircle2 className="w-5 h-5" />
                    ) : (
                      <XCircle className="w-5 h-5" />
                    )}
                  </button>

                  {/* Preview */}
                  <button
                    onClick={() => setPreviewTemplate(template)}
                    className={`p-2 rounded transition-colors ${
                      isDark
                        ? 'text-gray-400 hover:bg-gray-600 hover:text-white'
                        : 'text-gray-500 hover:bg-gray-100 hover:text-gray-700'
                    }`}
                    title={t('admin.settings.email_templates.preview')}
                  >
                    <Eye className="w-5 h-5" />
                  </button>

                  {/* Edit */}
                  <button
                    onClick={() => handleEdit(template)}
                    className={`p-2 rounded transition-colors ${
                      isDark
                        ? 'text-orange-400 hover:bg-orange-500/20'
                        : 'text-orange-500 hover:bg-orange-100'
                    }`}
                    title={t('admin.settings.email_templates.edit')}
                  >
                    <Edit2 className="w-5 h-5" />
                  </button>

                  {/* Delete */}
                  {!template.is_system && (
                    <button
                      onClick={() => handleDelete(template)}
                      className={`p-2 rounded transition-colors ${
                        isDark
                          ? 'text-red-400 hover:bg-red-500/20'
                          : 'text-red-500 hover:bg-red-100'
                      }`}
                      title={t('admin.settings.email_templates.delete')}
                    >
                      <Trash2 className="w-5 h-5" />
                    </button>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Edit/Create Modal */}
      {(editingTemplate || showCreateModal) && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => {
              setEditingTemplate(null)
              setShowCreateModal(false)
            }}
          />
          <div className={`relative w-full max-w-3xl max-h-[90vh] overflow-y-auto rounded-xl p-6 ${
            isDark ? 'bg-gray-800' : 'bg-white'
          }`}>
            <h3 className={`text-lg font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {editingTemplate
                ? t('admin.settings.email_templates.edit_title')
                : t('admin.settings.email_templates.create_title')}
            </h3>

            <div className="space-y-4">
              {/* Code (only for new templates) */}
              {!editingTemplate && (
                <div>
                  <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {t('admin.settings.email_templates.form.code')} *
                  </label>
                  <input
                    type="text"
                    value={formData.code}
                    onChange={(e) => setFormData({ ...formData, code: e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, '_') })}
                    placeholder="booking_confirmation"
                    className={`w-full px-3 py-2 rounded-lg border ${
                      isDark
                        ? 'bg-gray-700 border-gray-600 text-white'
                        : 'bg-gray-50 border-gray-200 text-gray-900'
                    } focus:outline-none focus:ring-2 focus:ring-orange-500`}
                  />
                  <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                    {t('admin.settings.email_templates.form.code_help')}
                  </p>
                </div>
              )}

              {/* Name */}
              <div>
                <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.settings.email_templates.form.name')} *
                </label>
                <input
                  type="text"
                  value={formData.name}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  placeholder="Confirmation de réservation"
                  className={`w-full px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-gray-50 border-gray-200 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-orange-500`}
                />
              </div>

              {/* Description */}
              <div>
                <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.settings.email_templates.form.description')}
                </label>
                <input
                  type="text"
                  value={formData.description}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                  placeholder="Email envoyé lors de la confirmation"
                  className={`w-full px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-gray-50 border-gray-200 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-orange-500`}
                />
              </div>

              {/* Subject */}
              <div>
                <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.settings.email_templates.form.subject')} *
                </label>
                <input
                  type="text"
                  value={formData.subject_template}
                  onChange={(e) => setFormData({ ...formData, subject_template: e.target.value })}
                  placeholder="Votre réservation est confirmée - Réf. {{booking_reference}}"
                  className={`w-full px-3 py-2 rounded-lg border ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-gray-50 border-gray-200 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-orange-500`}
                />
                <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                  {t('admin.settings.email_templates.form.variables_help')}
                </p>
              </div>

              {/* Body */}
              <div>
                <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.settings.email_templates.form.body')} *
                </label>
                <textarea
                  value={formData.body_template}
                  onChange={(e) => setFormData({ ...formData, body_template: e.target.value })}
                  rows={12}
                  placeholder="<html>...</html>"
                  className={`w-full px-3 py-2 rounded-lg border font-mono text-sm ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-gray-50 border-gray-200 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-orange-500`}
                />
              </div>

              {/* Active */}
              <div className="flex items-center gap-2">
                <input
                  type="checkbox"
                  id="is_active"
                  checked={formData.is_active}
                  onChange={(e) => setFormData({ ...formData, is_active: e.target.checked })}
                  className="w-4 h-4 rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                />
                <label htmlFor="is_active" className={`text-sm ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.settings.email_templates.form.active')}
                </label>
              </div>
            </div>

            <div className="mt-6 flex justify-end gap-2">
              <button
                onClick={() => {
                  setEditingTemplate(null)
                  setShowCreateModal(false)
                }}
                className={`px-4 py-2 rounded-lg ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-white'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                {t('admin.common.cancel')}
              </button>
              <button
                onClick={handleSave}
                disabled={saving || !formData.name || !formData.subject_template || !formData.body_template || (!editingTemplate && !formData.code)}
                className="px-4 py-2 rounded-lg bg-orange-600 hover:bg-orange-700 text-white disabled:opacity-50 flex items-center gap-2"
              >
                {saving && <Loader2 className="w-4 h-4 animate-spin" />}
                {t('admin.common.save')}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Preview Modal */}
      {previewTemplate && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => setPreviewTemplate(null)}
          />
          <div className={`relative w-full max-w-4xl max-h-[90vh] overflow-hidden rounded-xl ${
            isDark ? 'bg-gray-800' : 'bg-white'
          }`}>
            <div className={`p-4 border-b flex items-center justify-between ${
              isDark ? 'border-gray-700' : 'border-gray-200'
            }`}>
              <h3 className={`font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.settings.email_templates.preview')}: {previewTemplate.name}
              </h3>
              <button
                onClick={() => setPreviewTemplate(null)}
                className={`p-1 rounded hover:bg-gray-600 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}
              >
                <XCircle className="w-5 h-5" />
              </button>
            </div>

            <div className="p-4">
              <div className={`mb-4 p-3 rounded-lg ${isDark ? 'bg-gray-700' : 'bg-gray-100'}`}>
                <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.settings.email_templates.form.subject')}:
                </p>
                <p className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  {previewTemplate.subject_template}
                </p>
              </div>

              <div className="border rounded-lg overflow-hidden" style={{ height: '60vh' }}>
                <iframe
                  srcDoc={previewTemplate.body_template}
                  className="w-full h-full bg-white"
                  title="Email preview"
                />
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/settings/components/ICountCatalogSection.tsx">
'use client'

import { useState, useEffect } from 'react'
import {
  Loader2,
  AlertCircle,
  CheckCircle2,
  Plus,
  Edit2,
  Trash2,
  Package,
  Calculator,
  Home,
  Save,
  X,
  RefreshCw,
} from 'lucide-react'
import { useBranches } from '@/hooks/useBranches'
import { useTranslation } from '@/contexts/LanguageContext'

interface ICountCatalogSectionProps {
  isDark: boolean
}

// Types simplifiés
interface ICountProduct {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  name_en: string | null
  unit_price: number
  is_active: boolean
  sort_order: number
}

interface ICountRoom {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  name_en: string | null
  price: number
  is_active: boolean
  sort_order: number
}

interface ICountEventFormula {
  id: string
  branch_id: string
  name: string
  game_type: 'LASER' | 'ACTIVE' | 'BOTH'
  min_participants: number
  max_participants: number
  price_per_person: number
  room_id: string | null
  is_active: boolean
  priority: number
  // Joined
  room?: ICountRoom | null
}

type ActiveTab = 'products' | 'rooms' | 'formulas'

// Helper function to get localized name
function getLocalizedName(
  item: { name: string; name_he: string | null; name_en: string | null },
  locale: string
): string {
  if (locale === 'he' && item.name_he) return item.name_he
  if (locale === 'en' && item.name_en) return item.name_en
  return item.name // Default to French name
}

export function ICountCatalogSection({ isDark }: ICountCatalogSectionProps) {
  const { selectedBranch } = useBranches()
  const { t, locale } = useTranslation()

  const GAME_TYPES = [
    { value: 'LASER', label: t('admin.icount_catalog.game_types.laser'), color: 'bg-blue-500' },
    { value: 'ACTIVE', label: t('admin.icount_catalog.game_types.active'), color: 'bg-green-500' },
    { value: 'BOTH', label: t('admin.icount_catalog.game_types.both'), color: 'bg-purple-500' },
  ]

  const [activeTab, setActiveTab] = useState<ActiveTab>('products')
  const [products, setProducts] = useState<ICountProduct[]>([])
  const [rooms, setRooms] = useState<ICountRoom[]>([])
  const [formulas, setFormulas] = useState<ICountEventFormula[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [successMessage, setSuccessMessage] = useState<string | null>(null)

  // Modal states
  const [showProductModal, setShowProductModal] = useState(false)
  const [editingProduct, setEditingProduct] = useState<ICountProduct | null>(null)
  const [showRoomModal, setShowRoomModal] = useState(false)
  const [editingRoom, setEditingRoom] = useState<ICountRoom | null>(null)
  const [showFormulaModal, setShowFormulaModal] = useState(false)
  const [editingFormula, setEditingFormula] = useState<ICountEventFormula | null>(null)
  const [saving, setSaving] = useState(false)
  const [syncing, setSyncing] = useState(false)

  // Sync all products to iCount
  const handleSyncToICount = async () => {
    if (!selectedBranch) return

    setSyncing(true)
    setError(null)

    try {
      const response = await fetch('/api/icount-products/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ branch_id: selectedBranch.id }),
      })

      const result = await response.json()

      if (!response.ok) {
        throw new Error(result.error || 'Erreur de synchronisation')
      }

      if (result.synced > 0 || result.failed > 0) {
        if (result.failed > 0) {
          setSuccessMessage(t('admin.icount_catalog.sync.success_with_failures', { synced: result.synced, failed: result.failed }))
        } else {
          setSuccessMessage(t('admin.icount_catalog.sync.success', { synced: result.synced }))
        }
      } else {
        setSuccessMessage(t('admin.icount_catalog.sync.no_products'))
      }

      // Refresh data to show updated sync status
      fetchData()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erreur')
    } finally {
      setSyncing(false)
    }
  }

  // Fetch data
  const fetchData = async () => {
    if (!selectedBranch) return

    setLoading(true)
    setError(null)

    try {
      // Add cache-busting timestamp to prevent stale data
      const ts = Date.now()
      const [productsRes, roomsRes, formulasRes] = await Promise.all([
        fetch(`/api/icount-products?branchId=${selectedBranch.id}&includeInactive=true&_t=${ts}`),
        fetch(`/api/icount-rooms?branchId=${selectedBranch.id}&includeInactive=true&_t=${ts}`),
        fetch(`/api/icount-event-formulas?branchId=${selectedBranch.id}&includeInactive=true&_t=${ts}`),
      ])

      const productsData = productsRes.ok ? await productsRes.json() : { data: [] }
      const roomsData = roomsRes.ok ? await roomsRes.json() : { data: [] }
      const formulasData = formulasRes.ok ? await formulasRes.json() : { data: [] }

      setProducts(productsData.data || [])
      setRooms(roomsData.data || [])
      setFormulas(formulasData.data || [])
    } catch (err) {
      console.error('Error fetching catalog data:', err)
      setError('Erreur lors du chargement des données')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchData()
  }, [selectedBranch?.id])

  useEffect(() => {
    if (successMessage) {
      const timer = setTimeout(() => setSuccessMessage(null), 3000)
      return () => clearTimeout(timer)
    }
  }, [successMessage])

  // Save handlers
  const handleSaveProduct = async (data: Partial<ICountProduct>) => {
    if (!selectedBranch) return
    setSaving(true)
    setError(null)

    try {
      const isNew = !editingProduct?.id
      const url = isNew ? '/api/icount-products' : `/api/icount-products/${editingProduct.id}`

      const response = await fetch(url, {
        method: isNew ? 'POST' : 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...data, branch_id: selectedBranch.id }),
      })

      if (!response.ok) {
        const res = await response.json()
        throw new Error(res.error || 'Erreur')
      }

      setSuccessMessage(isNew ? 'Produit créé' : 'Produit mis à jour')
      setShowProductModal(false)
      setEditingProduct(null)
      fetchData()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erreur')
    } finally {
      setSaving(false)
    }
  }

  const handleSaveRoom = async (data: Partial<ICountRoom>) => {
    if (!selectedBranch) return
    setSaving(true)
    setError(null)

    try {
      const isNew = !editingRoom?.id
      const url = isNew ? '/api/icount-rooms' : `/api/icount-rooms/${editingRoom.id}`

      const response = await fetch(url, {
        method: isNew ? 'POST' : 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...data, branch_id: selectedBranch.id }),
      })

      if (!response.ok) {
        const res = await response.json()
        throw new Error(res.error || 'Erreur')
      }

      setSuccessMessage(isNew ? 'Salle créée' : 'Salle mise à jour')
      setShowRoomModal(false)
      setEditingRoom(null)
      fetchData()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erreur')
    } finally {
      setSaving(false)
    }
  }

  const handleSaveFormula = async (data: Partial<ICountEventFormula>) => {
    if (!selectedBranch) return
    setSaving(true)
    setError(null)

    try {
      const isNew = !editingFormula?.id
      const url = isNew ? '/api/icount-event-formulas' : `/api/icount-event-formulas/${editingFormula.id}`

      const response = await fetch(url, {
        method: isNew ? 'POST' : 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...data, branch_id: selectedBranch.id }),
      })

      if (!response.ok) {
        const res = await response.json()
        throw new Error(res.error || 'Erreur')
      }

      setSuccessMessage(isNew ? 'Formule créée' : 'Formule mise à jour')
      setShowFormulaModal(false)
      setEditingFormula(null)
      fetchData()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erreur')
    } finally {
      setSaving(false)
    }
  }

  // Delete handlers
  const handleDelete = async (type: 'product' | 'room' | 'formula', id: string) => {
    if (!confirm('Voulez-vous désactiver cet élément?')) return

    try {
      const endpoints = {
        product: '/api/icount-products',
        room: '/api/icount-rooms',
        formula: '/api/icount-event-formulas',
      }
      const response = await fetch(`${endpoints[type]}/${id}`, { method: 'DELETE' })
      if (!response.ok) throw new Error('Erreur')
      setSuccessMessage('Élément désactivé')
      fetchData()
    } catch {
      setError('Erreur lors de la suppression')
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div>
        <h2 className={`text-xl font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>
          {t('admin.icount_catalog.title')}
        </h2>
        <p className={`text-sm mt-1 ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
          {t('admin.icount_catalog.subtitle', { branch: selectedBranch?.name || '' })}
        </p>
      </div>

      {/* Messages */}
      {error && (
        <div className={`flex items-center gap-2 p-3 rounded-lg ${isDark ? 'bg-red-500/10 border border-red-500/20' : 'bg-red-50 border border-red-200'}`}>
          <AlertCircle className="w-5 h-5 text-red-500" />
          <p className="text-red-500 text-sm">{error}</p>
        </div>
      )}

      {successMessage && (
        <div className={`flex items-center gap-2 p-3 rounded-lg ${isDark ? 'bg-green-500/10 border border-green-500/20' : 'bg-green-50 border border-green-200'}`}>
          <CheckCircle2 className="w-5 h-5 text-green-500" />
          <p className="text-green-500 text-sm">{successMessage}</p>
        </div>
      )}

      {/* Tabs */}
      <div className={`flex gap-1 p-1 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-gray-100'}`}>
        <TabButton
          active={activeTab === 'products'}
          onClick={() => setActiveTab('products')}
          isDark={isDark}
          icon={<Package className="w-4 h-4" />}
          label={`${t('admin.icount_catalog.tabs.products')} (${products.length})`}
        />
        <TabButton
          active={activeTab === 'rooms'}
          onClick={() => setActiveTab('rooms')}
          isDark={isDark}
          icon={<Home className="w-4 h-4" />}
          label={`${t('admin.icount_catalog.tabs.rooms')} (${rooms.length})`}
        />
        <TabButton
          active={activeTab === 'formulas'}
          onClick={() => setActiveTab('formulas')}
          isDark={isDark}
          icon={<Calculator className="w-4 h-4" />}
          label={`${t('admin.icount_catalog.tabs.formulas')} (${formulas.length})`}
        />
      </div>

      {/* Products Tab */}
      {activeTab === 'products' && (
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <button
              onClick={() => { setEditingProduct(null); setShowProductModal(true) }}
              className="flex items-center gap-2 px-4 py-2 rounded-lg font-medium bg-orange-500 hover:bg-orange-600 text-white"
            >
              <Plus className="w-4 h-4" />
              {t('admin.icount_catalog.products.add')}
            </button>
            <button
              onClick={handleSyncToICount}
              disabled={syncing}
              className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium ${isDark ? 'bg-blue-600 hover:bg-blue-700' : 'bg-blue-500 hover:bg-blue-600'} text-white disabled:opacity-50`}
            >
              {syncing ? <Loader2 className="w-4 h-4 animate-spin" /> : <RefreshCw className="w-4 h-4" />}
              {syncing ? t('admin.icount_catalog.sync.syncing') : t('admin.icount_catalog.sync.button')}
            </button>
          </div>

          <div className={`rounded-xl border-2 overflow-hidden ${isDark ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}`}>
            <table className="w-full">
              <thead>
                <tr className={isDark ? 'bg-gray-700/50' : 'bg-gray-50'}>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.products.code')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.products.price_per_person')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.products.status')}</th>
                  <th className={`px-4 py-3 text-right text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.products.actions')}</th>
                </tr>
              </thead>
              <tbody className={`divide-y ${isDark ? 'divide-gray-700' : 'divide-gray-200'}`}>
                {products.map(product => (
                  <tr key={product.id} className={!product.is_active ? 'opacity-50' : ''}>
                    <td className={`px-4 py-3 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                      <div className="font-medium" dir={locale === 'he' ? 'rtl' : 'ltr'}>
                        {getLocalizedName(product, locale)}
                      </div>
                      <div className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                        {product.code}
                      </div>
                    </td>
                    <td className={`px-4 py-3 font-semibold ${isDark ? 'text-green-400' : 'text-green-600'}`}>
                      ₪{product.unit_price}
                    </td>
                    <td className="px-4 py-3">
                      <StatusBadge active={product.is_active} isDark={isDark} activeLabel={t('admin.icount_catalog.status.active')} inactiveLabel={t('admin.icount_catalog.status.inactive')} />
                    </td>
                    <td className="px-4 py-3">
                      <ActionButtons
                        isDark={isDark}
                        onEdit={() => { setEditingProduct(product); setShowProductModal(true) }}
                        onDelete={() => handleDelete('product', product.id)}
                      />
                    </td>
                  </tr>
                ))}
                {products.length === 0 && (
                  <tr>
                    <td colSpan={4} className={`px-4 py-8 text-center ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.icount_catalog.products.none')}
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* Rooms Tab */}
      {activeTab === 'rooms' && (
        <div className="space-y-4">
          <button
            onClick={() => { setEditingRoom(null); setShowRoomModal(true) }}
            className="flex items-center gap-2 px-4 py-2 rounded-lg font-medium bg-orange-500 hover:bg-orange-600 text-white"
          >
            <Plus className="w-4 h-4" />
            {t('admin.icount_catalog.rooms.add')}
          </button>

          <div className={`rounded-xl border-2 overflow-hidden ${isDark ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}`}>
            <table className="w-full">
              <thead>
                <tr className={isDark ? 'bg-gray-700/50' : 'bg-gray-50'}>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.rooms.code')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.rooms.price')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.rooms.status')}</th>
                  <th className={`px-4 py-3 text-right text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.rooms.actions')}</th>
                </tr>
              </thead>
              <tbody className={`divide-y ${isDark ? 'divide-gray-700' : 'divide-gray-200'}`}>
                {rooms.map(room => (
                  <tr key={room.id} className={!room.is_active ? 'opacity-50' : ''}>
                    <td className={`px-4 py-3 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                      <div className="font-medium" dir={locale === 'he' ? 'rtl' : 'ltr'}>
                        {getLocalizedName(room, locale)}
                      </div>
                      <div className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                        {room.code}
                      </div>
                    </td>
                    <td className={`px-4 py-3 font-semibold ${room.price > 0 ? (isDark ? 'text-green-400' : 'text-green-600') : (isDark ? 'text-gray-500' : 'text-gray-400')}`}>
                      {room.price > 0 ? `₪${room.price}` : t('admin.icount_catalog.rooms.free')}
                    </td>
                    <td className="px-4 py-3">
                      <StatusBadge active={room.is_active} isDark={isDark} activeLabel={t('admin.icount_catalog.status.active')} inactiveLabel={t('admin.icount_catalog.status.inactive')} />
                    </td>
                    <td className="px-4 py-3">
                      <ActionButtons
                        isDark={isDark}
                        onEdit={() => { setEditingRoom(room); setShowRoomModal(true) }}
                        onDelete={() => handleDelete('room', room.id)}
                      />
                    </td>
                  </tr>
                ))}
                {rooms.length === 0 && (
                  <tr>
                    <td colSpan={4} className={`px-4 py-8 text-center ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.icount_catalog.rooms.none')}
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* Formulas Tab */}
      {activeTab === 'formulas' && (
        <div className="space-y-4">
          <button
            onClick={() => { setEditingFormula(null); setShowFormulaModal(true) }}
            className="flex items-center gap-2 px-4 py-2 rounded-lg font-medium bg-orange-500 hover:bg-orange-600 text-white"
          >
            <Plus className="w-4 h-4" />
            {t('admin.icount_catalog.formulas.add')}
          </button>

          <div className={`rounded-xl border-2 overflow-hidden ${isDark ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}`}>
            <table className="w-full">
              <thead>
                <tr className={isDark ? 'bg-gray-700/50' : 'bg-gray-50'}>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.formulas.game_type')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.formulas.participants')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.formulas.price_per_person')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.formulas.room')}</th>
                  <th className={`px-4 py-3 text-left text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.formulas.status')}</th>
                  <th className={`px-4 py-3 text-right text-xs font-medium uppercase ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.icount_catalog.formulas.actions')}</th>
                </tr>
              </thead>
              <tbody className={`divide-y ${isDark ? 'divide-gray-700' : 'divide-gray-200'}`}>
                {formulas.map(formula => {
                  const room = rooms.find(r => r.id === formula.room_id)
                  const gameType = GAME_TYPES.find(g => g.value === formula.game_type)

                  return (
                    <tr key={formula.id} className={!formula.is_active ? 'opacity-50' : ''}>
                      <td className="px-4 py-3">
                        <span className={`inline-flex px-2 py-1 text-xs font-medium rounded-full text-white ${gameType?.color || 'bg-gray-500'}`}>
                          {gameType?.label || formula.game_type}
                        </span>
                      </td>
                      <td className={`px-4 py-3 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                        {formula.min_participants} - {formula.max_participants === 999 ? '∞' : formula.max_participants}
                      </td>
                      <td className={`px-4 py-3 font-semibold ${isDark ? 'text-green-400' : 'text-green-600'}`}>
                        ₪{formula.price_per_person}
                      </td>
                      <td className={`px-4 py-3 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                        {room ? (
                          <span>
                            {room.name}
                            {room.price > 0 && <span className={`ml-1 text-sm ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>(+₪{room.price})</span>}
                          </span>
                        ) : (
                          <span className={isDark ? 'text-gray-500' : 'text-gray-400'}>-</span>
                        )}
                      </td>
                      <td className="px-4 py-3">
                        <StatusBadge active={formula.is_active} isDark={isDark} activeLabel={t('admin.icount_catalog.status.active')} inactiveLabel={t('admin.icount_catalog.status.inactive')} />
                      </td>
                      <td className="px-4 py-3">
                        <ActionButtons
                          isDark={isDark}
                          onEdit={() => { setEditingFormula(formula); setShowFormulaModal(true) }}
                          onDelete={() => handleDelete('formula', formula.id)}
                        />
                      </td>
                    </tr>
                  )
                })}
                {formulas.length === 0 && (
                  <tr>
                    <td colSpan={6} className={`px-4 py-8 text-center ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.icount_catalog.formulas.none')}
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>

          {/* Formulas explanation */}
          <div className={`p-4 rounded-lg ${isDark ? 'bg-gray-800/50 border border-gray-700' : 'bg-gray-50 border border-gray-200'}`}>
            <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
              {t('admin.icount_catalog.formulas.calculation')}
            </p>
            <p className={`text-sm mt-1 ${isDark ? 'text-gray-500' : 'text-gray-500'}`}>
              {t('admin.icount_catalog.formulas.priority_info')}
            </p>
          </div>
        </div>
      )}

      {/* Modals */}
      {showProductModal && (
        <ProductModal
          isDark={isDark}
          product={editingProduct}
          saving={saving}
          onSave={handleSaveProduct}
          onClose={() => { setShowProductModal(false); setEditingProduct(null) }}
        />
      )}

      {showRoomModal && (
        <RoomModal
          isDark={isDark}
          room={editingRoom}
          saving={saving}
          onSave={handleSaveRoom}
          onClose={() => { setShowRoomModal(false); setEditingRoom(null) }}
        />
      )}

      {showFormulaModal && (
        <FormulaModal
          isDark={isDark}
          formula={editingFormula}
          rooms={rooms.filter(r => r.is_active)}
          gameTypes={GAME_TYPES}
          saving={saving}
          onSave={handleSaveFormula}
          onClose={() => { setShowFormulaModal(false); setEditingFormula(null) }}
        />
      )}
    </div>
  )
}

// Helper Components
function TabButton({ active, onClick, isDark, icon, label }: { active: boolean; onClick: () => void; isDark: boolean; icon: React.ReactNode; label: string }) {
  return (
    <button
      onClick={onClick}
      className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-colors ${
        active
          ? isDark ? 'bg-orange-500 text-white' : 'bg-white text-orange-600 shadow'
          : isDark ? 'text-gray-400 hover:text-white' : 'text-gray-600 hover:text-gray-900'
      }`}
    >
      {icon}
      {label}
    </button>
  )
}

function StatusBadge({ active, isDark, activeLabel, inactiveLabel }: { active: boolean; isDark: boolean; activeLabel: string; inactiveLabel: string }) {
  return (
    <span className={`inline-flex px-2 py-1 text-xs font-medium rounded-full ${
      active
        ? isDark ? 'bg-green-500/20 text-green-400' : 'bg-green-100 text-green-700'
        : isDark ? 'bg-gray-600 text-gray-400' : 'bg-gray-200 text-gray-500'
    }`}>
      {active ? activeLabel : inactiveLabel}
    </span>
  )
}

function ActionButtons({ isDark, onEdit, onDelete }: { isDark: boolean; onEdit: () => void; onDelete: () => void }) {
  return (
    <div className="flex items-center justify-end gap-2">
      <button
        onClick={onEdit}
        className={`p-1.5 rounded-lg ${isDark ? 'hover:bg-gray-700 text-gray-400 hover:text-white' : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'}`}
      >
        <Edit2 className="w-4 h-4" />
      </button>
      <button
        onClick={onDelete}
        className={`p-1.5 rounded-lg ${isDark ? 'hover:bg-red-500/20 text-gray-400 hover:text-red-400' : 'hover:bg-red-100 text-gray-500 hover:text-red-600'}`}
      >
        <Trash2 className="w-4 h-4" />
      </button>
    </div>
  )
}

// Product Modal
function ProductModal({ isDark, product, saving, onSave, onClose }: {
  isDark: boolean
  product: ICountProduct | null
  saving: boolean
  onSave: (data: Partial<ICountProduct>) => void
  onClose: () => void
}) {
  const [form, setForm] = useState({
    code: product?.code || '',
    name: product?.name || '',
    name_he: product?.name_he || '',
    name_en: product?.name_en || '',
    unit_price: product?.unit_price?.toString() || '',
    sort_order: product?.sort_order?.toString() || '0',
    is_active: product?.is_active ?? true,
  })

  // Code is read-only for existing products (code is the key linking everything)
  const isEventProduct = product?.code?.startsWith('event_') || false
  const isEditing = !!product?.id

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSave({
      code: form.code,
      name: form.name,
      name_he: form.name_he || null,
      name_en: form.name_en || null,
      unit_price: parseFloat(form.unit_price),
      sort_order: parseInt(form.sort_order) || 0,
      is_active: form.is_active,
    })
  }

  return (
    <Modal isDark={isDark} title={product ? 'Edit Product' : 'New Product'} onClose={onClose}>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div className="grid grid-cols-2 gap-4">
          <Input
            isDark={isDark}
            label="Code"
            value={form.code}
            onChange={v => setForm(p => ({ ...p, code: v }))}
            required
            placeholder="laser_1"
            readOnly={isEditing}
            hint={isEditing ? (isEventProduct ? 'Auto-generated from formula' : 'Code cannot be changed') : undefined}
          />
          <Input isDark={isDark} label="Price/person (₪)" type="number" value={form.unit_price} onChange={v => setForm(p => ({ ...p, unit_price: v }))} required placeholder="70" />
        </div>
        <Input isDark={isDark} label="Name (EN)" value={form.name_en} onChange={v => setForm(p => ({ ...p, name_en: v }))} placeholder="Laser 1 game" />
        <Input isDark={isDark} label="Name (HE)" value={form.name_he} onChange={v => setForm(p => ({ ...p, name_he: v }))} placeholder="לייזר משחק 1" dir="rtl" />
        <Input isDark={isDark} label="Name (FR)" value={form.name} onChange={v => setForm(p => ({ ...p, name: v }))} required placeholder="Laser 1 partie" />
        <div className="flex items-center gap-4">
          <Input isDark={isDark} label="Order" type="number" value={form.sort_order} onChange={v => setForm(p => ({ ...p, sort_order: v }))} className="w-24" />
          <Checkbox isDark={isDark} label="Active" checked={form.is_active} onChange={v => setForm(p => ({ ...p, is_active: v }))} />
        </div>
        <ModalFooter isDark={isDark} saving={saving} onClose={onClose} />
      </form>
    </Modal>
  )
}

// Room Modal
function RoomModal({ isDark, room, saving, onSave, onClose }: {
  isDark: boolean
  room: ICountRoom | null
  saving: boolean
  onSave: (data: Partial<ICountRoom>) => void
  onClose: () => void
}) {
  const [form, setForm] = useState({
    code: room?.code || '',
    name: room?.name || '',
    name_he: room?.name_he || '',
    name_en: room?.name_en || '',
    price: room?.price?.toString() || '0',
    sort_order: room?.sort_order?.toString() || '0',
    is_active: room?.is_active ?? true,
  })

  const isEditing = !!room?.id

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSave({
      code: form.code,
      name: form.name,
      name_he: form.name_he || null,
      name_en: form.name_en || null,
      price: parseFloat(form.price) || 0,
      sort_order: parseInt(form.sort_order) || 0,
      is_active: form.is_active,
    })
  }

  return (
    <Modal isDark={isDark} title={room ? 'Edit Room' : 'New Room'} onClose={onClose}>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div className="grid grid-cols-2 gap-4">
          <Input isDark={isDark} label="Code" value={form.code} onChange={v => setForm(p => ({ ...p, code: v }))} required placeholder="room_1" readOnly={isEditing} hint={isEditing ? 'Code cannot be changed' : undefined} />
          <Input isDark={isDark} label="Price (₪)" type="number" value={form.price} onChange={v => setForm(p => ({ ...p, price: v }))} placeholder="0 = free" />
        </div>
        <Input isDark={isDark} label="Name (EN)" value={form.name_en} onChange={v => setForm(p => ({ ...p, name_en: v }))} placeholder="Room 1" />
        <Input isDark={isDark} label="Name (HE)" value={form.name_he} onChange={v => setForm(p => ({ ...p, name_he: v }))} placeholder="חדר 1" dir="rtl" />
        <Input isDark={isDark} label="Name (FR)" value={form.name} onChange={v => setForm(p => ({ ...p, name: v }))} required placeholder="Salle 1" />
        <div className="flex items-center gap-4">
          <Input isDark={isDark} label="Order" type="number" value={form.sort_order} onChange={v => setForm(p => ({ ...p, sort_order: v }))} className="w-24" />
          <Checkbox isDark={isDark} label="Active" checked={form.is_active} onChange={v => setForm(p => ({ ...p, is_active: v }))} />
        </div>
        <ModalFooter isDark={isDark} saving={saving} onClose={onClose} />
      </form>
    </Modal>
  )
}

// Formula Modal
function FormulaModal({ isDark, formula, rooms, gameTypes, saving, onSave, onClose }: {
  isDark: boolean
  formula: ICountEventFormula | null
  rooms: ICountRoom[]
  gameTypes: Array<{ value: string; label: string; color: string }>
  saving: boolean
  onSave: (data: Partial<ICountEventFormula>) => void
  onClose: () => void
}) {
  const [form, setForm] = useState({
    name: formula?.name || '',
    game_type: formula?.game_type || 'LASER',
    min_participants: formula?.min_participants?.toString() || '15',
    max_participants: formula?.max_participants?.toString() || '999',
    price_per_person: formula?.price_per_person?.toString() || '',
    room_id: formula?.room_id || '',
    priority: formula?.priority?.toString() || '0',
    is_active: formula?.is_active ?? true,
  })

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSave({
      name: form.name,
      game_type: form.game_type as 'LASER' | 'ACTIVE' | 'BOTH',
      min_participants: parseInt(form.min_participants) || 1,
      max_participants: parseInt(form.max_participants) || 999,
      price_per_person: parseFloat(form.price_per_person),
      room_id: form.room_id || null,
      priority: parseInt(form.priority) || 0,
      is_active: form.is_active,
    })
  }

  return (
    <Modal isDark={isDark} title={formula ? 'Edit Formula' : 'New EVENT Formula'} onClose={onClose}>
      <form onSubmit={handleSubmit} className="space-y-4">
        <Input isDark={isDark} label="Name" value={form.name} onChange={v => setForm(p => ({ ...p, name: v }))} required placeholder="Laser 15-29 pers" />

        <div>
          <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
            Game Type
          </label>
          <div className="flex gap-2">
            {gameTypes.map(gt => (
              <button
                key={gt.value}
                type="button"
                onClick={() => setForm(p => ({ ...p, game_type: gt.value as 'LASER' | 'ACTIVE' | 'BOTH' }))}
                className={`flex-1 px-3 py-2 rounded-lg font-medium transition-colors ${
                  form.game_type === gt.value
                    ? `${gt.color} text-white`
                    : isDark ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                }`}
              >
                {gt.label}
              </button>
            ))}
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <Input isDark={isDark} label="Min participants" type="number" value={form.min_participants} onChange={v => setForm(p => ({ ...p, min_participants: v }))} required />
          <Input isDark={isDark} label="Max participants" type="number" value={form.max_participants} onChange={v => setForm(p => ({ ...p, max_participants: v }))} placeholder="999 = unlimited" />
        </div>

        <Input isDark={isDark} label="Price per person (₪)" type="number" value={form.price_per_person} onChange={v => setForm(p => ({ ...p, price_per_person: v }))} required placeholder="110" />

        <div>
          <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
            Room (optional)
          </label>
          <select
            value={form.room_id}
            onChange={e => setForm(p => ({ ...p, room_id: e.target.value }))}
            className={`w-full px-3 py-2 rounded-lg border ${isDark ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'}`}
          >
            <option value="">No room</option>
            {rooms.map(r => (
              <option key={r.id} value={r.id}>
                {r.name} {r.price > 0 ? `(+₪${r.price})` : '(free)'}
              </option>
            ))}
          </select>
        </div>

        <div className="flex items-center gap-4">
          <Input isDark={isDark} label="Priority" type="number" value={form.priority} onChange={v => setForm(p => ({ ...p, priority: v }))} className="w-24" />
          <Checkbox isDark={isDark} label="Active" checked={form.is_active} onChange={v => setForm(p => ({ ...p, is_active: v }))} />
        </div>

        <ModalFooter isDark={isDark} saving={saving} onClose={onClose} />
      </form>
    </Modal>
  )
}

// Shared Modal Components
function Modal({ isDark, title, onClose, children }: { isDark: boolean; title: string; onClose: () => void; children: React.ReactNode }) {
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/50" onClick={onClose} />
      <div className={`relative w-full max-w-lg mx-4 rounded-xl shadow-xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
        <div className={`flex items-center justify-between px-6 py-4 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <h3 className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>{title}</h3>
          <button onClick={onClose} className={`p-1 rounded-lg ${isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'}`}>
            <X className="w-5 h-5" />
          </button>
        </div>
        <div className="p-6">{children}</div>
      </div>
    </div>
  )
}

function Input({ isDark, label, value, onChange, required, placeholder, type = 'text', dir, className, readOnly, hint }: {
  isDark: boolean; label: string; value: string; onChange: (v: string) => void; required?: boolean; placeholder?: string; type?: string; dir?: string; className?: string; readOnly?: boolean; hint?: string
}) {
  return (
    <div className={className}>
      <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>{label}</label>
      <input
        type={type}
        value={value}
        onChange={e => onChange(e.target.value)}
        required={required}
        placeholder={placeholder}
        dir={dir}
        step={type === 'number' ? '0.01' : undefined}
        readOnly={readOnly}
        className={`w-full px-3 py-2 rounded-lg border ${isDark ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'} ${readOnly ? 'opacity-60 cursor-not-allowed' : ''}`}
      />
      {hint && <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>{hint}</p>}
    </div>
  )
}

function Checkbox({ isDark, label, checked, onChange }: { isDark: boolean; label: string; checked: boolean; onChange: (v: boolean) => void }) {
  return (
    <label className="flex items-center gap-2 cursor-pointer pt-6">
      <input type="checkbox" checked={checked} onChange={e => onChange(e.target.checked)} className="w-4 h-4 rounded" />
      <span className={isDark ? 'text-gray-300' : 'text-gray-700'}>{label}</span>
    </label>
  )
}

function ModalFooter({ isDark, saving, onClose }: { isDark: boolean; saving: boolean; onClose: () => void }) {
  return (
    <div className="flex justify-end gap-3 pt-4">
      <button
        type="button"
        onClick={onClose}
        className={`px-4 py-2 rounded-lg font-medium ${isDark ? 'bg-gray-700 hover:bg-gray-600 text-white' : 'bg-gray-100 hover:bg-gray-200 text-gray-800'}`}
      >
        Cancel
      </button>
      <button
        type="submit"
        disabled={saving}
        className="flex items-center gap-2 px-4 py-2 rounded-lg font-medium bg-orange-500 hover:bg-orange-600 text-white disabled:opacity-50"
      >
        {saving ? <Loader2 className="w-4 h-4 animate-spin" /> : <Save className="w-4 h-4" />}
        Save
      </button>
    </div>
  )
}
</file>

<file path="src/app/admin/settings/components/TermsConditionsSection.tsx">
'use client'

import { useState, useEffect } from 'react'
import {
  Loader2,
  AlertCircle,
  Edit2,
  Eye,
  XCircle,
  CheckCircle2,
  FileText
} from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import { createClient } from '@/lib/supabase/client'
import type { EmailTemplate } from '@/lib/supabase/types'

interface TermsConditionsSectionProps {
  isDark: boolean
}

type TermsType = 'game' | 'event'
type TermsLanguage = 'he' | 'en' | 'fr'

interface TermsTemplate {
  type: TermsType
  language: TermsLanguage
  template: EmailTemplate | null
}

const TERMS_CODES = {
  game: {
    he: 'terms_game_he',
    en: 'terms_game_en',
    fr: 'terms_game_fr'
  },
  event: {
    he: 'terms_event_he',
    en: 'terms_event_en',
    fr: 'terms_event_fr'
  }
}

const LANGUAGE_LABELS: Record<TermsLanguage, { name: string; flag: string }> = {
  he: { name: 'Hebrew', flag: '🇮🇱' },
  en: { name: 'English', flag: '🇬🇧' },
  fr: { name: 'French', flag: '🇫🇷' }
}

export function TermsConditionsSection({ isDark }: TermsConditionsSectionProps) {
  const { t } = useTranslation()
  const [templates, setTemplates] = useState<EmailTemplate[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editingTemplate, setEditingTemplate] = useState<EmailTemplate | null>(null)
  const [previewTemplate, setPreviewTemplate] = useState<EmailTemplate | null>(null)
  const [saving, setSaving] = useState(false)
  const [selectedType, setSelectedType] = useState<TermsType>('game')

  // Form state
  const [formData, setFormData] = useState({
    body_template: ''
  })

  const supabase = createClient()

  const fetchTemplates = async () => {
    setLoading(true)
    setError(null)

    try {
      const allCodes = [
        ...Object.values(TERMS_CODES.game),
        ...Object.values(TERMS_CODES.event)
      ]

      const { data, error: fetchError } = await supabase
        .from('email_templates')
        .select('*')
        .in('code', allCodes)

      if (fetchError) throw fetchError

      setTemplates(data || [])
    } catch (err) {
      console.error('Error fetching terms templates:', err)
      setError(t('admin.settings.terms.fetch_error'))
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchTemplates()
  }, [])

  const getTemplate = (type: TermsType, language: TermsLanguage): EmailTemplate | undefined => {
    const code = TERMS_CODES[type][language]
    return templates.find(t => t.code === code)
  }

  const handleEdit = (template: EmailTemplate) => {
    setEditingTemplate(template)
    setFormData({
      body_template: template.body_template
    })
  }

  const handleSave = async () => {
    if (!editingTemplate) return

    setSaving(true)

    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error: updateError } = await (supabase as any)
        .from('email_templates')
        .update({
          body_template: formData.body_template,
          updated_at: new Date().toISOString()
        })
        .eq('id', editingTemplate.id)

      if (updateError) throw updateError

      // Refresh templates
      await fetchTemplates()
      setEditingTemplate(null)
    } catch (err) {
      console.error('Error saving template:', err)
      alert(t('admin.settings.terms.save_error'))
    } finally {
      setSaving(false)
    }
  }

  const handleToggleActive = async (template: EmailTemplate) => {
    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error: updateError } = await (supabase as any)
        .from('email_templates')
        .update({
          is_active: !template.is_active,
          updated_at: new Date().toISOString()
        })
        .eq('id', template.id)

      if (updateError) throw updateError

      await fetchTemplates()
    } catch (err) {
      console.error('Error toggling template:', err)
      alert(t('admin.settings.terms.toggle_error'))
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className="w-8 h-8 animate-spin text-orange-500" />
      </div>
    )
  }

  if (error) {
    return (
      <div className={`p-4 rounded-lg border flex items-start gap-2 ${
        isDark
          ? 'bg-red-500/10 border-red-500/50 text-red-400'
          : 'bg-red-50 border-red-200 text-red-600'
      }`}>
        <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
        <span>{error}</span>
      </div>
    )
  }

  const languages: TermsLanguage[] = ['he', 'en', 'fr']

  return (
    <div className="space-y-6">
      {/* Header */}
      <div>
        <h2 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
          {t('admin.settings.terms.title')}
        </h2>
        <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
          {t('admin.settings.terms.subtitle')}
        </p>
      </div>

      {/* Type selector tabs */}
      <div className={`flex gap-2 p-1 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-gray-100'}`}>
        <button
          onClick={() => setSelectedType('game')}
          className={`flex-1 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
            selectedType === 'game'
              ? 'bg-orange-600 text-white'
              : isDark
                ? 'text-gray-400 hover:text-white hover:bg-gray-700'
                : 'text-gray-600 hover:text-gray-900 hover:bg-gray-200'
          }`}
        >
          {t('admin.settings.terms.type_game')}
        </button>
        <button
          onClick={() => setSelectedType('event')}
          className={`flex-1 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
            selectedType === 'event'
              ? 'bg-orange-600 text-white'
              : isDark
                ? 'text-gray-400 hover:text-white hover:bg-gray-700'
                : 'text-gray-600 hover:text-gray-900 hover:bg-gray-200'
          }`}
        >
          {t('admin.settings.terms.type_event')}
        </button>
      </div>

      {/* Description based on type */}
      <div className={`p-4 rounded-lg ${isDark ? 'bg-gray-800/50' : 'bg-gray-50'}`}>
        <p className={`text-sm ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
          {selectedType === 'game'
            ? t('admin.settings.terms.desc_game')
            : t('admin.settings.terms.desc_event')
          }
        </p>
      </div>

      {/* Templates by language */}
      <div className={`rounded-lg border overflow-hidden ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        <div className="divide-y divide-gray-700">
          {languages.map((lang) => {
            const template = getTemplate(selectedType, lang)
            const langInfo = LANGUAGE_LABELS[lang]

            return (
              <div
                key={lang}
                className={`p-4 flex items-center justify-between ${
                  isDark ? 'hover:bg-gray-700/50' : 'hover:bg-gray-50'
                } transition-colors`}
              >
                <div className="flex items-center gap-4">
                  {/* Status indicator */}
                  <div className={`w-2 h-2 rounded-full ${
                    template?.is_active ? 'bg-green-500' : 'bg-gray-500'
                  }`} />

                  <div className="flex items-center gap-3">
                    <span className="text-2xl">{langInfo.flag}</span>
                    <div>
                      <h3 className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                        {langInfo.name}
                      </h3>
                      <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                        {template
                          ? template.name
                          : t('admin.settings.terms.not_configured')
                        }
                      </p>
                    </div>
                  </div>
                </div>

                {template && (
                  <div className="flex items-center gap-2">
                    {/* Toggle active */}
                    <button
                      onClick={() => handleToggleActive(template)}
                      className={`p-2 rounded transition-colors ${
                        template.is_active
                          ? isDark
                            ? 'text-green-400 hover:bg-green-500/20'
                            : 'text-green-600 hover:bg-green-100'
                          : isDark
                            ? 'text-gray-500 hover:bg-gray-600'
                            : 'text-gray-400 hover:bg-gray-100'
                      }`}
                      title={template.is_active
                        ? t('admin.settings.email_templates.deactivate')
                        : t('admin.settings.email_templates.activate')
                      }
                    >
                      {template.is_active ? (
                        <CheckCircle2 className="w-5 h-5" />
                      ) : (
                        <XCircle className="w-5 h-5" />
                      )}
                    </button>

                    {/* Preview */}
                    <button
                      onClick={() => setPreviewTemplate(template)}
                      className={`p-2 rounded transition-colors ${
                        isDark
                          ? 'text-gray-400 hover:bg-gray-600 hover:text-white'
                          : 'text-gray-500 hover:bg-gray-100 hover:text-gray-700'
                      }`}
                      title={t('admin.settings.email_templates.preview')}
                    >
                      <Eye className="w-5 h-5" />
                    </button>

                    {/* Edit */}
                    <button
                      onClick={() => handleEdit(template)}
                      className={`p-2 rounded transition-colors ${
                        isDark
                          ? 'text-orange-400 hover:bg-orange-500/20'
                          : 'text-orange-500 hover:bg-orange-100'
                      }`}
                      title={t('admin.settings.email_templates.edit')}
                    >
                      <Edit2 className="w-5 h-5" />
                    </button>
                  </div>
                )}

                {!template && (
                  <span className={`text-sm px-3 py-1 rounded ${
                    isDark ? 'bg-gray-700 text-gray-400' : 'bg-gray-100 text-gray-500'
                  }`}>
                    {t('admin.settings.terms.run_migration')}
                  </span>
                )}
              </div>
            )
          })}
        </div>
      </div>

      {/* Usage info */}
      <div className={`p-4 rounded-lg border ${
        isDark ? 'bg-blue-500/10 border-blue-500/30' : 'bg-blue-50 border-blue-200'
      }`}>
        <div className="flex items-start gap-3">
          <FileText className={`w-5 h-5 mt-0.5 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
          <div>
            <h4 className={`font-medium ${isDark ? 'text-blue-300' : 'text-blue-800'}`}>
              {t('admin.settings.terms.usage_title')}
            </h4>
            <p className={`text-sm mt-1 ${isDark ? 'text-blue-300/70' : 'text-blue-700'}`}>
              {t('admin.settings.terms.usage_desc')}
            </p>
          </div>
        </div>
      </div>

      {/* Edit Modal */}
      {editingTemplate && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => setEditingTemplate(null)}
          />
          <div className={`relative w-full max-w-4xl max-h-[90vh] overflow-y-auto rounded-xl p-6 ${
            isDark ? 'bg-gray-800' : 'bg-white'
          }`}>
            <h3 className={`text-lg font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {t('admin.settings.terms.edit_title')}: {editingTemplate.name}
            </h3>

            <div className="space-y-4">
              {/* Body */}
              <div>
                <label className={`block text-sm font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.settings.terms.content')} (HTML)
                </label>
                <textarea
                  value={formData.body_template}
                  onChange={(e) => setFormData({ ...formData, body_template: e.target.value })}
                  rows={20}
                  className={`w-full px-3 py-2 rounded-lg border font-mono text-sm ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white'
                      : 'bg-gray-50 border-gray-200 text-gray-900'
                  } focus:outline-none focus:ring-2 focus:ring-orange-500`}
                />
              </div>
            </div>

            <div className="mt-6 flex justify-end gap-2">
              <button
                onClick={() => setEditingTemplate(null)}
                className={`px-4 py-2 rounded-lg ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-white'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                {t('admin.common.cancel')}
              </button>
              <button
                onClick={handleSave}
                disabled={saving || !formData.body_template}
                className="px-4 py-2 rounded-lg bg-orange-600 hover:bg-orange-700 text-white disabled:opacity-50 flex items-center gap-2"
              >
                {saving && <Loader2 className="w-4 h-4 animate-spin" />}
                {t('admin.common.save')}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Preview Modal */}
      {previewTemplate && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => setPreviewTemplate(null)}
          />
          <div className={`relative w-full max-w-4xl max-h-[90vh] overflow-hidden rounded-xl ${
            isDark ? 'bg-gray-800' : 'bg-white'
          }`}>
            <div className={`p-4 border-b flex items-center justify-between ${
              isDark ? 'border-gray-700' : 'border-gray-200'
            }`}>
              <h3 className={`font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.settings.email_templates.preview')}: {previewTemplate.name}
              </h3>
              <button
                onClick={() => setPreviewTemplate(null)}
                className={`p-1 rounded hover:bg-gray-600 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}
              >
                <XCircle className="w-5 h-5" />
              </button>
            </div>

            <div className="p-4">
              <div className="border rounded-lg overflow-hidden" style={{ height: '60vh' }}>
                <iframe
                  srcDoc={previewTemplate.body_template}
                  className="w-full h-full bg-white"
                  title="Terms preview"
                />
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/users/components/UsersTable.tsx">
'use client'

import { useState } from 'react'
import { User, Mail, Phone, Building2, Edit2, Trash2, Shield, Users as UsersIcon, ArrowUpDown, ArrowUp, ArrowDown, Search } from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { UserWithBranches } from '@/lib/supabase/types'
import { CustomSelect } from '../../components/CustomSelect'

interface UsersTableProps {
  users: UserWithBranches[]
  isDark: boolean
  onEdit: (user: UserWithBranches) => void
  onDelete: (user: UserWithBranches) => void
  currentUserId: string
  canEdit?: boolean // Permission de modifier un utilisateur
  canDelete?: boolean // Permission de supprimer un utilisateur
}

export function UsersTable({
  users,
  isDark,
  onEdit,
  onDelete,
  currentUserId,
  canEdit = true,
  canDelete = true,
}: UsersTableProps) {
  const { t } = useTranslation()
  const [searchQuery, setSearchQuery] = useState('')
  const [filterRole, setFilterRole] = useState<string>('all')
  const [filterBranch, setFilterBranch] = useState<string>('all')
  const [sortField, setSortField] = useState<'name' | 'role' | 'phone'>('name')
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc')

  // Extraire toutes les branches uniques
  const allBranches = Array.from(
    new Set(users.flatMap(u => u.branches.map(b => b.id)))
  ).map(id => {
    const branch = users.flatMap(u => u.branches).find(b => b.id === id)
    return branch!
  }).filter(Boolean)

  // Filtrer les utilisateurs
  let filteredUsers = users.filter(user => {
    // Filtre par rôle
    if (filterRole !== 'all' && user.role !== filterRole) {
      return false
    }

    // Filtre par branche
    if (filterBranch !== 'all' && !user.branches.some(b => b.id === filterBranch)) {
      return false
    }

    // Filtre par recherche
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase()
      const fullName = `${user.first_name} ${user.last_name}`.toLowerCase()
      const phone = user.phone.toLowerCase()

      return fullName.includes(query) || phone.includes(query)
    }

    return true
  })

  // Trier les utilisateurs
  filteredUsers.sort((a, b) => {
    let compareResult = 0

    if (sortField === 'name') {
      const nameA = `${a.first_name} ${a.last_name}`.toLowerCase()
      const nameB = `${b.first_name} ${b.last_name}`.toLowerCase()
      compareResult = nameA.localeCompare(nameB)
    } else if (sortField === 'role') {
      const roleOrder: Record<string, number> = { super_admin: 0, branch_admin: 1, agent: 2 }
      compareResult = (roleOrder[a.role || ''] || 99) - (roleOrder[b.role || ''] || 99)
    } else if (sortField === 'phone') {
      compareResult = a.phone.localeCompare(b.phone)
    }

    return sortDirection === 'asc' ? compareResult : -compareResult
  })

  const handleSort = (field: 'name' | 'role' | 'phone') => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')
    } else {
      setSortField(field)
      setSortDirection('asc')
    }
  }

  const getSortIcon = (field: 'name' | 'role' | 'phone') => {
    if (sortField !== field) return <ArrowUpDown className="w-3 h-3 ml-1 opacity-50" />
    return sortDirection === 'asc' ? <ArrowUp className="w-3 h-3 ml-1" /> : <ArrowDown className="w-3 h-3 ml-1" />
  }

  const getRoleBadge = (role: string) => {
    switch (role) {
      case 'super_admin':
        return (
          <span className="inline-flex items-center gap-1 px-2 py-1 text-xs rounded-full bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-400">
            <Shield className="w-3 h-3" />
            {t('admin.roles.super_admin')}
          </span>
        )
      case 'branch_admin':
        return (
          <span className="inline-flex items-center gap-1 px-2 py-1 text-xs rounded-full bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-400">
            <Building2 className="w-3 h-3" />
            {t('admin.roles.manager')}
          </span>
        )
      case 'agent':
        return (
          <span className="inline-flex items-center gap-1 px-2 py-1 text-xs rounded-full bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400">
            <UsersIcon className="w-3 h-3" />
            {t('admin.roles.employee')}
          </span>
        )
      default:
        return role
    }
  }

  return (
    <div className={`rounded-lg border ${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
      {/* Filtres */}
      <div className={`p-4 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'} space-y-4`}>
        {/* Barre de recherche */}
        <div className="relative">
          <Search className={`absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
          <input
            type="text"
            placeholder={t('admin.users.search_placeholder')}
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className={`w-full pl-10 pr-4 py-2 rounded-lg border ${
              isDark
                ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-400'
                : 'bg-white border-gray-300 text-gray-900 placeholder-gray-500'
            } focus:outline-none focus:ring-2 focus:ring-blue-500`}
          />
        </div>

        {/* Filtres en ligne */}
        <div className="flex flex-col sm:flex-row gap-3">
          {/* Filtre par rôle */}
          <div className="flex-1">
            <CustomSelect
              value={filterRole}
              onChange={setFilterRole}
              options={[
                { value: 'all', label: t('admin.users.filter.all_roles') },
                { value: 'super_admin', label: t('admin.roles.super_admin') },
                { value: 'branch_admin', label: t('admin.roles.manager') },
                { value: 'agent', label: t('admin.roles.employee') },
              ]}
              placeholder={t('admin.users.filter.by_role')}
              isDark={isDark}
            />
          </div>

          {/* Filtre par branche */}
          <div className="flex-1">
            <CustomSelect
              value={filterBranch}
              onChange={setFilterBranch}
              options={[
                { value: 'all', label: t('admin.users.filter.all_branches') },
                ...allBranches.map(b => ({ value: b.id, label: b.name }))
              ]}
              placeholder={t('admin.users.filter.by_branch')}
              isDark={isDark}
            />
          </div>
        </div>

        {/* Compteur */}
        <div className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
          {filteredUsers.length} {t('admin.users.table.user')}{filteredUsers.length !== 1 ? 's' : ''}
          {(searchQuery || filterRole !== 'all' || filterBranch !== 'all') && ` (${t('admin.common.of')} ${users.length} ${t('admin.common.total')})`}
        </div>
      </div>

      {/* Table */}
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead className={isDark ? 'bg-gray-700' : 'bg-gray-50'}>
            <tr>
              <th
                onClick={() => handleSort('name')}
                className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider cursor-pointer hover:bg-opacity-80 transition-colors ${
                  isDark ? 'text-gray-300 hover:bg-gray-600' : 'text-gray-600 hover:bg-gray-100'
                }`}
              >
                <div className="flex items-center">
                  {t('admin.users.table.user')}
                  {getSortIcon('name')}
                </div>
              </th>
              <th className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
                {t('admin.users.table.email')}
              </th>
              <th
                onClick={() => handleSort('phone')}
                className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider cursor-pointer hover:bg-opacity-80 transition-colors ${
                  isDark ? 'text-gray-300 hover:bg-gray-600' : 'text-gray-600 hover:bg-gray-100'
                }`}
              >
                <div className="flex items-center">
                  {t('admin.users.table.phone')}
                  {getSortIcon('phone')}
                </div>
              </th>
              <th
                onClick={() => handleSort('role')}
                className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider cursor-pointer hover:bg-opacity-80 transition-colors ${
                  isDark ? 'text-gray-300 hover:bg-gray-600' : 'text-gray-600 hover:bg-gray-100'
                }`}
              >
                <div className="flex items-center">
                  {t('admin.users.table.role')}
                  {getSortIcon('role')}
                </div>
              </th>
              <th className={`px-4 py-3 text-left text-xs font-medium uppercase tracking-wider ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
                {t('admin.users.table.branches')}
              </th>
              <th className={`px-4 py-3 text-right text-xs font-medium uppercase tracking-wider ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>
                {t('admin.common.actions')}
              </th>
            </tr>
          </thead>
          <tbody className={`divide-y ${isDark ? 'divide-gray-700' : 'divide-gray-200'}`}>
            {filteredUsers.length === 0 ? (
              <tr>
                <td colSpan={6} className={`px-4 py-8 text-center ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.users.no_users')}
                </td>
              </tr>
            ) : (
              filteredUsers.map((user) => (
                <tr
                  key={user.id}
                  className={`${isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-50'} transition-colors`}
                >
                  {/* Utilisateur */}
                  <td className="px-4 py-4 whitespace-nowrap">
                    <div className="flex items-center gap-3">
                      <div className={`w-10 h-10 rounded-full flex items-center justify-center ${
                        user.role === 'super_admin'
                          ? 'bg-purple-100 dark:bg-purple-900/30'
                          : user.role === 'branch_admin'
                          ? 'bg-blue-100 dark:bg-blue-900/30'
                          : 'bg-green-100 dark:bg-green-900/30'
                      }`}>
                        <User className={`w-5 h-5 ${
                          user.role === 'super_admin'
                            ? 'text-purple-600 dark:text-purple-400'
                            : user.role === 'branch_admin'
                            ? 'text-blue-600 dark:text-blue-400'
                            : 'text-green-600 dark:text-green-400'
                        }`} />
                      </div>
                      <div>
                        <div className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                          {user.first_name} {user.last_name}
                        </div>
                        {user.creator && (
                          <div className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                            {t('admin.users.created_by')} {user.creator.first_name} {user.creator.last_name}
                          </div>
                        )}
                      </div>
                    </div>
                  </td>

                  {/* Email */}
                  <td className="px-4 py-4">
                    <div className={`flex items-center gap-2 text-sm ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      <Mail className="w-4 h-4 flex-shrink-0" />
                      <span className="truncate">{user.email || 'N/A'}</span>
                    </div>
                  </td>

                  {/* Téléphone */}
                  <td className="px-4 py-4 whitespace-nowrap">
                    <div className={`flex items-center gap-2 text-sm ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      <Phone className="w-4 h-4 flex-shrink-0" />
                      <span>{user.phone}</span>
                    </div>
                  </td>

                  {/* Rôle */}
                  <td className="px-4 py-4 whitespace-nowrap">
                    {getRoleBadge(user.role)}
                  </td>

                  {/* Branches */}
                  <td className="px-4 py-4">
                    {user.branches.length === 0 ? (
                      <span className={`text-sm italic ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                        {t('admin.users.no_branch')}
                      </span>
                    ) : (
                      <div className="flex flex-wrap gap-1">
                        {user.branches.map((branch) => (
                          <span
                            key={branch.id}
                            className={`inline-flex items-center gap-1 px-2 py-1 text-xs rounded ${
                              isDark
                                ? 'bg-gray-700 text-gray-300'
                                : 'bg-gray-100 text-gray-700'
                            }`}
                          >
                            <Building2 className="w-3 h-3" />
                            {branch.name}
                          </span>
                        ))}
                      </div>
                    )}
                  </td>

                  {/* Actions */}
                  <td className="px-4 py-4 whitespace-nowrap text-right">
                    <div className="flex items-center justify-end gap-2">
                      <button
                        onClick={() => canEdit && onEdit(user)}
                        disabled={!canEdit}
                        className={`p-2 rounded-lg transition-colors ${
                          !canEdit
                            ? 'opacity-50 cursor-not-allowed text-gray-400'
                            : isDark
                              ? 'hover:bg-gray-600 text-gray-400 hover:text-white'
                              : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700'
                        }`}
                        title={!canEdit ? t('admin.common.no_permission') : t('admin.common.edit')}
                      >
                        <Edit2 className="w-4 h-4" />
                      </button>
                      <button
                        onClick={() => canDelete && onDelete(user)}
                        disabled={user.id === currentUserId || !canDelete}
                        className={`p-2 rounded-lg transition-colors ${
                          user.id === currentUserId || !canDelete
                            ? 'opacity-50 cursor-not-allowed text-gray-400'
                            : isDark
                            ? 'hover:bg-red-900/30 text-gray-400 hover:text-red-400'
                            : 'hover:bg-red-50 text-gray-500 hover:text-red-600'
                        }`}
                        title={!canDelete ? t('admin.common.no_permission') : user.id === currentUserId ? t('admin.users.cannot_delete_self') : t('admin.common.delete')}
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/users/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Plus, Loader2, AlertCircle, Trash2, Shield } from 'lucide-react'
import { useAuth } from '@/hooks/useAuth'
import { useUsers } from '@/hooks/useUsers'
import { useBranches } from '@/hooks/useBranches'
import { useRoles } from '@/hooks/useRoles'
import { useUserPermissions, type UserRole } from '@/hooks/useUserPermissions'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { UsersTable } from './components/UsersTable'
import { CreateUserModal } from './components/CreateUserModal'
import { EditUserModal } from './components/EditUserModal'
import { EditSelfModal } from './components/EditSelfModal'
import type { UserWithBranches } from '@/lib/supabase/types'
import { createClient } from '@/lib/supabase/client'

export default function UsersPage() {
  const router = useRouter()
  const { t } = useTranslation()
  const { user, loading: authLoading } = useAuth()
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()
  const { users, loading: usersLoading, error, createUser, updateUser, deleteUser } = useUsers()
  const { getRoleLevel } = useRoles()

  // Get the current user's level for hierarchy checks
  const currentUserLevel = user?.role ? getRoleLevel(user.role) : 10

  // Permissions
  const { hasPermission } = useUserPermissions(user?.role as UserRole || null)
  const canCreateUser = hasPermission('users', 'can_create')
  const canEditUser = hasPermission('users', 'can_edit')
  const canDeleteUser = hasPermission('users', 'can_delete')
  
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [showEditModal, setShowEditModal] = useState(false)
  const [showEditSelfModal, setShowEditSelfModal] = useState(false)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const [selectedUser, setSelectedUser] = useState<UserWithBranches | null>(null)

  // Gérer le thème (synchronisé avec localStorage) - EXACTEMENT comme clients
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')
  
  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  const handleEdit = (editUser: UserWithBranches) => {
    if (!user) return
    setSelectedUser(editUser)
    // Si l'utilisateur édite son propre compte, ouvrir le modal simplifié
    if (editUser.id === user.id) {
      setShowEditSelfModal(true)
    } else {
      setShowEditModal(true)
    }
  }

  const handleDelete = (user: UserWithBranches) => {
    setSelectedUser(user)
    setShowDeleteConfirm(true)
  }

  const handleConfirmDelete = async () => {
    if (!selectedUser) return

    const result = await deleteUser(selectedUser.id)
    
    if (result.success) {
      setShowDeleteConfirm(false)
      setSelectedUser(null)
    } else {
      alert(result.error || 'Erreur lors de la suppression')
    }
  }

  // Vérifier les permissions - level < 8 peut gérer les utilisateurs
  if (user && currentUserLevel >= 8) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <div className="text-center">
          <AlertCircle className="w-16 h-16 text-red-500 mx-auto mb-4" />
          <h1 className={`text-2xl font-bold mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {t('admin.users.access_denied')}
          </h1>
          <p className={isDark ? 'text-gray-400' : 'text-gray-600'}>
            {t('admin.users.access_denied_message')}
          </p>
        </div>
      </div>
    )
  }

  // Loading state
  if (authLoading || branchesLoading || !user || !selectedBranch) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header avec navigation */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={handleSignOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sous-header avec titre et actions */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
              isDark ? 'bg-purple-500/20' : 'bg-purple-100'
            }`}>
              <Shield className={`w-6 h-6 ${isDark ? 'text-purple-400' : 'text-purple-600'}`} />
            </div>
            <div>
              <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.users.title')}
              </h1>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                {t('admin.users.subtitle')}
              </p>
            </div>
          </div>
          <button
            onClick={() => canCreateUser && setShowCreateModal(true)}
            disabled={!canCreateUser}
            title={!canCreateUser ? t('admin.common.no_permission') : undefined}
            className={`inline-flex items-center gap-2 px-4 py-2 rounded-lg transition-colors ${
              !canCreateUser
                ? 'bg-gray-500 text-gray-300 cursor-not-allowed opacity-50'
                : 'bg-blue-600 hover:bg-blue-700 text-white'
            }`}
          >
            <Plus className="w-5 h-5" />
            {t('admin.users.create')}
          </button>
        </div>
      </div>

      {/* Contenu principal */}
      <div className="p-6 space-y-6">
        {/* Error */}
        {error && (
          <div className={`p-4 rounded-lg border flex items-start gap-2 ${
            isDark
              ? 'bg-red-500/10 border-red-500/50 text-red-400'
              : 'bg-red-50 border-red-200 text-red-600'
          }`}>
            <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
            <span>{error}</span>
          </div>
        )}

        {/* Loading */}
        {usersLoading && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 animate-spin text-blue-500" />
          </div>
        )}

        {/* Table */}
        {!usersLoading && (
          <UsersTable
            users={users}
            isDark={isDark}
            onEdit={handleEdit}
            onDelete={handleDelete}
            currentUserId={user.id}
            canEdit={canEditUser}
            canDelete={canDeleteUser}
          />
        )}
      </div>

      {/* Modals */}
      {user && (
        <>
          <CreateUserModal
            isOpen={showCreateModal}
            onClose={() => setShowCreateModal(false)}
            onSubmit={createUser}
            branches={user.branches}
            currentUserRole={user.role || 'agent'}
            currentUserBranchIds={user.branches.map(b => b.id)}
            currentUserLevel={currentUserLevel}
            isDark={isDark}
          />

          <EditSelfModal
            isOpen={showEditSelfModal}
            onClose={() => {
              setShowEditSelfModal(false)
              setSelectedUser(null)
            }}
            onSubmit={updateUser}
            user={selectedUser}
            isDark={isDark}
          />

          <EditUserModal
            isOpen={showEditModal}
            onClose={() => {
              setShowEditModal(false)
              setSelectedUser(null)
            }}
            onSubmit={updateUser}
            user={selectedUser}
            branches={user.branches}
            currentUserRole={user.role || 'agent'}
            currentUserBranchIds={user.branches.map(b => b.id)}
            currentUserLevel={currentUserLevel}
            isDark={isDark}
          />
        </>
      )}

      {/* Delete Confirmation Modal */}
      {showDeleteConfirm && selectedUser && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
          <div className={`w-full max-w-md rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className={`p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
              <div className="flex items-center gap-3">
                <div className="w-12 h-12 rounded-full bg-red-100 dark:bg-red-900/30 flex items-center justify-center">
                  <Trash2 className="w-6 h-6 text-red-600 dark:text-red-400" />
                </div>
                <div>
                  <h2 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {t('admin.users.modal.delete_title')}
                  </h2>
                  <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                    {selectedUser.first_name} {selectedUser.last_name}
                  </p>
                </div>
              </div>
            </div>

            <div className="p-6">
              <div className={`p-4 rounded-lg ${isDark ? 'bg-yellow-900/20 border border-yellow-700' : 'bg-yellow-50 border border-yellow-200'}`}>
                <div className="flex items-start gap-2">
                  <AlertCircle className="w-5 h-5 text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-0.5" />
                  <div className="flex-1">
                    <p className={`text-sm font-medium ${isDark ? 'text-yellow-300' : 'text-yellow-800'}`}>
                      {t('admin.users.modal.delete_warning')}
                    </p>
                    <p className={`text-sm mt-1 ${isDark ? 'text-yellow-400' : 'text-yellow-700'}`}>
                      {t('admin.users.modal.delete_message')}
                    </p>
                  </div>
                </div>
              </div>
            </div>

            <div className={`flex items-center justify-end gap-3 p-6 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
              <button
                onClick={() => {
                  setShowDeleteConfirm(false)
                  setSelectedUser(null)
                }}
                className={`px-4 py-2 rounded-lg transition-colors ${
                  isDark
                    ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                    : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                }`}
              >
                {t('admin.common.cancel')}
              </button>
              <button
                onClick={handleConfirmDelete}
                className="px-6 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white transition-colors"
              >
                {t('admin.users.modal.delete_confirm')}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/api/admin/data-management/counts/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ success: false, error: 'Non autorisé' }, { status: 401 })
    }

    // Vérifier que l'utilisateur est super_admin
    const { data: profileData } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    const profile = profileData as { role: string } | null
    if (!profile || profile.role !== 'super_admin') {
      return NextResponse.json({ success: false, error: 'Accès réservé aux super administrateurs' }, { status: 403 })
    }

    const body = await request.json()
    const { branchIds, includeNullBranch = true } = body

    if (!branchIds || !Array.isArray(branchIds) || branchIds.length === 0) {
      return NextResponse.json({ success: false, error: 'Veuillez sélectionner au moins une branche' }, { status: 400 })
    }

    // Utiliser le client service role pour bypass RLS
    const supabaseAdmin = createServiceRoleClient()

    // Compter les données pour chaque catégorie
    const counts = {
      logs: 0,
      emails: 0,
      orders: 0,
      bookings: 0,
      game_sessions: 0,
      booking_slots: 0,
      contacts: 0
    }

    // Helper pour créer une requête qui inclut branch_id IN (...) OR branch_id IS NULL
    // Supabase ne supporte pas OR facilement, donc on fait 2 requêtes

    // Logs (activity_logs)
    const { count: logsCount1, error: logsError1 } = await supabaseAdmin
      .from('activity_logs')
      .select('*', { count: 'exact', head: true })
      .in('branch_id', branchIds)

    console.log('[COUNTS] activity_logs with branchIds:', logsCount1, 'error:', logsError1)

    let logsCountNull = 0
    if (includeNullBranch) {
      const { count, error } = await supabaseAdmin
        .from('activity_logs')
        .select('*', { count: 'exact', head: true })
        .is('branch_id', null)
      logsCountNull = count || 0
      console.log('[COUNTS] activity_logs with null branch:', count, 'error:', error)
    }
    counts.logs = (logsCount1 || 0) + logsCountNull

    // Debug: compter TOUS les logs pour voir s'il y en a qui échappent
    const { count: totalLogsCount } = await supabaseAdmin
      .from('activity_logs')
      .select('*', { count: 'exact', head: true })
    console.log('[COUNTS] TOTAL activity_logs in DB:', totalLogsCount)

    // Emails (email_logs)
    const { count: emailsCount1 } = await supabaseAdmin
      .from('email_logs')
      .select('*', { count: 'exact', head: true })
      .in('branch_id', branchIds)

    let emailsCountNull = 0
    if (includeNullBranch) {
      const { count } = await supabaseAdmin
        .from('email_logs')
        .select('*', { count: 'exact', head: true })
        .is('branch_id', null)
      emailsCountNull = count || 0
    }
    counts.emails = (emailsCount1 || 0) + emailsCountNull

    // Orders
    const { count: ordersCount1 } = await supabaseAdmin
      .from('orders')
      .select('*', { count: 'exact', head: true })
      .in('branch_id', branchIds)

    let ordersCountNull = 0
    if (includeNullBranch) {
      const { count } = await supabaseAdmin
        .from('orders')
        .select('*', { count: 'exact', head: true })
        .is('branch_id', null)
      ordersCountNull = count || 0
    }
    counts.orders = (ordersCount1 || 0) + ordersCountNull

    // Bookings
    const { data: bookingData1Raw, count: bookingsCount1 } = await supabaseAdmin
      .from('bookings')
      .select('id', { count: 'exact' })
      .in('branch_id', branchIds)

    const bookingData1 = (bookingData1Raw || []) as { id: string }[]

    let bookingDataNull: { id: string }[] = []
    let bookingsCountNull = 0
    if (includeNullBranch) {
      const { data, count } = await supabaseAdmin
        .from('bookings')
        .select('id', { count: 'exact' })
        .is('branch_id', null)
      bookingDataNull = (data || []) as { id: string }[]
      bookingsCountNull = count || 0
    }
    counts.bookings = (bookingsCount1 || 0) + bookingsCountNull

    // Game Sessions et Booking Slots - via booking_id
    const allBookingIds = [
      ...bookingData1.map(b => b.id),
      ...bookingDataNull.map(b => b.id)
    ]

    if (allBookingIds.length > 0) {
      // Game Sessions
      const { count: gameSessionsCount } = await supabaseAdmin
        .from('game_sessions')
        .select('*', { count: 'exact', head: true })
        .in('booking_id', allBookingIds)
      counts.game_sessions = gameSessionsCount || 0

      // Booking Slots
      const { count: slotsCount } = await supabaseAdmin
        .from('booking_slots')
        .select('*', { count: 'exact', head: true })
        .in('booking_id', allBookingIds)
      counts.booking_slots = slotsCount || 0
    }

    // Contacts - utilise branch_id_main (pas branch_id)
    const { count: contactsCount1 } = await supabaseAdmin
      .from('contacts')
      .select('*', { count: 'exact', head: true })
      .in('branch_id_main', branchIds)

    let contactsCountNull = 0
    if (includeNullBranch) {
      const { count } = await supabaseAdmin
        .from('contacts')
        .select('*', { count: 'exact', head: true })
        .is('branch_id_main', null)
      contactsCountNull = count || 0
    }
    counts.contacts = (contactsCount1 || 0) + contactsCountNull

    console.log('[COUNTS] Final counts:', counts)

    return NextResponse.json({
      success: true,
      counts
    })

  } catch (error) {
    console.error('[DATA-MANAGEMENT] Error getting counts:', error)
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/admin/data-management/delete/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ success: false, error: 'Non autorisé' }, { status: 401 })
    }

    // Vérifier que l'utilisateur est super_admin
    const { data: profileData } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    const profile = profileData as { role: string } | null
    if (!profile || profile.role !== 'super_admin') {
      return NextResponse.json({ success: false, error: 'Accès réservé aux super administrateurs' }, { status: 403 })
    }

    const body = await request.json()
    const { branchIds, groups, password, includeNullBranch = true } = body

    // Support ancien format (group unique) et nouveau format (groups multiples)
    const groupsToDelete: string[] = groups || (body.group ? [body.group] : [])

    if (!branchIds || !Array.isArray(branchIds) || branchIds.length === 0) {
      return NextResponse.json({ success: false, error: 'Veuillez sélectionner au moins une branche' }, { status: 400 })
    }

    if (!groupsToDelete.length || !groupsToDelete.every(g => ['logs', 'reservations', 'contacts'].includes(g))) {
      return NextResponse.json({ success: false, error: 'Groupe de suppression invalide' }, { status: 400 })
    }

    if (!password) {
      return NextResponse.json({ success: false, error: 'Mot de passe requis' }, { status: 400 })
    }

    // Vérifier le mot de passe
    const { error: signInError } = await supabase.auth.signInWithPassword({
      email: user.email!,
      password: password
    })

    if (signInError) {
      return NextResponse.json({ success: false, error: 'Mot de passe incorrect' }, { status: 401 })
    }

    // Utiliser le client service role pour bypass RLS
    const supabaseAdmin = createServiceRoleClient()

    const deletedCounts = {
      logs: 0,
      emails: 0,
      orders: 0,
      bookings: 0,
      game_sessions: 0,
      booking_slots: 0,
      contacts: 0
    }

    const errors: string[] = []

    // Helper pour supprimer avec branch_id IN (...) OR branch_id IS NULL
    async function deleteWithNullBranch(table: string, branchColumn = 'branch_id'): Promise<number> {
      let total = 0

      // Supprimer ceux avec branch_id dans la liste
      const { count: count1, error: error1 } = await supabaseAdmin
        .from(table)
        .delete({ count: 'exact' })
        .in(branchColumn, branchIds)

      if (error1) {
        console.error(`[DELETE] ${table} (in branchIds) error:`, error1)
        errors.push(`${table}: ${error1.message}`)
      } else {
        total += count1 || 0
      }

      // Supprimer ceux avec branch_id NULL
      if (includeNullBranch) {
        const { count: count2, error: error2 } = await supabaseAdmin
          .from(table)
          .delete({ count: 'exact' })
          .is(branchColumn, null)

        if (error2) {
          console.error(`[DELETE] ${table} (null branch) error:`, error2)
          errors.push(`${table} (null): ${error2.message}`)
        } else {
          total += count2 || 0
        }
      }

      return total
    }

    // Ordre de suppression important: logs d'abord, puis reservations, puis contacts

    // 1. LOGS
    if (groupsToDelete.includes('logs')) {
      deletedCounts.logs = await deleteWithNullBranch('activity_logs')
      deletedCounts.emails = await deleteWithNullBranch('email_logs')
    }

    // 2. RESERVATIONS (ordre: slots → sessions → bookings → orders)
    if (groupsToDelete.includes('reservations')) {
      // Récupérer tous les bookings
      const { data: bookings1Raw } = await supabaseAdmin
        .from('bookings')
        .select('id')
        .in('branch_id', branchIds)

      const bookings1 = (bookings1Raw || []) as { id: string }[]

      let bookingsNull: { id: string }[] = []
      if (includeNullBranch) {
        const { data } = await supabaseAdmin
          .from('bookings')
          .select('id')
          .is('branch_id', null)
        bookingsNull = (data || []) as { id: string }[]
      }

      const allBookingIds = [
        ...bookings1.map(b => b.id),
        ...bookingsNull.map(b => b.id)
      ]

      // Récupérer tous les orders
      const { data: orders1Raw } = await supabaseAdmin
        .from('orders')
        .select('id')
        .in('branch_id', branchIds)

      const orders1 = (orders1Raw || []) as { id: string }[]

      let ordersNull: { id: string }[] = []
      if (includeNullBranch) {
        const { data } = await supabaseAdmin
          .from('orders')
          .select('id')
          .is('branch_id', null)
        ordersNull = (data || []) as { id: string }[]
      }

      const allOrderIds = [
        ...orders1.map(o => o.id),
        ...ordersNull.map(o => o.id)
      ]

      // 2.1 Supprimer booking_slots
      if (allBookingIds.length > 0) {
        const { count, error } = await supabaseAdmin
          .from('booking_slots')
          .delete({ count: 'exact' })
          .in('booking_id', allBookingIds)

        if (error) {
          console.error('[DELETE] booking_slots error:', error)
          errors.push(`booking_slots: ${error.message}`)
        } else {
          deletedCounts.booking_slots = count || 0
        }
      }

      // 2.2 Supprimer game_sessions
      if (allBookingIds.length > 0) {
        const { count, error } = await supabaseAdmin
          .from('game_sessions')
          .delete({ count: 'exact' })
          .in('booking_id', allBookingIds)

        if (error) {
          console.error('[DELETE] game_sessions error:', error)
          errors.push(`game_sessions: ${error.message}`)
        } else {
          deletedCounts.game_sessions = count || 0
        }
      }

      // 2.3 Supprimer bookings
      if (allBookingIds.length > 0) {
        const { count, error } = await supabaseAdmin
          .from('bookings')
          .delete({ count: 'exact' })
          .in('id', allBookingIds)

        if (error) {
          console.error('[DELETE] bookings error:', error)
          errors.push(`bookings: ${error.message}`)
        } else {
          deletedCounts.bookings = count || 0
        }
      }

      // 2.4 Supprimer orders
      if (allOrderIds.length > 0) {
        const { count, error } = await supabaseAdmin
          .from('orders')
          .delete({ count: 'exact' })
          .in('id', allOrderIds)

        if (error) {
          console.error('[DELETE] orders error:', error)
          errors.push(`orders: ${error.message}`)
        } else {
          deletedCounts.orders = count || 0
        }
      }
    }

    // 3. CONTACTS - utilise branch_id_main (pas branch_id)
    if (groupsToDelete.includes('contacts')) {
      // Vérifier qu'il n'y a plus de réservations liées
      const { count: remainingOrders1 } = await supabaseAdmin
        .from('orders')
        .select('*', { count: 'exact', head: true })
        .in('branch_id', branchIds)

      let remainingOrdersNull = 0
      if (includeNullBranch) {
        const { count } = await supabaseAdmin
          .from('orders')
          .select('*', { count: 'exact', head: true })
          .is('branch_id', null)
        remainingOrdersNull = count || 0
      }

      const totalRemainingOrders = (remainingOrders1 || 0) + remainingOrdersNull

      if (totalRemainingOrders > 0 && !groupsToDelete.includes('reservations')) {
        errors.push(`Impossible de supprimer les contacts: ${totalRemainingOrders} commandes sont encore liées`)
      } else {
        // Contacts utilise branch_id_main pas branch_id
        let contactsTotal = 0

        const { count: count1, error: error1 } = await supabaseAdmin
          .from('contacts')
          .delete({ count: 'exact' })
          .in('branch_id_main', branchIds)

        if (error1) {
          console.error('[DELETE] contacts (in branchIds) error:', error1)
          errors.push(`contacts: ${error1.message}`)
        } else {
          contactsTotal += count1 || 0
        }

        if (includeNullBranch) {
          const { count: count2, error: error2 } = await supabaseAdmin
            .from('contacts')
            .delete({ count: 'exact' })
            .is('branch_id_main', null)

          if (error2) {
            console.error('[DELETE] contacts (null branch) error:', error2)
            errors.push(`contacts (null): ${error2.message}`)
          } else {
            contactsTotal += count2 || 0
          }
        }

        deletedCounts.contacts = contactsTotal
      }
    }

    // Logger l'action
    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      await (supabaseAdmin as any).from('activity_logs').insert({
        user_id: user.id,
        branch_id: branchIds[0],
        action: 'data_deletion',
        entity_type: 'system',
        entity_id: null,
        details: {
          groups: groupsToDelete,
          branches: branchIds,
          includeNullBranch,
          deleted_counts: deletedCounts,
          errors: errors.length > 0 ? errors : undefined
        }
      })
    } catch (logError) {
      console.error('[DATA-MANAGEMENT] Error logging deletion:', logError)
    }

    if (errors.length > 0) {
      return NextResponse.json({
        success: false,
        error: errors.join(', '),
        deleted: deletedCounts
      }, { status: 500 })
    }

    return NextResponse.json({
      success: true,
      deleted: deletedCounts
    })

  } catch (error) {
    console.error('[DATA-MANAGEMENT] Error deleting data:', error)
    return NextResponse.json(
      { success: false, error: 'Erreur serveur lors de la suppression' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/contacts/[id]/route.ts">
/**
 * API Route pour gérer un contact individuel
 * GET: Récupérer un contact
 * PUT: Mettre à jour un contact
 * DELETE: Archiver un contact (soft delete)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logContactAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { syncContactToICountBackground } from '@/lib/icount-sync'
import type { Contact, ContactStatus, UserRole, ClientType } from '@/lib/supabase/types'

/**
 * GET /api/contacts/[id]
 * Récupère un contact spécifique
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('clients', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    const { data: contact, error } = await supabase
      .from('contacts')
      .select('*')
      .eq('id', id)
      .single<Contact>()

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json(
          { success: false, error: 'Contact not found', messageKey: 'errors.contactNotFound' },
          { status: 404 }
        )
      }
      console.error('Error fetching contact:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch contact', messageKey: 'errors.fetchFailed' },
        { status: 500 }
      )
    }

    return NextResponse.json({ success: true, contact })
  } catch (error) {
    console.error('Error fetching contact:', error)
    return NextResponse.json(
      { success: false, error: 'Failed to fetch contact', messageKey: 'errors.fetchFailed' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/contacts/[id]
 * Met à jour un contact spécifique
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('clients', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body = await request.json()
    const supabase = createServiceRoleClient()
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer le contact actuel pour le log (avant modification)
    const { data: oldContact } = await supabase
      .from('contacts')
      .select('*')
      .eq('id', id)
      .single<Contact>()

    if (!oldContact) {
      return NextResponse.json(
        { success: false, error: 'Contact not found', messageKey: 'errors.contactNotFound' },
        { status: 404 }
      )
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateData: any = {}

    if (body.first_name !== undefined) updateData.first_name = body.first_name?.trim()
    if (body.last_name !== undefined) updateData.last_name = body.last_name?.trim() || null
    if (body.phone !== undefined) updateData.phone = body.phone?.trim()
    if (body.email !== undefined) updateData.email = body.email?.trim() || null
    if (body.notes_client !== undefined) updateData.notes_client = body.notes_client?.trim() || null
    if (body.preferred_locale !== undefined) updateData.preferred_locale = body.preferred_locale
    if (body.alias !== undefined) updateData.alias = body.alias?.trim() || null
    if (body.source !== undefined) updateData.source = body.source
    if (body.client_type !== undefined) updateData.client_type = body.client_type as ClientType
    if (body.company_name !== undefined) updateData.company_name = body.company_name?.trim() || null
    if (body.vat_id !== undefined) updateData.vat_id = body.vat_id?.trim() || null

    // Gestion du status (archivage/désarchivage)
    if (body.status !== undefined) {
      updateData.status = body.status as ContactStatus
      if (body.status === 'archived') {
        updateData.archived_at = new Date().toISOString()
        if (body.archived_reason !== undefined) {
          updateData.archived_reason = body.archived_reason?.trim() || null
        }
      } else if (body.status === 'active') {
        updateData.archived_at = null
        updateData.archived_reason = null
      }
    }

    updateData.updated_at = new Date().toISOString()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: contact, error } = await (supabase as any)
      .from('contacts')
      .update(updateData)
      .eq('id', id)
      .select()
      .single() as { data: Contact | null; error: any }

    if (error || !contact) {
      if (error?.code === 'PGRST116') {
        return NextResponse.json(
          { success: false, error: 'Contact not found', messageKey: 'errors.contactNotFound' },
          { status: 404 }
        )
      }
      console.error('Error updating contact:', error)
      return NextResponse.json(
        { success: false, error: error?.message || 'Failed to update contact', messageKey: 'errors.updateFailed' },
        { status: 500 }
      )
    }

    // ====================================================================
    // SYNCHRONISER les données vers les orders et bookings liés
    // ====================================================================
    // Si les champs de données client ont changé, mettre à jour les copies
    const customerFieldsChanged =
      updateData.first_name !== undefined ||
      updateData.last_name !== undefined ||
      updateData.phone !== undefined ||
      updateData.email !== undefined

    if (customerFieldsChanged) {
      // Préparer les données pour la synchronisation
      const syncData: Record<string, unknown> = {}
      if (updateData.first_name !== undefined) syncData.customer_first_name = contact.first_name
      if (updateData.last_name !== undefined) syncData.customer_last_name = contact.last_name || ''
      if (updateData.phone !== undefined) syncData.customer_phone = contact.phone
      if (updateData.email !== undefined) syncData.customer_email = contact.email

      // Synchroniser vers les orders liées
      if (Object.keys(syncData).length > 0) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { error: ordersError } = await (supabase as any)
          .from('orders')
          .update(syncData)
          .eq('contact_id', id)

        if (ordersError) {
          console.warn('Warning: Failed to sync contact data to orders:', ordersError)
          // On continue quand même - ce n'est pas bloquant
        }

        // Synchroniser vers les bookings liés (via primary_contact_id)
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { error: bookingsError } = await (supabase as any)
          .from('bookings')
          .update(syncData)
          .eq('primary_contact_id', id)

        if (bookingsError) {
          console.warn('Warning: Failed to sync contact data to bookings:', bookingsError)
          // On continue quand même - ce n'est pas bloquant
        }
      }
    }

    // Déterminer l'action (archivage ou simple update)
    const actionType = body.status === 'archived' ? 'archived' : 'updated'

    // Logger la modification
    await logContactAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: actionType,
      contactId: id,
      contactName: `${contact.first_name} ${contact.last_name || ''}`.trim(),
      details: {
        changes: Object.keys(updateData).filter(k => k !== 'updated_at'),
        oldValues: {
          first_name: oldContact.first_name,
          last_name: oldContact.last_name,
          phone: oldContact.phone,
          email: oldContact.email,
          status: oldContact.status
        },
        newValues: {
          first_name: contact.first_name,
          last_name: contact.last_name,
          phone: contact.phone,
          email: contact.email,
          status: contact.status
        }
      },
      ipAddress
    })

    // Sync to iCount in background (non-blocking) - only if not archiving
    if (actionType !== 'archived') {
      syncContactToICountBackground(contact, contact.branch_id_main)
    }

    return NextResponse.json({ success: true, contact })
  } catch (error) {
    console.error('Error updating contact:', error)
    return NextResponse.json(
      { success: false, error: 'Failed to update contact', messageKey: 'errors.updateFailed' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/contacts/[id]
 * Archive un contact (soft delete) - pas de hard delete via UI
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('clients', 'delete')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer le contact avant archivage pour le log
    const { data: contact } = await supabase
      .from('contacts')
      .select('*')
      .eq('id', id)
      .single<Contact>()

    if (!contact) {
      return NextResponse.json(
        { success: false, error: 'Contact not found', messageKey: 'errors.contactNotFound' },
        { status: 404 }
      )
    }

    // Soft delete = archivage (pas de hard delete via UI en v1)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { error } = await (supabase as any)
      .from('contacts')
      .update({
        status: 'archived',
        archived_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })
      .eq('id', id)

    if (error) {
      console.error('Error archiving contact:', error)
      return NextResponse.json(
        { success: false, error: error.message || 'Failed to archive contact', messageKey: 'errors.archiveFailed' },
        { status: 500 }
      )
    }

    // Logger l'archivage
    await logContactAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'archived',
      contactId: id,
      contactName: `${contact.first_name} ${contact.last_name || ''}`.trim(),
      details: {
        phone: contact.phone,
        email: contact.email,
        previousStatus: contact.status
      },
      ipAddress
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error archiving contact:', error)
    return NextResponse.json(
      { success: false, error: 'Failed to archive contact', messageKey: 'errors.archiveFailed' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/contacts/route.ts">
/**
 * API Route pour gérer les contacts
 * GET: Liste des contacts avec filtres et pagination
 * POST: Créer un nouveau contact
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logContactAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { validateIsraeliPhone, formatIsraeliPhone } from '@/lib/validation'
import { syncContactToICountBackground } from '@/lib/icount-sync'
import type { UserRole, Contact, ClientType } from '@/lib/supabase/types'

/**
 * GET /api/contacts
 * Liste les contacts avec filtres et pagination
 */
export async function GET(request: NextRequest) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('clients', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const searchParams = request.nextUrl.searchParams
    // Support both naming conventions (branchId and branch_id)
    const branchId = searchParams.get('branchId') || searchParams.get('branch_id')
    const query = searchParams.get('query')
    const status = searchParams.get('status') || 'active'
    const includeArchived = searchParams.get('includeArchived') === 'true' || searchParams.get('include_archived') === 'true'
    const source = searchParams.get('source')
    const dateFrom = searchParams.get('dateFrom') || searchParams.get('date_from')
    const dateTo = searchParams.get('dateTo') || searchParams.get('date_to')
    const page = parseInt(searchParams.get('page') || '1')
    const pageSize = parseInt(searchParams.get('pageSize') || searchParams.get('page_size') || '50')

    // Mode vérification de doublons
    const checkDuplicates = searchParams.get('checkDuplicates') === 'true'
    const phone = searchParams.get('phone')
    const email = searchParams.get('email')
    const excludeId = searchParams.get('excludeId')

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branchId is required', messageKey: 'errors.branchRequired' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // Mode checkDuplicates
    if (checkDuplicates && phone) {
      const formattedPhone = formatIsraeliPhone(phone)

      // Chercher par téléphone
      let phoneQuery = supabase
        .from('contacts')
        .select('*')
        .eq('branch_id_main', branchId)
        .eq('phone', formattedPhone)

      if (excludeId) {
        phoneQuery = phoneQuery.neq('id', excludeId)
      }

      const { data: phoneMatches } = await phoneQuery.returns<Contact[]>()

      // Chercher par email si fourni
      let emailMatches: Contact[] = []
      if (email && email.trim()) {
        let emailQuery = supabase
          .from('contacts')
          .select('*')
          .eq('branch_id_main', branchId)
          .eq('email', email.trim())

        if (excludeId) {
          emailQuery = emailQuery.neq('id', excludeId)
        }

        const { data: emailData } = await emailQuery.returns<Contact[]>()
        emailMatches = emailData || []
      }

      return NextResponse.json({
        success: true,
        phoneMatches: phoneMatches || [],
        emailMatches
      })
    }

    const from = (page - 1) * pageSize
    const to = from + pageSize - 1

    // Construire la requête
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let dbQuery = (supabase as any)
      .from('contacts')
      .select('*', { count: 'exact' })
      .eq('branch_id_main', branchId)

    // Filtrer par status
    if (!includeArchived) {
      if (status) {
        dbQuery = dbQuery.eq('status', status)
      } else {
        dbQuery = dbQuery.eq('status', 'active')
      }
    }

    // Filtrer par source
    if (source) {
      dbQuery = dbQuery.eq('source', source)
    }

    // Filtrer par date
    if (dateFrom) {
      dbQuery = dbQuery.gte('created_at', dateFrom)
    }
    if (dateTo) {
      dbQuery = dbQuery.lte('created_at', dateTo + 'T23:59:59')
    }

    // Recherche multi-champs
    if (query && query.trim().length > 0) {
      const searchQuery = query.trim()
      dbQuery = dbQuery.or(
        `first_name.ilike.%${searchQuery}%,last_name.ilike.%${searchQuery}%,phone.ilike.%${searchQuery}%,email.ilike.%${searchQuery}%`
      )
    }

    // Tri et pagination
    dbQuery = dbQuery
      .order('created_at', { ascending: false })
      .range(from, to)

    const { data: contacts, error, count } = await dbQuery

    if (error) {
      console.error('Error fetching contacts:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch contacts', messageKey: 'errors.fetchFailed' },
        { status: 500 }
      )
    }

    const total = count || 0
    const totalPages = Math.ceil(total / pageSize)

    return NextResponse.json({
      success: true,
      contacts: contacts || [],
      total,
      page,
      pageSize,
      totalPages
    })

  } catch (error) {
    console.error('Error in GET /api/contacts:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/contacts
 * Créer un nouveau contact
 */
export async function POST(request: NextRequest) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('clients', 'create')
    if (!success || !user) {
      return errorResponse
    }

    const body = await request.json()
    const {
      branch_id_main,
      first_name,
      last_name,
      phone,
      email,
      notes_client,
      alias,
      source = 'admin_agenda',
      client_type = 'individual',
      company_name,
      vat_id
    } = body

    // Validation des champs requis
    if (!branch_id_main || !first_name || !phone) {
      return NextResponse.json(
        { success: false, error: 'branch_id_main, first_name, and phone are required', messageKey: 'errors.missingFields' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branch_id_main)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
        { status: 403 }
      )
    }

    // Valider le format téléphone
    if (!validateIsraeliPhone(phone)) {
      return NextResponse.json(
        { success: false, error: 'Invalid phone format (expected 05XXXXXXXX)', messageKey: 'errors.invalidPhoneFormat' },
        { status: 400 }
      )
    }

    const formattedPhone = formatIsraeliPhone(phone)
    const supabase = createServiceRoleClient()
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Créer le contact (pas de vérification de doublon - plusieurs contacts peuvent avoir le même tel/email)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: contact, error } = await (supabase as any)
      .from('contacts')
      .insert({
        branch_id_main,
        first_name: first_name.trim(),
        last_name: last_name?.trim() || null,
        phone: formattedPhone,
        email: email?.trim() || null,
        notes_client: notes_client?.trim() || null,
        alias: alias?.trim() || null,
        source,
        status: 'active',
        client_type: client_type as ClientType,
        company_name: client_type === 'company' ? company_name?.trim() || null : null,
        vat_id: client_type === 'company' ? vat_id?.trim() || null : null
      })
      .select()
      .single() as { data: Contact | null; error: any }

    if (error || !contact) {
      console.error('Error creating contact:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to create contact', messageKey: 'errors.createFailed' },
        { status: 500 }
      )
    }

    // Logger la création
    await logContactAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
      action: 'created',
      contactId: contact.id,
      contactName: `${contact.first_name} ${contact.last_name || ''}`.trim(),
      branchId: branch_id_main,
      details: {
        phone: contact.phone,
        email: contact.email,
        source: contact.source,
        client_type: contact.client_type,
        company_name: contact.company_name
      },
      ipAddress
    })

    // Sync to iCount in background (non-blocking)
    syncContactToICountBackground(contact, branch_id_main)

    return NextResponse.json({ success: true, contact }, { status: 201 })

  } catch (error) {
    console.error('Error in POST /api/contacts:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/cron/check-email-status/route.ts">
/**
 * Cron Job: Check Email Status
 * Polls Brevo API to get real delivery status of recent emails
 *
 * Run every 30 minutes via Vercel Cron or external cron service
 * GET /api/cron/check-email-status
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient as createSupabaseClient } from '@supabase/supabase-js'

// Get admin Supabase client
const getAdminSupabase = () => {
  return createSupabaseClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

// Brevo API base URL
const BREVO_API_URL = 'https://api.brevo.com/v3'

interface BrevoEventResponse {
  events: Array<{
    email: string
    date: string
    messageId: string
    event: string
    reason?: string
    tag?: string
  }>
}

// Map Brevo events to our status
function mapBrevoEventToStatus(event: string): 'delivered' | 'failed' | 'bounced' | null {
  switch (event) {
    case 'delivered':
    case 'opened':
    case 'clicks':
      return 'delivered'
    case 'softBounces':
    case 'hardBounces':
    case 'blocked':
    case 'spam':
      return 'bounced'
    case 'invalid':
    case 'error':
      return 'failed'
    default:
      return null
  }
}

export async function GET(request: NextRequest) {
  try {
    // Verify cron secret (optional security)
    const authHeader = request.headers.get('authorization')
    const cronSecret = process.env.CRON_SECRET

    if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
      // Allow without auth if no secret is set (for testing)
      if (cronSecret) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
      }
    }

    const apiKey = process.env.BREVO_API_KEY
    if (!apiKey) {
      return NextResponse.json({ error: 'BREVO_API_KEY not configured' }, { status: 500 })
    }

    const supabase = getAdminSupabase()

    // Get emails with status 'sent' from the last 24 hours
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: pendingEmails, error: fetchError } = await (supabase as any)
      .from('email_logs')
      .select('id, recipient_email, metadata, sent_at')
      .eq('status', 'sent')
      .gte('sent_at', oneDayAgo)
      .limit(50)

    if (fetchError) {
      console.error('[CRON check-email-status] Error fetching emails:', fetchError)
      return NextResponse.json({ error: 'Database error' }, { status: 500 })
    }

    if (!pendingEmails || pendingEmails.length === 0) {
      return NextResponse.json({
        message: 'No pending emails to check',
        checked: 0,
        updated: 0
      })
    }

    console.log(`[CRON check-email-status] Checking ${pendingEmails.length} emails`)

    let updatedCount = 0
    const errors: string[] = []

    // Check each email via Brevo API
    for (const email of pendingEmails) {
      const brevoMessageId = email.metadata?.brevo_message_id

      if (!brevoMessageId) {
        console.log(`[CRON] Email ${email.id} has no brevo_message_id, skipping`)
        continue
      }

      try {
        // Try to get events by email address (more reliable endpoint)
        const response = await fetch(
          `${BREVO_API_URL}/smtp/statistics/events?email=${encodeURIComponent(email.recipient_email)}&limit=50&startDate=${encodeURIComponent(new Date(email.sent_at).toISOString().split('T')[0])}`,
          {
            headers: {
              'api-key': apiKey,
              'Content-Type': 'application/json',
            },
          }
        )

        if (!response.ok) {
          const errorText = await response.text()
          console.error(`[CRON] Brevo API error for ${email.id}:`, response.status, errorText)

          // If statistics API doesn't work, try alternative: assume delivered after 5 minutes
          const sentTime = new Date(email.sent_at).getTime()
          const now = Date.now()
          const fiveMinutes = 5 * 60 * 1000

          if (now - sentTime > fiveMinutes) {
            // Mark as delivered if sent more than 5 minutes ago (optimistic)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const { error: updateError } = await (supabase as any)
              .from('email_logs')
              .update({
                status: 'delivered',
                metadata: {
                  ...(email.metadata || {}),
                  status_source: 'assumed_delivered',
                  checked_at: new Date().toISOString(),
                }
              })
              .eq('id', email.id)

            if (!updateError) {
              console.log(`[CRON] Assumed delivered for email ${email.id} (API unavailable)`)
              updatedCount++
            }
          }
          continue
        }

        const data = await response.json() as BrevoEventResponse

        if (!data.events || data.events.length === 0) {
          // No events yet - if sent more than 5 minutes ago, assume delivered
          const sentTime = new Date(email.sent_at).getTime()
          const now = Date.now()
          const fiveMinutes = 5 * 60 * 1000

          if (now - sentTime > fiveMinutes) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const { error: updateError } = await (supabase as any)
              .from('email_logs')
              .update({
                status: 'delivered',
                metadata: {
                  ...(email.metadata || {}),
                  status_source: 'assumed_delivered_no_events',
                  checked_at: new Date().toISOString(),
                }
              })
              .eq('id', email.id)

            if (!updateError) {
              console.log(`[CRON] Assumed delivered for email ${email.id} (no events after 5min)`)
              updatedCount++
            }
          }
          continue
        }

        // Find events matching this specific message (by messageId or by timing)
        const matchingEvents = data.events.filter(evt =>
          evt.messageId === brevoMessageId ||
          // Fallback: match by timing (within 1 minute of send time)
          Math.abs(new Date(evt.date).getTime() - new Date(email.sent_at).getTime()) < 60000
        )

        if (matchingEvents.length === 0) {
          // No matching events, assume delivered if old enough
          const sentTime = new Date(email.sent_at).getTime()
          const now = Date.now()
          const fiveMinutes = 5 * 60 * 1000

          if (now - sentTime > fiveMinutes) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const { error: updateError } = await (supabase as any)
              .from('email_logs')
              .update({
                status: 'delivered',
                metadata: {
                  ...(email.metadata || {}),
                  status_source: 'assumed_delivered_no_match',
                  checked_at: new Date().toISOString(),
                }
              })
              .eq('id', email.id)

            if (!updateError) {
              console.log(`[CRON] Assumed delivered for email ${email.id} (no matching events)`)
              updatedCount++
            }
          }
          continue
        }

        // Get the most recent matching event
        const latestEvent = matchingEvents[0]
        const newStatus = mapBrevoEventToStatus(latestEvent.event)

        if (newStatus) {
          // Update the email log
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const updateData: Record<string, any> = {
            status: newStatus,
            metadata: {
              ...(email.metadata || {}),
              brevo_last_event: latestEvent.event,
              brevo_last_event_date: latestEvent.date,
            }
          }

          if (newStatus === 'bounced' || newStatus === 'failed') {
            updateData.error_message = latestEvent.reason || `Brevo: ${latestEvent.event}`
          }

          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const { error: updateError } = await (supabase as any)
            .from('email_logs')
            .update(updateData)
            .eq('id', email.id)

          if (updateError) {
            console.error(`[CRON] Error updating email ${email.id}:`, updateError)
            errors.push(`Email ${email.id}: Update failed`)
          } else {
            console.log(`[CRON] Updated email ${email.id} to status: ${newStatus}`)
            updatedCount++
          }
        }

        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100))

      } catch (err) {
        console.error(`[CRON] Error checking email ${email.id}:`, err)
        errors.push(`Email ${email.id}: ${err instanceof Error ? err.message : 'Unknown error'}`)
      }
    }

    return NextResponse.json({
      message: 'Email status check completed',
      checked: pendingEmails.length,
      updated: updatedCount,
      errors: errors.length > 0 ? errors : undefined
    })

  } catch (error) {
    console.error('[CRON check-email-status] Error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/emails/route.ts">
/**
 * API Route: /api/emails
 *
 * GET: Liste des emails envoyés (avec filtres et pagination)
 * POST: Envoyer un nouvel email manuellement
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyApiPermission } from '@/lib/permissions'
import { sendBookingConfirmationEmail } from '@/lib/email-sender'
import type { EmailLog, Branch, Booking } from '@/lib/supabase/types'

// GET: Récupérer la liste des emails
export async function GET(request: NextRequest) {
  // Vérifier les permissions - on utilise 'orders' car les emails sont liés aux commandes
  const permCheck = await verifyApiPermission('orders', 'view')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const user = permCheck.user!
  const supabase = await createClient()
  const searchParams = request.nextUrl.searchParams

  // Paramètres de pagination
  const page = parseInt(searchParams.get('page') || '1')
  const limit = parseInt(searchParams.get('limit') || '20')
  const offset = (page - 1) * limit

  // Paramètres de filtre
  const status = searchParams.get('status')
  const branchId = searchParams.get('branch_id')
  const entityType = searchParams.get('entity_type')
  const search = searchParams.get('search')
  const dateFrom = searchParams.get('date_from')
  const dateTo = searchParams.get('date_to')

  // Construire la requête
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let query = (supabase as any)
    .from('email_logs')
    .select('*', { count: 'exact' })
    .order('created_at', { ascending: false })

  // Filtrer par branches autorisées si pas super_admin
  if (user.role !== 'super_admin') {
    if (user.branchIds.length === 0) {
      return NextResponse.json({
        success: true,
        data: [],
        pagination: { total: 0, page, limit, totalPages: 0 }
      })
    }
    query = query.in('branch_id', user.branchIds)
  }

  // Appliquer les filtres
  if (status) {
    query = query.eq('status', status)
  }

  if (branchId) {
    query = query.eq('branch_id', branchId)
  }

  if (entityType) {
    query = query.eq('entity_type', entityType)
  }

  if (dateFrom) {
    query = query.gte('created_at', dateFrom)
  }

  if (dateTo) {
    query = query.lte('created_at', dateTo)
  }

  if (search) {
    query = query.or(`recipient_email.ilike.%${search}%,recipient_name.ilike.%${search}%,subject.ilike.%${search}%`)
  }

  // Pagination
  query = query.range(offset, offset + limit - 1)

  const { data: emails, error, count } = await query

  if (error) {
    console.error('Error fetching emails:', error)
    return NextResponse.json(
      { success: false, error: 'Failed to fetch emails' },
      { status: 500 }
    )
  }

  return NextResponse.json({
    success: true,
    data: emails || [],
    pagination: {
      total: count || 0,
      page,
      limit,
      totalPages: Math.ceil((count || 0) / limit)
    }
  })
}

// POST: Envoyer un email manuellement (depuis l'admin)
export async function POST(request: NextRequest) {
  // Vérifier les permissions
  const permCheck = await verifyApiPermission('orders', 'create')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const user = permCheck.user!
  const supabase = await createClient()

  try {
    const body = await request.json()
    const { action, bookingId, emailLogId } = body

    // Action: renvoyer un email
    if (action === 'resend' && emailLogId) {
      const { resendEmail } = await import('@/lib/email-sender')
      const result = await resendEmail(emailLogId, user.id)

      if (result.success) {
        return NextResponse.json({
          success: true,
          message: 'Email resent successfully',
          emailLogId: result.newEmailLogId
        })
      } else {
        return NextResponse.json(
          { success: false, error: result.error || 'Failed to resend email' },
          { status: 500 }
        )
      }
    }

    // Action: envoyer confirmation pour un booking
    if (action === 'send_confirmation' && bookingId) {
      // Récupérer le booking avec sa branche
      const { data: booking, error: bookingError } = await supabase
        .from('bookings')
        .select('*')
        .eq('id', bookingId)
        .single<Booking>()

      if (bookingError || !booking) {
        return NextResponse.json(
          { success: false, error: 'Booking not found' },
          { status: 404 }
        )
      }

      // Vérifier l'accès à la branche
      if (user.role !== 'super_admin' && booking.branch_id && !user.branchIds.includes(booking.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Access denied to this branch' },
          { status: 403 }
        )
      }

      // Récupérer la branche
      const { data: branch, error: branchError } = await supabase
        .from('branches')
        .select('*')
        .eq('id', booking.branch_id!)
        .single<Branch>()

      if (branchError || !branch) {
        return NextResponse.json(
          { success: false, error: 'Branch not found' },
          { status: 404 }
        )
      }

      // Récupérer la langue préférée du contact si disponible
      let contactLocale: 'he' | 'fr' | 'en' = 'he'
      if (booking.primary_contact_id) {
        const { data: contactData } = await supabase
          .from('contacts')
          .select('preferred_locale')
          .eq('id', booking.primary_contact_id)
          .single<{ preferred_locale: string | null }>()
        if (contactData?.preferred_locale) {
          contactLocale = contactData.preferred_locale as 'he' | 'fr' | 'en'
        }
      }

      // Envoyer l'email de confirmation
      const result = await sendBookingConfirmationEmail({
        booking,
        branch,
        triggeredBy: user.id,
        locale: contactLocale
      })

      if (result.success) {
        return NextResponse.json({
          success: true,
          message: 'Confirmation email sent successfully',
          emailLogId: result.emailLogId
        })
      } else {
        return NextResponse.json(
          { success: false, error: result.error || 'Failed to send email' },
          { status: 500 }
        )
      }
    }

    return NextResponse.json(
      { success: false, error: 'Invalid action' },
      { status: 400 }
    )

  } catch (error) {
    console.error('Error in POST /api/emails:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-event-formulas/[id]/route.ts">
/**
 * API Route pour gérer une formule EVENT iCount spécifique
 * GET: Récupérer une formule
 * PUT: Mettre à jour une formule
 * DELETE: Supprimer une formule
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { ensureEventProductForFormula, updateEventProductPrice, deleteEventProduct } from '@/lib/icount-sync'

interface RouteParams {
  params: Promise<{ id: string }>
}

/**
 * GET /api/icount-event-formulas/[id]
 */
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: formula, error } = await (supabase as any)
      .from('icount_event_formulas')
      .select('*')
      .eq('id', id)
      .single()

    if (error || !formula) {
      return NextResponse.json(
        { success: false, error: 'Formula not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(formula.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    return NextResponse.json({
      success: true,
      data: formula,
    })
  } catch (error) {
    console.error('[API icount-event-formulas] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/icount-event-formulas/[id]
 */
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body = await request.json()
    const {
      name,
      game_type,
      min_participants,
      max_participants,
      price_per_person,
      room_id,
      priority,
      is_active,
    } = body

    const supabase = createServiceRoleClient()

    // Vérifier que la formule existe
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: existingFormula, error: fetchError } = await (supabase as any)
      .from('icount_event_formulas')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !existingFormula) {
      return NextResponse.json(
        { success: false, error: 'Formula not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingFormula.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Valider game_type si fourni
    if (game_type && !['LASER', 'ACTIVE', 'BOTH'].includes(game_type)) {
      return NextResponse.json(
        { success: false, error: 'game_type must be LASER, ACTIVE or BOTH' },
        { status: 400 }
      )
    }

    // Check for overlapping ranges if min/max/game_type is changing
    const newMin = min_participants ?? existingFormula.min_participants
    const newMax = max_participants ?? existingFormula.max_participants
    const newGameType = game_type ?? existingFormula.game_type

    if (newMin > newMax) {
      return NextResponse.json(
        { success: false, error: 'min_participants cannot be greater than max_participants' },
        { status: 400 }
      )
    }

    // Only check for overlaps if ranges or game_type changed
    const rangeOrTypeChanged =
      min_participants !== undefined ||
      max_participants !== undefined ||
      game_type !== undefined

    if (rangeOrTypeChanged) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { data: existingFormulas } = await (supabase as any)
        .from('icount_event_formulas')
        .select('id, name, game_type, min_participants, max_participants')
        .eq('branch_id', existingFormula.branch_id)
        .eq('is_active', true)
        .neq('id', id) // Exclude current formula

      if (existingFormulas) {
        for (const existing of existingFormulas) {
          // Each game_type creates a separate product, so only check same game_type
          // LASER, ACTIVE, and BOTH are 3 different product types
          if (newGameType === existing.game_type) {
            // Check if participant ranges overlap
            const rangesOverlap = newMin <= existing.max_participants && existing.min_participants <= newMax

            if (rangesOverlap) {
              return NextResponse.json(
                {
                  success: false,
                  error: `Range ${newMin}-${newMax} overlaps with existing ${newGameType} formula "${existing.name}" (${existing.min_participants}-${existing.max_participants})`
                },
                { status: 400 }
              )
            }
          }
        }
      }
    }

    // Construire l'objet de mise à jour
    const updateData: Record<string, unknown> = {
      updated_at: new Date().toISOString(),
    }

    if (name !== undefined) updateData.name = name
    if (game_type !== undefined) updateData.game_type = game_type
    if (min_participants !== undefined) updateData.min_participants = min_participants
    if (max_participants !== undefined) updateData.max_participants = max_participants
    if (price_per_person !== undefined) updateData.price_per_person = price_per_person
    if (room_id !== undefined) updateData.room_id = room_id || null
    if (priority !== undefined) updateData.priority = priority
    if (is_active !== undefined) updateData.is_active = is_active

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: formula, error } = await (supabase as any)
      .from('icount_event_formulas')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      console.error('[API icount-event-formulas] Error updating formula:', error)
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    // Handle product price sync when price_per_person changes
    let productSyncResult = null
    const priceChanged = price_per_person !== undefined && price_per_person !== existingFormula.price_per_person
    const tierChanged = (
      (game_type !== undefined && game_type !== existingFormula.game_type) ||
      (min_participants !== undefined && min_participants !== existingFormula.min_participants) ||
      (max_participants !== undefined && max_participants !== existingFormula.max_participants)
    )

    if (formula.product_id && priceChanged && !tierChanged) {
      // Just update the price on the existing linked product
      console.log('[API icount-event-formulas] Updating product price:', formula.product_id, price_per_person)
      productSyncResult = await updateEventProductPrice(
        formula.product_id,
        price_per_person,
        formula.branch_id
      )
    } else if (tierChanged || !formula.product_id) {
      // Tier changed or no product linked - need to ensure correct product exists
      console.log('[API icount-event-formulas] Tier changed or no product, ensuring product exists')
      const productResult = await ensureEventProductForFormula({
        id: formula.id,
        branch_id: formula.branch_id,
        name: formula.name,
        game_type: formula.game_type,
        min_participants: formula.min_participants,
        max_participants: formula.max_participants,
        price_per_person: formula.price_per_person,
      })

      if (productResult.success && productResult.productId && productResult.productId !== formula.product_id) {
        // Link new product to formula
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        await (supabase as any)
          .from('icount_event_formulas')
          .update({ product_id: productResult.productId })
          .eq('id', formula.id)

        formula.product_id = productResult.productId
        console.log('[API icount-event-formulas] Linked new product:', productResult.productCode)
      }
      productSyncResult = productResult
    }

    return NextResponse.json({
      success: true,
      data: formula,
      productSync: productSyncResult,
    })
  } catch (error) {
    console.error('[API icount-event-formulas] PUT error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/icount-event-formulas/[id]
 */
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // Vérifier que la formule existe
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: existingFormula, error: fetchError } = await (supabase as any)
      .from('icount_event_formulas')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !existingFormula) {
      return NextResponse.json(
        { success: false, error: 'Formula not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(existingFormula.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // Hard delete ou soft delete
    const hardDelete = request.nextUrl.searchParams.get('hard') === 'true'

    // Delete or deactivate the associated product first
    let productDeleted = false
    if (existingFormula.product_id) {
      console.log('[API icount-event-formulas] Deleting associated product:', existingFormula.product_id)
      const deleteResult = await deleteEventProduct(existingFormula.product_id, existingFormula.branch_id)
      productDeleted = deleteResult.success
      if (!deleteResult.success) {
        console.warn('[API icount-event-formulas] Failed to delete product:', deleteResult.error)
      }
    }

    if (hardDelete) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_event_formulas')
        .delete()
        .eq('id', id)

      if (error) {
        console.error('[API icount-event-formulas] Error deleting formula:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    } else {
      // Soft delete
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error } = await (supabase as any)
        .from('icount_event_formulas')
        .update({ is_active: false, product_id: null, updated_at: new Date().toISOString() })
        .eq('id', id)

      if (error) {
        console.error('[API icount-event-formulas] Error deactivating formula:', error)
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 500 }
        )
      }
    }

    return NextResponse.json({
      success: true,
      message: hardDelete ? 'Formula deleted' : 'Formula deactivated',
      productDeleted,
    })
  } catch (error) {
    console.error('[API icount-event-formulas] DELETE error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-event-formulas/route.ts">
/**
 * API Route pour gérer les formules EVENT iCount
 * GET: Liste des formules
 * POST: Créer une formule
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { ensureEventProductForFormula } from '@/lib/icount-sync'

export interface ICountEventFormula {
  id: string
  branch_id: string
  name: string
  game_type: 'LASER' | 'ACTIVE' | 'BOTH'
  min_participants: number
  max_participants: number
  price_per_person: number
  room_id: string | null
  is_active: boolean
  priority: number
  product_id: string | null
  created_at: string
  updated_at: string
}

/**
 * GET /api/icount-event-formulas
 * Liste des formules EVENT pour une branche
 */
export async function GET(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { searchParams } = new URL(request.url)
    const branchId = searchParams.get('branchId')
    const includeInactive = searchParams.get('includeInactive') === 'true'
    const gameType = searchParams.get('gameType') // Filter by game_type

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branchId is required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let query = (supabase as any)
      .from('icount_event_formulas')
      .select('*')
      .eq('branch_id', branchId)
      .order('priority', { ascending: false })
      .order('min_participants', { ascending: true })

    if (!includeInactive) {
      query = query.eq('is_active', true)
    }

    if (gameType) {
      query = query.eq('game_type', gameType)
    }

    const { data: formulas, error } = await query

    if (error) {
      console.error('[API icount-event-formulas] Error fetching formulas:', error)
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      data: formulas || [],
    })
  } catch (error) {
    console.error('[API icount-event-formulas] GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/icount-event-formulas
 * Créer une nouvelle formule EVENT
 */
export async function POST(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const body = await request.json()
    const {
      branch_id,
      name,
      game_type,
      min_participants,
      max_participants,
      price_per_person,
      room_id,
      priority,
      is_active,
    } = body

    if (!branch_id || !name || !game_type || price_per_person === undefined) {
      return NextResponse.json(
        { success: false, error: 'branch_id, name, game_type and price_per_person are required' },
        { status: 400 }
      )
    }

    // Valider game_type
    if (!['LASER', 'ACTIVE', 'BOTH'].includes(game_type)) {
      return NextResponse.json(
        { success: false, error: 'game_type must be LASER, ACTIVE or BOTH' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    const supabase = createServiceRoleClient()

    // Validate participant ranges don't overlap with existing formulas
    const newMin = min_participants ?? 1
    const newMax = max_participants ?? 999

    if (newMin > newMax) {
      return NextResponse.json(
        { success: false, error: 'min_participants cannot be greater than max_participants' },
        { status: 400 }
      )
    }

    // Check for overlapping ranges with same game_type (or BOTH)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: existingFormulas } = await (supabase as any)
      .from('icount_event_formulas')
      .select('id, name, game_type, min_participants, max_participants')
      .eq('branch_id', branch_id)
      .eq('is_active', true)

    if (existingFormulas) {
      for (const existing of existingFormulas) {
        // Each game_type creates a separate product, so only check same game_type
        // LASER, ACTIVE, and BOTH are 3 different product types
        if (game_type === existing.game_type) {
          // Check if participant ranges overlap
          // Two ranges [a,b] and [c,d] overlap if a <= d AND c <= b
          const rangesOverlap = newMin <= existing.max_participants && existing.min_participants <= newMax

          if (rangesOverlap) {
            return NextResponse.json(
              {
                success: false,
                error: `Range ${newMin}-${newMax} overlaps with existing ${game_type} formula "${existing.name}" (${existing.min_participants}-${existing.max_participants})`
              },
              { status: 400 }
            )
          }
        }
      }
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: formula, error } = await (supabase as any)
      .from('icount_event_formulas')
      .insert({
        branch_id,
        name,
        game_type,
        min_participants: min_participants ?? 1,
        max_participants: max_participants ?? 999,
        price_per_person,
        room_id: room_id || null,
        priority: priority ?? 0,
        is_active: is_active ?? true,
      })
      .select()
      .single()

    if (error) {
      console.error('[API icount-event-formulas] Error creating formula:', error)
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    // Auto-create/link product for this formula
    const productResult = await ensureEventProductForFormula({
      id: formula.id,
      branch_id: formula.branch_id,
      name: formula.name,
      game_type: formula.game_type,
      min_participants: formula.min_participants,
      max_participants: formula.max_participants,
      price_per_person: formula.price_per_person,
    })

    if (productResult.success && productResult.productId) {
      // Link product to formula
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error: linkError } = await (supabase as any)
        .from('icount_event_formulas')
        .update({ product_id: productResult.productId })
        .eq('id', formula.id)

      if (linkError) {
        console.warn('[API icount-event-formulas] Failed to link product to formula:', linkError)
      } else {
        formula.product_id = productResult.productId
        console.log('[API icount-event-formulas] Linked product:', productResult.productCode, 'to formula:', formula.id)
      }
    }

    return NextResponse.json({
      success: true,
      data: formula,
      product: productResult.success ? {
        id: productResult.productId,
        code: productResult.productCode,
        created: productResult.created,
      } : null,
    })
  } catch (error) {
    console.error('[API icount-event-formulas] POST error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/icount-products/sync/route.ts">
/**
 * API Route pour synchroniser tous les produits avec iCount
 * POST: Synchronise tous les produits actifs de la branche avec iCount
 */

import { NextRequest, NextResponse } from 'next/server'
import { verifyApiPermission } from '@/lib/permissions'
import { syncAllProductsToICount } from '@/lib/icount-sync'

/**
 * POST /api/icount-products/sync
 * Synchronise tous les produits de la branche avec iCount
 */
export async function POST(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('settings', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const body = await request.json()
    const { branch_id } = body

    if (!branch_id) {
      return NextResponse.json(
        { success: false, error: 'branch_id is required' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    console.log('[API icount-products/sync] Syncing all products for branch:', branch_id)

    // Sync all products
    const result = await syncAllProductsToICount(branch_id)

    return NextResponse.json({
      success: result.success,
      synced: result.synced,
      deleted: result.deleted,
      failed: result.failed,
      errors: result.errors,
    })
  } catch (error) {
    console.error('[API icount-products/sync] Error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/authorize-card/route.ts">
/**
 * API Route pour pré-autoriser une carte (J5 / empreinte)
 * POST: Créer une pré-autorisation sans débiter
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logOrderAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { getPaymentProvider } from '@/lib/payment-provider'
import type { UserRole } from '@/lib/supabase/types'

interface AuthorizeCardRequest {
  amount: number
  cardInfo: {
    cc_number: string
    cc_validity: string
    cc_cvv: string
    cc_holder_id: string
    cc_holder_name?: string
  }
  // Optionally store the card for future use
  storeCard?: boolean
}

/**
 * POST /api/orders/[id]/authorize-card
 * Create a J5 preauthorization (card imprint)
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body: AuthorizeCardRequest = await request.json()
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Validation
    if (!body.amount || body.amount < 5) {
      return NextResponse.json(
        { success: false, error: 'Amount must be at least 5 ILS for J5 preauthorization' },
        { status: 400 }
      )
    }

    if (!body.cardInfo || !body.cardInfo.cc_number || !body.cardInfo.cc_validity || !body.cardInfo.cc_cvv || !body.cardInfo.cc_holder_id) {
      return NextResponse.json(
        { success: false, error: 'Complete card information required' },
        { status: 400 }
      )
    }

    // Get order
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    // Verify branch access
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied' },
          { status: 403 }
        )
      }
    }

    // Block if order is closed
    if (order.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Cannot authorize card on a closed order', messageKey: 'errors.orderClosed' },
        { status: 400 }
      )
    }

    // Get payment provider
    const provider = await getPaymentProvider(order.branch_id)
    if (!provider) {
      return NextResponse.json(
        { success: false, error: 'Payment provider not configured' },
        { status: 500 }
      )
    }

    // Create J5 preauthorization
    const j5Result = await provider.creditCard.createJ5Preapproval({
      cardInfo: body.cardInfo,
      amount: body.amount,
      currencyCode: 'ILS',
    })

    if (!j5Result.success || !j5Result.data) {
      return NextResponse.json(
        {
          success: false,
          error: j5Result.error?.message || 'Card authorization failed',
          errorCode: j5Result.error?.code,
        },
        { status: 400 }
      )
    }

    // Optionally store the card for future use
    let storedCardTokenId: number | undefined
    if (body.storeCard && order.contact_id) {
      const storeResult = await provider.creditCard.storeCard({
        customClientId: order.contact_id,
        email: order.customer_email || undefined,
        clientName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
        cardInfo: body.cardInfo,
      })

      if (storeResult.success && storeResult.data) {
        storedCardTokenId = storeResult.data.token_id

        // Update contact with stored card info
        await supabase
          .from('contacts')
          .update({
            icount_cc_token_id: storedCardTokenId,
            cc_last4: storeResult.data.cc_last4,
            cc_type: storeResult.data.cc_type,
            cc_validity: storeResult.data.cc_validity,
            cc_holder_name: body.cardInfo.cc_holder_name,
          })
          .eq('id', order.contact_id)
      }
    }

    // Update order with J5 info
    await supabase
      .from('orders')
      .update({
        payment_status: 'card_authorized',
        icount_j5_code: j5Result.data.confirmation_code,
        cc_last4: j5Result.data.cc_last4,
        cc_type: j5Result.data.cc_type,
        total_amount: order.total_amount || body.amount,
      })
      .eq('id', id)

    // Log the action
    await logOrderAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'updated',
      orderId: id,
      orderRef: order.request_reference,
      branchId: order.branch_id,
      details: {
        cardAuthorized: true,
        amount: body.amount,
        ccLast4: j5Result.data.cc_last4,
        ccType: j5Result.data.cc_type,
        cardStored: !!storedCardTokenId,
      },
      ipAddress,
    })

    return NextResponse.json({
      success: true,
      authorization: {
        confirmationCode: j5Result.data.confirmation_code,
        amount: body.amount,
        ccLast4: j5Result.data.cc_last4,
        ccType: j5Result.data.cc_type,
      },
      cardStored: !!storedCardTokenId,
      message: 'Card authorized successfully. Amount will not be charged until payment is processed.',
    })

  } catch (error) {
    console.error('Error authorizing card:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/close/route.ts">
/**
 * API Route pour clôturer une commande
 * POST: Clôturer la commande et créer une facture+reçu du montant CB prélevé
 *
 * Workflow simplifié:
 * - Pas de devis iCount à annuler (plus de création de devis)
 * - Création d'une facture+reçu simple avec le total des paiements CB
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logOrderAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { getPaymentProvider } from '@/lib/payment-provider'
import type { UserRole } from '@/lib/supabase/types'

interface Payment {
  id: string
  amount: number
  payment_method: 'card' | 'cash' | 'transfer' | 'check'
  payment_type: string
  created_at: string
  icount_confirmation_code?: string
  cc_last4?: string
  cc_type?: string
  check_number?: string
  check_bank?: string
  check_date?: string
  transfer_reference?: string
}

/**
 * POST /api/orders/[id]/close
 * Clôturer une commande : créer une facture+reçu du montant prélevé par CB
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    console.log('[CLOSE ORDER API] Received request for orderId:', id)

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer la commande avec les paiements et le booking
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select(`
        *,
        payments(*),
        booking:bookings(
          id,
          reference_code,
          type
        )
      `)
      .eq('id', id)
      .single()

    if (orderError || !order) {
      console.log('[CLOSE ORDER API] Order not found. Error:', orderError, 'ID was:', id)
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    // Vérifier que la commande n'est pas déjà clôturée ou annulée
    if (order.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Order already closed' },
        { status: 400 }
      )
    }

    if (order.status === 'cancelled') {
      return NextResponse.json(
        { success: false, error: 'Cannot close a cancelled order' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied' },
          { status: 403 }
        )
      }
    }

    // Calculer les totaux par méthode de paiement
    const payments: Payment[] = order.payments || []
    const cardPayments = payments.filter((p: Payment) => p.payment_method === 'card')
    const cashPayments = payments.filter((p: Payment) => p.payment_method === 'cash')
    const totalCardAmount = cardPayments.reduce((sum: number, p: Payment) => sum + (p.amount || 0), 0)
    const totalCashAmount = cashPayments.reduce((sum: number, p: Payment) => sum + (p.amount || 0), 0)
    const totalPaidAmount = totalCardAmount + totalCashAmount

    // Récupérer le provider de paiement pour iCount
    const provider = await getPaymentProvider(order.branch_id)

    let icountInvrecId: number | undefined
    let icountInvrecUrl: string | undefined

    // Si on a des paiements, créer une facture+reçu
    if (totalPaidAmount > 0 && provider) {
      // Déterminer le type de jeu pour la description
      const bookingType = order.booking?.type || order.order_type || 'GAME'
      let gameDescription: string

      if (bookingType === 'EVENT') {
        gameDescription = 'אירוע פרטי - Active Games & Laser City'
      } else {
        // Pour les GAME, on peut avoir LASER, ACTIVE ou les deux
        gameDescription = 'משחקים - Active Games & Laser City'
      }

      // Préparer les paramètres de la facture+reçu
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const invrecParams: any = {
        custom_client_id: order.contact_id,
        client_name: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
        email: order.customer_email,
        phone: order.customer_phone,
        items: [{
          description: gameDescription,
          quantity: 1,
          unitprice_incvat: totalPaidAmount,
        }],
        sanity_string: `close-${id}`.slice(0, 30),
        doc_title: `חשבונית ${order.request_reference}`,
        doc_lang: 'he',
      }

      // Ajouter les paiements CB avec l'objet cc natif iCount
      // On prend le dernier paiement CB comme référence pour les détails
      if (totalCardAmount > 0 && cardPayments.length > 0) {
        const lastCardPayment = cardPayments[cardPayments.length - 1]
        invrecParams.cc = {
          sum: totalCardAmount,
          card_type: lastCardPayment.cc_type || 'VISA',
          card_number: lastCardPayment.cc_last4 || '0000',
          confirmation_code: lastCardPayment.icount_confirmation_code || '',
          num_of_payments: 1,
        }

        // Si plusieurs paiements CB, ajouter les détails en commentaire
        if (cardPayments.length > 1) {
          const paymentDetails = cardPayments.map((p: Payment) => {
            const date = new Date(p.created_at).toLocaleDateString('he-IL')
            const confirmCode = p.icount_confirmation_code ? ` (${p.icount_confirmation_code})` : ''
            const last4 = p.cc_last4 ? ` ****${p.cc_last4}` : ''
            return `${date}: ₪${p.amount}${last4}${confirmCode}`
          }).join('\n')
          invrecParams.hwc = `פירוט תשלומי אשראי:\n${paymentDetails}`
        }
      }

      // Ajouter les paiements en espèces avec l'objet cash natif iCount
      if (totalCashAmount > 0) {
        invrecParams.cash = {
          sum: totalCashAmount,
        }
      }

      // Créer la facture+reçu dans iCount
      // Le client sera créé/mis à jour automatiquement par iCount avec custom_client_id
      const invrecResult = await provider.documents.createInvoiceReceipt(invrecParams)

      if (invrecResult.success && invrecResult.data) {
        icountInvrecId = invrecResult.data.docnum
        icountInvrecUrl = invrecResult.data.doc_url
        console.log('[CLOSE ORDER] InvRec created:', icountInvrecId)
      } else {
        console.error('[CLOSE ORDER] Failed to create invrec:', invrecResult.error)
        // On continue quand même - la clôture est plus importante que le document iCount
      }
    }

    // Mettre à jour la commande
    // Note: Si les colonnes closed_at, closed_by, icount_invrec_id n'existent pas,
    // on fait juste l'update du status qui est le minimum requis
    const updateData: Record<string, unknown> = {
      status: 'closed',
    }

    // Essayer d'ajouter les colonnes optionnelles (peuvent ne pas exister si migration non appliquée)
    try {
      updateData.closed_at = new Date().toISOString()
      updateData.closed_by = user.id
      if (icountInvrecId) {
        updateData.icount_invrec_id = icountInvrecId
        updateData.icount_invrec_url = icountInvrecUrl
      }
    } catch {
      // Colonnes peuvent ne pas exister
    }

    const { error: updateError } = await supabase
      .from('orders')
      .update(updateData)
      .eq('id', id)

    if (updateError) {
      console.error('[CLOSE ORDER] Failed to update order status:', updateError)
      // Si l'erreur est liée aux colonnes manquantes, essayer avec juste le status
      if (updateError.message?.includes('column')) {
        const { error: fallbackError } = await supabase
          .from('orders')
          .update({ status: 'closed' })
          .eq('id', id)

        if (fallbackError) {
          console.error('[CLOSE ORDER] Fallback update also failed:', fallbackError)
          return NextResponse.json(
            { success: false, error: 'Failed to update order status' },
            { status: 500 }
          )
        }
      } else {
        return NextResponse.json(
          { success: false, error: 'Failed to update order status' },
          { status: 500 }
        )
      }
    }

    console.log('[CLOSE ORDER] Order status updated to closed for:', id)

    // Logger l'action
    await logOrderAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'updated',
      orderId: id,
      orderRef: order.request_reference,
      branchId: order.branch_id,
      details: {
        orderClosed: true,
        totalCardAmount,
        totalCashAmount,
        totalPaidAmount,
        icountInvrecId,
      },
      ipAddress,
    })

    return NextResponse.json({
      success: true,
      message: 'Order closed successfully',
      data: {
        status: 'closed',
        totalCardAmount,
        totalCashAmount,
        totalPaidAmount,
        icountInvrecId,
        icountInvrecUrl,
      },
    })

  } catch (error) {
    console.error('Error closing order:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/preauth/route.ts">
/**
 * API Route pour gérer les pré-autorisations (J5) d'une commande
 * POST: Créer une pré-autorisation
 * DELETE: Annuler/libérer une pré-autorisation
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logOrderAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { getPaymentProvider } from '@/lib/payment-provider'
import type { UserRole } from '@/lib/supabase/types'

interface PreauthRequest {
  amount: number
  cardInfo: {
    cc_number: string
    cc_validity: string
    cc_cvv: string
    cc_holder_id: string
    cc_holder_name?: string
  }
  saveCard?: boolean // Optionnel: sauvegarder aussi la carte
}

/**
 * POST /api/orders/[id]/preauth
 * Créer une pré-autorisation (J5)
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body: PreauthRequest = await request.json()
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Validation de base
    if (!body.amount || body.amount < 5) {
      return NextResponse.json(
        { success: false, error: 'Minimum amount for preauthorization is 5₪' },
        { status: 400 }
      )
    }

    if (!body.cardInfo) {
      return NextResponse.json(
        { success: false, error: 'Card info required' },
        { status: 400 }
      )
    }

    // Récupérer la commande
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied' },
          { status: 403 }
        )
      }
    }

    // BLOQUER si la commande est fermée
    if (order.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Cannot create preauth on a closed order', messageKey: 'errors.orderClosed' },
        { status: 400 }
      )
    }

    // Récupérer le provider de paiement
    const provider = await getPaymentProvider(order.branch_id)
    if (!provider) {
      return NextResponse.json(
        { success: false, error: 'Payment provider not configured' },
        { status: 500 }
      )
    }

    // Créer la pré-autorisation via iCount J5
    console.log('[PREAUTH] Creating J5 preapproval:', {
      amount: body.amount,
      hasCardInfo: !!body.cardInfo,
      ccLast4: body.cardInfo?.cc_number?.slice(-4),
      ccValidity: body.cardInfo?.cc_validity,
      ccValidityLength: body.cardInfo?.cc_validity?.length,
    })

    const j5Result = await provider.creditCard.createJ5Preapproval({
      cardInfo: body.cardInfo,
      amount: body.amount,
      currencyCode: 'ILS',
    })

    console.log('[PREAUTH] J5 result:', JSON.stringify(j5Result, null, 2))

    if (!j5Result.success || !j5Result.data) {
      console.log('[PREAUTH] Failed:', j5Result.error)
      return NextResponse.json(
        {
          success: false,
          error: j5Result.error?.message || 'Preauthorization failed',
          errorCode: j5Result.error?.code,
        },
        { status: 400 }
      )
    }

    // Stocker la pré-autorisation dans la commande
    const updateData: Record<string, unknown> = {
      preauth_code: j5Result.data.confirmation_code,
      preauth_amount: body.amount,
      preauth_cc_last4: j5Result.data.cc_last4,
      preauth_cc_type: j5Result.data.cc_type,
      preauth_created_at: new Date().toISOString(),
      preauth_created_by: user.id,
    }

    // Optionnel: sauvegarder la carte pour utilisation future
    let tokenId: number | undefined
    if (body.saveCard && order.contact_id) {
      try {
        const storeResult = await provider.creditCard.storeCard({
          customClientId: order.contact_id,
          email: order.customer_email || undefined,
          clientName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
          cardInfo: body.cardInfo,
        })

        if (storeResult.success && storeResult.data) {
          tokenId = storeResult.data.token_id

          // Mettre à jour le contact avec les infos de carte
          await supabase
            .from('contacts')
            .update({
              icount_cc_token_id: storeResult.data.token_id,
              cc_last4: storeResult.data.cc_last4,
              cc_type: storeResult.data.cc_type,
              cc_expiry: storeResult.data.cc_validity,
            })
            .eq('id', order.contact_id)
        }
      } catch (storeError) {
        // Log l'erreur mais ne pas faire échouer la pré-autorisation
        console.error('Error storing card:', storeError)
      }
    }

    await supabase
      .from('orders')
      .update(updateData)
      .eq('id', id)

    // Logger l'action
    await logOrderAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'updated',
      orderId: id,
      orderRef: order.request_reference,
      branchId: order.branch_id,
      details: {
        preauthCreated: true,
        amount: body.amount,
        confirmationCode: j5Result.data.confirmation_code,
        ccLast4: j5Result.data.cc_last4,
      },
      ipAddress,
    })

    return NextResponse.json({
      success: true,
      preauth: {
        confirmationCode: j5Result.data.confirmation_code,
        transactionId: j5Result.data.transaction_id,
        amount: body.amount,
        ccLast4: j5Result.data.cc_last4,
        ccType: j5Result.data.cc_type,
        tokenId, // Retourné si la carte a été sauvegardée
      },
    })

  } catch (error) {
    console.error('Error creating preauthorization:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * GET /api/orders/[id]/preauth
 * Récupérer la pré-autorisation existante
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: order, error: orderError } = await (supabase as any)
      .from('orders')
      .select('preauth_code, preauth_amount, preauth_cc_last4, preauth_cc_type, preauth_created_at')
      .eq('id', id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    if (!order.preauth_code) {
      return NextResponse.json({
        success: true,
        preauth: null,
      })
    }

    return NextResponse.json({
      success: true,
      preauth: {
        code: order.preauth_code,
        amount: order.preauth_amount,
        ccLast4: order.preauth_cc_last4,
        ccType: order.preauth_cc_type,
        createdAt: order.preauth_created_at,
      },
    })

  } catch (error) {
    console.error('Error fetching preauthorization:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/orders/[id]/preauth
 * Supprimer/libérer la pré-autorisation (elle expire naturellement mais on peut la marquer comme annulée)
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer la commande
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*, preauth_code, preauth_amount')
      .eq('id', id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    if (!order.preauth_code) {
      return NextResponse.json(
        { success: false, error: 'No preauthorization to cancel' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied' },
          { status: 403 }
        )
      }
    }

    // BLOQUER si la commande est fermée
    if (order.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Cannot cancel preauth on a closed order', messageKey: 'errors.orderClosed' },
        { status: 400 }
      )
    }

    // Supprimer la pré-autorisation de la commande
    // Note: La pré-autorisation J5 dans iCount expire naturellement après quelques jours
    // On la marque simplement comme annulée dans notre système
    await supabase
      .from('orders')
      .update({
        preauth_code: null,
        preauth_amount: null,
        preauth_cc_last4: null,
        preauth_cc_type: null,
        preauth_created_at: null,
        preauth_created_by: null,
        preauth_cancelled_at: new Date().toISOString(),
        preauth_cancelled_by: user.id,
      })
      .eq('id', id)

    // Logger l'action
    await logOrderAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'updated',
      orderId: id,
      orderRef: order.request_reference,
      branchId: order.branch_id,
      details: {
        preauthCancelled: true,
        previousAmount: order.preauth_amount,
      },
      ipAddress,
    })

    return NextResponse.json({
      success: true,
      message: 'Preauthorization cancelled',
    })

  } catch (error) {
    console.error('Error cancelling preauthorization:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/resend-cgv/route.ts">
/**
 * API Route pour renvoyer un rappel CGV pour une commande admin
 * POST: Envoie un email de rappel CGV au client
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { verifyApiPermission } from '@/lib/permissions'
import { sendEmail } from '@/lib/email-sender'
import type { Branch } from '@/lib/supabase/types'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: orderId } = await params

    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    // Récupérer la commande
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select(`
        id,
        status,
        request_reference,
        customer_first_name,
        customer_last_name,
        customer_email,
        cgv_token,
        cgv_validated_at,
        cgv_reminder_count,
        requested_date,
        requested_time,
        participants_count,
        source,
        branch_id
      `)
      .eq('id', orderId)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Commande non trouvée' },
        { status: 404 }
      )
    }

    // BLOQUER si la commande est fermée
    if (order.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Cannot resend CGV on a closed order', messageKey: 'errors.orderClosed' },
        { status: 400 }
      )
    }

    // Vérifier que c'est une commande admin
    if (order.source !== 'admin_agenda') {
      return NextResponse.json(
        { success: false, error: 'Cette commande n\'est pas une commande admin' },
        { status: 400 }
      )
    }

    // Vérifier que le client a un email
    if (!order.customer_email) {
      return NextResponse.json(
        { success: false, error: 'Le client n\'a pas d\'adresse email' },
        { status: 400 }
      )
    }

    // Vérifier que les CGV ne sont pas déjà validées
    if (order.cgv_validated_at) {
      return NextResponse.json(
        { success: false, error: 'Les CGV ont déjà été validées' },
        { status: 400 }
      )
    }

    // Vérifier qu'il y a un token CGV
    if (!order.cgv_token) {
      return NextResponse.json(
        { success: false, error: 'Pas de token CGV pour cette commande' },
        { status: 400 }
      )
    }

    // Récupérer la branche
    const { data: branch } = await supabase
      .from('branches')
      .select('*')
      .eq('id', order.branch_id)
      .single()

    const branchData = branch as Branch | null

    // URL de base pour les liens CGV
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://activegames.co.il'
    const cgvUrl = `${baseUrl}/cgv/${order.cgv_token}`
    const reminderNumber = (order.cgv_reminder_count || 0) + 1

    // Générer le HTML du rappel (en hébreu)
    const subject = `[תזכורת] אישור תנאים - הזמנה ${order.request_reference}`

    const html = `
      <!DOCTYPE html>
      <html dir="rtl" lang="he">
      <head>
        <meta charset="utf-8">
      </head>
      <body style="font-family: Arial, sans-serif; background-color: #0a0a1a; margin: 0; padding: 20px; direction: rtl;">
        <div style="max-width: 600px; margin: 0 auto; background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%); border-radius: 16px; overflow: hidden; border: 1px solid rgba(0, 240, 255, 0.2);">

          <!-- Header avec logos -->
          <div style="padding: 30px; text-align: center; background: linear-gradient(135deg, #00f0ff20 0%, transparent 100%);">
            <div style="display: inline-block; margin: 0 10px;">
              <img src="${baseUrl}/images/logo-activegames.png" alt="Active Games" style="height: 50px; width: auto;">
            </div>
            <div style="display: inline-block; margin: 0 10px;">
              <img src="${baseUrl}/images/logo_laser_city.png" alt="Laser City" style="height: 50px; width: auto;">
            </div>
          </div>

          <!-- Contenu principal -->
          <div style="padding: 30px;">
            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; padding: 25px; border: 2px solid #f59e0b; margin-bottom: 25px;">
              <h2 style="color: #92400e; margin: 0 0 15px 0; font-size: 20px;">⚠️ תזכורת: ממתין לאישור תנאים</h2>
              <p style="color: #78350f; margin: 0 0 20px 0; font-size: 15px; line-height: 1.6;">
                שלום ${order.customer_first_name},<br><br>
                אנו מזכירים לך שההזמנה שלך דורשת אישור של תנאי השירות שלנו כדי להשלים את ההזמנה.
              </p>
              <div style="text-align: center;">
                <a href="${cgvUrl}" target="_blank" style="display: inline-block; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: #ffffff; padding: 14px 35px; border-radius: 8px; text-decoration: none; font-weight: bold; font-size: 16px;">
                  אשר תנאים עכשיו
                </a>
              </div>
            </div>

            <!-- Récapitulatif réservation -->
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 20px; border: 1px solid rgba(255, 255, 255, 0.1);">
              <h3 style="color: #00f0ff; margin: 0 0 15px 0; font-size: 16px;">📋 ההזמנה שלך</h3>
              <table style="width: 100%; color: #ffffff; font-size: 14px;">
                <tr>
                  <td style="padding: 8px 0; color: #888;">מספר הזמנה:</td>
                  <td style="padding: 8px 0; font-weight: bold;">${order.request_reference}</td>
                </tr>
                <tr>
                  <td style="padding: 8px 0; color: #888;">תאריך:</td>
                  <td style="padding: 8px 0;">${new Date(order.requested_date).toLocaleDateString('he-IL', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}</td>
                </tr>
                <tr>
                  <td style="padding: 8px 0; color: #888;">שעה:</td>
                  <td style="padding: 8px 0;">${order.requested_time.slice(0, 5)}</td>
                </tr>
                <tr>
                  <td style="padding: 8px 0; color: #888;">משתתפים:</td>
                  <td style="padding: 8px 0;">${order.participants_count} אנשים</td>
                </tr>
              </table>
            </div>
          </div>

          <!-- Footer -->
          <div style="padding: 20px 30px; background: rgba(0, 0, 0, 0.3); text-align: center;">
            <p style="color: #666; font-size: 12px; margin: 0;">
              ${branchData?.name || 'Laser City'} • Active Games World<br>
              תזכורת מס׳ ${reminderNumber}
            </p>
          </div>
        </div>
      </body>
      </html>
    `

    // Envoyer l'email
    const emailResult = await sendEmail({
      to: order.customer_email,
      toName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
      subject,
      html,
      templateCode: 'cgv_reminder_manual',
      entityType: 'order',
      entityId: order.id,
      branchId: order.branch_id,
      triggeredBy: user.id,
      metadata: {
        reminder_number: reminderNumber,
        cgv_token: order.cgv_token,
        manual: true
      }
    })

    if (!emailResult.success) {
      return NextResponse.json(
        { success: false, error: emailResult.error || 'Erreur lors de l\'envoi' },
        { status: 500 }
      )
    }

    // Mettre à jour le compteur de rappels
    await supabase
      .from('orders')
      .update({
        cgv_reminder_sent_at: new Date().toISOString(),
        cgv_reminder_count: reminderNumber,
      })
      .eq('id', order.id)

    return NextResponse.json({
      success: true,
      message: 'Rappel CGV envoyé avec succès',
      emailLogId: emailResult.emailLogId
    })

  } catch (error) {
    console.error('[RESEND-CGV] Error:', error)
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/send-invoice/route.ts">
/**
 * API Route: /api/orders/[id]/send-invoice
 *
 * POST: Envoyer la facture iCount par email au client
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyApiPermission } from '@/lib/permissions'
import { sendEmail } from '@/lib/email-sender'
import type { Order, Branch } from '@/lib/supabase/types'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const permCheck = await verifyApiPermission('orders', 'edit')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const user = permCheck.user!
  const { id: orderId } = await params
  const supabase = await createClient()

  // Récupérer la commande avec la branche
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select(`
      *,
      branch:branches(*)
    `)
    .eq('id', orderId)
    .single<Order & { branch: Branch | null }>()

  if (orderError || !order) {
    return NextResponse.json(
      { success: false, error: 'Order not found' },
      { status: 404 }
    )
  }

  // Vérifier l'accès à la branche
  if (user.role !== 'super_admin' && !user.branchIds.includes(order.branch_id!)) {
    return NextResponse.json(
      { success: false, error: 'Access denied' },
      { status: 403 }
    )
  }

  // Vérifier que la commande a un email
  if (!order.customer_email) {
    return NextResponse.json(
      { success: false, error: 'No email address for this order', messageKey: 'admin.invoice.errors.no_email' },
      { status: 400 }
    )
  }

  // Vérifier que la commande est fermée et a une facture
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const orderAny = order as any
  if (order.status !== 'closed') {
    return NextResponse.json(
      { success: false, error: 'Order must be closed to send invoice', messageKey: 'admin.invoice.errors.not_closed' },
      { status: 400 }
    )
  }

  if (!orderAny.icount_invrec_url) {
    return NextResponse.json(
      { success: false, error: 'No invoice available for this order', messageKey: 'admin.invoice.errors.no_invoice' },
      { status: 400 }
    )
  }

  try {
    const invoiceUrl = orderAny.icount_invrec_url as string
    const customerName = `${order.customer_first_name || ''} ${order.customer_last_name || ''}`.trim() || 'לקוח יקר'
    const orderRef = order.request_reference || ''
    const branchName = order.branch?.name || 'Active Games'
    const branchPhone = order.branch?.phone || ''
    const branchAddress = order.branch?.address || ''
    const currentYear = new Date().getFullYear()
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://activegames.co.il'
    const logoActivegamesUrl = `${baseUrl}/images/logo-activegames.png`
    const logoLasercityUrl = `${baseUrl}/images/logo_laser_city.png`

    // Récupérer la langue préférée du contact si disponible
    let locale: 'he' | 'fr' | 'en' = 'he'
    if (order.contact_id) {
      const { data: contactData } = await supabase
        .from('contacts')
        .select('preferred_locale')
        .eq('id', order.contact_id)
        .single<{ preferred_locale: string | null }>()
      if (contactData?.preferred_locale) {
        locale = contactData.preferred_locale as 'he' | 'fr' | 'en'
      }
    }

    // Construire l'email selon la langue avec le design Active Games
    let subject: string
    let htmlContent: string

    // Template de base avec le branding Active Games (couleurs: fond #1a1a2e, carte #252540, accent #00f0ff)
    const generateInvoiceEmail = (
      lang: 'he' | 'fr' | 'en',
      texts: {
        title: string
        greeting: string
        thankYou: string
        invoiceText: string
        viewInvoice: string
        questions: string
        regards: string
        footerThank: string
        footerRights: string
      }
    ) => {
      const isRTL = lang === 'he'
      return `<!DOCTYPE html>
<html lang="${lang}"${isRTL ? ' dir="rtl"' : ''}>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${texts.title}</title>
</head>
<body style="margin: 0; padding: 0; background-color: #1a1a2e; font-family: Segoe UI, Tahoma, Geneva, Verdana, sans-serif;${isRTL ? ' direction: rtl;' : ''}">
  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background-color: #1a1a2e;">
    <tr>
      <td align="center" style="padding: 40px 20px;">
        <table role="presentation" width="600" cellspacing="0" cellpadding="0" style="background-color: #252540; border-radius: 16px; overflow: hidden; border: 2px solid rgba(0, 240, 255, 0.3); box-shadow: 0 0 30px rgba(0, 240, 255, 0.2);">

          <!-- Header with logos -->
          <tr>
            <td style="background: linear-gradient(135deg, #1a1a2e 0%, #252540 100%); padding: 30px; text-align: center; border-bottom: 1px solid rgba(0, 240, 255, 0.2);">
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0">
                <tr>
                  <td style="text-align: center;">
                    <img src="${logoActivegamesUrl}" alt="ActiveGames" style="max-height: 50px; margin: 0 15px;" />
                    <img src="${logoLasercityUrl}" alt="Laser City" style="max-height: 50px; margin: 0 15px;" />
                  </td>
                </tr>
              </table>
            </td>
          </tr>

          <!-- Main content -->
          <tr>
            <td style="padding: 40px 30px;">
              <!-- Invoice icon -->
              <div style="text-align: center; margin-bottom: 25px;">
                <div style="display: inline-block; background-color: rgba(0, 240, 255, 0.15); border-radius: 50%; width: 80px; height: 80px; line-height: 80px;">
                  <span style="font-size: 40px; color: #00f0ff;">📄</span>
                </div>
              </div>

              <h1 style="color: #00f0ff; font-size: 28px; margin: 0 0 10px 0; text-align: center; font-weight: bold; letter-spacing: 2px;">
                ${texts.title}
              </h1>

              <p style="color: #a0a0b0; font-size: 16px; line-height: 1.6; margin: 0 0 30px 0; text-align: center;">
                ${texts.greeting.replace('{name}', customerName)}
              </p>

              <!-- Order reference -->
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="margin-bottom: 25px;">
                <tr>
                  <td style="background-color: rgba(0, 240, 255, 0.1); border: 1px solid rgba(0, 240, 255, 0.3); border-radius: 12px; padding: 20px; text-align: center;">
                    <p style="color: #a0a0b0; font-size: 14px; margin: 0 0 8px 0;">${texts.invoiceText}</p>
                    <p style="color: #00f0ff; font-size: 28px; font-weight: bold; margin: 0; letter-spacing: 3px;">${orderRef}</p>
                  </td>
                </tr>
              </table>

              <!-- Thank you message -->
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background-color: rgba(30, 30, 50, 0.5); border-radius: 12px; border: 1px solid rgba(0, 240, 255, 0.2); margin-bottom: 25px;">
                <tr>
                  <td style="padding: 25px; text-align: center;">
                    <p style="color: #ffffff; font-size: 16px; margin: 0; line-height: 1.6;">
                      ${texts.thankYou.replace('{branch}', branchName)}
                    </p>
                  </td>
                </tr>
              </table>

              <!-- View Invoice Button -->
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="margin-bottom: 25px;">
                <tr>
                  <td style="text-align: center; padding: 10px 0;">
                    <a href="${invoiceUrl}" target="_blank" style="display: inline-block; background: linear-gradient(135deg, #00f0ff 0%, #00c4cc 100%); color: #1a1a2e; padding: 16px 40px; border-radius: 12px; text-decoration: none; font-weight: bold; font-size: 16px; letter-spacing: 1px; box-shadow: 0 4px 15px rgba(0, 240, 255, 0.4);">
                      ${texts.viewInvoice}
                    </a>
                  </td>
                </tr>
              </table>

              <!-- Branch info -->
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background-color: rgba(0, 240, 255, 0.08); border-radius: 12px; border: 1px solid rgba(0, 240, 255, 0.2); margin-bottom: 25px;">
                <tr>
                  <td style="padding: 20px;">
                    <p style="color: #00f0ff; font-size: 16px; font-weight: bold; margin: 0 0 10px 0;">
                      📍 ${branchName}
                    </p>
                    ${branchAddress ? `<p style="color: #ffffff; margin: 0 0 10px 0; line-height: 1.5;">${branchAddress}</p>` : ''}
                    ${branchPhone ? `<p style="color: #00f0ff; margin: 0;">📞 ${branchPhone}</p>` : ''}
                  </td>
                </tr>
              </table>

              <!-- Contact note -->
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background-color: rgba(30, 30, 50, 0.5); border-radius: 12px; border: 1px solid rgba(0, 240, 255, 0.2);">
                <tr>
                  <td style="padding: 20px; text-align: center;">
                    <p style="color: #a0a0b0; font-size: 14px; margin: 0;">
                      ${texts.questions}
                    </p>
                  </td>
                </tr>
              </table>
            </td>
          </tr>

          <!-- Footer -->
          <tr>
            <td style="background-color: #1a1a2e; padding: 25px 30px; text-align: center; border-top: 1px solid rgba(0, 240, 255, 0.2);">
              <p style="color: #a0a0b0; margin: 0 0 10px 0; font-size: 14px;">
                ${texts.footerThank}
              </p>
              <p style="color: #606070; margin: 0; font-size: 12px;">
                © ${currentYear} ActiveGames. ${texts.footerRights}
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`
    }

    if (locale === 'he') {
      subject = `חשבונית עבור הזמנה ${orderRef} - ${branchName}`
      htmlContent = generateInvoiceEmail('he', {
        title: 'החשבונית שלך',
        greeting: 'שלום {name},',
        thankYou: 'תודה שביקרתם אצלנו ב-{branch}!',
        invoiceText: 'חשבונית להזמנה מספר',
        viewInvoice: 'צפייה בחשבונית',
        questions: 'לשאלות או בירורים, אנחנו כאן לשירותכם.',
        regards: 'בברכה',
        footerThank: 'תודה שבחרתם ב-ActiveGames!',
        footerRights: 'כל הזכויות שמורות.',
      })
    } else if (locale === 'fr') {
      subject = `Facture pour la commande ${orderRef} - ${branchName}`
      htmlContent = generateInvoiceEmail('fr', {
        title: 'Votre Facture',
        greeting: 'Bonjour {name},',
        thankYou: 'Merci de votre visite chez {branch} !',
        invoiceText: 'Facture pour la commande',
        viewInvoice: 'Voir la facture',
        questions: 'Pour toute question, n\'hésitez pas à nous contacter.',
        regards: 'Cordialement',
        footerThank: 'Merci d\'avoir choisi ActiveGames !',
        footerRights: 'Tous droits réservés.',
      })
    } else {
      subject = `Invoice for order ${orderRef} - ${branchName}`
      htmlContent = generateInvoiceEmail('en', {
        title: 'Your Invoice',
        greeting: 'Hello {name},',
        thankYou: 'Thank you for visiting {branch}!',
        invoiceText: 'Invoice for order',
        viewInvoice: 'View Invoice',
        questions: 'If you have any questions, please don\'t hesitate to contact us.',
        regards: 'Best regards',
        footerThank: 'Thank you for choosing ActiveGames!',
        footerRights: 'All rights reserved.',
      })
    }

    // Envoyer l'email
    const result = await sendEmail({
      to: order.customer_email,
      toName: customerName,
      subject,
      html: htmlContent,
      templateCode: 'invoice_email',
      entityType: 'order',
      entityId: orderId,
      branchId: order.branch_id || undefined,
      triggeredBy: user.id,
      metadata: {
        invoiceUrl,
        orderRef,
        locale,
      },
    })

    if (!result.success) {
      return NextResponse.json(
        { success: false, error: result.error || 'Failed to send email', messageKey: 'admin.invoice.errors.send_failed' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      message: 'Invoice sent successfully',
      messageKey: 'admin.invoice.success',
      emailLogId: result.emailLogId,
    })
  } catch (error) {
    console.error('Error sending invoice email:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/roles/[id]/route.ts">
/**
 * API Roles - Gestion individuelle d'un rôle
 *
 * GET /api/roles/[id] - Détails d'un rôle
 * PUT /api/roles/[id] - Modifier un rôle
 * DELETE /api/roles/[id] - Supprimer un rôle
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import type { Role } from '@/lib/supabase/types'

/**
 * GET /api/roles/[id]
 * Récupérer les détails d'un rôle
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const serviceClient = createServiceRoleClient()

    const { data: role, error } = await serviceClient
      .from('roles')
      .select('*')
      .eq('id', id)
      .single()

    if (error || !role) {
      return NextResponse.json(
        { success: false, error: 'Role not found' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      success: true,
      role
    })

  } catch (error) {
    console.error('Error in roles GET API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/roles/[id]
 * Modifier un rôle existant
 * Règles:
 * - Les rôles is_system ne peuvent pas être modifiés
 * - L'utilisateur doit avoir un level < au level du rôle à modifier
 * - Le level ne peut pas être changé vers un level <= userLevel
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const serviceClient = createServiceRoleClient()

    // Récupérer le level de l'utilisateur
    const { data: profileData } = await serviceClient
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (!profileData) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    const profile = profileData as { role?: string | null }

    const { data: userRole } = await serviceClient
      .from('roles')
      .select('level')
      .eq('name', profile.role || '')
      .single<{ level: number }>()

    const userLevel = userRole?.level ?? 10

    // Récupérer le rôle à modifier
    const { data: targetRole, error: roleError } = await serviceClient
      .from('roles')
      .select('*')
      .eq('id', id)
      .single<Role>()

    if (roleError || !targetRole) {
      return NextResponse.json(
        { success: false, error: 'Role not found' },
        { status: 404 }
      )
    }

    // Vérifier que le rôle n'est pas un rôle système
    if (targetRole.is_system) {
      return NextResponse.json(
        { success: false, error: 'System roles cannot be modified' },
        { status: 403 }
      )
    }

    // Vérifier la hiérarchie: l'utilisateur doit avoir un level < au level du rôle
    // Exception: le super_admin (level 1) peut modifier tous les rôles non-système
    if (userLevel !== 1 && userLevel >= targetRole.level) {
      return NextResponse.json(
        { success: false, error: 'You can only modify roles with level greater than yours' },
        { status: 403 }
      )
    }

    // Parser le body
    const body = await request.json()
    const { display_name, description, level, color, icon } = body

    // Construire l'objet de mise à jour
    const updates: Record<string, unknown> = {}

    if (display_name !== undefined) {
      if (typeof display_name !== 'string' || display_name.trim().length === 0) {
        return NextResponse.json(
          { success: false, error: 'Display name cannot be empty' },
          { status: 400 }
        )
      }
      updates.display_name = display_name.trim()
    }

    if (description !== undefined) {
      updates.description = description?.trim() || null
    }

    if (level !== undefined) {
      if (typeof level !== 'number' || level < 1 || level > 10) {
        return NextResponse.json(
          { success: false, error: 'Level must be between 1 and 10' },
          { status: 400 }
        )
      }
      // Le nouveau level doit être > userLevel (sauf pour super_admin level 1)
      if (userLevel !== 1 && level <= userLevel) {
        return NextResponse.json(
          { success: false, error: `You can only set level greater than ${userLevel}` },
          { status: 403 }
        )
      }
      // Le level 1 est réservé
      if (level === 1) {
        return NextResponse.json(
          { success: false, error: 'Level 1 is reserved for system super_admin' },
          { status: 403 }
        )
      }
      updates.level = level
    }

    if (color !== undefined) {
      updates.color = color || '#3B82F6'
    }

    if (icon !== undefined) {
      updates.icon = icon || 'User'
    }

    if (Object.keys(updates).length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No changes to apply',
        role: targetRole
      })
    }

    // Mettre à jour le rôle
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: updatedRole, error: updateError } = await (serviceClient as any)
      .from('roles')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating role:', updateError)
      return NextResponse.json(
        { success: false, error: 'Failed to update role' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      role: updatedRole
    })

  } catch (error) {
    console.error('Error in roles PUT API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/roles/[id]
 * Supprimer un rôle
 * Règles:
 * - Les rôles is_system ne peuvent pas être supprimés
 * - L'utilisateur doit avoir un level < au level du rôle
 * - Si des utilisateurs ont ce rôle, la suppression est refusée (sauf si reassign_to est fourni)
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const serviceClient = createServiceRoleClient()

    // Récupérer le level de l'utilisateur
    const { data: profileData } = await serviceClient
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (!profileData) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    const profile = profileData as { role?: string | null }

    const { data: userRole } = await serviceClient
      .from('roles')
      .select('level')
      .eq('name', profile.role || '')
      .single<{ level: number }>()

    const userLevel = userRole?.level ?? 10

    // Récupérer le rôle à supprimer
    const { data: targetRole, error: roleError } = await serviceClient
      .from('roles')
      .select('*')
      .eq('id', id)
      .single<Role>()

    if (roleError || !targetRole) {
      return NextResponse.json(
        { success: false, error: 'Role not found' },
        { status: 404 }
      )
    }

    // Vérifier que le rôle n'est pas un rôle système
    if (targetRole.is_system) {
      return NextResponse.json(
        { success: false, error: 'System roles cannot be deleted' },
        { status: 403 }
      )
    }

    // Vérifier la hiérarchie (sauf super_admin level 1)
    if (userLevel !== 1 && userLevel >= targetRole.level) {
      return NextResponse.json(
        { success: false, error: 'You can only delete roles with level greater than yours' },
        { status: 403 }
      )
    }

    // Vérifier si des utilisateurs ont ce rôle
    const { data: usersWithRole, error: usersError } = await serviceClient
      .from('profiles')
      .select('id')
      .eq('role_id', id)

    if (usersError) {
      console.error('Error checking users with role:', usersError)
      return NextResponse.json(
        { success: false, error: 'Failed to check users with this role' },
        { status: 500 }
      )
    }

    // Vérifier les paramètres
    const url = new URL(request.url)
    const forceRemove = url.searchParams.get('force_remove') === 'true'
    const checkOnly = url.searchParams.get('check_only') === 'true'

    // Si check_only, retourner les informations sans supprimer (pour confirmation en deux étapes)
    if (checkOnly) {
      return NextResponse.json({
        success: true,
        users_count: usersWithRole?.length || 0,
        role_name: targetRole.display_name,
        requires_confirmation: true
      })
    }

    if (usersWithRole && usersWithRole.length > 0) {
      if (!forceRemove) {
        // Retourner le nombre d'utilisateurs affectés pour que le frontend affiche un popup de confirmation
        return NextResponse.json(
          {
            success: false,
            error: `Ce rôle est assigné à ${usersWithRole.length} utilisateur(s). Ces utilisateurs seront mis sans rôle et n'auront plus accès au système jusqu'à réassignation.`,
            users_count: usersWithRole.length,
            requires_confirmation: true
          },
          { status: 409 }
        )
      }

      // Mettre les utilisateurs sans rôle (role = null, role_id = null)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error: removeRoleError } = await (serviceClient as any)
        .from('profiles')
        .update({
          role: null,
          role_id: null
        })
        .eq('role_id', id)

      if (removeRoleError) {
        console.error('Error removing role from users:', removeRoleError)
        return NextResponse.json(
          { success: false, error: 'Failed to remove role from users' },
          { status: 500 }
        )
      }
    }

    // Supprimer les permissions du rôle
    await serviceClient
      .from('role_permissions')
      .delete()
      .eq('role_id', id)

    // Supprimer le rôle
    const { error: deleteError } = await serviceClient
      .from('roles')
      .delete()
      .eq('id', id)

    if (deleteError) {
      console.error('Error deleting role:', deleteError)
      return NextResponse.json(
        { success: false, error: 'Failed to delete role' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      message: 'Role deleted successfully'
    })

  } catch (error) {
    console.error('Error in roles DELETE API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/roles/route.ts">
/**
 * API Roles - Gestion des rôles dynamiques
 *
 * GET /api/roles - Liste tous les rôles (triés par level)
 * POST /api/roles - Créer un nouveau rôle (selon hiérarchie)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import type { Role } from '@/lib/supabase/types'

/**
 * GET /api/roles
 * Liste tous les rôles disponibles, triés par niveau (1 = plus haute autorité)
 * Accessible à tous les utilisateurs authentifiés
 */
export async function GET() {
  try {
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Utiliser le service role client pour fetch les rôles
    const serviceClient = createServiceRoleClient()

    const { data: roles, error } = await serviceClient
      .from('roles')
      .select('*')
      .order('level', { ascending: true })

    if (error) {
      console.error('Error fetching roles:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch roles' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      roles: roles || []
    })

  } catch (error) {
    console.error('Error in roles API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/roles
 * Créer un nouveau rôle
 * Règles de hiérarchie:
 * - L'utilisateur doit avoir un level < au level du nouveau rôle
 * - Le level 1 ne peut pas être créé (réservé à super_admin système)
 * - Le nom doit être unique
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Vérifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Récupérer le profil et le rôle de l'utilisateur
    const serviceClient = createServiceRoleClient()

    const { data: profileData, error: profileError } = await serviceClient
      .from('profiles')
      .select('role, role_id')
      .eq('id', user.id)
      .single()

    if (profileError || !profileData) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    const profile = profileData as { role?: string | null; role_id?: string | null }

    // Récupérer le level de l'utilisateur
    const { data: userRole, error: userRoleError } = await serviceClient
      .from('roles')
      .select('level')
      .eq('name', profile.role || '')
      .single<{ level: number }>()

    if (userRoleError || !userRole) {
      return NextResponse.json(
        { success: false, error: 'User role not found' },
        { status: 404 }
      )
    }

    const userLevel = userRole.level

    // Parser le body
    const body = await request.json()
    const { name, display_name, description, level, color, icon } = body

    // Validations
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return NextResponse.json(
        { success: false, error: 'Name is required' },
        { status: 400 }
      )
    }

    if (!display_name || typeof display_name !== 'string' || display_name.trim().length === 0) {
      return NextResponse.json(
        { success: false, error: 'Display name is required' },
        { status: 400 }
      )
    }

    if (typeof level !== 'number' || level < 1 || level > 10) {
      return NextResponse.json(
        { success: false, error: 'Level must be between 1 and 10' },
        { status: 400 }
      )
    }

    // Vérifier la hiérarchie: l'utilisateur ne peut créer que des rôles avec level > son level
    if (level <= userLevel) {
      return NextResponse.json(
        { success: false, error: `You can only create roles with level greater than ${userLevel}` },
        { status: 403 }
      )
    }

    // Le level 1 est réservé au super_admin système
    if (level === 1) {
      return NextResponse.json(
        { success: false, error: 'Level 1 is reserved for system super_admin' },
        { status: 403 }
      )
    }

    // Vérifier que le nom est unique
    const { data: existingRole } = await serviceClient
      .from('roles')
      .select('id')
      .eq('name', name.trim().toLowerCase().replace(/\s+/g, '_'))
      .single()

    if (existingRole) {
      return NextResponse.json(
        { success: false, error: 'A role with this name already exists' },
        { status: 409 }
      )
    }

    // Créer le rôle
    const newRole: Partial<Role> = {
      name: name.trim().toLowerCase().replace(/\s+/g, '_'),
      display_name: display_name.trim(),
      description: description?.trim() || null,
      level,
      color: color || '#3B82F6',
      icon: icon || 'User',
      is_system: false
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: createdRole, error: createError } = await (serviceClient as any)
      .from('roles')
      .insert(newRole)
      .select()
      .single()

    if (createError) {
      console.error('Error creating role:', createError)
      return NextResponse.json(
        { success: false, error: 'Failed to create role' },
        { status: 500 }
      )
    }

    // Créer les permissions par défaut pour ce nouveau rôle (toutes à false)
    const resources = ['agenda', 'orders', 'clients', 'users', 'logs', 'settings', 'permissions']
    const permissionsToInsert = resources.map(resource => ({
      role: createdRole.name,
      role_id: createdRole.id,
      resource,
      can_view: false,
      can_create: false,
      can_edit: false,
      can_delete: false
    }))

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { error: permissionsError } = await (serviceClient as any)
      .from('role_permissions')
      .insert(permissionsToInsert)

    if (permissionsError) {
      console.error('Error creating permissions for role:', permissionsError)
      // Rollback: delete the created role since permissions failed
      await serviceClient.from('roles').delete().eq('id', createdRole.id)
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to create role permissions. Please ensure the database constraint "role_permissions_role_check" has been removed to allow dynamic roles.',
          details: permissionsError.message
        },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      role: createdRole
    })

  } catch (error) {
    console.error('Error in roles POST API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/components/Clara/ClaraProvider.tsx">
'use client'

import { createContext, useContext, useState, useCallback, ReactNode } from 'react'
import { ClaraAssistant } from './ClaraAssistant'

interface ClaraContextType {
  isOpen: boolean
  openClara: () => void
  closeClara: () => void
  toggleClara: () => void
  position: 'left' | 'right'
  setPosition: (position: 'left' | 'right') => void
}

const ClaraContext = createContext<ClaraContextType | undefined>(undefined)

interface ClaraProviderProps {
  children: ReactNode
  theme?: 'light' | 'dark'
}

export function ClaraProvider({ children, theme = 'dark' }: ClaraProviderProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [position, setPosition] = useState<'left' | 'right'>('right')

  const openClara = useCallback(() => setIsOpen(true), [])
  const closeClara = useCallback(() => setIsOpen(false), [])
  const toggleClara = useCallback(() => setIsOpen(prev => !prev), [])

  return (
    <ClaraContext.Provider value={{
      isOpen,
      openClara,
      closeClara,
      toggleClara,
      position,
      setPosition
    }}>
      {children}
      <ClaraAssistant
        isOpen={isOpen}
        onClose={closeClara}
        position={position}
        onPositionChange={setPosition}
        theme={theme}
      />
    </ClaraContext.Provider>
  )
}

export function useClara() {
  const context = useContext(ClaraContext)
  if (context === undefined) {
    throw new Error('useClara must be used within a ClaraProvider')
  }
  return context
}
</file>

<file path="src/hooks/useContacts.ts">
'use client'

import { useState, useCallback } from 'react'
import type { Contact, ContactStatus, ContactSource, ClientType } from '@/lib/supabase/types'

export interface SearchContactsParams {
  query?: string
  branchId: string | null
  includeArchived?: boolean
  status?: 'active' | 'archived'
  source?: 'admin_agenda' | 'public_booking'
  dateFrom?: string
  dateTo?: string
  page?: number
  pageSize?: number
}

export interface SearchContactsResult {
  contacts: Contact[]
  total: number
  page: number
  pageSize: number
  totalPages: number
}

export interface CreateContactData {
  branch_id_main: string
  first_name: string
  last_name?: string | null
  phone: string
  email?: string | null
  notes_client?: string | null
  alias?: string | null
  source?: ContactSource
  client_type?: ClientType
  company_name?: string | null
  vat_id?: string | null
  preferred_locale?: 'he' | 'fr' | 'en'
}

export interface UpdateContactData extends Partial<CreateContactData> {
  status?: ContactStatus
  archived_reason?: string | null
}

/**
 * Hook pour gérer les contacts via les routes API
 * IMPORTANT: Toutes les opérations passent par /api/contacts pour garantir
 * les vérifications de permissions et le logging des actions
 */
export function useContacts(branchId: string | null) {
  const [contacts, setContacts] = useState<Contact[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Rechercher des contacts (avec pagination server-side)
  const searchContacts = useCallback(async (params: SearchContactsParams): Promise<SearchContactsResult> => {
    if (!params.branchId) {
      return { contacts: [], total: 0, page: params.page || 1, pageSize: params.pageSize || 50, totalPages: 0 }
    }

    setLoading(true)
    setError(null)

    try {
      // Construire les query params
      const queryParams = new URLSearchParams()
      queryParams.set('branchId', params.branchId)
      if (params.query) queryParams.set('query', params.query)
      if (params.status) queryParams.set('status', params.status)
      if (params.includeArchived) queryParams.set('includeArchived', 'true')
      if (params.source) queryParams.set('source', params.source)
      if (params.dateFrom) queryParams.set('dateFrom', params.dateFrom)
      if (params.dateTo) queryParams.set('dateTo', params.dateTo)
      if (params.page) queryParams.set('page', String(params.page))
      if (params.pageSize) queryParams.set('pageSize', String(params.pageSize))

      const response = await fetch(`/api/contacts?${queryParams.toString()}`)
      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Erreur lors de la recherche des contacts')
      }

      return {
        contacts: data.contacts || [],
        total: data.total || 0,
        page: data.page || 1,
        pageSize: data.pageSize || 50,
        totalPages: data.totalPages || 0,
      }
    } catch (err) {
      console.error('Error searching contacts:', err)
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la recherche des contacts'
      setError(errorMessage)
      return { contacts: [], total: 0, page: params.page || 1, pageSize: params.pageSize || 50, totalPages: 0 }
    } finally {
      setLoading(false)
    }
  }, [])

  // Créer un contact
  const createContact = useCallback(async (data: CreateContactData): Promise<Contact | null> => {
    setError(null)

    try {
      const response = await fetch('/api/contacts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      const result = await response.json()

      if (!response.ok) {
        throw new Error(result.error || 'Erreur lors de la création du contact')
      }

      return result.contact
    } catch (err) {
      console.error('Error creating contact:', err)
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la création du contact'
      setError(errorMessage)
      return null
    }
  }, [])

  // Obtenir un contact par ID
  const getContact = useCallback(async (contactId: string): Promise<Contact | null> => {
    setError(null)

    try {
      const response = await fetch(`/api/contacts/${contactId}`)
      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Erreur lors de la récupération du contact')
      }

      return data.contact
    } catch (err) {
      console.error('Error fetching contact:', err)
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la récupération du contact'
      setError(errorMessage)
      return null
    }
  }, [])

  // Mettre à jour un contact
  const updateContact = useCallback(async (contactId: string, data: UpdateContactData): Promise<Contact | null> => {
    setError(null)

    try {
      const response = await fetch(`/api/contacts/${contactId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      const result = await response.json()

      if (!response.ok) {
        throw new Error(result.error || 'Erreur lors de la mise à jour du contact')
      }

      return result.contact
    } catch (err) {
      console.error('Error updating contact:', err)
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la mise à jour du contact'
      setError(errorMessage)
      return null
    }
  }, [])

  // Archiver un contact (soft delete)
  const archiveContact = useCallback(async (contactId: string, reason?: string): Promise<boolean> => {
    setError(null)

    try {
      const response = await fetch(`/api/contacts/${contactId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status: 'archived',
          archived_reason: reason || null
        })
      })

      const result = await response.json()

      if (!response.ok) {
        throw new Error(result.error || 'Erreur lors de l\'archivage du contact')
      }

      return true
    } catch (err) {
      console.error('Error archiving contact:', err)
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de l\'archivage du contact'
      setError(errorMessage)
      return false
    }
  }, [])

  // Restaurer un contact archivé
  const unarchiveContact = useCallback(async (contactId: string): Promise<boolean> => {
    setError(null)

    try {
      const response = await fetch(`/api/contacts/${contactId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status: 'active'
        })
      })

      const result = await response.json()

      if (!response.ok) {
        throw new Error(result.error || 'Erreur lors de la restauration du contact')
      }

      return true
    } catch (err) {
      console.error('Error unarchiving contact:', err)
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la restauration du contact'
      setError(errorMessage)
      return false
    }
  }, [])

  // Vérifier les doublons (phone ou email) - via API
  const checkDuplicates = useCallback(async (phone: string, email: string | null, excludeContactId?: string): Promise<{ phoneMatches: Contact[]; emailMatches: Contact[] }> => {
    if (!branchId) {
      return { phoneMatches: [], emailMatches: [] }
    }

    try {
      const queryParams = new URLSearchParams()
      queryParams.set('branchId', branchId)
      queryParams.set('checkDuplicates', 'true')
      queryParams.set('phone', phone.trim())
      if (email) queryParams.set('email', email.trim())
      if (excludeContactId) queryParams.set('excludeId', excludeContactId)

      const response = await fetch(`/api/contacts?${queryParams.toString()}`)
      const data = await response.json()

      if (!response.ok) {
        console.error('Error checking duplicates:', data.error)
        return { phoneMatches: [], emailMatches: [] }
      }

      return {
        phoneMatches: data.phoneMatches || [],
        emailMatches: data.emailMatches || [],
      }
    } catch (err) {
      console.error('Error checking duplicates:', err)
      return { phoneMatches: [], emailMatches: [] }
    }
  }, [branchId])

  // Récupérer les réservations liées à un contact - via API
  const getLinkedBookings = useCallback(async (contactId: string) => {
    if (!branchId) {
      return []
    }

    try {
      const response = await fetch(`/api/contacts/${contactId}/bookings?branchId=${branchId}`)
      const data = await response.json()

      if (!response.ok) {
        console.error('Error fetching linked bookings:', data.error)
        return []
      }

      return data.bookings || []
    } catch (err) {
      console.error('Error fetching linked bookings:', err)
      return []
    }
  }, [branchId])

  // Statistiques d'un contact - via API
  const getContactStats = useCallback(async (contactId: string) => {
    if (!branchId) {
      return null
    }

    try {
      const response = await fetch(`/api/contacts/${contactId}/stats?branchId=${branchId}`)
      const data = await response.json()

      if (!response.ok) {
        console.error('Error fetching contact stats:', data.error)
        return null
      }

      return data.stats || null
    } catch (err) {
      console.error('Error fetching contact stats:', err)
      return null
    }
  }, [branchId])

  return {
    contacts,
    loading,
    error,
    searchContacts,
    createContact,
    getContact,
    updateContact,
    archiveContact,
    unarchiveContact,
    checkDuplicates,
    getLinkedBookings,
    getContactStats,
  }
}
</file>

<file path="src/lib/payment-provider/icount/items.ts">
/**
 * iCount Inventory Module
 * Synchronisation des produits/items vers iCount via le module inventory
 *
 * API Endpoints (from Products-inventory-management.yaml):
 * - inventory/add_item : Créer un item (retourne inventory_item_id)
 * - inventory/update_item : Mettre à jour un item (requiert inventory_item_id)
 * - inventory/get_items : Rechercher des items par SKU
 * - inventory/get_item : Récupérer un item par inventory_item_id
 */

import type { ICountClient } from './client'
import type { ProviderResult } from '../types'

interface ICountInventoryResponse {
  status: boolean
  reason?: string
  error_description?: string
  error_details?: string[]
  // Réponse add_item
  inventory_item_id?: number
  // Réponse get_items
  items?: Array<{
    inventory_item_id: number
    sku: string
    description: string
    long_description?: string
    unitprice: number
    currency_id?: number
    tax_exempt?: boolean
    [key: string]: unknown
  }>
  // Réponse get_item (single)
  sku?: string
  description?: string
  long_description?: string
  unitprice?: number
  currency_id?: number
  tax_exempt?: boolean
  [key: string]: unknown
}

export interface ItemData {
  id: string                    // Notre UUID
  code: string                  // SKU / Code produit (ex: laser_1p)
  name: string                  // Nom principal (description iCount)
  nameHe?: string               // Nom hébreu
  nameEn?: string               // Nom anglais
  description?: string          // Description longue
  unitPrice: number             // Prix unitaire
  vatExempt?: boolean           // Exonéré de TVA
  active?: boolean              // Actif (not used by iCount directly)
}

export interface SyncItemResult {
  providerId: string            // inventory_item_id iCount
  itemCode?: string             // sku retourné par iCount
  action: 'created' | 'updated'
}

export class ICountItemsModule {
  constructor(private client: ICountClient) {}

  /**
   * Synchroniser un item vers iCount
   * - Si l'item existe (trouvé par SKU) → update_item
   * - Sinon → add_item
   */
  async syncItem(data: ItemData): Promise<ProviderResult<SyncItemResult>> {
    console.log('[ICOUNT INVENTORY] Syncing item:', data.code, data.name)

    // 1. Chercher si l'item existe déjà par SKU
    const existingItem = await this.findItemBySku(data.code)

    if (existingItem) {
      // Item existe → update
      console.log('[ICOUNT INVENTORY] Item exists, updating:', existingItem.inventory_item_id)
      return this.updateItem(existingItem.inventory_item_id, data)
    } else {
      // Item n'existe pas → create
      console.log('[ICOUNT INVENTORY] Item does not exist, creating...')
      return this.createItem(data)
    }
  }

  /**
   * Créer un nouvel item sur iCount
   */
  private async createItem(data: ItemData): Promise<ProviderResult<SyncItemResult>> {
    const params: Record<string, unknown> = {
      sku: data.code,
      description: data.nameHe || data.name,  // Nom principal (hébreu de préférence)
      unitprice: data.unitPrice,
      unit_price_includes_vat: true, // Prix TTC - iCount ne rajoutera pas la TVA
    }

    // Description longue (nom FR + EN si disponibles)
    const longDesc = [data.name]
    if (data.nameEn) longDesc.push(data.nameEn)
    if (data.description) longDesc.push(data.description)
    if (longDesc.length > 1 || data.description) {
      params.long_description = longDesc.join(' | ')
    }

    if (data.vatExempt !== undefined) params.tax_exempt = data.vatExempt

    const result = await this.client.request<ICountInventoryResponse>(
      'inventory',
      'add_item',
      params
    )

    if (result.success && result.data?.inventory_item_id) {
      console.log('[ICOUNT INVENTORY] Item created:', result.data.inventory_item_id)
      return {
        success: true,
        data: {
          providerId: result.data.inventory_item_id.toString(),
          itemCode: data.code,
          action: 'created',
        },
      }
    }

    console.error('[ICOUNT INVENTORY] Create failed:', result.error)
    return {
      success: false,
      error: result.error,
    }
  }

  /**
   * Mettre à jour un item existant sur iCount
   */
  private async updateItem(inventoryItemId: number, data: ItemData): Promise<ProviderResult<SyncItemResult>> {
    const params: Record<string, unknown> = {
      inventory_item_id: inventoryItemId,
      sku: data.code,
      description: data.nameHe || data.name,
      unitprice: data.unitPrice,
      unit_price_includes_vat: true, // Prix TTC - iCount ne rajoutera pas la TVA
    }

    // Description longue
    const longDesc = [data.name]
    if (data.nameEn) longDesc.push(data.nameEn)
    if (data.description) longDesc.push(data.description)
    if (longDesc.length > 1 || data.description) {
      params.long_description = longDesc.join(' | ')
    }

    if (data.vatExempt !== undefined) params.tax_exempt = data.vatExempt

    const result = await this.client.request<ICountInventoryResponse>(
      'inventory',
      'update_item',
      params
    )

    if (result.success) {
      console.log('[ICOUNT INVENTORY] Item updated:', inventoryItemId)
      return {
        success: true,
        data: {
          providerId: inventoryItemId.toString(),
          itemCode: data.code,
          action: 'updated',
        },
      }
    }

    console.error('[ICOUNT INVENTORY] Update failed:', result.error)
    return {
      success: false,
      error: result.error,
    }
  }

  /**
   * Rechercher un item par SKU
   */
  private async findItemBySku(sku: string): Promise<{ inventory_item_id: number; sku: string } | null> {
    const result = await this.client.request<ICountInventoryResponse>(
      'inventory',
      'get_items',
      {
        sku: sku,  // Recherche exacte
        limit: 1,
      }
    )

    if (result.success && result.data?.items) {
      // Note: iCount returns an OBJECT with numeric keys, not an array
      // Example: { "17": { inventory_item_id: "17", sku: "laser_4", ... } }
      const items = result.data.items
      type ItemType = { inventory_item_id: number | string; sku: string }
      const itemsArray: ItemType[] = Array.isArray(items)
        ? items
        : Object.values(items) as ItemType[]
      if (itemsArray.length > 0) {
        const item = itemsArray[0]
        // Vérifier que le SKU correspond exactement (au cas où iCount fait un wildcard)
        if (item.sku === sku) {
          return {
            inventory_item_id: typeof item.inventory_item_id === 'string'
              ? parseInt(item.inventory_item_id, 10)
              : item.inventory_item_id,
            sku: item.sku,
          }
        }
      }
    }

    return null
  }

  /**
   * Récupérer un item par son inventory_item_id
   */
  async getItem(inventoryItemId: number): Promise<ProviderResult<ItemData & { providerId: string }>> {
    const result = await this.client.request<ICountInventoryResponse>(
      'inventory',
      'get_item',
      {
        inventory_item_id: inventoryItemId,
      }
    )

    if (result.success && result.data) {
      const data = result.data
      return {
        success: true,
        data: {
          id: '',
          providerId: inventoryItemId.toString(),
          code: data.sku || '',
          name: data.description || '',
          description: data.long_description,
          unitPrice: data.unitprice || 0,
          vatExempt: data.tax_exempt,
        },
      }
    }

    return {
      success: false,
      error: result.error,
    }
  }

  /**
   * Lister tous les items
   */
  async listItems(): Promise<ProviderResult<Array<ItemData & { providerId: string }>>> {
    const result = await this.client.request<ICountInventoryResponse>(
      'inventory',
      'get_items',
      {
        limit: 0,  // 0 = unlimited
      }
    )

    if (result.success && result.data) {
      // Note: iCount returns an OBJECT with numeric keys, not an array
      const items = result.data.items
      type ListItemType = {
        inventory_item_id: number | string
        sku: string
        description: string
        long_description?: string
        unitprice?: number
        tax_exempt?: boolean
      }
      const itemsArray: ListItemType[] = Array.isArray(items)
        ? items
        : Object.values(items || {}) as ListItemType[]

      const itemsList = itemsArray.map((item) => ({
        id: '',
        providerId: item.inventory_item_id.toString(),
        code: item.sku,
        name: item.description,
        description: item.long_description,
        unitPrice: item.unitprice || 0,
        vatExempt: item.tax_exempt,
      }))

      return {
        success: true,
        data: itemsList,
      }
    }

    return {
      success: false,
      error: result.error,
    }
  }

  /**
   * Supprimer plusieurs items par leurs IDs
   */
  async deleteItems(inventoryItemIds: number[]): Promise<ProviderResult<{ deleted: number[] }>> {
    if (inventoryItemIds.length === 0) {
      return { success: true, data: { deleted: [] } }
    }

    console.log('[ICOUNT INVENTORY] Deleting items:', inventoryItemIds)

    const result = await this.client.request<ICountInventoryResponse & { delete_status?: Record<string, boolean> }>(
      'inventory',
      'delete_items',
      {
        inventory_item_ids: inventoryItemIds,
      }
    )

    if (result.success && result.data?.delete_status) {
      const deleted = Object.entries(result.data.delete_status)
        .filter(([, success]) => success)
        .map(([id]) => parseInt(id, 10))

      console.log('[ICOUNT INVENTORY] Deleted items:', deleted)
      return {
        success: true,
        data: { deleted },
      }
    }

    console.error('[ICOUNT INVENTORY] Delete failed:', result.error)
    return {
      success: false,
      error: result.error,
    }
  }
}
</file>

<file path="README.md">
# Active Laser - Système de Gestion de Réservations

Système complet de gestion de réservations pour Active Games / Laser City avec interface d'administration.

## 🚀 Installation Rapide

### Prérequis
- Node.js 18+ 
- npm ou yarn
- Accès à Supabase (les clés sont déjà configurées dans `.env.local`)

### Installation

1. **Cloner le projet**
```bash
git clone https://github.com/mymy770/activelaser.git
cd activelaser
```

2. **Installer les dépendances**
```bash
npm install
```

3. **Les variables d'environnement sont déjà configurées**
Le fichier `.env.local` contient déjà toutes les clés Supabase nécessaires. Aucune configuration supplémentaire n'est requise.

4. **Lancer le serveur de développement**
```bash
npm run dev
```

5. **Ouvrir dans le navigateur**
- Page d'accueil : http://localhost:3000
- Interface admin : http://localhost:3000/admin

## 📁 Structure du Projet

```
activelaser/
├── src/
│   ├── app/
│   │   ├── admin/          # Interface d'administration
│   │   │   ├── page.tsx     # Page principale admin (agenda)
│   │   │   └── components/  # Composants admin
│   │   ├── page.tsx         # Page d'accueil publique
│   │   ├── layout.tsx       # Layout principal
│   │   └── globals.css      # Styles globaux
│   ├── components/          # Composants publics
│   ├── hooks/               # Hooks React personnalisés
│   ├── lib/                 # Utilitaires et configurations
│   │   ├── supabase/        # Client Supabase
│   │   └── scheduler/       # Moteur de planification
│   ├── i18n/                # Traductions (EN, FR, HE)
│   └── data/                # Données statiques
├── public/                  # Assets (images, vidéos)
├── .env.local              # Variables d'environnement (déjà configuré)
└── package.json            # Dépendances
```

## 🛠️ Scripts Disponibles

- `npm run dev` - Lance le serveur de développement (port 3000)
- `npm run dev:3003` - Lance le serveur sur le port 3003
- `npm run build` - Build de production
- `npm run start` - Lance le serveur de production
- `npm run lint` - Vérifie le code avec ESLint

## 🔐 Configuration Supabase

Les clés Supabase sont déjà configurées dans `.env.local` :
- `NEXT_PUBLIC_SUPABASE_URL` - URL du projet
- `NEXT_PUBLIC_SUPABASE_ANON_KEY` - Clé publique
- `SUPABASE_SERVICE_ROLE_KEY` - Clé de service (admin)

**Note** : Ces clés sont incluses dans le dépôt pour faciliter le démarrage. En production, utilisez des variables d'environnement sécurisées.

## 📝 Fonctionnalités

### Interface Admin (`/admin`)
- 📅 Agenda avec 3 grilles (ACTIVE, LASER, ROOMS)
- ➕ Création/Modification de réservations
- 👥 Gestion des contacts
- 🏢 Gestion multi-branches
- ⚙️ Paramètres configurables
- 📊 Calcul d'overbooking automatique

### Page Publique (`/`)
- 🎮 Présentation des jeux
- 📍 Informations sur les branches
- 💬 Formulaire de contact
- 🌐 Support multi-langues (EN, FR, HE)

## 🗄️ Base de Données

Le projet utilise Supabase (PostgreSQL) avec les tables suivantes :
- `bookings` - Réservations
- `game_sessions` - Sessions de jeu
- `contacts` - Contacts clients
- `branches` - Succursales
- `rooms` - Salles d'anniversaire
- `laser_rooms` - Salles laser
- `settings` - Paramètres par branche

## 🚨 Dépannage

### Le serveur ne démarre pas
- Vérifiez que Node.js 18+ est installé : `node --version`
- Supprimez `node_modules` et `.next` puis relancez `npm install`

### Erreur Supabase
- Vérifiez que `.env.local` existe et contient les bonnes clés
- Redémarrez le serveur après modification de `.env.local`

### Port déjà utilisé
- Utilisez `npm run dev:3003` pour un autre port
- Ou tuez le processus : `lsof -ti:3000 | xargs kill`

## 📄 Licence

Propriétaire - Active Games World

## 👥 Support

Pour toute question, contactez l'équipe de développement.
# Backup system active
# Backup system active
</file>

<file path="src/app/admin/statistics/page.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import {
  BarChart3,
  TrendingUp,
  Users,
  CreditCard,
  Calendar,
  DollarSign,
  ShoppingCart,
  UserCheck,
  Clock,
  RefreshCw,
  Building2,
  Loader2,
  Target,
  PartyPopper,
  ArrowUpRight,
  ArrowDownRight,
  Percent,
  Download
} from 'lucide-react'
import {
  BarChart,
  Bar,
  LineChart,
  Line,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  Area,
  AreaChart
} from 'recharts'
import { useAuth } from '@/hooks/useAuth'
import { useBranches } from '@/hooks/useBranches'
import { AdminHeader } from '../components/AdminHeader'
import { createClient } from '@/lib/supabase/client'

// Types
interface StatsData {
  // Revenue
  totalRevenue: number
  totalOrders: number
  paidRevenue: number
  pendingRevenue: number
  averageOrderValue: number
  // Orders
  ordersByStatus: { status: string; count: number }[]
  ordersByType: { type: string; count: number }[]
  ordersByMonth: { month: string; count: number; revenue: number }[]
  ordersByBranch: { branch: string; count: number; revenue: number }[]
  // Clients
  totalClients: number
  newClientsThisMonth: number
  returningClients: number
  topClients: { name: string; orders: number; revenue: number }[]
  // Users
  ordersByUser: { user: string; count: number }[]
  // Time
  popularDays: { day: string; count: number }[]
  popularHours: { hour: string; count: number }[]
}

// Date range options
const DATE_RANGES = [
  { label: 'Aujourd\'hui', value: 'today' },
  { label: 'Cette semaine', value: 'week' },
  { label: 'Ce mois', value: 'month' },
  { label: 'Ce trimestre', value: 'quarter' },
  { label: 'Cette année', value: 'year' },
  { label: 'Tout', value: 'all' },
  { label: 'Personnalisé', value: 'custom' },
]

// Colors for charts
const CHART_COLORS = {
  light: ['#3b82f6', '#f97316', '#22c55e', '#a855f7', '#ec4899', '#eab308'],
  dark: ['#60a5fa', '#fb923c', '#4ade80', '#c084fc', '#f472b6', '#facc15']
}

const STATUS_COLORS: Record<string, { light: string; dark: string; label: string }> = {
  pending: { light: 'bg-yellow-100 text-yellow-700', dark: 'bg-yellow-500/20 text-yellow-400', label: 'En attente' },
  auto_confirmed: { light: 'bg-green-100 text-green-700', dark: 'bg-green-500/20 text-green-400', label: 'Auto confirmé' },
  manually_confirmed: { light: 'bg-blue-100 text-blue-700', dark: 'bg-blue-500/20 text-blue-400', label: 'Confirmé manuellement' },
  cancelled: { light: 'bg-red-100 text-red-700', dark: 'bg-red-500/20 text-red-400', label: 'Annulé' },
  closed: { light: 'bg-purple-100 text-purple-700', dark: 'bg-purple-500/20 text-purple-400', label: 'Clôturé' },
}

export default function StatisticsPage() {
  const router = useRouter()
  const { user, loading: authLoading, signOut } = useAuth()
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()

  const [loading, setLoading] = useState(true)
  const [stats, setStats] = useState<StatsData | null>(null)
  const [dateRange, setDateRange] = useState('month')
  const [customStartDate, setCustomStartDate] = useState('')
  const [customEndDate, setCustomEndDate] = useState('')
  const [selectedBranchId, setSelectedBranchId] = useState<string>('all')
  const [activeTab, setActiveTab] = useState<'overview' | 'orders' | 'clients' | 'revenue' | 'team'>('overview')
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')

  // Charger le thème depuis localStorage
  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'
  const colors = isDark ? CHART_COLORS.dark : CHART_COLORS.light

  // Charger les stats
  const loadStats = useCallback(async () => {
    setLoading(true)
    try {
      let url = `/api/admin/statistics?range=${dateRange}&branch=${selectedBranchId}`
      if (dateRange === 'custom' && customStartDate && customEndDate) {
        url += `&startDate=${customStartDate}&endDate=${customEndDate}`
      }
      const response = await fetch(url)
      const data = await response.json()
      if (data.success) {
        setStats(data.stats)
      }
    } catch (error) {
      console.error('Error loading stats:', error)
    } finally {
      setLoading(false)
    }
  }, [dateRange, selectedBranchId, customStartDate, customEndDate])

  // Auth check et chargement initial
  useEffect(() => {
    const checkAuth = async () => {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) {
        router.push('/admin/login')
        return
      }
      await loadStats()
    }
    checkAuth()
  }, [router, loadStats])

  // Recharger quand les filtres changent
  useEffect(() => {
    if (!loading) {
      // Pour les dates custom, attendre que les deux soient renseignées
      if (dateRange === 'custom') {
        if (customStartDate && customEndDate) {
          loadStats()
        }
      } else {
        loadStats()
      }
    }
  }, [dateRange, selectedBranchId, customStartDate, customEndDate])

  // Format currency
  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('he-IL', { style: 'currency', currency: 'ILS' }).format(amount)
  }

  // Format number
  const formatNumber = (num: number) => {
    return new Intl.NumberFormat('fr-FR').format(num)
  }

  // Calculer effectiveSelectedBranch
  const effectiveSelectedBranch = selectedBranch || (branches.length > 0 ? branches[0] : null)

  // Export CSV
  const handleExportCSV = () => {
    if (!stats) return

    const rows = [
      ['Statistiques', dateRange, new Date().toLocaleDateString('fr-FR')],
      [],
      ['Chiffre d\'affaires total', formatCurrency(stats.totalRevenue)],
      ['CA encaissé', formatCurrency(stats.paidRevenue)],
      ['CA en attente', formatCurrency(stats.pendingRevenue)],
      ['Panier moyen', formatCurrency(stats.averageOrderValue)],
      ['Nombre de commandes', stats.totalOrders],
      ['Nombre de clients', stats.totalClients],
      ['Nouveaux clients ce mois', stats.newClientsThisMonth],
      ['Clients récurrents', stats.returningClients],
      [],
      ['Top Clients'],
      ['Nom', 'Commandes', 'CA'],
      ...stats.topClients.map(c => [c.name, c.orders, formatCurrency(c.revenue)]),
    ]

    const csvContent = rows.map(row => row.join(',')).join('\n')
    const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' })
    const link = document.createElement('a')
    link.href = URL.createObjectURL(blob)
    link.download = `statistiques_${dateRange}_${new Date().toISOString().split('T')[0]}.csv`
    link.click()
  }

  if (authLoading || branchesLoading || !user) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={effectiveSelectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={signOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sous-header */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex items-center gap-4">
            <div className={`p-2 rounded-lg ${isDark ? 'bg-blue-500/20' : 'bg-blue-100'}`}>
              <BarChart3 className={`w-6 h-6 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
            </div>
            <div>
              <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                Statistiques
              </h1>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                Analysez vos performances et données
              </p>
            </div>
          </div>

          {/* Filtres */}
          <div className="flex flex-wrap items-center gap-3">
            {/* Date Range */}
            <div className="relative">
              <select
                value={dateRange}
                onChange={(e) => setDateRange(e.target.value)}
                className={`appearance-none rounded-lg px-4 py-2 pr-10 focus:outline-none focus:ring-2 ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white focus:ring-blue-500'
                    : 'bg-white border-gray-300 text-gray-900 focus:ring-blue-400'
                } border`}
              >
                {DATE_RANGES.map(range => (
                  <option key={range.value} value={range.value}>{range.label}</option>
                ))}
              </select>
              <Calendar className={`absolute right-3 top-1/2 -translate-y-1/2 w-4 h-4 pointer-events-none ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`} />
            </div>

            {/* Custom Date Range */}
            {dateRange === 'custom' && (
              <>
                <input
                  type="date"
                  value={customStartDate}
                  onChange={(e) => setCustomStartDate(e.target.value)}
                  className={`rounded-lg px-3 py-2 focus:outline-none focus:ring-2 ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white focus:ring-blue-500'
                      : 'bg-white border-gray-300 text-gray-900 focus:ring-blue-400'
                  } border`}
                />
                <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>à</span>
                <input
                  type="date"
                  value={customEndDate}
                  onChange={(e) => setCustomEndDate(e.target.value)}
                  className={`rounded-lg px-3 py-2 focus:outline-none focus:ring-2 ${
                    isDark
                      ? 'bg-gray-700 border-gray-600 text-white focus:ring-blue-500'
                      : 'bg-white border-gray-300 text-gray-900 focus:ring-blue-400'
                  } border`}
                />
              </>
            )}

            {/* Branch Filter */}
            <div className="relative">
              <select
                value={selectedBranchId}
                onChange={(e) => setSelectedBranchId(e.target.value)}
                className={`appearance-none rounded-lg px-4 py-2 pr-10 focus:outline-none focus:ring-2 ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white focus:ring-blue-500'
                    : 'bg-white border-gray-300 text-gray-900 focus:ring-blue-400'
                } border`}
              >
                <option value="all">Toutes les branches</option>
                {branches.map(branch => (
                  <option key={branch.id} value={branch.id}>{branch.name}</option>
                ))}
              </select>
              <Building2 className={`absolute right-3 top-1/2 -translate-y-1/2 w-4 h-4 pointer-events-none ${
                isDark ? 'text-gray-400' : 'text-gray-500'
              }`} />
            </div>

            {/* Refresh */}
            <button
              onClick={loadStats}
              disabled={loading}
              className={`rounded-lg px-4 py-2 flex items-center gap-2 transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-white'
                  : 'bg-white hover:bg-gray-50 text-gray-700 border border-gray-300'
              }`}
            >
              <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              Actualiser
            </button>

            {/* Export */}
            <button
              onClick={handleExportCSV}
              disabled={!stats}
              className={`rounded-lg px-4 py-2 flex items-center gap-2 transition-colors ${
                isDark
                  ? 'bg-green-600 hover:bg-green-700 text-white'
                  : 'bg-green-500 hover:bg-green-600 text-white'
              }`}
            >
              <Download className="w-4 h-4" />
              Export
            </button>
          </div>
        </div>
      </div>

      {/* Tabs */}
      <div className={`${isDark ? 'bg-gray-800/50' : 'bg-gray-50'} px-6 py-3 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
        <div className="flex gap-2 overflow-x-auto">
          {[
            { id: 'overview', label: 'Vue d\'ensemble', icon: BarChart3 },
            { id: 'revenue', label: 'Chiffre d\'affaires', icon: DollarSign },
            { id: 'orders', label: 'Commandes', icon: ShoppingCart },
            { id: 'clients', label: 'Clients', icon: Users },
            { id: 'team', label: 'Équipe', icon: UserCheck },
          ].map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id as typeof activeTab)}
              className={`flex items-center gap-2 px-4 py-2 rounded-lg whitespace-nowrap transition-colors font-medium ${
                activeTab === tab.id
                  ? isDark
                    ? 'bg-blue-600 text-white'
                    : 'bg-blue-500 text-white'
                  : isDark
                    ? 'text-gray-400 hover:text-white hover:bg-gray-700'
                    : 'text-gray-600 hover:text-gray-900 hover:bg-gray-200'
              }`}
            >
              <tab.icon className="w-4 h-4" />
              {tab.label}
            </button>
          ))}
        </div>
      </div>

      {/* Content */}
      <main className="p-6">
        {loading && !stats ? (
          <div className="flex justify-center py-20">
            <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
          </div>
        ) : stats ? (
          <>
            {/* Overview Tab */}
            {activeTab === 'overview' && (
              <div className="space-y-6">
                {/* KPI Cards */}
                <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                  <KPICard
                    title="Chiffre d'affaires"
                    value={formatCurrency(stats.totalRevenue)}
                    icon={DollarSign}
                    trend={stats.paidRevenue > 0 ? `${Math.round((stats.paidRevenue / stats.totalRevenue) * 100)}% encaissé` : undefined}
                    trendUp={true}
                    isDark={isDark}
                    color="green"
                  />
                  <KPICard
                    title="Commandes"
                    value={formatNumber(stats.totalOrders)}
                    icon={ShoppingCart}
                    trend={`${formatCurrency(stats.averageOrderValue)} / commande`}
                    isDark={isDark}
                    color="blue"
                  />
                  <KPICard
                    title="Clients"
                    value={formatNumber(stats.totalClients)}
                    icon={Users}
                    trend={`+${stats.newClientsThisMonth} ce mois`}
                    trendUp={true}
                    isDark={isDark}
                    color="purple"
                  />
                  <KPICard
                    title="Taux fidélité"
                    value={stats.totalClients > 0 ? `${Math.round((stats.returningClients / stats.totalClients) * 100)}%` : '0%'}
                    icon={UserCheck}
                    trend={`${stats.returningClients} récurrents`}
                    isDark={isDark}
                    color="orange"
                  />
                </div>

                {/* Charts Row */}
                <div className="grid lg:grid-cols-2 gap-6">
                  {/* Revenue Evolution */}
                  <ChartCard title="Évolution du CA" isDark={isDark}>
                    <ResponsiveContainer width="100%" height={280}>
                      <AreaChart data={stats.ordersByMonth}>
                        <defs>
                          <linearGradient id="colorRevenue" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor={colors[0]} stopOpacity={0.3}/>
                            <stop offset="95%" stopColor={colors[0]} stopOpacity={0}/>
                          </linearGradient>
                        </defs>
                        <CartesianGrid strokeDasharray="3 3" stroke={isDark ? '#374151' : '#e5e7eb'} />
                        <XAxis dataKey="month" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                        <YAxis stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} tickFormatter={(v) => `₪${v}`} />
                        <Tooltip
                          contentStyle={{
                            backgroundColor: isDark ? '#1f2937' : '#ffffff',
                            border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                            borderRadius: '8px',
                            color: isDark ? '#ffffff' : '#000000'
                          }}
                          formatter={(value) => [formatCurrency(value as number), 'CA']}
                        />
                        <Area type="monotone" dataKey="revenue" stroke={colors[0]} fill="url(#colorRevenue)" strokeWidth={2} />
                      </AreaChart>
                    </ResponsiveContainer>
                  </ChartCard>

                  {/* Orders by Type */}
                  <ChartCard title="Répartition par type" isDark={isDark}>
                    <ResponsiveContainer width="100%" height={280}>
                      <PieChart>
                        <Pie
                          data={stats.ordersByType}
                          cx="50%"
                          cy="50%"
                          innerRadius={60}
                          outerRadius={100}
                          paddingAngle={5}
                          dataKey="count"
                          nameKey="type"
                          label={({ name, percent }) => `${name === 'GAME' ? 'Jeux' : 'Événements'} ${((percent || 0) * 100).toFixed(0)}%`}
                        >
                          {stats.ordersByType.map((entry, index) => (
                            <Cell key={`cell-${index}`} fill={colors[index % colors.length]} />
                          ))}
                        </Pie>
                        <Tooltip
                          contentStyle={{
                            backgroundColor: isDark ? '#1f2937' : '#ffffff',
                            border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                            borderRadius: '8px',
                            color: isDark ? '#ffffff' : '#000000'
                          }}
                        />
                      </PieChart>
                    </ResponsiveContainer>
                  </ChartCard>
                </div>

                {/* Popular Times */}
                <div className="grid lg:grid-cols-2 gap-6">
                  <ChartCard title="Jours populaires" isDark={isDark}>
                    <ResponsiveContainer width="100%" height={220}>
                      <BarChart data={stats.popularDays}>
                        <CartesianGrid strokeDasharray="3 3" stroke={isDark ? '#374151' : '#e5e7eb'} />
                        <XAxis dataKey="day" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                        <YAxis stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                        <Tooltip
                          contentStyle={{
                            backgroundColor: isDark ? '#1f2937' : '#ffffff',
                            border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                            borderRadius: '8px',
                            color: isDark ? '#ffffff' : '#000000'
                          }}
                        />
                        <Bar dataKey="count" fill={colors[0]} radius={[4, 4, 0, 0]} />
                      </BarChart>
                    </ResponsiveContainer>
                  </ChartCard>

                  <ChartCard title="Heures populaires" isDark={isDark}>
                    <ResponsiveContainer width="100%" height={220}>
                      <BarChart data={stats.popularHours}>
                        <CartesianGrid strokeDasharray="3 3" stroke={isDark ? '#374151' : '#e5e7eb'} />
                        <XAxis dataKey="hour" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                        <YAxis stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                        <Tooltip
                          contentStyle={{
                            backgroundColor: isDark ? '#1f2937' : '#ffffff',
                            border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                            borderRadius: '8px',
                            color: isDark ? '#ffffff' : '#000000'
                          }}
                        />
                        <Bar dataKey="count" fill={colors[3]} radius={[4, 4, 0, 0]} />
                      </BarChart>
                    </ResponsiveContainer>
                  </ChartCard>
                </div>
              </div>
            )}

            {/* Revenue Tab */}
            {activeTab === 'revenue' && (
              <div className="space-y-6">
                <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                  <KPICard title="CA Total" value={formatCurrency(stats.totalRevenue)} icon={DollarSign} isDark={isDark} color="green" />
                  <KPICard title="CA Encaissé" value={formatCurrency(stats.paidRevenue)} icon={CreditCard} isDark={isDark} color="blue" />
                  <KPICard title="CA En attente" value={formatCurrency(stats.pendingRevenue)} icon={Clock} isDark={isDark} color="orange" />
                  <KPICard title="Panier moyen" value={formatCurrency(stats.averageOrderValue)} icon={ShoppingCart} isDark={isDark} color="purple" />
                </div>

                {/* Revenue by Branch */}
                <ChartCard title="CA par branche" isDark={isDark}>
                  <ResponsiveContainer width="100%" height={300}>
                    <BarChart data={stats.ordersByBranch} layout="vertical">
                      <CartesianGrid strokeDasharray="3 3" stroke={isDark ? '#374151' : '#e5e7eb'} />
                      <XAxis type="number" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} tickFormatter={(v) => `₪${v}`} />
                      <YAxis type="category" dataKey="branch" stroke={isDark ? '#9ca3af' : '#6b7280'} width={100} fontSize={12} />
                      <Tooltip
                        contentStyle={{
                          backgroundColor: isDark ? '#1f2937' : '#ffffff',
                          border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                          borderRadius: '8px',
                          color: isDark ? '#ffffff' : '#000000'
                        }}
                        formatter={(value) => [formatCurrency(value as number), 'CA']}
                      />
                      <Bar dataKey="revenue" fill={colors[2]} radius={[0, 4, 4, 0]} />
                    </BarChart>
                  </ResponsiveContainer>
                </ChartCard>

                {/* Monthly Evolution with dual axis */}
                <ChartCard title="Évolution mensuelle" isDark={isDark}>
                  <ResponsiveContainer width="100%" height={300}>
                    <LineChart data={stats.ordersByMonth}>
                      <CartesianGrid strokeDasharray="3 3" stroke={isDark ? '#374151' : '#e5e7eb'} />
                      <XAxis dataKey="month" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                      <YAxis yAxisId="left" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} tickFormatter={(v) => `₪${v}`} />
                      <YAxis yAxisId="right" orientation="right" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                      <Tooltip
                        contentStyle={{
                          backgroundColor: isDark ? '#1f2937' : '#ffffff',
                          border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                          borderRadius: '8px',
                          color: isDark ? '#ffffff' : '#000000'
                        }}
                      />
                      <Legend />
                      <Line yAxisId="left" type="monotone" dataKey="revenue" name="CA" stroke={colors[0]} strokeWidth={2} dot={{ fill: colors[0] }} />
                      <Line yAxisId="right" type="monotone" dataKey="count" name="Commandes" stroke={colors[3]} strokeWidth={2} dot={{ fill: colors[3] }} />
                    </LineChart>
                  </ResponsiveContainer>
                </ChartCard>
              </div>
            )}

            {/* Orders Tab */}
            {activeTab === 'orders' && (
              <div className="space-y-6">
                <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                  <KPICard title="Total commandes" value={formatNumber(stats.totalOrders)} icon={ShoppingCart} isDark={isDark} color="blue" />
                  <KPICard title="Panier moyen" value={formatCurrency(stats.averageOrderValue)} icon={DollarSign} isDark={isDark} color="green" />
                  <KPICard
                    title="Jeux"
                    value={formatNumber(stats.ordersByType.find(t => t.type === 'GAME')?.count || 0)}
                    icon={Target}
                    isDark={isDark}
                    color="purple"
                  />
                  <KPICard
                    title="Événements"
                    value={formatNumber(stats.ordersByType.find(t => t.type === 'EVENT')?.count || 0)}
                    icon={PartyPopper}
                    isDark={isDark}
                    color="orange"
                  />
                </div>

                {/* Orders by Status */}
                <ChartCard title="Statut des commandes" isDark={isDark}>
                  <div className="grid grid-cols-2 md:grid-cols-5 gap-4 p-4">
                    {stats.ordersByStatus.map((status) => {
                      const statusStyle = STATUS_COLORS[status.status] || STATUS_COLORS.pending
                      return (
                        <div
                          key={status.status}
                          className={`rounded-lg p-4 text-center ${isDark ? statusStyle.dark : statusStyle.light}`}
                        >
                          <p className="text-3xl font-bold">{formatNumber(status.count)}</p>
                          <p className="text-sm opacity-80">{statusStyle.label}</p>
                        </div>
                      )
                    })}
                  </div>
                </ChartCard>

                {/* Orders Evolution */}
                <ChartCard title="Évolution des commandes" isDark={isDark}>
                  <ResponsiveContainer width="100%" height={300}>
                    <AreaChart data={stats.ordersByMonth}>
                      <defs>
                        <linearGradient id="colorCount" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="5%" stopColor={colors[3]} stopOpacity={0.3}/>
                          <stop offset="95%" stopColor={colors[3]} stopOpacity={0}/>
                        </linearGradient>
                      </defs>
                      <CartesianGrid strokeDasharray="3 3" stroke={isDark ? '#374151' : '#e5e7eb'} />
                      <XAxis dataKey="month" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                      <YAxis stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                      <Tooltip
                        contentStyle={{
                          backgroundColor: isDark ? '#1f2937' : '#ffffff',
                          border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                          borderRadius: '8px',
                          color: isDark ? '#ffffff' : '#000000'
                        }}
                      />
                      <Area type="monotone" dataKey="count" stroke={colors[3]} fill="url(#colorCount)" strokeWidth={2} />
                    </AreaChart>
                  </ResponsiveContainer>
                </ChartCard>
              </div>
            )}

            {/* Clients Tab */}
            {activeTab === 'clients' && (
              <div className="space-y-6">
                <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                  <KPICard title="Total clients" value={formatNumber(stats.totalClients)} icon={Users} isDark={isDark} color="blue" />
                  <KPICard title="Nouveaux ce mois" value={formatNumber(stats.newClientsThisMonth)} icon={UserCheck} trendUp={true} isDark={isDark} color="green" />
                  <KPICard title="Clients récurrents" value={formatNumber(stats.returningClients)} icon={TrendingUp} isDark={isDark} color="purple" />
                  <KPICard
                    title="Taux fidélité"
                    value={stats.totalClients > 0 ? `${Math.round((stats.returningClients / stats.totalClients) * 100)}%` : '0%'}
                    icon={Percent}
                    isDark={isDark}
                    color="orange"
                  />
                </div>

                {/* Top Clients */}
                <ChartCard title="Meilleurs clients" isDark={isDark}>
                  <div className="overflow-x-auto">
                    <table className="w-full">
                      <thead>
                        <tr className={`border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
                          <th className={`text-left py-3 px-4 font-medium ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>#</th>
                          <th className={`text-left py-3 px-4 font-medium ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>Client</th>
                          <th className={`text-center py-3 px-4 font-medium ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>Commandes</th>
                          <th className={`text-right py-3 px-4 font-medium ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>CA généré</th>
                        </tr>
                      </thead>
                      <tbody>
                        {stats.topClients.map((client, i) => (
                          <tr key={i} className={`border-b ${isDark ? 'border-gray-700/50 hover:bg-gray-800' : 'border-gray-100 hover:bg-gray-50'}`}>
                            <td className={`py-3 px-4 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{i + 1}</td>
                            <td className={`py-3 px-4 font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>{client.name}</td>
                            <td className={`py-3 px-4 text-center ${isDark ? 'text-gray-300' : 'text-gray-600'}`}>{client.orders}</td>
                            <td className={`py-3 px-4 text-right font-semibold ${isDark ? 'text-green-400' : 'text-green-600'}`}>{formatCurrency(client.revenue)}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </ChartCard>
              </div>
            )}

            {/* Team Tab */}
            {activeTab === 'team' && (
              <div className="space-y-6">
                <ChartCard title="Commandes par utilisateur" isDark={isDark}>
                  <ResponsiveContainer width="100%" height={Math.max(300, stats.ordersByUser.length * 50)}>
                    <BarChart data={stats.ordersByUser} layout="vertical">
                      <CartesianGrid strokeDasharray="3 3" stroke={isDark ? '#374151' : '#e5e7eb'} />
                      <XAxis type="number" stroke={isDark ? '#9ca3af' : '#6b7280'} fontSize={12} />
                      <YAxis type="category" dataKey="user" stroke={isDark ? '#9ca3af' : '#6b7280'} width={150} fontSize={12} />
                      <Tooltip
                        contentStyle={{
                          backgroundColor: isDark ? '#1f2937' : '#ffffff',
                          border: `1px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                          borderRadius: '8px',
                          color: isDark ? '#ffffff' : '#000000'
                        }}
                      />
                      <Bar dataKey="count" fill={colors[0]} radius={[0, 4, 4, 0]} />
                    </BarChart>
                  </ResponsiveContainer>
                </ChartCard>
              </div>
            )}
          </>
        ) : (
          <div className={`text-center py-20 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
            Aucune donnée disponible
          </div>
        )}
      </main>
    </div>
  )
}

// KPI Card Component
function KPICard({
  title,
  value,
  icon: Icon,
  trend,
  trendUp,
  isDark,
  color = 'blue'
}: {
  title: string
  value: string
  icon: React.ComponentType<{ className?: string }>
  trend?: string
  trendUp?: boolean
  isDark: boolean
  color?: 'blue' | 'green' | 'purple' | 'orange' | 'red'
}) {
  const colorClasses = {
    blue: {
      light: 'bg-blue-100 text-blue-600',
      dark: 'bg-blue-500/20 text-blue-400',
      value: isDark ? 'text-blue-400' : 'text-blue-600'
    },
    green: {
      light: 'bg-green-100 text-green-600',
      dark: 'bg-green-500/20 text-green-400',
      value: isDark ? 'text-green-400' : 'text-green-600'
    },
    purple: {
      light: 'bg-purple-100 text-purple-600',
      dark: 'bg-purple-500/20 text-purple-400',
      value: isDark ? 'text-purple-400' : 'text-purple-600'
    },
    orange: {
      light: 'bg-orange-100 text-orange-600',
      dark: 'bg-orange-500/20 text-orange-400',
      value: isDark ? 'text-orange-400' : 'text-orange-600'
    },
    red: {
      light: 'bg-red-100 text-red-600',
      dark: 'bg-red-500/20 text-red-400',
      value: isDark ? 'text-red-400' : 'text-red-600'
    }
  }

  const c = colorClasses[color]

  return (
    <div className={`rounded-xl p-5 ${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border`}>
      <div className="flex items-center justify-between mb-3">
        <span className={`text-sm font-medium ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{title}</span>
        <div className={`p-2 rounded-lg ${isDark ? c.dark : c.light}`}>
          <Icon className="w-4 h-4" />
        </div>
      </div>
      <p className={`text-2xl font-bold ${c.value}`}>{value}</p>
      {trend && (
        <div className={`flex items-center gap-1 mt-2 text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
          {trendUp !== undefined && (
            trendUp ? (
              <ArrowUpRight className="w-3 h-3 text-green-500" />
            ) : (
              <ArrowDownRight className="w-3 h-3 text-red-500" />
            )
          )}
          {trend}
        </div>
      )}
    </div>
  )
}

// Chart Card Component
function ChartCard({
  title,
  isDark,
  children
}: {
  title: string
  isDark: boolean
  children: React.ReactNode
}) {
  return (
    <div className={`rounded-xl p-5 ${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border`}>
      <h3 className={`text-lg font-semibold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>{title}</h3>
      {children}
    </div>
  )
}
</file>

<file path="src/app/api/admin/clara/conversations/route.ts">
/**
 * API pour gérer les conversations Clara
 * GET: Liste des conversations
 * PATCH: Renommer une conversation
 * DELETE: Supprimer une conversation
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'

// Types pour les conversations
interface ConversationMessage {
  id: string
  content: string
}

interface ConversationData {
  id: string
  title: string | null
  updated_at: string
  ai_messages: ConversationMessage[] | null
}

// GET - Liste des conversations
export async function GET() {
  try {
    const { success, errorResponse, user } = await verifyApiPermission('orders', 'view')
    if (!success || !user) {
      return errorResponse || NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })
    }
    const userId = user.id

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any

    // Récupérer les conversations de l'utilisateur
    const { data: conversations, error } = await supabase
      .from('ai_conversations')
      .select(`
        id,
        title,
        updated_at,
        ai_messages (
          id,
          content
        )
      `)
      .eq('user_id', userId)
      .order('updated_at', { ascending: false })
      .limit(50)

    if (error) {
      console.error('Error fetching conversations:', error)
      return NextResponse.json({ success: false, error: 'Failed to fetch conversations' }, { status: 500 })
    }

    // Formater les conversations
    const formattedConversations = (conversations as ConversationData[] | null)?.map(conv => ({
      id: conv.id,
      title: conv.title || generateTitle(conv.ai_messages),
      lastMessage: conv.ai_messages?.[0]?.content?.substring(0, 50) || '',
      updatedAt: conv.updated_at,
      messageCount: conv.ai_messages?.length || 0
    })) || []

    return NextResponse.json({
      success: true,
      conversations: formattedConversations
    })

  } catch (error) {
    console.error('Error in conversations API:', error)
    return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 })
  }
}

// PATCH - Renommer une conversation
export async function PATCH(request: NextRequest) {
  try {
    const { success, errorResponse, user } = await verifyApiPermission('orders', 'view')
    if (!success || !user) {
      return errorResponse || NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })
    }
    const userId = user.id

    const { conversationId, title } = await request.json()

    if (!conversationId || !title) {
      return NextResponse.json({ success: false, error: 'Missing conversationId or title' }, { status: 400 })
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any

    // Vérifier que la conversation appartient à l'utilisateur
    const { data: conv } = await supabase
      .from('ai_conversations')
      .select('id')
      .eq('id', conversationId)
      .eq('user_id', userId)
      .single()

    if (!conv) {
      return NextResponse.json({ success: false, error: 'Conversation not found' }, { status: 404 })
    }

    // Mettre à jour le titre
    const { error } = await supabase
      .from('ai_conversations')
      .update({ title })
      .eq('id', conversationId)

    if (error) {
      console.error('Error updating conversation:', error)
      return NextResponse.json({ success: false, error: 'Failed to update conversation' }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Error in conversations PATCH:', error)
    return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 })
  }
}

// DELETE - Supprimer une conversation
export async function DELETE(request: NextRequest) {
  try {
    const { success, errorResponse, user } = await verifyApiPermission('orders', 'view')
    if (!success || !user) {
      return errorResponse || NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })
    }
    const userId = user.id

    const { conversationId } = await request.json()

    if (!conversationId) {
      return NextResponse.json({ success: false, error: 'Missing conversationId' }, { status: 400 })
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any

    // Vérifier que la conversation appartient à l'utilisateur
    const { data: conv } = await supabase
      .from('ai_conversations')
      .select('id')
      .eq('id', conversationId)
      .eq('user_id', userId)
      .single()

    if (!conv) {
      return NextResponse.json({ success: false, error: 'Conversation not found' }, { status: 404 })
    }

    // Supprimer les messages d'abord (FK constraint)
    await supabase
      .from('ai_messages')
      .delete()
      .eq('conversation_id', conversationId)

    // Supprimer la conversation
    const { error } = await supabase
      .from('ai_conversations')
      .delete()
      .eq('id', conversationId)

    if (error) {
      console.error('Error deleting conversation:', error)
      return NextResponse.json({ success: false, error: 'Failed to delete conversation' }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Error in conversations DELETE:', error)
    return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 })
  }
}

// Helper pour générer un titre à partir des messages
function generateTitle(messages: ConversationMessage[] | null): string {
  if (!messages || messages.length === 0) return 'Sans titre'

  // Prendre le premier message utilisateur
  const firstMessage = messages[0]?.content || ''

  // Tronquer à 30 caractères
  if (firstMessage.length <= 30) return firstMessage
  return firstMessage.substring(0, 30) + '...'
}
</file>

<file path="src/app/api/orders/[id]/resend-email/route.ts">
/**
 * API Route: /api/orders/[id]/resend-email
 *
 * POST: Renvoyer l'email de confirmation pour une commande
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyApiPermission } from '@/lib/permissions'
import { sendBookingConfirmationEmail } from '@/lib/email-sender'
import type { Order, Booking, Branch } from '@/lib/supabase/types'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const permCheck = await verifyApiPermission('orders', 'edit')
  if (!permCheck.success) {
    return permCheck.errorResponse
  }

  const user = permCheck.user!
  const { id: orderId } = await params
  const supabase = await createClient()

  // Récupérer la commande avec la réservation et la branche
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select(`
      *,
      booking:bookings(*),
      branch:branches(*)
    `)
    .eq('id', orderId)
    .single<Order & { booking: Booking | null; branch: Branch | null }>()

  if (orderError || !order) {
    return NextResponse.json(
      { success: false, error: 'Order not found' },
      { status: 404 }
    )
  }

  // Vérifier l'accès à la branche
  if (user.role !== 'super_admin' && !user.branchIds.includes(order.branch_id!)) {
    return NextResponse.json(
      { success: false, error: 'Access denied' },
      { status: 403 }
    )
  }

  // Vérifier que la commande a un email
  if (!order.customer_email) {
    return NextResponse.json(
      { success: false, error: 'No email address for this order' },
      { status: 400 }
    )
  }

  // Vérifier que la commande a une réservation associée
  if (!order.booking) {
    return NextResponse.json(
      { success: false, error: 'No booking associated with this order' },
      { status: 400 }
    )
  }

  // Vérifier que la commande n'est pas annulée
  if (order.status === 'cancelled') {
    return NextResponse.json(
      { success: false, error: 'Cannot send email for cancelled order' },
      { status: 400 }
    )
  }

  try {
    // Préparer les données du booking pour l'envoi
    const booking = order.booking as Booking
    const branch = order.branch as Branch

    // Récupérer la langue préférée du contact si disponible
    let contactLocale: 'he' | 'fr' | 'en' = 'he'
    if (order.contact_id) {
      const { data: contactData } = await supabase
        .from('contacts')
        .select('preferred_locale')
        .eq('id', order.contact_id)
        .single<{ preferred_locale: string | null }>()
      if (contactData?.preferred_locale) {
        contactLocale = contactData.preferred_locale as 'he' | 'fr' | 'en'
      }
    }

    // Envoyer l'email avec le cgvToken (pour les commandes admin ET website)
    const result = await sendBookingConfirmationEmail({
      booking,
      branch,
      triggeredBy: user.id,
      locale: contactLocale,
      cgvToken: order.cgv_token || undefined,
    })

    if (!result.success) {
      return NextResponse.json(
        { success: false, error: result.error || 'Failed to send email' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailLogId: result.emailLogId,
    })
  } catch (error) {
    console.error('Error sending confirmation email:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/cgv/[token]/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useParams } from 'next/navigation'
import Image from 'next/image'
import { Loader2, CheckCircle, AlertCircle, FileText, Calendar, Users, X, Receipt } from 'lucide-react'

interface PriceBreakdownLine {
  description: string
  label?: string
  quantity: number
  unitPrice: number
  totalPrice: number
}

interface OrderInfo {
  id: string
  request_reference: string
  customer_first_name: string
  customer_last_name: string | null
  requested_date: string
  requested_time: string
  participants_count: number
  event_type: string | null
  cgv_validated_at: string | null
  branch_name: string
  booking_type: 'game' | 'event'
  preferred_locale: 'he' | 'fr' | 'en'
  priceBreakdown: PriceBreakdownLine[]
  subtotal: number
  discountAmount: number
  totalAmount: number
}

export default function CGVValidationPage() {
  const params = useParams()
  const token = params.token as string

  const [loading, setLoading] = useState(true)
  const [submitting, setSubmitting] = useState(false)
  const [order, setOrder] = useState<OrderInfo | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState(false)
  const [cgvAccepted, setCgvAccepted] = useState(false)
  const [showTermsModal, setShowTermsModal] = useState(false)
  const [termsContent, setTermsContent] = useState<{ game: string | null; event: string | null }>({ game: null, event: null })
  const [termsLoading, setTermsLoading] = useState(false)

  useEffect(() => {
    fetchOrder()
  }, [token])

  // Charger les CGV quand on a les infos de la commande
  useEffect(() => {
    if (order && !termsContent.game && !termsContent.event) {
      fetchTerms(order.preferred_locale)
    }
  }, [order])

  const fetchTerms = async (locale: string) => {
    setTermsLoading(true)
    try {
      const response = await fetch(`/api/terms?lang=${locale}`)
      if (response.ok) {
        const data = await response.json()
        setTermsContent({
          game: data.game,
          event: data.event
        })
      }
    } catch (err) {
      console.error('Error fetching terms:', err)
    } finally {
      setTermsLoading(false)
    }
  }

  const fetchOrder = async () => {
    try {
      const response = await fetch(`/api/cgv/${token}`)
      const data = await response.json()

      if (!data.success) {
        setError(data.error || 'Lien invalide ou expiré')
        return
      }

      setOrder(data.order)
    } catch (err) {
      console.error('Error fetching order:', err)
      setError('Erreur lors du chargement')
    } finally {
      setLoading(false)
    }
  }

  const handleSubmit = async () => {
    if (!cgvAccepted) return

    setSubmitting(true)
    try {
      const response = await fetch(`/api/cgv/${token}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ accepted: true })
      })

      const data = await response.json()

      if (!data.success) {
        setError(data.error || 'Erreur lors de la validation')
        return
      }

      setSuccess(true)
    } catch (err) {
      console.error('Error validating CGV:', err)
      setError('Erreur lors de la validation')
    } finally {
      setSubmitting(false)
    }
  }

  // Traductions multi-langues
  const translations: Record<string, Record<string, string>> = {
    he: {
      pageTitle: 'אישור תנאי שימוש',
      pageSubtitle: 'צפה בפרטי ההזמנה שלך ואשר את התנאים',
      actionRequired: '⚠️ נדרשת פעולה',
      orderDetails: 'פרטי ההזמנה שלך',
      reservationNumber: 'מספר הזמנה',
      date: 'תאריך',
      participants: 'משתתפים',
      eventType: 'סוג אירוע',
      room: 'חדר',
      games: 'משחקים',
      formula: 'נוסחה',
      unitPrice: 'מחיר ליחידה',
      subtotal: 'סכום ביניים',
      total: 'סה"כ לתשלום',
      termsCheckbox: 'קראתי ואני מאשר/ת את',
      termsLink: 'תנאי השימוש',
      validateButton: 'אישור תנאי השימוש',
      validating: 'מאשר...',
      alreadyValidated: 'התנאים אושרו',
      alreadyValidatedMessage: 'תודה! אישרת את תנאי השימוש להזמנה שלך.',
      invalidLink: 'קישור לא תקין',
      persons: 'אנשים',
      priceBreakdown: 'פירוט מחיר',
      description: 'תיאור',
      qty: 'כמות',
      discount: 'הנחה',
      event: 'אירוע',
      game: 'משחק',
    },
    fr: {
      pageTitle: 'Validation des CGV',
      pageSubtitle: 'Consultez les détails de votre commande et acceptez les conditions',
      actionRequired: '⚠️ Action requise',
      orderDetails: 'Détails de votre commande',
      reservationNumber: 'Numéro de réservation',
      date: 'Date',
      participants: 'Participants',
      eventType: "Type d'événement",
      room: 'Salle',
      games: 'parties',
      formula: 'Formule',
      unitPrice: 'Prix unitaire',
      subtotal: 'Sous-total',
      total: 'Total à payer',
      termsCheckbox: "J'ai lu et j'accepte les",
      termsLink: 'conditions générales de vente',
      validateButton: 'Confirmer et accepter les CGV',
      validating: 'Validation en cours...',
      alreadyValidated: 'CGV acceptées',
      alreadyValidatedMessage: 'Merci ! Vous avez accepté les conditions générales de vente pour votre réservation.',
      invalidLink: 'Lien invalide',
      persons: 'personnes',
      priceBreakdown: 'Détail du prix',
      description: 'Description',
      qty: 'Qté',
      discount: 'Remise',
      event: 'Événement',
      game: 'Jeu',
    },
    en: {
      pageTitle: 'Terms & Conditions',
      pageSubtitle: 'Review your order details and accept the terms',
      actionRequired: '⚠️ Action required',
      orderDetails: 'Your Order Details',
      reservationNumber: 'Reservation number',
      date: 'Date',
      participants: 'Participants',
      eventType: 'Event type',
      room: 'Room',
      games: 'games',
      formula: 'Formula',
      unitPrice: 'Unit price',
      subtotal: 'Subtotal',
      total: 'Total to pay',
      termsCheckbox: 'I have read and accept the',
      termsLink: 'terms and conditions',
      validateButton: 'Confirm and accept T&C',
      validating: 'Validating...',
      alreadyValidated: 'Terms accepted',
      alreadyValidatedMessage: 'Thank you! You have accepted the terms and conditions for your reservation.',
      invalidLink: 'Invalid link',
      persons: 'persons',
      priceBreakdown: 'Price Breakdown',
      description: 'Description',
      qty: 'Qty',
      discount: 'Discount',
      event: 'Event',
      game: 'Game',
    },
  }

  const t = (key: string) => {
    const locale = order?.preferred_locale || 'he'
    return translations[locale]?.[key] || translations['en'][key] || key
  }

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr)
    const locale = order?.preferred_locale || 'he'
    const localeMap = { he: 'he-IL', fr: 'fr-FR', en: 'en-US' }
    return date.toLocaleDateString(localeMap[locale], {
      weekday: 'long',
      day: 'numeric',
      month: 'long',
      year: 'numeric'
    })
  }

  const isRTL = order?.preferred_locale === 'he'

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-900">
        <Loader2 className="w-8 h-8 animate-spin text-cyan-500" />
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-900 px-4">
        <div className="max-w-md w-full text-center">
          <div className="flex justify-center mb-6">
            <div className="p-4 bg-red-900/30 rounded-full">
              <AlertCircle className="w-12 h-12 text-red-400" />
            </div>
          </div>
          <h1 className="text-2xl font-bold text-white mb-2">Lien invalide</h1>
          <p className="text-gray-400">{error}</p>
        </div>
      </div>
    )
  }

  if (!order) {
    return null
  }

  // Déjà validé - afficher quand même les détails
  if (order.cgv_validated_at || success) {
    return (
      <div className={`min-h-screen bg-gray-900 px-4 py-8 ${isRTL ? 'rtl' : 'ltr'}`} dir={isRTL ? 'rtl' : 'ltr'}>
        <div className="max-w-lg mx-auto">
          {/* Logos */}
          <div className="flex justify-center items-center gap-6 mb-8">
            <Image
              src="/images/logo-activegames.png"
              alt="Active Games"
              width={120}
              height={45}
              className="h-12 w-auto object-contain"
            />
            <Image
              src="/images/logo_laser_city.png"
              alt="Laser City"
              width={120}
              height={45}
              className="h-12 w-auto object-contain"
            />
          </div>

          {/* Success banner */}
          <div className="bg-green-900/30 border border-green-700 rounded-xl p-4 mb-6 flex items-center gap-3">
            <CheckCircle className="w-8 h-8 text-green-400 flex-shrink-0" />
            <div>
              <h2 className="text-lg font-semibold text-green-400">{t('alreadyValidated')}</h2>
              <p className="text-green-300/80 text-sm">{t('alreadyValidatedMessage')}</p>
            </div>
          </div>

          {/* Order details card */}
          <div className="bg-gray-800 rounded-2xl shadow-xl border border-gray-700 overflow-hidden">
            <div className="bg-gradient-to-r from-cyan-600 to-blue-600 px-6 py-4">
              <h1 className="text-xl font-bold text-white">{t('orderDetails')}</h1>
            </div>

            <div className="p-6">
              {/* Reference */}
              <div className="bg-gray-700/50 rounded-xl p-4 mb-6">
                <p className="text-sm text-gray-400 mb-1">{t('reservationNumber')}</p>
                <p className="text-2xl font-bold text-white">{order.request_reference}</p>
              </div>

              {/* Date & Participants */}
              <div className="grid grid-cols-2 gap-4 mb-6">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-gray-700 rounded-lg">
                    <Calendar className="w-5 h-5 text-cyan-400" />
                  </div>
                  <div>
                    <p className="text-sm text-gray-400">{t('date')}</p>
                    <p className="text-white text-sm">{formatDate(order.requested_date)}</p>
                    <p className="text-cyan-400 font-medium">{order.requested_time}</p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-gray-700 rounded-lg">
                    <Users className="w-5 h-5 text-cyan-400" />
                  </div>
                  <div>
                    <p className="text-sm text-gray-400">{t('participants')}</p>
                    <p className="text-white">{order.participants_count} {t('persons')}</p>
                  </div>
                </div>
              </div>

              {/* Price Breakdown Table - Same format as AccountingModal */}
              {order.priceBreakdown && order.priceBreakdown.length > 0 && (
                <div className="border-t border-gray-700 pt-4">
                  <h3 className="text-sm font-medium text-gray-400 mb-3 flex items-center gap-2">
                    <Receipt className="w-4 h-4" />
                    {t('priceBreakdown')}
                  </h3>

                  {/* Table */}
                  <div className="rounded-xl border border-gray-700 overflow-hidden">
                    {/* Table Header */}
                    <div className="grid grid-cols-12 gap-2 px-4 py-2 text-xs font-medium bg-gray-700/50 text-gray-400">
                      <div className="col-span-5">{t('description')}</div>
                      <div className="col-span-2 text-center">{t('qty')}</div>
                      <div className="col-span-2 text-right">{t('unitPrice')}</div>
                      <div className="col-span-3 text-right">{t('total')}</div>
                    </div>

                    {/* Table Rows */}
                    <div className="divide-y divide-gray-700">
                      {order.priceBreakdown.map((line, index) => (
                        <div key={index} className="grid grid-cols-12 gap-2 px-4 py-3 text-gray-300">
                          <div className="col-span-5">
                            <span className="font-medium text-white">{line.description}</span>
                            {line.label && (
                              <span className="block text-xs text-gray-500 mt-0.5">{line.label}</span>
                            )}
                          </div>
                          <div className="col-span-2 text-center">{line.quantity}</div>
                          <div className="col-span-2 text-right">{line.unitPrice.toLocaleString()} ₪</div>
                          <div className="col-span-3 text-right font-medium text-white">
                            {line.totalPrice.toLocaleString()} ₪
                          </div>
                        </div>
                      ))}
                    </div>

                    {/* Footer - Totals */}
                    <div className="px-4 py-3 bg-gray-700/30 space-y-2">
                      {/* Discount if any */}
                      {order.discountAmount > 0 && (
                        <>
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-400">{t('subtotal')}</span>
                            <span className="text-gray-300">{order.subtotal.toLocaleString()} ₪</span>
                          </div>
                          <div className="flex justify-between text-sm text-green-400">
                            <span>{t('discount')}</span>
                            <span>-{order.discountAmount.toLocaleString()} ₪</span>
                          </div>
                        </>
                      )}

                      {/* Total */}
                      <div className={`flex justify-between items-center pt-2 ${
                        order.discountAmount > 0 ? 'border-t border-gray-600' : ''
                      }`}>
                        <span className="text-lg font-bold text-white">{t('total')}</span>
                        <span className="text-2xl font-bold text-cyan-400">{order.totalAmount.toLocaleString()} ₪</span>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Footer */}
          <p className="text-center text-gray-500 text-sm mt-6">
            {order.branch_name} • Active Games World
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className={`min-h-screen bg-gray-900 px-4 py-8 ${isRTL ? 'rtl' : 'ltr'}`} dir={isRTL ? 'rtl' : 'ltr'}>
      <div className="max-w-lg mx-auto">
        {/* Logos */}
        <div className="flex justify-center items-center gap-6 mb-8">
          <Image
            src="/images/logo-activegames.png"
            alt="Active Games"
            width={140}
            height={53}
            className="h-14 w-auto object-contain"
          />
          <Image
            src="/images/logo_laser_city.png"
            alt="Laser City"
            width={140}
            height={53}
            className="h-14 w-auto object-contain"
          />
        </div>

        {/* Action Required Banner */}
        <div className="bg-amber-900/30 border border-amber-700 rounded-xl p-4 mb-6 flex items-center gap-3">
          <AlertCircle className="w-8 h-8 text-amber-400 flex-shrink-0" />
          <div>
            <h2 className="text-lg font-semibold text-amber-400">{t('actionRequired')}</h2>
            <p className="text-amber-300/80 text-sm">{t('pageSubtitle')}</p>
          </div>
        </div>

        {/* Card */}
        <div className="bg-gray-800 rounded-2xl shadow-xl border border-gray-700 overflow-hidden">
          {/* Header */}
          <div className="bg-gradient-to-r from-cyan-600 to-blue-600 px-6 py-4">
            <h1 className="text-xl font-bold text-white">{t('orderDetails')}</h1>
          </div>

          {/* Order Info */}
          <div className="p-6">
            {/* Reference - Highlighted */}
            <div className="bg-gray-700/50 rounded-xl p-4 mb-6">
              <p className="text-sm text-gray-400 mb-1">{t('reservationNumber')}</p>
              <p className="text-2xl font-bold text-white">{order.request_reference}</p>
            </div>

            {/* Date & Participants */}
            <div className="grid grid-cols-2 gap-4 mb-6">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-gray-700 rounded-lg">
                  <Calendar className="w-5 h-5 text-cyan-400" />
                </div>
                <div>
                  <p className="text-sm text-gray-400">{t('date')}</p>
                  <p className="text-white text-sm">{formatDate(order.requested_date)}</p>
                  <p className="text-cyan-400 font-medium">{order.requested_time}</p>
                </div>
              </div>
              <div className="flex items-center gap-3">
                <div className="p-2 bg-gray-700 rounded-lg">
                  <Users className="w-5 h-5 text-cyan-400" />
                </div>
                <div>
                  <p className="text-sm text-gray-400">{t('participants')}</p>
                  <p className="text-white">{order.participants_count} {t('persons')}</p>
                </div>
              </div>
            </div>

            {order.event_type && (
              <div className="flex items-center gap-3 mb-6">
                <div className="p-2 bg-gray-700 rounded-lg">
                  <FileText className="w-5 h-5 text-cyan-400" />
                </div>
                <div>
                  <p className="text-sm text-gray-400">{t('eventType')}</p>
                  <p className="text-white">{order.event_type}</p>
                </div>
              </div>
            )}

            {/* Price Breakdown Table - DEVIS */}
            {order.priceBreakdown && order.priceBreakdown.length > 0 && (
              <div className="border-t border-gray-700 pt-4 mb-6">
                <h3 className="text-sm font-medium text-gray-400 mb-3 flex items-center gap-2">
                  <Receipt className="w-4 h-4" />
                  {t('priceBreakdown')}
                </h3>

                {/* Table */}
                <div className="rounded-xl border border-gray-700 overflow-hidden">
                  {/* Table Header */}
                  <div className="grid grid-cols-12 gap-2 px-4 py-2 text-xs font-medium bg-gray-700/50 text-gray-400">
                    <div className="col-span-5">{t('description')}</div>
                    <div className="col-span-2 text-center">{t('qty')}</div>
                    <div className="col-span-2 text-right">{t('unitPrice')}</div>
                    <div className="col-span-3 text-right">{t('total')}</div>
                  </div>

                  {/* Table Rows */}
                  <div className="divide-y divide-gray-700">
                    {order.priceBreakdown.map((line, index) => (
                      <div key={index} className="grid grid-cols-12 gap-2 px-4 py-3 text-gray-300">
                        <div className="col-span-5">
                          <span className="font-medium text-white">{line.description}</span>
                          {line.label && (
                            <span className="block text-xs text-gray-500 mt-0.5">{line.label}</span>
                          )}
                        </div>
                        <div className="col-span-2 text-center">{line.quantity}</div>
                        <div className="col-span-2 text-right">{line.unitPrice.toLocaleString()} ₪</div>
                        <div className="col-span-3 text-right font-medium text-white">
                          {line.totalPrice.toLocaleString()} ₪
                        </div>
                      </div>
                    ))}
                  </div>

                  {/* Footer - Totals */}
                  <div className="px-4 py-3 bg-gray-700/30 space-y-2">
                    {/* Discount if any */}
                    {order.discountAmount > 0 && (
                      <>
                        <div className="flex justify-between text-sm">
                          <span className="text-gray-400">{t('subtotal')}</span>
                          <span className="text-gray-300">{order.subtotal.toLocaleString()} ₪</span>
                        </div>
                        <div className="flex justify-between text-sm text-green-400">
                          <span>{t('discount')}</span>
                          <span>-{order.discountAmount.toLocaleString()} ₪</span>
                        </div>
                      </>
                    )}

                    {/* Total */}
                    <div className={`flex justify-between items-center pt-2 ${
                      order.discountAmount > 0 ? 'border-t border-gray-600' : ''
                    }`}>
                      <span className="text-lg font-bold text-white">{t('total')}</span>
                      <span className="text-2xl font-bold text-cyan-400">{order.totalAmount.toLocaleString()} ₪</span>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* CGV Checkbox */}
            <div className="border-t border-gray-700 pt-6">
              <label className="flex items-start gap-3 cursor-pointer group">
                <input
                  type="checkbox"
                  checked={cgvAccepted}
                  onChange={(e) => setCgvAccepted(e.target.checked)}
                  className="mt-1 w-5 h-5 rounded border-gray-600 bg-gray-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-gray-800"
                />
                <span className="text-gray-300 text-sm leading-relaxed">
                  {t('termsCheckbox')}{' '}
                  <button
                    type="button"
                    onClick={() => setShowTermsModal(true)}
                    className="text-cyan-400 hover:text-cyan-300 underline"
                  >
                    {t('termsLink')}
                  </button>
                </span>
              </label>
            </div>

            {/* Submit Button */}
            <button
              onClick={handleSubmit}
              disabled={!cgvAccepted || submitting}
              className={`w-full mt-6 py-3 px-4 rounded-xl font-semibold transition-all flex items-center justify-center gap-2 ${
                cgvAccepted && !submitting
                  ? 'bg-cyan-600 hover:bg-cyan-700 text-white'
                  : 'bg-gray-700 text-gray-500 cursor-not-allowed'
              }`}
            >
              {submitting ? (
                <>
                  <Loader2 className="w-5 h-5 animate-spin" />
                  {t('validating')}
                </>
              ) : (
                <>
                  <CheckCircle className="w-5 h-5" />
                  {t('validateButton')}
                </>
              )}
            </button>
          </div>
        </div>

        {/* Footer */}
        <p className="text-center text-gray-500 text-sm mt-6">
          {order.branch_name} • Active Games World
        </p>
      </div>

      {/* Modal CGV */}
      {showTermsModal && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center p-4"
          onClick={() => setShowTermsModal(false)}
        >
          {/* Backdrop */}
          <div className="absolute inset-0 bg-black/80 backdrop-blur-sm" />

          {/* Modal */}
          <div
            className="relative bg-gray-800 rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col border border-gray-700"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Header */}
            <div className="flex items-center justify-between p-4 border-b border-gray-700">
              <h2 className="text-lg font-semibold text-white">
                Conditions Générales de Vente
              </h2>
              <button
                onClick={() => setShowTermsModal(false)}
                className="p-2 hover:bg-gray-700 rounded-lg transition-colors"
              >
                <X className="w-5 h-5 text-gray-400" />
              </button>
            </div>

            {/* Content */}
            <div className="flex-1 overflow-y-auto p-6">
              {termsLoading ? (
                <div className="flex items-center justify-center py-12">
                  <Loader2 className="w-8 h-8 animate-spin text-cyan-500" />
                </div>
              ) : (
                <div className="terms-content-wrapper">
                  {order.booking_type === 'event' && termsContent.event ? (
                    <div
                      className="terms-html-content"
                      dangerouslySetInnerHTML={{ __html: termsContent.event }}
                    />
                  ) : termsContent.game ? (
                    <div
                      className="terms-html-content"
                      dangerouslySetInnerHTML={{ __html: termsContent.game }}
                    />
                  ) : (
                    <p className="text-gray-400 text-center py-8">
                      Les conditions générales sont en cours de chargement...
                    </p>
                  )}
                </div>
              )}
              <style jsx global>{`
                .terms-html-content {
                  color: #e5e7eb;
                  line-height: 1.6;
                }
                .terms-html-content h2 {
                  color: #fff;
                  font-size: 1.25rem;
                  font-weight: 600;
                  margin-top: 1.5rem;
                  margin-bottom: 0.75rem;
                }
                .terms-html-content h2:first-child {
                  margin-top: 0;
                }
                .terms-html-content h3 {
                  color: #fff;
                  font-size: 1.1rem;
                  font-weight: 600;
                  margin-top: 1.25rem;
                  margin-bottom: 0.5rem;
                }
                .terms-html-content ul {
                  list-style-type: disc;
                  padding-left: 1.5rem;
                  margin: 0.5rem 0;
                }
                .terms-html-content li {
                  margin-bottom: 0.25rem;
                }
                .terms-html-content p {
                  margin-bottom: 0.75rem;
                }
                .terms-html-content strong {
                  color: #fff;
                  font-weight: 600;
                }
                .terms-html-content hr {
                  border-color: #374151;
                  margin: 1.5rem 0;
                }
              `}</style>
            </div>

            {/* Footer */}
            <div className="p-4 border-t border-gray-700">
              <button
                onClick={() => setShowTermsModal(false)}
                className="w-full py-2.5 px-4 bg-cyan-600 hover:bg-cyan-700 text-white rounded-xl font-medium transition-colors"
              >
                Fermer
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/components/Clara/ClaraButton.tsx">
'use client'

interface ClaraButtonProps {
  onClick: () => void
  isOpen?: boolean
}

export function ClaraButton({ onClick, isOpen }: ClaraButtonProps) {
  return (
    <button
      onClick={onClick}
      className={`relative flex items-center justify-center w-10 h-10 rounded-full transition-all duration-300 overflow-hidden ${
        isOpen
          ? 'bg-pink-100 border-2 border-pink-400 shadow-lg shadow-pink-300/30'
          : 'bg-pink-50 border border-pink-300 hover:border-pink-400'
      }`}
      title="Clara - Assistant IA"
    >
      {/* Icône vague / battement de coeur */}
      <svg
        viewBox="0 0 24 24"
        className={`w-5 h-5 ${isOpen ? 'text-pink-500' : 'text-pink-400'}`}
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      >
        {/* Forme de vague / battement cardiaque */}
        <path d="M2 12h2l3-9 4 18 4-9 3 0h4" />
      </svg>

      {/* Animation de pulse quand fermé */}
      {!isOpen && (
        <>
          {/* Onde qui s'étend */}
          <span className="absolute inset-0 rounded-full animate-ping bg-pink-300/20"></span>
          {/* Petit point lumineux */}
          <span className="absolute -top-0.5 -right-0.5 flex h-2.5 w-2.5">
            <span className="animate-pulse absolute inline-flex h-full w-full rounded-full bg-pink-400 opacity-75"></span>
            <span className="relative inline-flex rounded-full h-2.5 w-2.5 bg-pink-300"></span>
          </span>
        </>
      )}

      {/* Effet de glow quand ouvert */}
      {isOpen && (
        <span className="absolute inset-0 rounded-full bg-pink-200/30 animate-pulse"></span>
      )}
    </button>
  )
}
</file>

<file path="src/lib/payment-provider/icount/documents.ts">
/**
 * iCount Documents Module
 * Gestion des documents comptables (devis, factures, reçus)
 */

import { ICountClient } from './client'
import type { ProviderResult } from '../types'

// Types pour les documents iCount
export type ICountDocType = 'offer' | 'invoice' | 'receipt' | 'invrec' | 'deal' | 'order'

export interface ICountDocumentItem {
  description: string
  quantity: number
  unitprice?: number          // Prix HT (before VAT)
  unitprice_incvat?: number   // Prix TTC (including VAT) - préféré
  sku?: string
  inventory_item_id?: string
}

// Types de paiement iCount pour les documents (invrec, receipt)
export interface ICountCreditCardPayment {
  sum: number                    // Montant payé par CB
  card_type?: string             // VISA, MASTERCARD, AMEX, etc.
  card_number?: string           // 4 derniers chiffres (ex: "0000")
  confirmation_code?: string     // Code de confirmation de la transaction
  exp_year?: number              // Année d'expiration
  exp_month?: number             // Mois d'expiration
  holder_id?: string             // ID du titulaire (Teudat Zehut)
  holder_name?: string           // Nom du titulaire
  date?: string                  // Date de transaction (YYYY-MM-DD)
  num_of_payments?: number       // Nombre de paiements (1 si paiement unique)
  first_payment?: number         // Premier paiement si échelonné
}

export interface ICountCashPayment {
  sum: number                    // Montant en espèces
}

export interface ICountChequePayment {
  sum: number                    // Montant du chèque
  date: string                   // Date du chèque (YYYY-MM-DD)
  bank: number                   // Code banque
  branch: number                 // Code agence
  account: number                // Numéro de compte
  number: number                 // Numéro du chèque
}

export interface ICountBankTransferPayment {
  sum: number                    // Montant du virement
  date: string                   // Date du virement (YYYY-MM-DD)
  account?: number               // ID compte bancaire de destination dans iCount
}

export interface CreateDocumentParams {
  doctype: ICountDocType
  client_id?: number              // iCount client ID
  custom_client_id?: string       // ActiveLaser UUID (contact.id)
  client_name?: string            // Nom du client (si pas de client_id)
  email?: string                  // Email client
  phone?: string                  // Téléphone client
  doc_date?: string               // YYYY-MM-DD (défaut: aujourd'hui)
  duedate?: string                // Date d'échéance (pour offer/order)
  currency_code?: string          // "ILS" par défaut
  items: ICountDocumentItem[]
  hwc?: string                    // Commentaires additionnels
  doc_title?: string              // Titre du document
  sanity_string?: string          // Pour éviter les doublons (max 30 chars)
  send_email?: boolean            // Envoyer par email
  doc_lang?: string               // Langue du document (he/en/fr)
  // Paiements (pour invrec/receipt uniquement)
  cc?: ICountCreditCardPayment    // Paiement par carte de crédit
  cash?: ICountCashPayment        // Paiement en espèces
  cheques?: ICountChequePayment[] // Paiements par chèque(s)
  banktransfer?: ICountBankTransferPayment // Paiement par virement
}

export interface DocumentResult {
  doctype: string
  docnum: number
  doc_url?: string
  doc_copy_url?: string
  client_id?: number
  custom_client_id?: string
}

export interface DocumentInfo {
  doctype: string
  docnum: number
  client_id: number
  client_name: string
  doc_date: string
  currency_code: string
  totalsum: number
  totalwithvat: number
  status: number // 0=open, 1=closed, 2=partially closed
  items?: ICountDocumentItem[]
  doc_url?: string
  pdf_link?: string
}

interface ICountCreateResponse {
  status: boolean
  doctype?: string
  docnum?: number
  doc_url?: string
  doc_copy_url?: string
  client_id?: number
  custom_client_id?: string
  reason?: string
  error_description?: string
  [key: string]: unknown
}

interface ICountInfoResponse {
  status: boolean
  doctype?: string
  docnum?: number
  client_id?: number
  client_name?: string
  doc_date?: string
  currency_code?: string
  totalsum?: number
  totalwithvat?: number
  doc_status?: number
  items?: Array<{
    description: string
    unitprice: number
    quantity: number
  }>
  doc_url?: string
  pdf_link?: string
  reason?: string
  error_description?: string
  [key: string]: unknown
}

interface ICountCancelResponse {
  status: boolean
  reason?: string
  error_description?: string
  [key: string]: unknown
}

/**
 * Module de gestion des documents iCount
 */
export class ICountDocumentsModule {
  private client: ICountClient

  constructor(client: ICountClient) {
    this.client = client
  }

  /**
   * Créer un document (devis, facture, reçu, etc.)
   */
  async createDocument(params: CreateDocumentParams): Promise<ProviderResult<DocumentResult>> {
    const requestParams: Record<string, unknown> = {
      doctype: params.doctype,
      currency_code: params.currency_code || 'ILS',
      items: params.items.map(item => ({
        description: item.description,
        unitprice: item.unitprice,
        quantity: item.quantity,
        ...(item.unitprice_incvat && { unitprice_incvat: item.unitprice_incvat }),
        ...(item.sku && { sku: item.sku }),
      })),
    }

    // Client identification (order of priority)
    if (params.client_id) {
      requestParams.client_id = params.client_id
    } else if (params.custom_client_id) {
      requestParams.custom_client_id = params.custom_client_id
    }

    // Optional client info
    if (params.client_name) requestParams.client_name = params.client_name
    if (params.email) requestParams.email = params.email
    if (params.phone) requestParams.phone = params.phone

    // Dates
    if (params.doc_date) requestParams.doc_date = params.doc_date
    if (params.duedate) requestParams.duedate = params.duedate

    // Metadata
    if (params.hwc) requestParams.hwc = params.hwc
    if (params.doc_title) requestParams.doc_title = params.doc_title
    if (params.sanity_string) requestParams.sanity_string = params.sanity_string.slice(0, 30)
    if (params.doc_lang) requestParams.doc_lang = params.doc_lang

    // Email
    if (params.send_email) {
      requestParams.send_email = true
      requestParams.email_to_client = true
    }

    // Paiements (pour invrec/receipt)
    if (params.cc) {
      requestParams.cc = {
        sum: params.cc.sum,
        ...(params.cc.card_type && { card_type: params.cc.card_type }),
        ...(params.cc.card_number && { card_number: params.cc.card_number }),
        ...(params.cc.confirmation_code && { confirmation_code: params.cc.confirmation_code }),
        ...(params.cc.exp_year && { exp_year: params.cc.exp_year }),
        ...(params.cc.exp_month && { exp_month: params.cc.exp_month }),
        ...(params.cc.holder_id && { holder_id: params.cc.holder_id }),
        ...(params.cc.holder_name && { holder_name: params.cc.holder_name }),
        ...(params.cc.date && { date: params.cc.date }),
        ...(params.cc.num_of_payments && { num_of_payments: params.cc.num_of_payments }),
        ...(params.cc.first_payment && { first_payment: params.cc.first_payment }),
      }
    }

    if (params.cash) {
      requestParams.cash = { sum: params.cash.sum }
    }

    if (params.cheques && params.cheques.length > 0) {
      requestParams.cheques = params.cheques.map(cheque => ({
        sum: cheque.sum,
        date: cheque.date,
        bank: cheque.bank,
        branch: cheque.branch,
        account: cheque.account,
        number: cheque.number,
      }))
    }

    if (params.banktransfer) {
      requestParams.banktransfer = {
        sum: params.banktransfer.sum,
        date: params.banktransfer.date,
        ...(params.banktransfer.account && { account: params.banktransfer.account }),
      }
    }

    console.log('[ICOUNT DOCS] Creating document:', params.doctype, 'sanity:', params.sanity_string)

    const result = await this.client.request<ICountCreateResponse>('doc', 'create', requestParams)

    if (result.success && result.data) {
      const data = result.data
      if (data.docnum) {
        console.log('[ICOUNT DOCS] Document created:', data.doctype, data.docnum)
        return {
          success: true,
          data: {
            doctype: data.doctype || params.doctype,
            docnum: data.docnum,
            doc_url: data.doc_url,
            doc_copy_url: data.doc_copy_url,
            client_id: data.client_id,
            custom_client_id: data.custom_client_id,
          },
        }
      }
    }

    // Handle duplicate sanity_string error (document already exists)
    if (result.data?.reason === 'doc_exists_based_on_sanity_string') {
      console.log('[ICOUNT DOCS] Document already exists (sanity_string duplicate)')
      return {
        success: true, // Consider it a success - document exists
        data: {
          doctype: result.data.doctype || params.doctype,
          docnum: result.data.docnum || 0,
          doc_url: result.data.doc_url,
          doc_copy_url: result.data.doc_copy_url,
          client_id: result.data.client_id,
          custom_client_id: result.data.custom_client_id,
        },
      }
    }

    console.error('[ICOUNT DOCS] Failed to create document:', result.error)
    return {
      success: false,
      error: result.error || {
        code: 'create_failed',
        message: 'Failed to create document',
      },
    }
  }

  /**
   * Récupérer les informations d'un document
   */
  async getDocument(doctype: ICountDocType, docnum: number): Promise<ProviderResult<DocumentInfo>> {
    const result = await this.client.request<ICountInfoResponse>('doc', 'info', {
      doctype,
      docnum,
      get_items: true,
      get_pdf_link: true,
    })

    if (result.success && result.data) {
      const data = result.data
      return {
        success: true,
        data: {
          doctype: data.doctype || doctype,
          docnum: data.docnum || docnum,
          client_id: data.client_id || 0,
          client_name: data.client_name || '',
          doc_date: data.doc_date || '',
          currency_code: data.currency_code || 'ILS',
          totalsum: data.totalsum || 0,
          totalwithvat: data.totalwithvat || 0,
          status: data.doc_status || 0,
          items: data.items,
          doc_url: data.doc_url,
          pdf_link: data.pdf_link,
        },
      }
    }

    return {
      success: false,
      error: result.error || {
        code: 'get_failed',
        message: 'Failed to get document info',
      },
    }
  }

  /**
   * Annuler un document
   */
  async cancelDocument(
    doctype: ICountDocType,
    docnum: number,
    reason?: string,
    refundCreditCard?: boolean
  ): Promise<ProviderResult<void>> {
    console.log('[ICOUNT DOCS] Cancelling document:', doctype, docnum, refundCreditCard ? '(with CC refund)' : '')

    const result = await this.client.request<ICountCancelResponse>('doc', 'cancel', {
      doctype,
      docnum,
      reason: reason || 'Cancelled via ActiveLaser',
      ...(refundCreditCard && { refund_cc: true }),
    })

    if (result.success) {
      console.log('[ICOUNT DOCS] Document cancelled:', doctype, docnum)
      return { success: true }
    }

    console.error('[ICOUNT DOCS] Failed to cancel document:', result.error)
    return {
      success: false,
      error: result.error || {
        code: 'cancel_failed',
        message: 'Failed to cancel document',
      },
    }
  }

  /**
   * Annuler un document ET rembourser la transaction CB associée
   */
  async cancelDocumentWithRefund(
    doctype: ICountDocType,
    docnum: number,
    reason?: string
  ): Promise<ProviderResult<void>> {
    return this.cancelDocument(doctype, docnum, reason, true)
  }

  /**
   * Créer un devis (offer)
   * Raccourci pour createDocument avec doctype='offer'
   */
  async createOffer(
    params: Omit<CreateDocumentParams, 'doctype'>
  ): Promise<ProviderResult<DocumentResult>> {
    return this.createDocument({ ...params, doctype: 'offer' })
  }

  /**
   * Créer une facture+reçu combiné (invrec / חשבונית מס קבלה)
   * Raccourci pour createDocument avec doctype='invrec'
   */
  async createInvoiceReceipt(
    params: Omit<CreateDocumentParams, 'doctype'>
  ): Promise<ProviderResult<DocumentResult>> {
    return this.createDocument({ ...params, doctype: 'invrec' })
  }

  /**
   * Convertir un devis en facture+reçu (basé sur le devis)
   * Utile quand un paiement est reçu après un devis
   */
  async convertOfferToInvoiceReceipt(
    offerDocnum: number,
    additionalParams?: Partial<CreateDocumentParams>
  ): Promise<ProviderResult<DocumentResult>> {
    const params: CreateDocumentParams = {
      doctype: 'invrec',
      items: additionalParams?.items || [],
      ...additionalParams,
    }

    // Ajouter la référence au document de base
    const requestParams: Record<string, unknown> = {
      doctype: 'invrec',
      based_on: [{ doctype: 'offer', docnum: offerDocnum }],
      currency_code: params.currency_code || 'ILS',
    }

    if (params.client_id) requestParams.client_id = params.client_id
    if (params.custom_client_id) requestParams.custom_client_id = params.custom_client_id
    if (params.items && params.items.length > 0) {
      requestParams.items = params.items.map(item => ({
        description: item.description,
        unitprice: item.unitprice,
        quantity: item.quantity,
      }))
    }
    if (params.sanity_string) requestParams.sanity_string = params.sanity_string.slice(0, 30)

    console.log('[ICOUNT DOCS] Converting offer to invrec, offer:', offerDocnum)

    const result = await this.client.request<ICountCreateResponse>('doc', 'create', requestParams)

    if (result.success && result.data?.docnum) {
      console.log('[ICOUNT DOCS] InvRec created:', result.data.docnum)
      return {
        success: true,
        data: {
          doctype: result.data.doctype || 'invrec',
          docnum: result.data.docnum,
          doc_url: result.data.doc_url,
          doc_copy_url: result.data.doc_copy_url,
          client_id: result.data.client_id,
          custom_client_id: result.data.custom_client_id,
        },
      }
    }

    return {
      success: false,
      error: result.error || {
        code: 'convert_failed',
        message: 'Failed to convert offer to invoice/receipt',
      },
    }
  }
}
</file>

<file path="src/lib/payment-provider/icount/index.ts">
/**
 * iCount Payment Provider - Exports
 */

export { ICountClient } from './client'
export { ICountClientsModule } from './clients'
export { ICountDocumentsModule } from './documents'
export { ICountItemsModule } from './items'
export { ICountCreditCardModule } from './credit-card'
export type {
  ICountDocType,
  ICountDocumentItem,
  CreateDocumentParams,
  DocumentResult,
  DocumentInfo,
} from './documents'
export type {
  ItemData,
  SyncItemResult,
} from './items'
export type {
  CreditCardInfo,
  StoredCardInfo,
  J5PreapprovalResult,
  BillResult,
  StoreCardParams,
  J5PreapprovalParams,
  BillCardParams,
  GetTokenParams,
} from './credit-card'
</file>

<file path="src/lib/payment-provider/index.ts">
/**
 * Payment Provider Abstraction Layer - Main Exports
 */

import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import { ICountClient } from './icount/client'
import { ICountCreditCardModule } from './icount/credit-card'
import { ICountClientsModule } from './icount/clients'
import { ICountDocumentsModule } from './icount/documents'

// Types
export * from './types'

// iCount Client & Modules
export { ICountClient, ICountClientsModule, ICountDocumentsModule, ICountItemsModule, ICountCreditCardModule } from './icount'
export type {
  ICountDocType,
  ICountDocumentItem,
  CreateDocumentParams,
  DocumentResult,
  DocumentInfo,
  ItemData,
  SyncItemResult,
  CreditCardInfo,
  StoredCardInfo,
  J5PreapprovalResult,
  BillResult,
  StoreCardParams,
  J5PreapprovalParams,
  BillCardParams,
  GetTokenParams,
} from './icount'

/**
 * Unified Payment Provider with all modules
 */
export interface PaymentProviderModules {
  client: ICountClient
  creditCard: ICountCreditCardModule
  clients: ICountClientsModule
  documents: ICountDocumentsModule
}

// Cache for payment providers by branch
const providerCache = new Map<string, { provider: PaymentProviderModules; expiresAt: number }>()
const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

/**
 * Create a raw Supabase client for fetching credentials
 */
function createRawServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
  return createSupabaseClient(supabaseUrl, supabaseServiceKey, {
    auth: { autoRefreshToken: false, persistSession: false }
  })
}

/**
 * Get payment provider for a branch
 * Initializes iCount client with branch credentials and all modules
 */
export async function getPaymentProvider(branchId: string): Promise<PaymentProviderModules | null> {
  // Check cache
  const cached = providerCache.get(branchId)
  if (cached && Date.now() < cached.expiresAt) {
    return cached.provider
  }

  const supabase = createRawServiceClient()

  // Get credentials from database
  const { data, error } = await supabase
    .from('payment_credentials')
    .select('cid, username, password')
    .eq('branch_id', branchId)
    .eq('provider', 'icount')
    .eq('is_active', true)
    .single()

  if (error || !data) {
    console.error('No payment credentials found for branch:', branchId)
    return null
  }

  // Create iCount client
  const client = new ICountClient({
    cid: data.cid,
    user: data.username,
    pass: data.password,
  })

  // Create all modules
  const provider: PaymentProviderModules = {
    client,
    creditCard: new ICountCreditCardModule(client),
    clients: new ICountClientsModule(client),
    documents: new ICountDocumentsModule(client),
  }

  // Cache the provider
  providerCache.set(branchId, {
    provider,
    expiresAt: Date.now() + CACHE_TTL,
  })

  return provider
}

/**
 * Clear cached provider for a branch (e.g., when credentials are updated)
 */
export function clearPaymentProviderCache(branchId?: string): void {
  if (branchId) {
    providerCache.delete(branchId)
  } else {
    providerCache.clear()
  }
}
</file>

<file path="src/lib/icount-sync.ts">
/**
 * iCount Sync Service
 * Synchronise les contacts ActiveLaser vers iCount
 */

import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import { ICountClient, ICountClientsModule, ICountItemsModule } from '@/lib/payment-provider'
import type { Contact } from '@/lib/supabase/types'

interface ICountCredentials {
  cid: string
  user: string
  pass: string
}

// Create a raw Supabase client for fetching credentials
function createRawServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
  return createSupabaseClient(supabaseUrl, supabaseServiceKey, {
    auth: { autoRefreshToken: false, persistSession: false }
  })
}

/**
 * Get iCount credentials for a branch
 */
async function getICountCredentials(branchId: string): Promise<ICountCredentials | null> {
  const supabase = createRawServiceClient()

  const { data, error } = await supabase
    .from('payment_credentials')
    .select('cid, username, password')
    .eq('branch_id', branchId)
    .eq('provider', 'icount')
    .eq('is_active', true)
    .single()

  if (error || !data) {
    return null
  }

  return {
    cid: data.cid,
    user: data.username,
    pass: data.password
  }
}

/**
 * Build client name for iCount
 * - For companies: use company_name
 * - For individuals: use first_name + last_name
 */
function buildClientName(contact: Contact): string {
  if (contact.client_type === 'company' && contact.company_name) {
    return contact.company_name
  }
  return `${contact.first_name} ${contact.last_name || ''}`.trim()
}

/**
 * Log iCount sync result to activity_logs
 */
async function logICountSync(
  contact: Contact,
  branchId: string,
  success: boolean,
  icountClientId?: number,
  action?: 'created' | 'updated',
  error?: string
): Promise<void> {
  console.log('[ICOUNT SYNC LOG] Logging to activity_logs:', {
    contactId: contact.id,
    branchId,
    success,
    icountClientId,
    action,
    error
  })

  const supabase = createRawServiceClient()

  const { error: insertError } = await supabase.from('activity_logs').insert({
    user_id: null, // System action
    user_role: 'system',
    user_name: 'iCount Sync',
    action_type: 'contact_synced_icount',
    target_type: 'contact',
    target_id: contact.id,
    target_name: `${contact.first_name} ${contact.last_name || ''}`.trim(),
    branch_id: branchId,
    details: {
      success,
      icount_client_id: icountClientId || null,
      action: action || null,
      error: error || null,
      contact_name: buildClientName(contact),
      client_type: contact.client_type
    }
  })

  if (insertError) {
    console.error('[ICOUNT SYNC LOG] Failed to insert activity log:', insertError)
  } else {
    console.log('[ICOUNT SYNC LOG] Activity log inserted successfully')
  }
}

/**
 * Sync a contact to iCount
 * Returns the iCount client_id if successful
 */
export async function syncContactToICount(
  contact: Contact,
  branchId: string
): Promise<{ success: boolean; icountClientId?: number; error?: string }> {
  console.log('[ICOUNT SYNC] === START syncContactToICount ===')
  console.log('[ICOUNT SYNC] Contact:', contact.id, contact.first_name, contact.last_name)
  console.log('[ICOUNT SYNC] Branch:', branchId)

  try {
    // Get credentials for this branch
    const credentials = await getICountCredentials(branchId)
    console.log('[ICOUNT SYNC] Credentials found:', !!credentials)

    if (!credentials) {
      // No iCount configured for this branch - not an error, just skip
      console.log('[ICOUNT SYNC] No credentials for branch, skipping sync')
      return { success: true }
    }

    // Create iCount client and module
    const icountClient = new ICountClient(credentials)
    const clientsModule = new ICountClientsModule(icountClient)

    // Build data for iCount
    const clientData = {
      id: contact.id, // UUID ActiveLaser as custom_client_id
      name: buildClientName(contact),
      firstName: contact.first_name,
      lastName: contact.last_name || undefined,
      email: contact.email || undefined,
      phone: contact.phone,
      vatId: contact.vat_id || undefined,
    }

    // Sync to iCount (create_or_update)
    console.log('[ICOUNT SYNC] Calling iCount API...')
    const result = await clientsModule.syncClient(clientData)
    console.log('[ICOUNT SYNC] iCount API result:', JSON.stringify(result, null, 2))

    if (result.success && result.data?.providerId) {
      const icountClientId = parseInt(result.data.providerId, 10)
      const action = result.data.action as 'created' | 'updated'

      // Update contact with icount_client_id
      const supabase = createRawServiceClient()
      await supabase
        .from('contacts')
        .update({ icount_client_id: icountClientId })
        .eq('id', contact.id)

      // Log success
      await logICountSync(contact, branchId, true, icountClientId, action)

      return { success: true, icountClientId }
    }

    const errorMsg = result.error?.message || 'iCount sync failed'

    // Log failure
    await logICountSync(contact, branchId, false, undefined, undefined, errorMsg)

    return {
      success: false,
      error: errorMsg
    }

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'

    // Log error
    await logICountSync(contact, branchId, false, undefined, undefined, errorMsg)

    return {
      success: false,
      error: errorMsg
    }
  }
}

/**
 * Sync contact to iCount in background (non-blocking)
 * Use this when you don't want to wait for the sync
 */
export function syncContactToICountBackground(contact: Contact, branchId: string): void {
  console.log('[ICOUNT SYNC BG] Starting background sync for contact:', contact.id)
  // Fire and forget - don't await
  syncContactToICount(contact, branchId)
    .then((result) => {
      console.log('[ICOUNT SYNC BG] Background sync completed:', result)
    })
    .catch((err) => {
      console.error('[ICOUNT SYNC BG] Background sync error:', err)
    })
}

// ============================================
// PRODUCTS SYNC
// ============================================

interface ProductToSync {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  name_en: string | null
  unit_price: number
  is_active: boolean
}

/**
 * Sync a product to iCount
 * Creates or updates the item on iCount and stores the icount_item_id
 */
export async function syncProductToICount(product: ProductToSync): Promise<{
  success: boolean
  icount_item_id?: number
  icount_itemcode?: string
  error?: string
}> {
  console.log('[ICOUNT SYNC] Syncing product:', product.code, product.name)

  try {
    // Get credentials for this branch
    const credentials = await getICountCredentials(product.branch_id)

    if (!credentials) {
      console.log('[ICOUNT SYNC] No iCount credentials for branch, skipping sync')
      return { success: true } // Not an error, just no iCount configured
    }

    // Create iCount client and items module
    const icountClient = new ICountClient(credentials)
    const itemsModule = new ICountItemsModule(icountClient)

    // Sync the item
    const result = await itemsModule.syncItem({
      id: product.id,
      code: product.code,
      name: product.name,
      nameHe: product.name_he || undefined,
      nameEn: product.name_en || undefined,
      unitPrice: product.unit_price,
      active: product.is_active,
    })

    if (result.success && result.data) {
      console.log('[ICOUNT SYNC] Product synced:', result.data.providerId, result.data.action)

      // Update product with iCount IDs
      const supabase = createRawServiceClient()
      const { error: updateError } = await supabase
        .from('icount_products')
        .update({
          icount_item_id: parseInt(result.data.providerId),
          icount_itemcode: result.data.itemCode || product.code,
          icount_synced_at: new Date().toISOString(),
        })
        .eq('id', product.id)

      if (updateError) {
        console.warn('[ICOUNT SYNC] Failed to update product with iCount IDs:', updateError)
      }

      return {
        success: true,
        icount_item_id: parseInt(result.data.providerId),
        icount_itemcode: result.data.itemCode || product.code,
      }
    }

    const errorMsg = result.error?.message || 'Failed to sync item to iCount'
    console.error('[ICOUNT SYNC] Sync failed:', errorMsg)

    return {
      success: false,
      error: errorMsg,
    }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    console.error('[ICOUNT SYNC] Exception:', errorMsg)
    return {
      success: false,
      error: errorMsg,
    }
  }
}

/**
 * Sync a product in background (non-blocking)
 */
export function syncProductToICountBackground(product: ProductToSync): void {
  console.log('[ICOUNT SYNC BG] Starting background sync for product:', product.code)
  syncProductToICount(product)
    .then((result) => {
      console.log('[ICOUNT SYNC BG] Background sync completed:', result)
    })
    .catch((err) => {
      console.error('[ICOUNT SYNC BG] Background sync error:', err)
    })
}

/**
 * Sync all products for a branch to iCount
 * - Creates new products on iCount
 * - Updates existing products
 * - Deletes products that no longer exist in Supabase (admin is source of truth)
 */
export async function syncAllProductsToICount(branchId: string): Promise<{
  success: boolean
  synced: number
  deleted: number
  failed: number
  errors: string[]
}> {
  console.log('[ICOUNT SYNC] Syncing all products for branch:', branchId)

  const supabase = createRawServiceClient()
  const errors: string[] = []
  let synced = 0
  let deleted = 0
  let failed = 0

  // Get credentials for this branch
  const credentials = await getICountCredentials(branchId)
  if (!credentials) {
    console.log('[ICOUNT SYNC] No iCount credentials for branch, skipping sync')
    return { success: true, synced: 0, deleted: 0, failed: 0, errors: [] }
  }

  // Get all active products for this branch from Supabase (source of truth)
  const { data: products, error } = await supabase
    .from('icount_products')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)

  if (error || !products) {
    return {
      success: false,
      synced: 0,
      deleted: 0,
      failed: 0,
      errors: [error?.message || 'Failed to fetch products'],
    }
  }

  // Create set of active product codes from Supabase
  const activeProductCodes = new Set(products.map(p => p.code))

  // Sync each product to iCount (create/update)
  for (const product of products) {
    const result = await syncProductToICount(product as ProductToSync)
    if (result.success && result.icount_item_id) {
      synced++
    } else if (result.error) {
      failed++
      errors.push(`${product.code}: ${result.error}`)
    }
  }

  // Get all products from iCount
  const icountClient = new ICountClient(credentials)
  const itemsModule = new ICountItemsModule(icountClient)
  const icountItemsResult = await itemsModule.listItems()

  if (icountItemsResult.success && icountItemsResult.data) {
    // Find items on iCount that don't exist in Supabase
    const itemsToDelete = icountItemsResult.data.filter(
      item => !activeProductCodes.has(item.code)
    )

    if (itemsToDelete.length > 0) {
      console.log('[ICOUNT SYNC] Found orphan items to delete:', itemsToDelete.map(i => i.code))

      const idsToDelete = itemsToDelete.map(item => parseInt(item.providerId, 10))
      const deleteResult = await itemsModule.deleteItems(idsToDelete)

      if (deleteResult.success && deleteResult.data) {
        deleted = deleteResult.data.deleted.length
        console.log('[ICOUNT SYNC] Deleted orphan items:', deleted)
      } else {
        errors.push(`Delete failed: ${deleteResult.error?.message || 'Unknown error'}`)
      }
    }
  }

  console.log('[ICOUNT SYNC] Sync complete:', { synced, deleted, failed })

  return {
    success: failed === 0,
    synced,
    deleted,
    failed,
    errors,
  }
}

// ============================================
// EVENT FORMULA PRODUCT MANAGEMENT
// ============================================

interface EventFormulaForProduct {
  id: string
  branch_id: string
  name: string
  game_type: 'LASER' | 'ACTIVE' | 'BOTH'
  min_participants: number
  max_participants: number
  price_per_person: number
}

/**
 * Generate a stable product code for an event formula
 * Format: event_{game_type}_{min}_{max}
 * Example: event_laser_5_15, event_active_16_30
 */
export function generateEventProductCode(formula: EventFormulaForProduct): string {
  return `event_${formula.game_type.toLowerCase()}_${formula.min_participants}_${formula.max_participants}`
}

/**
 * Ensure a product exists for an event formula
 * - Creates product if it doesn't exist
 * - Updates price if formula.price_per_person changed
 * - Syncs to iCount
 * Returns the product_id to link to the formula
 */
export async function ensureEventProductForFormula(
  formula: EventFormulaForProduct
): Promise<{
  success: boolean
  productId?: string
  productCode?: string
  created?: boolean
  error?: string
}> {
  console.log('[ICOUNT SYNC] ensureEventProductForFormula:', formula.name, formula.game_type)

  const supabase = createRawServiceClient()
  const productCode = generateEventProductCode(formula)

  try {
    // 1. Check if product already exists for this branch + code
    const { data: existingProduct, error: findError } = await supabase
      .from('icount_products')
      .select('*')
      .eq('branch_id', formula.branch_id)
      .eq('code', productCode)
      .single()

    if (findError && findError.code !== 'PGRST116') {
      // PGRST116 = not found, other errors are real
      console.error('[ICOUNT SYNC] Error finding product:', findError)
      return { success: false, error: findError.message }
    }

    if (existingProduct) {
      console.log('[ICOUNT SYNC] Found existing product:', existingProduct.id, productCode)

      // Check if price needs updating
      if (existingProduct.unit_price !== formula.price_per_person) {
        console.log('[ICOUNT SYNC] Updating product price:', existingProduct.unit_price, '->', formula.price_per_person)

        const { error: updateError } = await supabase
          .from('icount_products')
          .update({
            unit_price: formula.price_per_person,
            name: formula.name,
            name_he: formula.name,
          })
          .eq('id', existingProduct.id)

        if (updateError) {
          console.error('[ICOUNT SYNC] Error updating product:', updateError)
          return { success: false, error: updateError.message }
        }

        // Sync updated product to iCount
        syncProductToICountBackground({
          ...existingProduct,
          unit_price: formula.price_per_person,
          name: formula.name,
          name_he: formula.name,
        } as ProductToSync)
      }

      return {
        success: true,
        productId: existingProduct.id,
        productCode,
        created: false,
      }
    }

    // 2. Create new product
    console.log('[ICOUNT SYNC] Creating new product:', productCode)

    const { data: newProduct, error: createError } = await supabase
      .from('icount_products')
      .insert({
        branch_id: formula.branch_id,
        code: productCode,
        name: formula.name,
        name_he: formula.name,
        name_en: formula.name,
        unit_price: formula.price_per_person,
        is_active: true,
        sort_order: 100, // Default sort order for event products
      })
      .select()
      .single()

    if (createError || !newProduct) {
      console.error('[ICOUNT SYNC] Error creating product:', createError)
      return { success: false, error: createError?.message || 'Failed to create product' }
    }

    console.log('[ICOUNT SYNC] Created new product:', newProduct.id, productCode)

    // Sync new product to iCount in background
    syncProductToICountBackground(newProduct as ProductToSync)

    return {
      success: true,
      productId: newProduct.id,
      productCode,
      created: true,
    }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    console.error('[ICOUNT SYNC] Exception in ensureEventProductForFormula:', errorMsg)
    return { success: false, error: errorMsg }
  }
}

/**
 * Update the price of a product linked to a formula
 * Called when price_per_person changes on a formula
 */
export async function updateEventProductPrice(
  productId: string,
  newPrice: number,
  branchId: string
): Promise<{ success: boolean; error?: string }> {
  console.log('[ICOUNT SYNC] updateEventProductPrice:', productId, newPrice)

  const supabase = createRawServiceClient()

  try {
    // Get the product
    const { data: product, error: findError } = await supabase
      .from('icount_products')
      .select('*')
      .eq('id', productId)
      .single()

    if (findError || !product) {
      return { success: false, error: findError?.message || 'Product not found' }
    }

    // Update price
    const { error: updateError } = await supabase
      .from('icount_products')
      .update({ unit_price: newPrice })
      .eq('id', productId)

    if (updateError) {
      return { success: false, error: updateError.message }
    }

    // Sync to iCount in background
    syncProductToICountBackground({
      ...product,
      unit_price: newPrice,
    } as ProductToSync)

    return { success: true }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    return { success: false, error: errorMsg }
  }
}

/**
 * Delete a product linked to a formula
 * Called when a formula is deleted/deactivated
 * - Deactivates product in Supabase
 * - iCount sync will delete it when next sync runs
 */
export async function deleteEventProduct(
  productId: string,
  branchId: string
): Promise<{ success: boolean; error?: string }> {
  console.log('[ICOUNT SYNC] deleteEventProduct:', productId)

  const supabase = createRawServiceClient()

  try {
    // Get the product to check it's an EVENT product
    const { data: product, error: findError } = await supabase
      .from('icount_products')
      .select('*')
      .eq('id', productId)
      .single()

    if (findError || !product) {
      return { success: false, error: findError?.message || 'Product not found' }
    }

    // Safety check: only delete products that start with 'event_'
    if (!product.code.startsWith('event_')) {
      console.warn('[ICOUNT SYNC] Refusing to delete non-event product:', product.code)
      return { success: false, error: 'Can only delete EVENT products' }
    }

    // Deactivate the product (soft delete)
    const { error: updateError } = await supabase
      .from('icount_products')
      .update({ is_active: false })
      .eq('id', productId)

    if (updateError) {
      return { success: false, error: updateError.message }
    }

    console.log('[ICOUNT SYNC] Product deactivated:', product.code)
    console.log('[ICOUNT SYNC] Note: Product will be deleted from iCount on next sync')

    return { success: true }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    return { success: false, error: errorMsg }
  }
}
</file>

<file path=".gitignore">
.next
node_modules
*.log
data/
.env.local
.env*.local
</file>

<file path="src/app/admin/emails/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import {
  Loader2,
  AlertCircle,
  Mail,
  Search,
  Calendar,
  RefreshCw,
  ArrowLeft,
  Filter
} from 'lucide-react'
import { useAuth } from '@/hooks/useAuth'
import { useBranches } from '@/hooks/useBranches'
import { useEmails } from '@/hooks/useEmails'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { EmailsTable } from './components/EmailsTable'
import { createClient } from '@/lib/supabase/client'

export default function EmailsPage() {
  const router = useRouter()
  const { t } = useTranslation()
  const { user, loading: authLoading } = useAuth()
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()

  // Theme state
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')

  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'

  // Get user role
  const userRole = user?.role || 'agent'

  // Emails hook
  const {
    emails,
    loading: emailsLoading,
    error,
    pagination,
    filters,
    setFilters,
    setPage,
    refresh,
    resendEmail,
    deleteEmail,
    stats
  } = useEmails(userRole === 'super_admin' ? undefined : selectedBranch?.id)

  // Local filter states
  const [searchTerm, setSearchTerm] = useState('')
  const [statusFilter, setStatusFilter] = useState('')
  const [dateFrom, setDateFrom] = useState('')
  const [dateTo, setDateTo] = useState('')
  const [showFilters, setShowFilters] = useState(false)

  // Check email status from Brevo API (polling)
  const [checkingStatus, setCheckingStatus] = useState(false)

  // Apply filters with debounce for search
  useEffect(() => {
    const timer = setTimeout(() => {
      setFilters({
        ...filters,
        search: searchTerm || undefined,
        status: statusFilter || undefined,
        dateFrom: dateFrom || undefined,
        dateTo: dateTo || undefined,
        branchId: userRole === 'super_admin' ? undefined : selectedBranch?.id
      })
    }, 300)

    return () => clearTimeout(timer)
  }, [searchTerm, statusFilter, dateFrom, dateTo, selectedBranch?.id, userRole])

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  // Loading state
  if (authLoading || branchesLoading || !user || !selectedBranch) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  const handleResend = async (emailId: string) => {
    const result = await resendEmail(emailId)
    if (!result.success) {
      alert(result.error || t('admin.emails.resend_error'))
    }
  }

  const handleDelete = async (emailId: string) => {
    if (confirm(t('admin.emails.delete_confirm'))) {
      const result = await deleteEmail(emailId)
      if (!result.success) {
        alert(result.error || t('admin.emails.delete_error'))
      }
    }
  }

  const handleCheckStatus = async () => {
    setCheckingStatus(true)
    try {
      const response = await fetch('/api/cron/check-email-status')
      const data = await response.json()
      console.log('[Email Status Check]', data)
      // Refresh the list to show updated statuses
      await refresh()
    } catch (err) {
      console.error('Error checking email status:', err)
    } finally {
      setCheckingStatus(false)
    }
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={handleSignOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sub-header with title */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            {/* Back button */}
            <button
              onClick={() => router.push('/admin/orders')}
              className={`p-2 rounded-lg transition-colors ${
                isDark ? 'hover:bg-gray-700 text-gray-400' : 'hover:bg-gray-100 text-gray-500'
              }`}
            >
              <ArrowLeft className="w-5 h-5" />
            </button>

            <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
              isDark ? 'bg-purple-500/20' : 'bg-purple-100'
            }`}>
              <Mail className={`w-6 h-6 ${isDark ? 'text-purple-400' : 'text-purple-600'}`} />
            </div>
            <div>
              <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.emails.title')}
              </h1>
              <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                {t('admin.emails.subtitle')}
              </p>
            </div>
          </div>

          {/* Stats badges */}
          <div className="flex items-center gap-4">
            <div className={`px-3 py-2 rounded-lg ${isDark ? 'bg-green-500/20' : 'bg-green-100'}`}>
              <div className={`text-xs ${isDark ? 'text-green-400' : 'text-green-600'}`}>
                {t('admin.emails.stats.sent')}
              </div>
              <div className={`text-lg font-bold ${isDark ? 'text-green-400' : 'text-green-600'}`}>
                {stats.sent}
              </div>
            </div>
            <div className={`px-3 py-2 rounded-lg ${isDark ? 'bg-red-500/20' : 'bg-red-100'}`}>
              <div className={`text-xs ${isDark ? 'text-red-400' : 'text-red-600'}`}>
                {t('admin.emails.stats.failed')}
              </div>
              <div className={`text-lg font-bold ${isDark ? 'text-red-400' : 'text-red-600'}`}>
                {stats.failed}
              </div>
            </div>
            <div className={`px-3 py-2 rounded-lg ${isDark ? 'bg-gray-700' : 'bg-gray-100'}`}>
              <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.emails.stats.total')}
              </div>
              <div className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {stats.total}
              </div>
            </div>

            {/* Check Brevo status button */}
            <button
              onClick={handleCheckStatus}
              disabled={checkingStatus || emailsLoading}
              title={t('admin.emails.check_status')}
              className={`flex items-center gap-2 px-3 py-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-purple-600 hover:bg-purple-500 text-white'
                  : 'bg-purple-500 hover:bg-purple-600 text-white'
              } disabled:opacity-50`}
            >
              <RefreshCw className={`w-4 h-4 ${checkingStatus ? 'animate-spin' : ''}`} />
              <span className="text-sm">{checkingStatus ? t('admin.emails.checking') : t('admin.emails.check_status')}</span>
            </button>

            {/* Refresh button */}
            <button
              onClick={refresh}
              disabled={emailsLoading}
              className={`p-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              } disabled:opacity-50`}
            >
              <RefreshCw className={`w-5 h-5 ${emailsLoading ? 'animate-spin' : ''}`} />
            </button>
          </div>
        </div>
      </div>

      {/* Search and filters */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-3`}>
        <div className="flex items-center gap-4">
          {/* Search */}
          <div className="flex-1 max-w-md relative">
            <Search className={`absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
            <input
              type="text"
              placeholder={t('admin.emails.search_placeholder')}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className={`w-full pl-10 pr-4 py-2 rounded-lg border text-sm ${
                isDark
                  ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-400'
                  : 'bg-gray-50 border-gray-200 text-gray-900 placeholder-gray-500'
              } focus:outline-none focus:ring-2 focus:ring-purple-500`}
            />
          </div>

          {/* Status filter */}
          <select
            value={statusFilter}
            onChange={(e) => setStatusFilter(e.target.value)}
            className={`px-3 py-2 rounded-lg border text-sm ${
              isDark
                ? 'bg-gray-700 border-gray-600 text-white'
                : 'bg-gray-50 border-gray-200 text-gray-900'
            } focus:outline-none focus:ring-2 focus:ring-purple-500`}
          >
            <option value="">{t('admin.emails.filter.all_status')}</option>
            <option value="sent">{t('admin.emails.status.sent')}</option>
            <option value="delivered">{t('admin.emails.status.delivered')}</option>
            <option value="failed">{t('admin.emails.status.failed')}</option>
            <option value="pending">{t('admin.emails.status.pending')}</option>
            <option value="bounced">{t('admin.emails.status.bounced')}</option>
          </select>

          {/* Toggle filters button */}
          <button
            onClick={() => setShowFilters(!showFilters)}
            className={`flex items-center gap-2 px-3 py-2 rounded-lg border text-sm ${
              isDark
                ? 'bg-gray-700 border-gray-600 text-white hover:bg-gray-600'
                : 'bg-gray-50 border-gray-200 text-gray-900 hover:bg-gray-100'
            }`}
          >
            <Filter className="w-4 h-4" />
            {t('admin.emails.filter.more')}
          </button>
        </div>

        {/* Extended filters */}
        {showFilters && (
          <div className="mt-3 pt-3 border-t border-gray-600 flex items-center gap-4">
            <div className="flex items-center gap-2">
              <Calendar className={`w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
              <input
                type="date"
                value={dateFrom}
                onChange={(e) => setDateFrom(e.target.value)}
                className={`px-3 py-2 rounded-lg border text-sm ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white'
                    : 'bg-gray-50 border-gray-200 text-gray-900'
                } focus:outline-none focus:ring-2 focus:ring-purple-500`}
              />
              <span className={isDark ? 'text-gray-500' : 'text-gray-400'}>-</span>
              <input
                type="date"
                value={dateTo}
                onChange={(e) => setDateTo(e.target.value)}
                className={`px-3 py-2 rounded-lg border text-sm ${
                  isDark
                    ? 'bg-gray-700 border-gray-600 text-white'
                    : 'bg-gray-50 border-gray-200 text-gray-900'
                } focus:outline-none focus:ring-2 focus:ring-purple-500`}
              />
            </div>
          </div>
        )}
      </div>

      {/* Main content */}
      <div className="p-6 space-y-6">
        {/* Error */}
        {error && (
          <div className={`p-4 rounded-lg border flex items-start gap-2 ${
            isDark
              ? 'bg-red-500/10 border-red-500/50 text-red-400'
              : 'bg-red-50 border-red-200 text-red-600'
          }`}>
            <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
            <span>{error}</span>
          </div>
        )}

        {/* Loading */}
        {emailsLoading && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 animate-spin text-purple-500" />
          </div>
        )}

        {/* Table */}
        {!emailsLoading && (
          <EmailsTable
            emails={emails}
            isDark={isDark}
            pagination={pagination}
            onPageChange={setPage}
            onResend={handleResend}
            onDelete={userRole === 'super_admin' ? handleDelete : undefined}
          />
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/api/admin/statistics/route.ts">
/**
 * API pour récupérer les statistiques agrégées
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'

// Helper to get date range
function getDateRange(range: string, customStart?: string, customEnd?: string): { start: Date; end: Date } {
  const now = new Date()
  let end = new Date(now)
  end.setHours(23, 59, 59, 999)

  let start = new Date(now)
  start.setHours(0, 0, 0, 0)

  // Support custom date range
  if (range === 'custom' && customStart && customEnd) {
    start = new Date(customStart)
    start.setHours(0, 0, 0, 0)
    end = new Date(customEnd)
    end.setHours(23, 59, 59, 999)
    return { start, end }
  }

  switch (range) {
    case 'today':
      // Already set to today
      break
    case 'week':
      start.setDate(start.getDate() - start.getDay()) // Start of week (Sunday)
      break
    case 'month':
      start.setDate(1)
      break
    case 'quarter':
      const quarter = Math.floor(start.getMonth() / 3)
      start.setMonth(quarter * 3, 1)
      break
    case 'year':
      start.setMonth(0, 1)
      break
    case 'all':
      start = new Date('2020-01-01')
      break
  }

  return { start, end }
}

// Helper to format month
function formatMonth(date: Date): string {
  return date.toLocaleDateString('fr-FR', { month: 'short', year: '2-digit' })
}

// Helper to get day name
function getDayName(dayIndex: number): string {
  const days = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam']
  return days[dayIndex]
}

export async function GET(request: NextRequest) {
  try {
    console.log('[Statistics API] Starting...')
    const { success, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success) {
      console.log('[Statistics API] Permission denied')
      return errorResponse
    }
    console.log('[Statistics API] Permission granted')

    const { searchParams } = new URL(request.url)
    const range = searchParams.get('range') || 'month'
    const branchId = searchParams.get('branch')
    const customStart = searchParams.get('startDate') || undefined
    const customEnd = searchParams.get('endDate') || undefined

    console.log('[Statistics API] Params:', { range, branchId, customStart, customEnd })

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const { start, end } = getDateRange(range, customStart, customEnd)
    console.log('[Statistics API] Date range:', { start: start.toISOString(), end: end.toISOString() })

    // Build base query conditions
    const baseConditions = {
      branch: branchId && branchId !== 'all' ? branchId : null,
      startDate: start.toISOString(),
      endDate: end.toISOString()
    }

    // === ORDERS DATA ===
    let ordersQuery = supabase
      .from('orders')
      .select('id, total_amount, paid_amount, payment_status, status, order_type, created_at, branch_id, contact_id')
      .gte('created_at', baseConditions.startDate)
      .lte('created_at', baseConditions.endDate)

    if (baseConditions.branch) {
      ordersQuery = ordersQuery.eq('branch_id', baseConditions.branch)
    }

    const { data: orders, error: ordersError } = await ordersQuery
    console.log('[Statistics API] Orders fetched:', orders?.length || 0, 'error:', ordersError)

    if (ordersError) {
      console.error('Error fetching orders:', ordersError)
      return NextResponse.json({ success: false, error: 'Failed to fetch orders', details: ordersError.message }, { status: 500 })
    }

    // === CONTACTS DATA ===
    let contactsQuery = supabase
      .from('contacts')
      .select('id, created_at, first_name, last_name')

    if (baseConditions.branch) {
      contactsQuery = contactsQuery.eq('branch_id_main', baseConditions.branch)
    }

    const { data: contacts, error: contactsError } = await contactsQuery
    console.log('[Statistics API] Contacts fetched:', contacts?.length || 0, 'error:', contactsError)

    if (contactsError) {
      console.error('Error fetching contacts:', contactsError)
    }

    // === USERS DATA === (non utilisé pour l'instant, pas de created_by dans orders)
    // const { data: users } = await supabase
    //   .from('profiles')
    //   .select('id, first_name, last_name')
    // const userMap = new Map<string, string>(users?.map((u: { id: string; first_name: string; last_name: string }) =>
    //   [u.id, `${u.first_name} ${u.last_name}`]
    // ) || [])

    // === BRANCHES DATA ===
    const { data: branches } = await supabase
      .from('branches')
      .select('id, name')

    const branchMap = new Map<string, string>(branches?.map((b: { id: string; name: string }) => [b.id, b.name]) || [])

    // === CALCULATE STATS ===

    // Revenue
    const totalRevenue = orders?.reduce((sum: number, o: { total_amount: number | null }) => sum + (o.total_amount || 0), 0) || 0
    const paidRevenue = orders?.reduce((sum: number, o: { paid_amount: number | null }) => sum + (o.paid_amount || 0), 0) || 0
    const pendingRevenue = totalRevenue - paidRevenue
    const totalOrders = orders?.length || 0
    const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0

    // Orders by status
    const statusCounts: Record<string, number> = {}
    orders?.forEach((o: { status: string }) => {
      statusCounts[o.status] = (statusCounts[o.status] || 0) + 1
    })
    const ordersByStatus = Object.entries(statusCounts).map(([status, count]) => ({ status, count }))

    // Orders by type
    const typeCounts: Record<string, number> = {}
    orders?.forEach((o: { order_type: string }) => {
      typeCounts[o.order_type] = (typeCounts[o.order_type] || 0) + 1
    })
    const ordersByType = Object.entries(typeCounts).map(([type, count]) => ({ type, count }))

    // Orders by month (last 12 months)
    const monthlyData: Record<string, { count: number; revenue: number }> = {}
    const now = new Date()
    for (let i = 11; i >= 0; i--) {
      const d = new Date(now.getFullYear(), now.getMonth() - i, 1)
      const key = formatMonth(d)
      monthlyData[key] = { count: 0, revenue: 0 }
    }
    orders?.forEach((o: { created_at: string; total_amount: number | null }) => {
      const date = new Date(o.created_at)
      const key = formatMonth(date)
      if (monthlyData[key]) {
        monthlyData[key].count++
        monthlyData[key].revenue += o.total_amount || 0
      }
    })
    const ordersByMonth = Object.entries(monthlyData).map(([month, data]) => ({
      month,
      count: data.count,
      revenue: data.revenue
    }))

    // Orders by branch
    const branchData: Record<string, { count: number; revenue: number }> = {}
    orders?.forEach((o: { branch_id: string; total_amount: number | null }) => {
      const branchName: string = branchMap.get(o.branch_id) || 'Unknown'
      if (!branchData[branchName]) {
        branchData[branchName] = { count: 0, revenue: 0 }
      }
      branchData[branchName].count++
      branchData[branchName].revenue += o.total_amount || 0
    })
    const ordersByBranch = Object.entries(branchData)
      .map(([branch, data]) => ({ branch, ...data }))
      .sort((a, b) => b.revenue - a.revenue)

    // Clients stats
    const totalClients = contacts?.length || 0
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1)
    const newClientsThisMonth = contacts?.filter((c: { created_at: string }) =>
      new Date(c.created_at) >= monthStart
    ).length || 0

    // Returning clients (those with more than 1 order)
    const clientOrderCounts: Record<string, number> = {}
    orders?.forEach((o: { contact_id: string | null }) => {
      if (o.contact_id) {
        clientOrderCounts[o.contact_id] = (clientOrderCounts[o.contact_id] || 0) + 1
      }
    })
    const returningClients = Object.values(clientOrderCounts).filter(count => count > 1).length

    // Top clients
    const clientRevenue: Record<string, { name: string; orders: number; revenue: number }> = {}
    orders?.forEach((o: { contact_id: string | null; total_amount: number | null }) => {
      if (o.contact_id) {
        if (!clientRevenue[o.contact_id]) {
          const contact = contacts?.find((c: { id: string }) => c.id === o.contact_id)
          clientRevenue[o.contact_id] = {
            name: contact ? `${contact.first_name} ${contact.last_name}` : 'Unknown',
            orders: 0,
            revenue: 0
          }
        }
        clientRevenue[o.contact_id].orders++
        clientRevenue[o.contact_id].revenue += o.total_amount || 0
      }
    })
    const topClients = Object.values(clientRevenue)
      .sort((a, b) => b.revenue - a.revenue)
      .slice(0, 10)

    // Orders by user - pas de colonne created_by, on skip cette stat pour l'instant
    const ordersByUser: { user: string; count: number }[] = []

    // Popular days
    const dayCounts: Record<number, number> = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 }
    orders?.forEach((o: { created_at: string }) => {
      const day = new Date(o.created_at).getDay()
      dayCounts[day]++
    })
    const popularDays = Object.entries(dayCounts).map(([day, count]) => ({
      day: getDayName(parseInt(day)),
      count
    }))

    // Popular hours
    const hourCounts: Record<number, number> = {}
    for (let i = 9; i <= 22; i++) {
      hourCounts[i] = 0
    }
    orders?.forEach((o: { created_at: string }) => {
      const hour = new Date(o.created_at).getHours()
      if (hourCounts[hour] !== undefined) {
        hourCounts[hour]++
      }
    })
    const popularHours = Object.entries(hourCounts).map(([hour, count]) => ({
      hour: `${hour}h`,
      count
    }))

    return NextResponse.json({
      success: true,
      stats: {
        // Revenue
        totalRevenue,
        totalOrders,
        paidRevenue,
        pendingRevenue,
        averageOrderValue,
        // Orders
        ordersByStatus,
        ordersByType,
        ordersByMonth,
        ordersByBranch,
        // Clients
        totalClients,
        newClientsThisMonth,
        returningClients,
        topClients,
        // Users
        ordersByUser,
        // Time
        popularDays,
        popularHours
      }
    })

  } catch (error) {
    console.error('Error in statistics API:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/payment/route.ts">
/**
 * API Route pour gérer les paiements d'une commande
 * POST: Enregistrer un paiement (carte, espèces, chèque, virement)
 * GET: Récupérer l'historique des paiements
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logOrderAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { getPaymentProvider } from '@/lib/payment-provider'
import type { UserRole } from '@/lib/supabase/types'

interface PaymentRequest {
  amount: number
  paymentType: 'full' | 'deposit' | 'balance'
  paymentMethod: 'card' | 'cash' | 'transfer' | 'check'
  // Pour les paiements par carte
  cardInfo?: {
    cc_number: string
    cc_validity: string
    cc_cvv: string
    cc_holder_id: string
    cc_holder_name?: string
  }
  tokenId?: number // Utiliser un token de carte stockée
  saveCard?: boolean // Sauvegarder la carte pour utilisation future
  useJ5?: boolean // Débiter une pré-autorisation existante
  usePreauth?: boolean // Utiliser une pré-autorisation existante
  preauthCode?: string // Code de la pré-autorisation
  // Pour les chèques
  checkNumber?: string
  checkBank?: string
  checkDate?: string
  // Pour les virements
  transferReference?: string
  // Notes
  notes?: string
  // Test mode (ne pas débiter réellement)
  isTest?: boolean
}

/**
 * GET /api/orders/[id]/payment
 * Récupérer l'historique des paiements
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // Récupérer la commande
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: order, error: orderError } = await (supabase as any)
      .from('orders')
      .select('*, payments(*)')
      .eq('id', id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied' },
          { status: 403 }
        )
      }
    }

    return NextResponse.json({
      success: true,
      paymentStatus: order.payment_status,
      totalAmount: order.total_amount,
      depositAmount: order.deposit_amount,
      paidAmount: order.paid_amount,
      payments: order.payments || [],
    })

  } catch (error) {
    console.error('Error fetching payment history:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/orders/[id]/payment
 * Enregistrer un paiement
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body: PaymentRequest = await request.json()
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Validation de base
    if (!body.amount || body.amount <= 0) {
      return NextResponse.json(
        { success: false, error: 'Invalid amount' },
        { status: 400 }
      )
    }

    if (!body.paymentType || !['full', 'deposit', 'balance'].includes(body.paymentType)) {
      return NextResponse.json(
        { success: false, error: 'Invalid payment type' },
        { status: 400 }
      )
    }

    if (!body.paymentMethod || !['card', 'cash', 'transfer', 'check'].includes(body.paymentMethod)) {
      return NextResponse.json(
        { success: false, error: 'Invalid payment method' },
        { status: 400 }
      )
    }

    // Récupérer la commande
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied' },
          { status: 403 }
        )
      }
    }

    // Vérifier si la commande est fermée
    if (order.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Cannot add payment to a closed order', messageKey: 'errors.orderClosed' },
        { status: 400 }
      )
    }

    let paymentResult: {
      success: boolean
      transactionId?: string
      confirmationCode?: string
      ccLast4?: string
      ccType?: string
      tokenId?: number
      icountDoctype?: string
      icountDocnum?: number
      icountDocUrl?: string
      error?: string
    } = { success: true }

    // Si paiement par carte, utiliser iCount
    if (body.paymentMethod === 'card') {
      console.log('[PAYMENT] Card payment requested:', {
        hasCardInfo: !!body.cardInfo,
        hasTokenId: !!body.tokenId,
        tokenId: body.tokenId,
        usePreauth: body.usePreauth,
        preauthCode: body.preauthCode,
      })

      if (!body.cardInfo && !body.tokenId) {
        console.log('[PAYMENT] ERROR: No card info and no token provided')
        return NextResponse.json(
          { success: false, error: 'Card info or token required for card payment' },
          { status: 400 }
        )
      }

      // Récupérer le provider de paiement
      const provider = await getPaymentProvider(order.branch_id)
      if (!provider) {
        return NextResponse.json(
          { success: false, error: 'Payment provider not configured' },
          { status: 500 }
        )
      }

      // Effectuer le paiement via iCount
      console.log('[PAYMENT] Calling iCount billCard with:', {
        customClientId: order.contact_id,
        tokenId: body.tokenId,
        hasCardInfo: !!body.cardInfo,
        amount: body.amount,
        useJ5IfAvailable: body.useJ5,
      })

      const billResult = await provider.creditCard.billCard({
        customClientId: order.contact_id || undefined,
        email: order.customer_email || undefined,
        clientName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
        tokenId: body.tokenId,
        cardInfo: body.cardInfo,
        amount: body.amount,
        currencyCode: 'ILS',
        useJ5IfAvailable: body.useJ5,
        description: `Paiement commande ${order.request_reference}`,
        isTest: body.isTest,
      })

      console.log('[PAYMENT] iCount billCard result:', JSON.stringify(billResult, null, 2))

      if (!billResult.success || !billResult.data) {
        console.log('[PAYMENT] Payment failed:', billResult.error)
        return NextResponse.json(
          {
            success: false,
            error: billResult.error?.message || 'Card payment failed',
            errorCode: billResult.error?.code,
          },
          { status: 400 }
        )
      }

      paymentResult = {
        success: true,
        transactionId: billResult.data.transaction_id,
        confirmationCode: billResult.data.confirmation_code,
        ccLast4: billResult.data.cc_last4,
        ccType: billResult.data.cc_type,
      }

      // Créer le document iCount (invrec) pour ce paiement
      console.log('[PAYMENT] Creating iCount document for payment')

      // Parser la validité pour extraire mois/année si on a les infos carte
      let expMonth: number | undefined
      let expYear: number | undefined
      if (body.cardInfo?.cc_validity) {
        const validity = body.cardInfo.cc_validity.replace(/[^0-9]/g, '')
        expMonth = parseInt(validity.slice(0, 2), 10)
        expYear = 2000 + parseInt(validity.slice(2, 4), 10)
      }

      const docResult = await provider.documents.createInvoiceReceipt({
        custom_client_id: order.contact_id || undefined,
        client_name: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
        email: order.customer_email || undefined,
        phone: order.customer_phone || undefined,
        items: [{
          description: `${body.paymentType === 'deposit' ? 'Acompte' : 'Paiement'} commande ${order.request_reference}`,
          quantity: 1,
          unitprice_incvat: body.amount,
        }],
        cc: {
          sum: body.amount,
          card_type: billResult.data.cc_type,
          card_number: billResult.data.cc_last4,
          confirmation_code: billResult.data.confirmation_code,
          exp_month: expMonth,
          exp_year: expYear,
          holder_id: body.cardInfo?.cc_holder_id,
          holder_name: body.cardInfo?.cc_holder_name || `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
          num_of_payments: 1,
        },
        sanity_string: `pay_${id.slice(0, 10)}_${Date.now()}`,
        doc_lang: 'he',
      })

      if (docResult.success && docResult.data) {
        console.log('[PAYMENT] iCount document created:', docResult.data.doctype, docResult.data.docnum)
        paymentResult.icountDoctype = docResult.data.doctype
        paymentResult.icountDocnum = docResult.data.docnum
        paymentResult.icountDocUrl = docResult.data.doc_url
      } else {
        // Log l'erreur mais on continue - le paiement a été effectué
        console.error('[PAYMENT] Failed to create iCount document:', docResult.error)
      }

      // Si demandé, sauvegarder la carte pour utilisation future
      if (body.saveCard && body.cardInfo && order.contact_id) {
        console.log('[PAYMENT] Attempting to store card for contact:', order.contact_id)
        try {
          const storeResult = await provider.creditCard.storeCard({
            customClientId: order.contact_id,
            email: order.customer_email || undefined,
            clientName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
            cardInfo: body.cardInfo,
          })

          console.log('[PAYMENT] Store card result:', JSON.stringify(storeResult, null, 2))

          if (storeResult.success && storeResult.data) {
            paymentResult.tokenId = storeResult.data.token_id

            // Mettre à jour le contact avec les infos de carte
            const { error: updateError } = await supabase
              .from('contacts')
              .update({
                icount_cc_token_id: storeResult.data.token_id,
                cc_last4: storeResult.data.cc_last4,
                cc_type: storeResult.data.cc_type,
                cc_expiry: storeResult.data.cc_validity,
              })
              .eq('id', order.contact_id)

            if (updateError) {
              console.error('[PAYMENT] Error updating contact with card:', updateError)
            } else {
              console.log('[PAYMENT] Card stored successfully, token:', storeResult.data.token_id)
            }
          } else {
            console.error('[PAYMENT] Store card failed:', storeResult.error)
          }
        } catch (storeError) {
          // Log l'erreur mais ne pas faire échouer le paiement
          console.error('[PAYMENT] Exception storing card:', storeError)
        }
      } else if (body.saveCard) {
        console.log('[PAYMENT] Cannot save card - missing:', {
          hasCardInfo: !!body.cardInfo,
          hasContactId: !!order.contact_id,
        })
      }
    }

    // Créer l'enregistrement de paiement
    const paymentData = {
      order_id: id,
      booking_id: order.booking_id,
      contact_id: order.contact_id,
      branch_id: order.branch_id,
      amount: body.amount,
      currency: 'ILS',
      payment_type: body.paymentType,
      payment_method: body.paymentMethod,
      status: 'completed',
      icount_transaction_id: paymentResult.transactionId,
      icount_confirmation_code: paymentResult.confirmationCode,
      icount_doctype: paymentResult.icountDoctype,
      icount_docnum: paymentResult.icountDocnum,
      icount_doc_url: paymentResult.icountDocUrl,
      cc_last4: paymentResult.ccLast4,
      cc_type: paymentResult.ccType,
      check_number: body.checkNumber,
      check_bank: body.checkBank,
      check_date: body.checkDate,
      transfer_reference: body.transferReference,
      notes: body.notes,
      processed_by: user.id,
    }

    const { data: payment, error: paymentError } = await supabase
      .from('payments')
      .insert(paymentData)
      .select()
      .single()

    if (paymentError) {
      console.error('Error creating payment record:', paymentError)
      return NextResponse.json(
        { success: false, error: 'Failed to record payment' },
        { status: 500 }
      )
    }

    // Calculer le nouveau montant payé
    const newPaidAmount = (order.paid_amount || 0) + body.amount
    const totalAmount = order.total_amount || 0

    // Déterminer le nouveau statut de paiement
    let newPaymentStatus = order.payment_status
    if (newPaidAmount >= totalAmount && totalAmount > 0) {
      newPaymentStatus = 'fully_paid'
    } else if (newPaidAmount > 0) {
      newPaymentStatus = 'deposit_paid'
    }

    // Mettre à jour la commande
    const updateData: Record<string, unknown> = {
      paid_amount: newPaidAmount,
      payment_status: newPaymentStatus,
      payment_method: body.paymentMethod,
      paid_at: new Date().toISOString(),
    }

    if (paymentResult.transactionId) {
      updateData.icount_transaction_id = paymentResult.transactionId
    }
    if (paymentResult.confirmationCode) {
      updateData.icount_confirmation_code = paymentResult.confirmationCode
    }
    if (paymentResult.ccLast4) {
      updateData.cc_last4 = paymentResult.ccLast4
      updateData.cc_type = paymentResult.ccType
    }

    await supabase
      .from('orders')
      .update(updateData)
      .eq('id', id)

    // Logger l'action
    await logOrderAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'updated',
      orderId: id,
      orderRef: order.request_reference,
      branchId: order.branch_id,
      details: {
        paymentAdded: true,
        amount: body.amount,
        paymentType: body.paymentType,
        paymentMethod: body.paymentMethod,
        newPaymentStatus,
        totalPaid: newPaidAmount,
      },
      ipAddress,
    })

    return NextResponse.json({
      success: true,
      payment: {
        id: payment.id,
        amount: body.amount,
        paymentType: body.paymentType,
        paymentMethod: body.paymentMethod,
        confirmationCode: paymentResult.confirmationCode,
      },
      orderPaymentStatus: newPaymentStatus,
      totalPaid: newPaidAmount,
      remaining: Math.max(0, totalAmount - newPaidAmount),
    })

  } catch (error) {
    console.error('Error processing payment:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/components/Clara/ClaraAssistant.tsx">
'use client'

import { useState, useRef, useEffect, useCallback } from 'react'
import {
  X,
  Send,
  Loader2,
  Maximize2,
  Minimize2,
  Move,
  Settings,
  CheckCircle,
  XCircle,
  AlertTriangle,
  Play,
  ChevronLeft,
  ChevronRight,
  RotateCcw,
  Mic,
  MicOff,
  MessageSquare,
  Trash2,
  Edit3,
  Check,
  Plus,
  ZoomIn,
  ZoomOut,
  Menu
} from 'lucide-react'
import Link from 'next/link'

interface ProposedAction {
  name: string
  params: Record<string, unknown>
  description: string
}

interface ChatMessage {
  id?: string
  role: 'user' | 'assistant'
  content: string
  proposedAction?: ProposedAction
  actionExecuted?: boolean
  actionResult?: {
    success: boolean
    message: string
    details?: Record<string, unknown>
  }
}

interface Conversation {
  id: string
  title: string
  lastMessage: string
  updatedAt: string
  messageCount: number
}

interface ClaraAssistantProps {
  isOpen: boolean
  onClose: () => void
  position?: 'left' | 'right'
  onPositionChange?: (position: 'left' | 'right') => void
  theme?: 'light' | 'dark'
}

// Tailles de police disponibles
const FONT_SIZES = [
  { label: 'Très petit', value: 12 },
  { label: 'Petit', value: 14 },
  { label: 'Normal', value: 16 },
  { label: 'Grand', value: 18 },
  { label: 'Très grand', value: 20 },
  { label: 'Énorme', value: 24 },
  { label: 'Maximum', value: 28 }
]

export function ClaraAssistant({
  isOpen,
  onClose,
  position = 'right',
  onPositionChange,
  theme = 'dark'
}: ClaraAssistantProps) {
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [conversationId, setConversationId] = useState<string | null>(null)
  const [conversations, setConversations] = useState<Conversation[]>([])
  const [showConversationList, setShowConversationList] = useState(false)
  const [editingConversationId, setEditingConversationId] = useState<string | null>(null)
  const [editingTitle, setEditingTitle] = useState('')
  const [fontSize, setFontSize] = useState(14)
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)
  const [isExpanded, setIsExpanded] = useState(false)
  const [isDetached, setIsDetached] = useState(false)
  const [detachedPosition, setDetachedPosition] = useState({ x: 100, y: 100 })
  const [detachedSize, setDetachedSize] = useState({ width: 400, height: 500 })
  const [isDragging, setIsDragging] = useState(false)
  const [isResizing, setIsResizing] = useState(false)
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 })
  const [isListening, setIsListening] = useState(false)
  const [speechSupported, setSpeechSupported] = useState(false)

  const chatEndRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLInputElement>(null)
  const panelRef = useRef<HTMLDivElement>(null)
  const recognitionRef = useRef<SpeechRecognitionInstance | null>(null)

  const isDark = theme === 'dark'

  // Charger la taille de police depuis localStorage
  useEffect(() => {
    const savedFontSize = localStorage.getItem('clara_font_size')
    if (savedFontSize) {
      setFontSize(parseInt(savedFontSize))
    }
  }, [])

  // Sauvegarder la taille de police
  const changeFontSize = (delta: number) => {
    const currentIndex = FONT_SIZES.findIndex(s => s.value === fontSize)
    const newIndex = Math.max(0, Math.min(FONT_SIZES.length - 1, currentIndex + delta))
    const newSize = FONT_SIZES[newIndex].value
    setFontSize(newSize)
    localStorage.setItem('clara_font_size', newSize.toString())
  }

  // Check si la reconnaissance vocale est supportée
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition
      setSpeechSupported(!!SpeechRecognitionAPI)
      if (SpeechRecognitionAPI) {
        recognitionRef.current = new SpeechRecognitionAPI()
        recognitionRef.current.continuous = false
        recognitionRef.current.interimResults = false
        recognitionRef.current.lang = 'fr-FR'

        recognitionRef.current.onresult = (event: SpeechRecognitionEvent) => {
          const transcript = event.results[0][0].transcript
          setInput(prev => prev + ' ' + transcript.trim())
          setIsListening(false)
        }

        recognitionRef.current.onerror = () => {
          setIsListening(false)
        }

        recognitionRef.current.onend = () => {
          setIsListening(false)
        }
      }
    }
  }, [])

  // Charger l'historique au montage
  useEffect(() => {
    if (isOpen) {
      loadConversations()
      loadConversation()
    }
  }, [isOpen])

  // Auto-scroll to bottom
  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  // Focus input when opening
  useEffect(() => {
    if (isOpen && !showConversationList) {
      setTimeout(() => inputRef.current?.focus(), 100)
    }
  }, [isOpen, showConversationList])

  // Charger la liste des conversations
  const loadConversations = async () => {
    try {
      const response = await fetch('/api/admin/clara/conversations')
      const data = await response.json()
      if (data.success) {
        setConversations(data.conversations || [])
      }
    } catch (error) {
      console.error('Error loading conversations:', error)
    }
  }

  // Charger une conversation spécifique
  const loadConversation = async (convId?: string) => {
    try {
      const url = convId
        ? `/api/admin/statistics/ask?conversationId=${convId}`
        : '/api/admin/statistics/ask'
      const response = await fetch(url)
      const data = await response.json()
      if (data.success && data.messages) {
        setConversationId(data.conversationId)
        setMessages(data.messages.map((m: { id: string; role: string; content: string; metadata?: { proposedAction?: ProposedAction; actionResult?: { success: boolean; message: string } } }) => ({
          id: m.id,
          role: m.role as 'user' | 'assistant',
          content: m.content,
          proposedAction: m.metadata?.proposedAction,
          actionExecuted: !!m.metadata?.actionResult,
          actionResult: m.metadata?.actionResult
        })))
      } else {
        setMessages([])
        setConversationId(convId || null)
      }
      setShowConversationList(false)
    } catch (error) {
      console.error('Error loading conversation:', error)
    }
  }

  // Sélectionner une conversation
  const selectConversation = (conv: Conversation) => {
    loadConversation(conv.id)
  }

  // Nouvelle conversation
  const startNewConversation = async () => {
    setMessages([])
    setConversationId(null)
    setShowConversationList(false)
    inputRef.current?.focus()
  }

  // Renommer une conversation
  const renameConversation = async (convId: string, newTitle: string) => {
    try {
      await fetch('/api/admin/clara/conversations', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ conversationId: convId, title: newTitle })
      })
      setConversations(prev => prev.map(c =>
        c.id === convId ? { ...c, title: newTitle } : c
      ))
      setEditingConversationId(null)
    } catch (error) {
      console.error('Error renaming conversation:', error)
    }
  }

  // Supprimer une conversation
  const deleteConversation = async (convId: string) => {
    if (!confirm('Supprimer cette conversation ?')) return
    try {
      await fetch('/api/admin/clara/conversations', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ conversationId: convId })
      })
      setConversations(prev => prev.filter(c => c.id !== convId))
      if (conversationId === convId) {
        setMessages([])
        setConversationId(null)
      }
    } catch (error) {
      console.error('Error deleting conversation:', error)
    }
  }

  // Toggle microphone
  const toggleListening = () => {
    if (!recognitionRef.current) return
    if (isListening) {
      recognitionRef.current.stop()
      setIsListening(false)
    } else {
      recognitionRef.current.start()
      setIsListening(true)
    }
  }

  // Handle dragging for detached window
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (!isDetached) return
    setIsDragging(true)
    setDragOffset({
      x: e.clientX - detachedPosition.x,
      y: e.clientY - detachedPosition.y
    })
  }, [isDetached, detachedPosition])

  useEffect(() => {
    if (!isDragging) return
    const handleMouseMove = (e: MouseEvent) => {
      setDetachedPosition({
        x: e.clientX - dragOffset.x,
        y: e.clientY - dragOffset.y
      })
    }
    const handleMouseUp = () => setIsDragging(false)
    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)
    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [isDragging, dragOffset])

  // Handle resizing for detached window
  const handleResizeStart = useCallback((e: React.MouseEvent) => {
    e.stopPropagation()
    setIsResizing(true)
  }, [])

  useEffect(() => {
    if (!isResizing) return
    const handleMouseMove = (e: MouseEvent) => {
      setDetachedSize({
        width: Math.max(300, e.clientX - detachedPosition.x),
        height: Math.max(300, e.clientY - detachedPosition.y)
      })
    }
    const handleMouseUp = () => setIsResizing(false)
    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)
    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [isResizing, detachedPosition])

  // Send message to Clara
  const sendMessage = async () => {
    if (!input.trim() || loading) return

    const userMessage = input.trim()
    setInput('')
    setMessages(prev => [...prev, { role: 'user', content: userMessage }])
    setLoading(true)

    try {
      const response = await fetch('/api/admin/statistics/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: userMessage,
          conversationId
        })
      })

      const data = await response.json()

      if (data.success) {
        if (data.conversationId) {
          setConversationId(data.conversationId)
        }
        setMessages(prev => [...prev, {
          role: 'assistant',
          content: data.answer || "Hmm, je n'ai pas compris. Tu peux reformuler ?",
          proposedAction: data.proposedAction
        }])
        // Recharger la liste des conversations
        loadConversations()
      } else {
        setMessages(prev => [...prev, {
          role: 'assistant',
          content: data.error || "Désolée, j'ai eu un souci. Réessaie !"
        }])
      }
    } catch (error) {
      console.error('Clara error:', error)
      setMessages(prev => [...prev, {
        role: 'assistant',
        content: "Oups ! Je n'arrive pas à me connecter. Vérifie que la clé API est configurée."
      }])
    } finally {
      setLoading(false)
    }
  }

  // Execute proposed action
  const handleExecuteAction = async (action: ProposedAction, messageIndex: number) => {
    setLoading(true)
    try {
      const response = await fetch('/api/admin/statistics/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          executeActions: true,
          conversationId,
          pendingAction: {
            name: action.name,
            params: action.params
          }
        })
      })

      const data = await response.json()

      setMessages(prev => prev.map((msg, i) => {
        if (i === messageIndex) {
          return {
            ...msg,
            actionExecuted: true,
            actionResult: data.actionResult
          }
        }
        return msg
      }))
    } catch (error) {
      console.error('Action error:', error)
      setMessages(prev => prev.map((msg, i) => {
        if (i === messageIndex) {
          return {
            ...msg,
            actionExecuted: true,
            actionResult: { success: false, message: "Erreur lors de l'exécution" }
          }
        }
        return msg
      }))
    } finally {
      setLoading(false)
    }
  }

  // Cancel action
  const handleCancelAction = (messageIndex: number) => {
    setMessages(prev => prev.map((msg, i) => {
      if (i === messageIndex) {
        return {
          ...msg,
          actionExecuted: true,
          actionResult: { success: false, message: "Action annulée" }
        }
      }
      return msg
    }))
  }

  // Handle key press
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      sendMessage()
    }
  }

  if (!isOpen) return null

  // Determine panel styles based on mode
  const getPanelStyles = () => {
    if (isDetached) {
      return {
        position: 'fixed' as const,
        left: detachedPosition.x,
        top: detachedPosition.y,
        width: detachedSize.width,
        height: detachedSize.height,
        zIndex: 9999
      }
    }
    const baseStyles = {
      position: 'fixed' as const,
      top: 0,
      bottom: 0,
      zIndex: 50,
      width: isExpanded ? '50vw' : '400px',
      maxWidth: isExpanded ? '800px' : '400px',
      transition: 'width 0.3s ease'
    }
    if (position === 'left') {
      return { ...baseStyles, left: 0 }
    }
    return { ...baseStyles, right: 0 }
  }

  // Classes de thème
  const themeClasses = {
    panel: isDark ? 'bg-gray-900 border-cyan-500/20' : 'bg-white border-gray-200',
    header: isDark ? 'border-cyan-500/20 bg-gradient-to-r from-cyan-500/10 to-teal-500/10' : 'border-gray-200 bg-gradient-to-r from-cyan-50 to-teal-50',
    headerText: isDark ? 'text-white' : 'text-gray-900',
    headerSubtext: isDark ? 'text-gray-400' : 'text-gray-500',
    iconButton: isDark ? 'hover:bg-white/10 text-gray-400 hover:text-white' : 'hover:bg-gray-100 text-gray-500 hover:text-gray-700',
    chatBg: isDark ? '' : 'bg-gray-50',
    userBubble: isDark ? 'bg-cyan-500/20 text-white' : 'bg-cyan-500 text-white',
    assistantBubble: isDark ? 'bg-gray-800 text-gray-200' : 'bg-white text-gray-800 border border-gray-200 shadow-sm',
    input: isDark ? 'bg-gray-800 border-cyan-500/20 text-white placeholder-gray-500' : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400',
    actionBox: isDark ? 'bg-gray-800/80 border-orange-500/30' : 'bg-orange-50 border-orange-200',
    backdrop: isDark ? 'bg-black/50' : 'bg-black/30',
    conversationItem: isDark ? 'hover:bg-gray-800 border-gray-700' : 'hover:bg-gray-100 border-gray-200',
    conversationItemActive: isDark ? 'bg-cyan-500/20 border-cyan-500' : 'bg-cyan-50 border-cyan-500'
  }

  return (
    <>
      {/* Backdrop for side panel mode */}
      {!isDetached && (
        <div
          className={`fixed inset-0 z-40 ${themeClasses.backdrop}`}
          onClick={onClose}
        />
      )}

      {/* Main Panel */}
      <div
        ref={panelRef}
        style={getPanelStyles()}
        className={`flex flex-col shadow-2xl ${themeClasses.panel} ${
          isDetached ? 'rounded-xl border' : ''
        } ${!isDetached && position === 'left' ? 'border-r' : !isDetached ? 'border-l' : ''}`}
      >
        {/* Header */}
        <div
          className={`flex items-center justify-between px-4 py-3 border-b ${themeClasses.header} ${
            isDetached ? 'cursor-move rounded-t-xl' : ''
          }`}
          onMouseDown={isDetached ? handleMouseDown : undefined}
        >
          <div className="flex items-center gap-3">
            {/* Logo Clara - Vague / Battement */}
            <div className="w-8 h-8 rounded-full bg-gradient-to-r from-cyan-500 to-teal-400 flex items-center justify-center">
              <svg viewBox="0 0 24 24" className="w-4 h-4 text-white" fill="none" stroke="currentColor" strokeWidth="2.5">
                <path d="M2 12h2l3-7 4 14 4-7 3 0h4" />
              </svg>
            </div>
            <div>
              <h3 className={`font-bold text-sm ${themeClasses.headerText}`}>Clara</h3>
              <p className={`text-xs ${themeClasses.headerSubtext}`}>Assistant IA</p>
            </div>
          </div>

          <div className="flex items-center gap-1">
            {/* Menu conversations */}
            <button
              onClick={() => {
                setShowConversationList(!showConversationList)
                if (!showConversationList) loadConversations()
              }}
              className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton} ${showConversationList ? 'bg-cyan-500/20 text-cyan-400' : ''}`}
              title="Conversations"
            >
              <Menu className="w-4 h-4" />
            </button>

            {/* Zoom police */}
            <button
              onClick={() => changeFontSize(-1)}
              className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
              title="Réduire la police"
              disabled={fontSize <= FONT_SIZES[0].value}
            >
              <ZoomOut className="w-4 h-4" />
            </button>
            <button
              onClick={() => changeFontSize(1)}
              className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
              title="Agrandir la police"
              disabled={fontSize >= FONT_SIZES[FONT_SIZES.length - 1].value}
            >
              <ZoomIn className="w-4 h-4" />
            </button>

            {/* Nouvelle conversation */}
            <button
              onClick={startNewConversation}
              className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
              title="Nouvelle conversation"
            >
              <RotateCcw className="w-4 h-4" />
            </button>

            {/* Position toggle */}
            {!isDetached && onPositionChange && (
              <button
                onClick={() => onPositionChange(position === 'left' ? 'right' : 'left')}
                className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
                title={position === 'left' ? 'Déplacer à droite' : 'Déplacer à gauche'}
              >
                {position === 'left' ? <ChevronRight className="w-4 h-4" /> : <ChevronLeft className="w-4 h-4" />}
              </button>
            )}

            {/* Detach/Attach */}
            <button
              onClick={() => setIsDetached(!isDetached)}
              className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
              title={isDetached ? 'Attacher' : 'Détacher'}
            >
              <Move className="w-4 h-4" />
            </button>

            {/* Expand/Collapse */}
            {!isDetached && (
              <button
                onClick={() => setIsExpanded(!isExpanded)}
                className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
                title={isExpanded ? 'Réduire' : 'Agrandir'}
              >
                {isExpanded ? <Minimize2 className="w-4 h-4" /> : <Maximize2 className="w-4 h-4" />}
              </button>
            )}

            {/* Settings */}
            <Link
              href="/admin/clara/settings"
              className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
              title="Paramètres"
            >
              <Settings className="w-4 h-4" />
            </Link>

            {/* Close */}
            <button
              onClick={onClose}
              className={`p-1.5 rounded-lg transition-colors ${themeClasses.iconButton}`}
              title="Fermer"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>

        {/* Conversation List Panel */}
        {showConversationList && (
          <div className={`border-b ${isDark ? 'border-gray-700 bg-gray-800/50' : 'border-gray-200 bg-gray-50'} max-h-64 overflow-y-auto`}>
            <div className="p-2">
              {/* Bouton nouvelle conversation */}
              <button
                onClick={startNewConversation}
                className={`w-full flex items-center gap-2 p-2 rounded-lg mb-2 ${isDark ? 'bg-cyan-500/20 text-cyan-400 hover:bg-cyan-500/30' : 'bg-cyan-50 text-cyan-600 hover:bg-cyan-100'}`}
              >
                <Plus className="w-4 h-4" />
                <span className="text-sm font-medium">Nouvelle conversation</span>
              </button>

              {conversations.length === 0 ? (
                <p className={`text-center py-4 text-sm ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                  Aucune conversation
                </p>
              ) : (
                <div className="space-y-1">
                  {conversations.map(conv => (
                    <div
                      key={conv.id}
                      className={`flex items-center gap-2 p-2 rounded-lg border cursor-pointer ${
                        conversationId === conv.id ? themeClasses.conversationItemActive : themeClasses.conversationItem
                      }`}
                      onClick={() => !editingConversationId && selectConversation(conv)}
                    >
                      <MessageSquare className={`w-4 h-4 flex-shrink-0 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />

                      {editingConversationId === conv.id ? (
                        <input
                          type="text"
                          value={editingTitle}
                          onChange={(e) => setEditingTitle(e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') renameConversation(conv.id, editingTitle)
                            if (e.key === 'Escape') setEditingConversationId(null)
                          }}
                          onClick={(e) => e.stopPropagation()}
                          className={`flex-1 text-sm px-1 py-0.5 rounded ${isDark ? 'bg-gray-700 text-white' : 'bg-white text-gray-900'}`}
                          autoFocus
                        />
                      ) : (
                        <div className="flex-1 min-w-0">
                          <p className={`text-sm font-medium truncate ${isDark ? 'text-white' : 'text-gray-900'}`}>
                            {conv.title || 'Sans titre'}
                          </p>
                          <p className={`text-xs truncate ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                            {conv.messageCount} messages
                          </p>
                        </div>
                      )}

                      <div className="flex items-center gap-1" onClick={(e) => e.stopPropagation()}>
                        {editingConversationId === conv.id ? (
                          <button
                            onClick={() => renameConversation(conv.id, editingTitle)}
                            className="p-1 rounded hover:bg-green-500/20 text-green-500"
                          >
                            <Check className="w-3 h-3" />
                          </button>
                        ) : (
                          <button
                            onClick={() => {
                              setEditingConversationId(conv.id)
                              setEditingTitle(conv.title || '')
                            }}
                            className={`p-1 rounded ${isDark ? 'hover:bg-gray-700 text-gray-500' : 'hover:bg-gray-200 text-gray-400'}`}
                          >
                            <Edit3 className="w-3 h-3" />
                          </button>
                        )}
                        <button
                          onClick={() => deleteConversation(conv.id)}
                          className="p-1 rounded hover:bg-red-500/20 text-red-500"
                        >
                          <Trash2 className="w-3 h-3" />
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}

        {/* Chat Area */}
        <div className={`flex-1 overflow-y-auto p-4 space-y-4 ${themeClasses.chatBg}`}>
          {messages.length === 0 ? (
            <div className="flex justify-start">
              <div className={`max-w-[85%] rounded-xl px-4 py-3 ${themeClasses.assistantBubble}`} style={{ fontSize }}>
                <div className={`flex items-center gap-2 mb-2 ${isDark ? 'text-cyan-400/70' : 'text-cyan-600'}`} style={{ fontSize: fontSize - 2 }}>
                  <svg viewBox="0 0 24 24" className="w-3 h-3" fill="none" stroke="currentColor" strokeWidth="2.5">
                    <path d="M2 12h2l3-7 4 14 4-7 3 0h4" />
                  </svg>
                  Clara
                </div>
                <p>
                  Salut ! Je suis Clara, ton assistante. Tu peux me poser des questions sur tes stats, me demander de l&apos;aide ou me faire faire des actions. Qu&apos;est-ce que je peux faire pour toi ?
                </p>
              </div>
            </div>
          ) : (
            <>
              {messages.map((msg, i) => (
                <div key={i} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                  <div
                    className={`max-w-[85%] rounded-xl px-4 py-3 ${msg.role === 'user' ? themeClasses.userBubble : themeClasses.assistantBubble}`}
                    style={{ fontSize }}
                  >
                    {msg.role === 'assistant' && (
                      <div className={`flex items-center gap-2 mb-2 ${isDark ? 'text-cyan-400/70' : 'text-cyan-600'}`} style={{ fontSize: fontSize - 2 }}>
                        <svg viewBox="0 0 24 24" className="w-3 h-3" fill="none" stroke="currentColor" strokeWidth="2.5">
                          <path d="M2 12h2l3-7 4 14 4-7 3 0h4" />
                        </svg>
                        Clara
                      </div>
                    )}
                    <p className="whitespace-pre-wrap">{msg.content}</p>

                    {/* Proposed Action */}
                    {msg.proposedAction && !msg.actionExecuted && (
                      <div className={`mt-3 p-3 rounded-lg border ${themeClasses.actionBox}`}>
                        <div className="flex items-center gap-2 text-orange-500 font-medium mb-2" style={{ fontSize: fontSize - 2 }}>
                          <AlertTriangle className="w-3 h-3" />
                          Action proposée
                        </div>
                        <p className={`mb-3 ${isDark ? 'text-white' : 'text-gray-700'}`} style={{ fontSize: fontSize - 2 }}>
                          {msg.proposedAction.description}
                        </p>
                        <div className="flex gap-2">
                          <button
                            onClick={() => handleExecuteAction(msg.proposedAction!, i)}
                            disabled={loading}
                            className="flex items-center gap-1 px-2 py-1 bg-green-600/20 border border-green-500 rounded text-green-500 hover:bg-green-600/30 disabled:opacity-50"
                            style={{ fontSize: fontSize - 2 }}
                          >
                            <Play className="w-3 h-3" />
                            Exécuter
                          </button>
                          <button
                            onClick={() => handleCancelAction(i)}
                            disabled={loading}
                            className="flex items-center gap-1 px-2 py-1 bg-red-600/20 border border-red-500 rounded text-red-500 hover:bg-red-600/30 disabled:opacity-50"
                            style={{ fontSize: fontSize - 2 }}
                          >
                            <XCircle className="w-3 h-3" />
                            Annuler
                          </button>
                        </div>
                      </div>
                    )}

                    {/* Action Result */}
                    {msg.actionExecuted && msg.actionResult && (
                      <div
                        className={`mt-3 p-2 rounded-lg border ${
                          msg.actionResult.success
                            ? 'bg-green-900/20 border-green-500/30 text-green-500'
                            : 'bg-red-900/20 border-red-500/30 text-red-500'
                        }`}
                        style={{ fontSize: fontSize - 2 }}
                      >
                        <div className="flex items-center gap-1 mb-1">
                          {msg.actionResult.success ? <CheckCircle className="w-3 h-3" /> : <XCircle className="w-3 h-3" />}
                          {msg.actionResult.success ? 'Effectuée' : 'Non effectuée'}
                        </div>
                        <p className={isDark ? 'text-gray-300' : 'text-gray-600'}>{msg.actionResult.message}</p>
                      </div>
                    )}
                  </div>
                </div>
              ))}

              {loading && (
                <div className="flex justify-start">
                  <div className={`rounded-xl px-4 py-2 flex items-center gap-2 ${themeClasses.assistantBubble}`}>
                    <Loader2 className="w-4 h-4 animate-spin text-cyan-500" />
                    <span className={isDark ? 'text-gray-400' : 'text-gray-500'} style={{ fontSize }}>Clara réfléchit...</span>
                  </div>
                </div>
              )}

              <div ref={chatEndRef} />
            </>
          )}
        </div>

        {/* Input Area */}
        <div className={`p-4 border-t ${isDark ? 'border-cyan-500/20' : 'border-gray-200'}`}>
          <div className="flex gap-2">
            {/* Microphone button */}
            {speechSupported && (
              <button
                onClick={toggleListening}
                disabled={loading}
                className={`p-2 rounded-xl transition-all ${
                  isListening
                    ? 'bg-red-500 text-white animate-pulse'
                    : isDark
                    ? 'bg-gray-800 text-gray-400 hover:text-white hover:bg-gray-700'
                    : 'bg-gray-100 text-gray-500 hover:text-gray-700 hover:bg-gray-200'
                } disabled:opacity-50`}
                title={isListening ? 'Arrêter' : 'Parler'}
              >
                {isListening ? <MicOff className="w-5 h-5" /> : <Mic className="w-5 h-5" />}
              </button>
            )}

            <input
              ref={inputRef}
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Écris ou parle à Clara..."
              disabled={loading}
              className={`flex-1 border rounded-xl px-4 py-2 focus:outline-none focus:border-cyan-500 disabled:opacity-50 ${themeClasses.input}`}
              style={{ fontSize }}
            />
            <button
              onClick={sendMessage}
              disabled={loading || !input.trim()}
              className="p-2 bg-gradient-to-r from-cyan-500 to-teal-400 rounded-xl text-white hover:opacity-90 disabled:opacity-50 transition-opacity"
            >
              <Send className="w-5 h-5" />
            </button>
          </div>
        </div>

        {/* Resize handle for detached mode */}
        {isDetached && (
          <div
            className="absolute bottom-0 right-0 w-4 h-4 cursor-se-resize"
            onMouseDown={handleResizeStart}
          >
            <svg className={`w-4 h-4 ${isDark ? 'text-gray-600' : 'text-gray-400'}`} viewBox="0 0 24 24" fill="currentColor">
              <path d="M22 22H20V20H22V22ZM22 18H18V22H16V18H22V18ZM14 22H12V18H18V16H12V14H18V12H12V10H18V8H12V6H18V4H20V18H22V20H20V22H18V20H16V22H14Z" />
            </svg>
          </div>
        )}
      </div>
    </>
  )
}

// Types pour la reconnaissance vocale
interface SpeechRecognitionEvent extends Event {
  results: SpeechRecognitionResultList
}

interface SpeechRecognitionResultList {
  readonly length: number
  [index: number]: SpeechRecognitionResult
}

interface SpeechRecognitionResult {
  readonly length: number
  [index: number]: SpeechRecognitionAlternative
}

interface SpeechRecognitionAlternative {
  readonly transcript: string
  readonly confidence: number
}

interface SpeechRecognitionClass {
  new(): SpeechRecognitionInstance
}

interface SpeechRecognitionInstance {
  continuous: boolean
  interimResults: boolean
  lang: string
  onresult: ((event: SpeechRecognitionEvent) => void) | null
  onerror: ((event: Event) => void) | null
  onend: (() => void) | null
  start: () => void
  stop: () => void
}

declare global {
  interface Window {
    SpeechRecognition: SpeechRecognitionClass
    webkitSpeechRecognition: SpeechRecognitionClass
  }
}
</file>

<file path="src/lib/icount-documents.ts">
/**
 * iCount Documents Service
 * Service haut niveau pour synchroniser les bookings vers des devis/factures iCount
 *
 * Structure simplifiée:
 * - GAME: utilise icount_products directement (Laser X parties, Active Xmin)
 * - EVENT: utilise icount_event_formulas (game_type + price_per_person + room)
 */

import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import { ICountClient, ICountDocumentsModule } from '@/lib/payment-provider'
import type { ICountDocumentItem, DocumentResult } from '@/lib/payment-provider/icount/documents'
import type { Booking, GameArea } from '@/lib/supabase/types'

interface ICountCredentials {
  cid: string
  user: string
  pass: string
}

// Nouveau schéma simplifié des produits
interface ICountProduct {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  name_en: string | null
  unit_price: number
  is_active: boolean
  sort_order: number
}

// Nouveau schéma des salles
interface ICountRoom {
  id: string
  branch_id: string
  code: string
  name: string
  name_he: string | null
  name_en: string | null
  price: number
  is_active: boolean
}

// Nouveau schéma des formules EVENT
interface ICountEventFormula {
  id: string
  branch_id: string
  name: string
  game_type: 'LASER' | 'ACTIVE' | 'BOTH'
  min_participants: number
  max_participants: number
  price_per_person: number
  room_id: string | null
  product_id: string | null // Direct link to icount_products (tier-based naming)
  is_active: boolean
  priority: number
}

interface BookingWithSessions extends Booking {
  game_sessions?: Array<{
    game_area: GameArea
    session_order: number
    start_datetime?: string
    end_datetime?: string
  }>
  // Discount fields
  discount_type?: 'percent' | 'fixed' | null
  discount_value?: number | null
}

// Create a raw Supabase client for fetching data
function createRawServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
  return createSupabaseClient(supabaseUrl, supabaseServiceKey, {
    auth: { autoRefreshToken: false, persistSession: false }
  })
}

/**
 * Get iCount credentials for a branch
 */
async function getICountCredentials(branchId: string): Promise<ICountCredentials | null> {
  const supabase = createRawServiceClient()

  const { data, error } = await supabase
    .from('payment_credentials')
    .select('cid, username, password')
    .eq('branch_id', branchId)
    .eq('provider', 'icount')
    .eq('is_active', true)
    .single()

  if (error || !data) {
    return null
  }

  return {
    cid: data.cid,
    user: data.username,
    pass: data.password
  }
}

/**
 * Get products for a branch
 */
async function getProducts(branchId: string): Promise<ICountProduct[]> {
  const supabase = createRawServiceClient()

  const { data, error } = await supabase
    .from('icount_products')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)
    .order('sort_order')

  if (error || !data) {
    console.error('[ICOUNT DOCS] Failed to fetch products:', error)
    return []
  }

  return data as ICountProduct[]
}

/**
 * Get rooms for a branch
 */
async function getRooms(branchId: string): Promise<ICountRoom[]> {
  const supabase = createRawServiceClient()

  const { data, error } = await supabase
    .from('icount_rooms')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)

  if (error || !data) {
    console.error('[ICOUNT DOCS] Failed to fetch rooms:', error)
    return []
  }

  return data as ICountRoom[]
}

/**
 * Get EVENT formulas for a branch
 */
async function getEventFormulas(branchId: string): Promise<ICountEventFormula[]> {
  const supabase = createRawServiceClient()

  const { data, error } = await supabase
    .from('icount_event_formulas')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)
    .order('priority', { ascending: false }) // Higher priority first

  if (error || !data) {
    console.error('[ICOUNT DOCS] Failed to fetch event formulas:', error)
    return []
  }

  return data as ICountEventFormula[]
}

/**
 * Convert HTML to plain text for iCount documents
 * Strips HTML tags and decodes entities
 */
function htmlToPlainText(html: string): string {
  if (!html) return ''

  let text = html
    // Replace <br>, <br/>, <br /> with newlines
    .replace(/<br\s*\/?>/gi, '\n')
    // Replace </p>, </div>, </li> with newlines
    .replace(/<\/(p|div|li|h[1-6])>/gi, '\n')
    // Replace <li> with bullet point
    .replace(/<li[^>]*>/gi, '• ')
    // Remove all remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode common HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    // Clean up multiple newlines
    .replace(/\n{3,}/g, '\n\n')
    // Trim whitespace from each line
    .split('\n')
    .map(line => line.trim())
    .join('\n')
    // Final trim
    .trim()

  return text
}

/**
 * Get terms & conditions for a booking type
 * Returns plain text version for iCount documents
 */
async function getTermsConditionsForOffer(
  bookingType: 'GAME' | 'EVENT',
  locale: string = 'he'
): Promise<string> {
  const supabase = createRawServiceClient()

  // Determine template code
  const templateType = bookingType === 'EVENT' ? 'event' : 'game'
  const langCode = ['en', 'fr', 'he'].includes(locale) ? locale : 'he'
  const templateCode = `terms_${templateType}_${langCode}`

  // Fetch terms template
  const { data: template } = await supabase
    .from('email_templates')
    .select('body_template')
    .eq('code', templateCode)
    .eq('is_active', true)
    .single()

  if (template?.body_template) {
    return htmlToPlainText(template.body_template)
  }

  // Fallback to Hebrew if not found
  if (langCode !== 'he') {
    const { data: fallbackTemplate } = await supabase
      .from('email_templates')
      .select('body_template')
      .eq('code', `terms_${templateType}_he`)
      .eq('is_active', true)
      .single()

    if (fallbackTemplate?.body_template) {
      return htmlToPlainText(fallbackTemplate.body_template)
    }
  }

  return ''
}

/**
 * Find the best matching EVENT formula for a booking
 */
function findMatchingEventFormula(
  booking: BookingWithSessions,
  formulas: ICountEventFormula[]
): ICountEventFormula | null {
  const hasLaser = booking.game_sessions?.some(s => s.game_area === 'LASER') || false
  const hasActive = booking.game_sessions?.some(s => s.game_area === 'ACTIVE') || false

  // Determine booking's game_type
  let bookingGameType: 'LASER' | 'ACTIVE' | 'BOTH'
  if (hasLaser && hasActive) {
    bookingGameType = 'BOTH'
  } else if (hasActive) {
    bookingGameType = 'ACTIVE'
  } else {
    bookingGameType = 'LASER' // Default to LASER
  }

  console.log('[ICOUNT DOCS] Booking game_type:', bookingGameType, 'participants:', booking.participants_count)

  // Find matching formula (already sorted by priority desc)
  for (const formula of formulas) {
    // Check participant count
    if (booking.participants_count < formula.min_participants) continue
    if (booking.participants_count > formula.max_participants) continue

    // Check game_type
    if (formula.game_type === 'BOTH') {
      // Formula BOTH matches any game_type
    } else if (formula.game_type !== bookingGameType) {
      continue
    }

    console.log('[ICOUNT DOCS] Matched formula:', formula.name)
    return formula
  }

  return null
}

/**
 * Calculate the total duration in minutes for ACTIVE sessions
 */
function calculateActiveDurationMinutes(sessions: BookingWithSessions['game_sessions']): number {
  if (!sessions) return 0

  let totalMinutes = 0
  for (const session of sessions) {
    if (session.game_area === 'ACTIVE' && session.start_datetime && session.end_datetime) {
      const start = new Date(session.start_datetime)
      const end = new Date(session.end_datetime)
      const durationMs = end.getTime() - start.getTime()
      totalMinutes += Math.round(durationMs / 60000)
    }
  }
  return totalMinutes
}

/**
 * Find the best product for ACTIVE games based on duration
 * Products have codes like: active_30, active_60, active_90, active_120
 * MUST match price-calculator.ts codes exactly
 */
function findActiveProduct(products: ICountProduct[], durationMinutes: number): ICountProduct | null {
  // Map duration to product codes - MUST match price-calculator.ts
  const durationMap: { [key: string]: number } = {
    'active_30': 30,
    'active_60': 60,
    'active_90': 90,
    'active_120': 120,
  }

  // Find product that matches duration (rounded to nearest standard duration)
  let bestProduct: ICountProduct | null = null
  let bestDiff = Infinity

  for (const product of products) {
    const productDuration = durationMap[product.code]
    if (productDuration !== undefined) {
      const diff = Math.abs(productDuration - durationMinutes)
      if (diff < bestDiff) {
        bestDiff = diff
        bestProduct = product
      }
    }
  }

  // NO FALLBACK - if product not found, return null and let caller handle it
  // This prevents silent wrong pricing
  if (!bestProduct) {
    console.error('[ICOUNT DOCS] CRITICAL: No Active product found for duration:', durationMinutes, 'min. Available products:', products.filter(p => p.code.startsWith('active_')).map(p => p.code).join(', '))
  }

  return bestProduct
}

/**
 * Find the best product for LASER games based on number of parties
 * Products have codes like: laser_1, laser_2, laser_3, laser_4
 * MUST match price-calculator.ts codes exactly
 */
function findLaserProduct(products: ICountProduct[], numberOfParties: number): ICountProduct | null {
  const code = `laser_${Math.min(numberOfParties, 4)}`
  const product = products.find(p => p.code === code)

  // NO FALLBACK - if product not found, log error and return null
  if (!product) {
    console.error('[ICOUNT DOCS] CRITICAL: No Laser product found for code:', code, '. Available products:', products.filter(p => p.code.startsWith('laser_')).map(p => p.code).join(', '))
  }

  return product || null
}

/**
 * Calculate price and build items for a booking
 * Returns the items to put on the iCount document
 * Now returns errors array to prevent silent failures
 */
async function calculateBookingItems(
  booking: BookingWithSessions,
  branchId: string
): Promise<{ items: ICountDocumentItem[]; total: number; discountAmount: number; errors: string[] }> {
  const products = await getProducts(branchId)
  const items: ICountDocumentItem[] = []
  const errors: string[] = []
  let subtotal = 0
  let discountAmount = 0

  // Count sessions
  const laserSessions = booking.game_sessions?.filter(s => s.game_area === 'LASER') || []
  const activeSessions = booking.game_sessions?.filter(s => s.game_area === 'ACTIVE') || []

  console.log('[ICOUNT DOCS] Booking type:', booking.type)
  console.log('[ICOUNT DOCS] Laser sessions:', laserSessions.length)
  console.log('[ICOUNT DOCS] Active sessions:', activeSessions.length)
  console.log('[ICOUNT DOCS] Available products:', products.map(p => p.code).join(', '))

  if (booking.type === 'EVENT') {
    // EVENT: Use event formula to find matching product
    const formulas = await getEventFormulas(branchId)
    const formula = findMatchingEventFormula(booking, formulas)

    if (formula) {
      console.log('[ICOUNT DOCS] Using EVENT formula:', formula.name, 'game_type:', formula.game_type, 'price:', formula.price_per_person, 'product_id:', formula.product_id)

      // Find the matching EVENT product
      // 1. First try by direct product_id link (new tier-based system)
      // 2. Fallback: by tier-based code (event_laser_5_15)
      // 3. Legacy fallback: by price-based code (event_laser_120)
      let eventProduct: ICountProduct | undefined

      if (formula.product_id) {
        // Direct FK lookup (preferred)
        eventProduct = products.find(p => p.id === formula.product_id)
        if (eventProduct) {
          console.log('[ICOUNT DOCS] Found EVENT product via product_id:', eventProduct.code)
        }
      }

      if (!eventProduct) {
        // Tier-based code fallback
        const tierCode = `event_${formula.game_type.toLowerCase()}_${formula.min_participants}_${formula.max_participants}`
        eventProduct = products.find(p => p.code === tierCode)
        if (eventProduct) {
          console.log('[ICOUNT DOCS] Found EVENT product via tier code:', tierCode)
        }
      }

      if (!eventProduct) {
        // Legacy price-based code fallback
        const legacyCode = `event_${formula.game_type.toLowerCase()}_${formula.price_per_person}`
        eventProduct = products.find(p => p.code === legacyCode)
        if (eventProduct) {
          console.log('[ICOUNT DOCS] Found EVENT product via legacy code:', legacyCode)
        }
      }

      if (eventProduct) {
        console.log('[ICOUNT DOCS] Found EVENT product:', eventProduct.code)
        const lineTotal = eventProduct.unit_price * booking.participants_count
        subtotal += lineTotal

        items.push({
          sku: eventProduct.code, // Lien vers le produit iCount
          description: eventProduct.name_he || eventProduct.name,
          unitprice_incvat: eventProduct.unit_price, // Prix TTC
          quantity: booking.participants_count,
        })
      } else {
        // NO FALLBACK - report error instead of using unlinked formula
        const expectedCode = formula.product_id
          ? `product_id:${formula.product_id}`
          : `event_${formula.game_type.toLowerCase()}_${formula.min_participants}_${formula.max_participants}`
        const errorMsg = `Produit EVENT non trouvé pour la formule "${formula.name}". Code attendu: ${expectedCode}. Exécutez la synchronisation iCount.`
        console.error('[ICOUNT DOCS] CRITICAL:', errorMsg)
        errors.push(errorMsg)
      }

      // Add room price if formula has a room
      if (formula.room_id) {
        const rooms = await getRooms(branchId)
        const room = rooms.find(r => r.id === formula.room_id)
        if (room && room.price > 0) {
          // Find the matching room product
          const roomProductCode = `room_event_${room.price}`
          const roomProduct = products.find(p => p.code === roomProductCode)

          if (roomProduct) {
            console.log('[ICOUNT DOCS] Found ROOM product:', roomProduct.code)
            subtotal += roomProduct.unit_price
            items.push({
              sku: roomProduct.code, // Lien vers le produit iCount
              description: roomProduct.name_he || roomProduct.name,
              unitprice_incvat: roomProduct.unit_price, // Prix TTC
              quantity: 1,
            })
          } else {
            // NO FALLBACK - report error for missing room product
            const errorMsg = `Produit salle non trouvé pour "${room.name_he || room.name}". Code attendu: ${roomProductCode}. Créez le produit salle dans la configuration.`
            console.error('[ICOUNT DOCS] CRITICAL:', errorMsg)
            errors.push(errorMsg)
          }
        }
      }
    } else {
      // NO FALLBACK - report error for missing formula
      const errorMsg = `Aucune formule EVENT trouvée pour ${booking.participants_count} participants. Créez une formule dans la configuration.`
      console.error('[ICOUNT DOCS] CRITICAL:', errorMsg)
      errors.push(errorMsg)
    }

  } else if (booking.type === 'GAME') {
    // GAME: Direct product lookup based on sessions

    if (laserSessions.length > 0) {
      // Laser pricing: laser_Xp based on number of parties
      const product = findLaserProduct(products, laserSessions.length)

      if (product) {
        console.log('[ICOUNT DOCS] Using Laser product:', product.code, 'price:', product.unit_price)
        // Price is per person (TTC)
        const quantity = booking.participants_count
        const lineTotal = product.unit_price * quantity
        subtotal += lineTotal

        items.push({
          sku: product.code, // Lien vers le produit iCount
          description: product.name_he || product.name,
          unitprice_incvat: product.unit_price, // Prix TTC
          quantity,
        })
      } else {
        const errorMsg = `Produit Laser non trouvé pour ${laserSessions.length} partie(s). Code attendu: laser_${Math.min(laserSessions.length, 4)}`
        console.error('[ICOUNT DOCS] CRITICAL:', errorMsg)
        errors.push(errorMsg)
      }
    }

    if (activeSessions.length > 0) {
      // Active pricing: based on total duration
      const totalDuration = calculateActiveDurationMinutes(activeSessions)
      const product = findActiveProduct(products, totalDuration)

      if (product) {
        console.log('[ICOUNT DOCS] Using Active product:', product.code, 'duration:', totalDuration, 'min')
        // Price is per person (TTC)
        const quantity = booking.participants_count
        const lineTotal = product.unit_price * quantity
        subtotal += lineTotal

        items.push({
          sku: product.code, // Lien vers le produit iCount
          description: product.name_he || product.name,
          unitprice_incvat: product.unit_price, // Prix TTC
          quantity,
        })
      } else {
        const errorMsg = `Produit Active non trouvé pour ${totalDuration} minutes. Codes attendus: active_30, active_60, active_90, active_120`
        console.error('[ICOUNT DOCS] CRITICAL:', errorMsg)
        errors.push(errorMsg)
      }
    }
  }

  // NEVER create generic fallback items - this hides pricing errors
  if (items.length === 0 && errors.length === 0) {
    const errorMsg = `Aucun produit trouvé pour la réservation ${booking.reference_code} (type: ${booking.type})`
    console.error('[ICOUNT DOCS] CRITICAL:', errorMsg)
    errors.push(errorMsg)
  }

  // Apply discount if present
  if (booking.discount_type && booking.discount_value && booking.discount_value > 0) {
    if (booking.discount_type === 'percent') {
      discountAmount = subtotal * (booking.discount_value / 100)
    } else if (booking.discount_type === 'fixed') {
      discountAmount = Math.min(booking.discount_value, subtotal) // Don't discount more than total
    }

    if (discountAmount > 0) {
      console.log('[ICOUNT DOCS] Applying discount:', booking.discount_type, booking.discount_value, '=', discountAmount)
      items.push({
        description: booking.discount_type === 'percent'
          ? `הנחה ${booking.discount_value}%`
          : 'הנחה',
        unitprice_incvat: -discountAmount, // Remise TTC
        quantity: 1,
      })
    }
  }

  const total = subtotal - discountAmount

  return { items, total, discountAmount, errors }
}

/**
 * Log iCount document action to activity_logs
 */
async function logICountDocument(
  booking: Booking,
  branchId: string,
  action: 'offer_created' | 'offer_cancelled' | 'invrec_created',
  success: boolean,
  docnum?: number,
  error?: string
): Promise<void> {
  const supabase = createRawServiceClient()

  const { error: insertError } = await supabase.from('activity_logs').insert({
    user_id: null,
    user_role: 'system',
    user_name: 'iCount Sync',
    action_type: 'booking_updated', // Using existing action type
    target_type: 'booking',
    target_id: booking.id,
    target_name: booking.reference_code,
    branch_id: branchId,
    details: {
      icount_action: action,
      success,
      docnum: docnum || null,
      error: error || null,
      booking_type: booking.type,
      participants: booking.participants_count,
    }
  })

  if (insertError) {
    console.error('[ICOUNT DOCS LOG] Failed to insert activity log:', insertError)
  }
}

/**
 * Create an offer (devis/הצעת מחיר) for a booking
 * Called when a booking is confirmed
 */
export async function createOfferForBooking(
  booking: BookingWithSessions,
  branchId: string
): Promise<{ success: boolean; offerId?: number; error?: string }> {
  console.log('[ICOUNT DOCS] === START createOfferForBooking ===')
  console.log('[ICOUNT DOCS] Booking:', booking.id, booking.reference_code)
  console.log('[ICOUNT DOCS] Branch:', branchId)

  try {
    // Get credentials for this branch
    const credentials = await getICountCredentials(branchId)

    if (!credentials) {
      // No iCount configured for this branch - not an error, just skip
      console.log('[ICOUNT DOCS] No iCount credentials for branch, skipping')
      return { success: true }
    }

    // Calculate items and total
    const { items, total, errors } = await calculateBookingItems(booking, branchId)
    console.log('[ICOUNT DOCS] Calculated items:', items.length, 'Total:', total)
    console.log('[ICOUNT DOCS] Items:', JSON.stringify(items))

    // CRITICAL: Block document creation if there are pricing errors
    if (errors.length > 0) {
      const errorMessage = `Erreurs de configuration produits: ${errors.join('; ')}`
      console.error('[ICOUNT DOCS] BLOCKING document creation due to errors:', errors)
      await logICountDocument(booking, branchId, 'offer_created', false, undefined, errorMessage)
      return { success: false, error: errorMessage }
    }

    // Additional safety check: refuse to create 0₪ documents
    if (total <= 0 && items.length > 0) {
      const errorMessage = 'Le total calculé est 0₪ - vérifiez les prix des produits'
      console.error('[ICOUNT DOCS] BLOCKING document creation - total is 0')
      await logICountDocument(booking, branchId, 'offer_created', false, undefined, errorMessage)
      return { success: false, error: errorMessage }
    }

    // Create iCount client and module
    const icountClient = new ICountClient(credentials)
    const documentsModule = new ICountDocumentsModule(icountClient)

    // Build offer params
    const customerName = `${booking.customer_first_name} ${booking.customer_last_name || ''}`.trim()

    // Build description (hwc = hand written comment)
    const gameInfo = booking.game_sessions?.map(s => s.game_area).join(' + ') || booking.type

    // Get terms & conditions for the offer (in Hebrew)
    const termsConditions = await getTermsConditionsForOffer(booking.type as 'GAME' | 'EVENT', 'he')

    // Build hwc with booking info + terms
    const hwcParts = [
      `הזמנה #${booking.reference_code}`,
      `${booking.participants_count} משתתפים`,
      gameInfo,
    ]

    // Add separator and terms if available
    if (termsConditions) {
      hwcParts.push('')
      hwcParts.push('─'.repeat(40))
      hwcParts.push('')
      hwcParts.push(termsConditions)
    }

    const hwc = hwcParts.join('\n')

    // Use contact ID for linking if available
    const offerParams = {
      custom_client_id: booking.primary_contact_id || undefined,
      client_name: customerName,
      email: booking.customer_email || undefined,
      items,
      sanity_string: `booking-${booking.id}`, // Prevent duplicates
      doc_title: `הזמנה ${booking.reference_code}`,
      hwc,
      doc_lang: 'he',
    }

    console.log('[ICOUNT DOCS] Creating offer with sanity_string:', offerParams.sanity_string)

    const result = await documentsModule.createOffer(offerParams)

    if (result.success && result.data) {
      const offerId = result.data.docnum
      const offerUrl = result.data.doc_url
      console.log('[ICOUNT DOCS] Offer created:', offerId, 'URL:', offerUrl)

      // Update booking with icount_offer_id and offer URL
      const supabase = createRawServiceClient()
      const { error: updateError } = await supabase
        .from('bookings')
        .update({
          icount_offer_id: offerId,
          icount_offer_url: offerUrl, // Store URL for email link
          total_price: total, // Also update the total_price
        })
        .eq('id', booking.id)

      if (updateError) {
        console.warn('[ICOUNT DOCS] Failed to update booking with offer ID:', updateError)
      }

      // Log success
      await logICountDocument(booking, branchId, 'offer_created', true, offerId)

      return { success: true, offerId }
    }

    const errorMsg = result.error?.message || 'Failed to create offer'
    console.error('[ICOUNT DOCS] Failed to create offer:', errorMsg)

    // Log failure
    await logICountDocument(booking, branchId, 'offer_created', false, undefined, errorMsg)

    return { success: false, error: errorMsg }

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    console.error('[ICOUNT DOCS] Exception:', errorMsg)

    // Log error
    await logICountDocument(booking, branchId, 'offer_created', false, undefined, errorMsg)

    return { success: false, error: errorMsg }
  }
}

/**
 * Create offer in background (non-blocking)
 */
export function createOfferForBookingBackground(
  booking: BookingWithSessions,
  branchId: string
): void {
  console.log('[ICOUNT DOCS BG] Starting background offer creation for booking:', booking.id)
  createOfferForBooking(booking, branchId)
    .then((result) => {
      console.log('[ICOUNT DOCS BG] Background offer creation completed:', result)
    })
    .catch((err) => {
      console.error('[ICOUNT DOCS BG] Background offer creation error:', err)
    })
}

/**
 * Cancel an offer when a booking is cancelled
 */
export async function cancelOfferForBooking(
  bookingId: string,
  reason?: string
): Promise<{ success: boolean; error?: string }> {
  console.log('[ICOUNT DOCS] === START cancelOfferForBooking ===')
  console.log('[ICOUNT DOCS] Booking ID:', bookingId)

  try {
    const supabase = createRawServiceClient()

    // Get booking with icount_offer_id
    const { data: booking, error: bookingError } = await supabase
      .from('bookings')
      .select('*, branch_id')
      .eq('id', bookingId)
      .single()

    if (bookingError || !booking) {
      console.error('[ICOUNT DOCS] Booking not found:', bookingError)
      return { success: false, error: 'Booking not found' }
    }

    if (!booking.icount_offer_id) {
      console.log('[ICOUNT DOCS] No offer ID on booking, nothing to cancel')
      return { success: true }
    }

    // Get credentials
    const credentials = await getICountCredentials(booking.branch_id)
    if (!credentials) {
      console.log('[ICOUNT DOCS] No iCount credentials, skipping cancel')
      return { success: true }
    }

    // Cancel the offer on iCount
    const icountClient = new ICountClient(credentials)
    const documentsModule = new ICountDocumentsModule(icountClient)

    const result = await documentsModule.cancelDocument(
      'offer',
      booking.icount_offer_id,
      reason || `Booking ${booking.reference_code} cancelled`
    )

    if (result.success) {
      console.log('[ICOUNT DOCS] Offer cancelled:', booking.icount_offer_id)

      // Clear the offer ID from booking
      await supabase
        .from('bookings')
        .update({ icount_offer_id: null })
        .eq('id', bookingId)

      // Log success
      await logICountDocument(
        booking as Booking,
        booking.branch_id,
        'offer_cancelled',
        true,
        booking.icount_offer_id
      )

      return { success: true }
    }

    const errorMsg = result.error?.message || 'Failed to cancel offer'
    console.error('[ICOUNT DOCS] Failed to cancel offer:', errorMsg)

    // Log failure (but don't fail the overall cancel operation)
    await logICountDocument(
      booking as Booking,
      booking.branch_id,
      'offer_cancelled',
      false,
      booking.icount_offer_id,
      errorMsg
    )

    // Return success anyway - we don't want to block booking cancellation
    return { success: true }

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    console.error('[ICOUNT DOCS] Exception during cancel:', errorMsg)
    // Return success anyway - we don't want to block booking cancellation
    return { success: true }
  }
}

/**
 * Cancel offer in background (non-blocking)
 */
export function cancelOfferForBookingBackground(
  bookingId: string,
  reason?: string
): void {
  console.log('[ICOUNT DOCS BG] Starting background offer cancellation for booking:', bookingId)
  cancelOfferForBooking(bookingId, reason)
    .then((result) => {
      console.log('[ICOUNT DOCS BG] Background offer cancellation completed:', result)
    })
    .catch((err) => {
      console.error('[ICOUNT DOCS BG] Background offer cancellation error:', err)
    })
}

/**
 * Cancel an offer directly using the offer ID and branch ID
 * Use this when the booking has already been deleted from the database
 */
export async function cancelOfferDirect(
  offerId: number,
  branchId: string,
  reason?: string
): Promise<{ success: boolean; error?: string }> {
  console.log('[ICOUNT DOCS] === START cancelOfferDirect ===')
  console.log('[ICOUNT DOCS] Offer ID:', offerId, 'Branch ID:', branchId)

  try {
    // Get credentials
    const credentials = await getICountCredentials(branchId)
    if (!credentials) {
      console.log('[ICOUNT DOCS] No iCount credentials, skipping cancel')
      return { success: true }
    }

    // Cancel the offer on iCount
    const icountClient = new ICountClient(credentials)
    const documentsModule = new ICountDocumentsModule(icountClient)

    const result = await documentsModule.cancelDocument(
      'offer',
      offerId,
      reason || 'Document cancelled'
    )

    if (result.success) {
      console.log('[ICOUNT DOCS] Offer cancelled:', offerId)
      return { success: true }
    }

    const errorMsg = result.error?.message || 'Failed to cancel offer'
    console.error('[ICOUNT DOCS] Failed to cancel offer:', errorMsg)
    // Return success anyway - we don't want to block the delete operation
    return { success: true }

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    console.error('[ICOUNT DOCS] Exception during cancel:', errorMsg)
    // Return success anyway - we don't want to block the delete operation
    return { success: true }
  }
}

/**
 * Cancel offer directly in background (non-blocking)
 * Use this when the booking has already been deleted from the database
 */
export function cancelOfferDirectBackground(
  offerId: number,
  branchId: string,
  reason?: string
): void {
  console.log('[ICOUNT DOCS BG] Starting background direct offer cancellation for offer:', offerId)
  cancelOfferDirect(offerId, branchId, reason)
    .then((result) => {
      console.log('[ICOUNT DOCS BG] Background direct offer cancellation completed:', result)
    })
    .catch((err) => {
      console.error('[ICOUNT DOCS BG] Background direct offer cancellation error:', err)
    })
}

/**
 * Convert an offer to invoice+receipt when payment is received
 * (For future use - when payment module is implemented)
 */
export async function convertOfferToInvoiceReceipt(
  bookingId: string
): Promise<{ success: boolean; invrecId?: number; error?: string }> {
  console.log('[ICOUNT DOCS] === START convertOfferToInvoiceReceipt ===')
  console.log('[ICOUNT DOCS] Booking ID:', bookingId)

  try {
    const supabase = createRawServiceClient()

    // Get booking
    const { data: booking, error: bookingError } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', bookingId)
      .single()

    if (bookingError || !booking) {
      return { success: false, error: 'Booking not found' }
    }

    if (!booking.icount_offer_id) {
      return { success: false, error: 'No offer exists for this booking' }
    }

    // Get credentials
    const credentials = await getICountCredentials(booking.branch_id)
    if (!credentials) {
      return { success: false, error: 'No iCount credentials configured' }
    }

    // Convert offer to invrec
    const icountClient = new ICountClient(credentials)
    const documentsModule = new ICountDocumentsModule(icountClient)

    const result = await documentsModule.convertOfferToInvoiceReceipt(
      booking.icount_offer_id,
      {
        custom_client_id: booking.primary_contact_id,
        sanity_string: `invrec-${booking.id}`,
      }
    )

    if (result.success && result.data) {
      const invrecId = result.data.docnum
      console.log('[ICOUNT DOCS] Invoice+Receipt created:', invrecId)

      // Update booking
      const { error: updateError } = await supabase
        .from('bookings')
        .update({ icount_invrec_id: invrecId })
        .eq('id', booking.id)

      if (updateError) {
        console.warn('[ICOUNT DOCS] Failed to update booking with invrec ID:', updateError)
      }

      // Log success
      await logICountDocument(
        booking as Booking,
        booking.branch_id,
        'invrec_created',
        true,
        invrecId
      )

      return { success: true, invrecId }
    }

    const errorMsg = result.error?.message || 'Failed to convert offer'
    console.error('[ICOUNT DOCS] Failed to convert offer:', errorMsg)

    return { success: false, error: errorMsg }

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    console.error('[ICOUNT DOCS] Exception:', errorMsg)
    return { success: false, error: errorMsg }
  }
}
</file>

<file path="src/lib/price-calculator.ts">
import type { ICountProduct, ICountEventFormula, ICountRoom } from '@/hooks/usePricingData'

export interface PriceCalculationResult {
  breakdown: string       // "26 × 100₪ + 400₪ (salle) - 10%"
  total: number           // 2700
  subtotal: number        // Before discount
  discountAmount: number  // Discount amount
  valid: boolean          // If we have enough data to calculate
  details: {
    participants: number
    unitPrice: number
    unitLabel?: string      // "2 parties", "1h", etc.
    roomPrice?: number
    roomName?: string
    discountType?: 'percent' | 'fixed' | null
    discountValue?: number
  }
}

export interface CalculatePriceParams {
  bookingType: 'GAME' | 'EVENT'
  participants: number
  // GAME params
  gameArea?: 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null
  numberOfGames?: number            // For LASER: number of parties
  gameDurations?: string[]          // For ACTIVE: durations in minutes
  // GAME CUSTOM params
  customGameAreas?: ('ACTIVE' | 'LASER')[]  // Area for each game in CUSTOM mode
  customGameDurations?: string[]             // Duration for each game in CUSTOM mode
  // EVENT params
  eventQuickPlan?: string           // Quick plan like 'AA', 'LL', 'AL', 'LA', etc.
  eventRoomId?: string | null
  // Discount
  discountType?: 'percent' | 'fixed' | null
  discountValue?: string | number
  // Pricing data
  products: ICountProduct[]
  eventFormulas: ICountEventFormula[]
  rooms: ICountRoom[]
  // Locale for room name display
  locale?: 'he' | 'en' | 'fr'
}

/**
 * Find the laser product based on number of parties
 * Matches the logic in icount-documents.ts (max 4 parties)
 * Product codes: laser_1, laser_2, laser_3, laser_4
 */
function findLaserProduct(products: ICountProduct[], numParties: number): ICountProduct | undefined {
  const code = `laser_${Math.min(numParties, 4)}`
  return products.find(p => p.code === code)
}

/**
 * Find the active product based on total duration in minutes
 * Matches the logic in icount-documents.ts (finds closest duration)
 * Product codes: active_30, active_60, active_90, active_120
 */
function findActiveProduct(products: ICountProduct[], durationMinutes: number): ICountProduct | undefined {
  // Map duration to product codes (same as icount-documents.ts)
  const durationMap: { [key: string]: number } = {
    'active_30': 30,
    'active_60': 60,
    'active_90': 90,
    'active_120': 120,
  }

  // Find product that matches duration (rounded to nearest standard duration)
  let bestProduct: ICountProduct | undefined
  let bestDiff = Infinity

  for (const product of products) {
    const productDuration = durationMap[product.code]
    if (productDuration !== undefined) {
      const diff = Math.abs(productDuration - durationMinutes)
      if (diff < bestDiff) {
        bestDiff = diff
        bestProduct = product
      }
    }
  }

  // If no duration-based match, try to find any active product
  if (!bestProduct) {
    bestProduct = products.find(p => p.code.startsWith('active_') && !p.code.includes('event'))
  }

  return bestProduct
}

/**
 * Format duration for display
 */
function formatDuration(minutes: number): string {
  if (minutes <= 30) return '30m'
  if (minutes <= 60) return '1h'
  if (minutes <= 90) return '1h30'
  return '2h'
}

/**
 * Determine the game type from EVENT quick plan
 * Matches the logic in icount-documents.ts
 */
function getEventGameTypeFromPlan(quickPlan: string): 'LASER' | 'ACTIVE' | 'BOTH' {
  const hasLaser = quickPlan.includes('L')
  const hasActive = quickPlan.includes('A')

  if (hasLaser && hasActive) {
    return 'BOTH'
  } else if (hasActive) {
    return 'ACTIVE'
  } else {
    return 'LASER' // Default to LASER
  }
}

/**
 * Find matching event formula based on participants and game type
 * Matches the logic in icount-documents.ts
 */
function findMatchingEventFormula(
  formulas: ICountEventFormula[],
  participants: number,
  gameType: 'LASER' | 'ACTIVE' | 'BOTH'
): ICountEventFormula | undefined {
  // Find matching formula (same logic as icount-documents.ts)
  for (const formula of formulas) {
    // Check participant count
    if (participants < formula.min_participants) continue
    if (participants > formula.max_participants) continue

    // Check game_type
    // Formula BOTH matches any game_type
    // Formula game_type must match booking game_type
    if (formula.game_type === 'BOTH') {
      // BOTH formula matches any game_type
      return formula
    } else if (formula.game_type === gameType) {
      return formula
    }
  }

  return undefined
}

/**
 * Calculate the price breakdown for a booking
 */
export function calculateBookingPrice(params: CalculatePriceParams): PriceCalculationResult {
  const {
    bookingType,
    participants,
    gameArea,
    numberOfGames = 1,
    gameDurations = [],
    eventQuickPlan = 'AA',
    eventRoomId,
    discountType,
    discountValue,
    products,
    eventFormulas,
    rooms,
    locale = 'en'
  } = params

  // Helper to get room name based on locale
  const getRoomName = (room: ICountRoom): string => {
    if (locale === 'he' && room.name_he) return room.name_he
    return room.name
  }

  // Invalid if no participants
  if (participants < 1) {
    return {
      breakdown: '',
      total: 0,
      subtotal: 0,
      discountAmount: 0,
      valid: false,
      details: { participants: 0, unitPrice: 0 }
    }
  }

  let subtotal = 0
  let unitPrice = 0
  let unitLabel: string | undefined
  let roomPrice: number | undefined
  let roomName: string | undefined
  let breakdownParts: string[] = []

  if (bookingType === 'GAME') {
    if (gameArea === 'LASER') {
      // LASER: price per party × participants
      const product = findLaserProduct(products, numberOfGames)
      if (product) {
        unitPrice = product.unit_price
        subtotal = unitPrice * participants
        unitLabel = numberOfGames === 1 ? '1 partie' : `${numberOfGames} parties`
        breakdownParts.push(`${participants} × ${unitPrice}₪ (${unitLabel})`)
      } else {
        // No product found
        return {
          breakdown: 'Prix laser non configuré',
          total: 0,
          subtotal: 0,
          discountAmount: 0,
          valid: false,
          details: { participants, unitPrice: 0 }
        }
      }
    } else if (gameArea === 'ACTIVE') {
      // ACTIVE: price per duration × participants
      const totalDuration = gameDurations.reduce((sum, d) => sum + parseInt(d || '0'), 0)
      const product = findActiveProduct(products, totalDuration)
      if (product) {
        unitPrice = product.unit_price
        subtotal = unitPrice * participants
        unitLabel = formatDuration(totalDuration)
        breakdownParts.push(`${participants} × ${unitPrice}₪ (${unitLabel})`)
      } else {
        return {
          breakdown: 'Prix active non configuré',
          total: 0,
          subtotal: 0,
          discountAmount: 0,
          valid: false,
          details: { participants, unitPrice: 0 }
        }
      }
    } else if (gameArea === 'CUSTOM') {
      // CUSTOM: combine LASER and ACTIVE games
      const { customGameAreas = [], customGameDurations = [] } = params

      if (customGameAreas.length === 0) {
        return {
          breakdown: '',
          total: 0,
          subtotal: 0,
          discountAmount: 0,
          valid: false,
          details: { participants, unitPrice: 0 }
        }
      }

      // Calculate price for each game
      const priceDetails: string[] = []
      let totalUnitPrice = 0
      let laserCount = 0
      let activeDuration = 0

      for (let i = 0; i < customGameAreas.length; i++) {
        const area = customGameAreas[i]
        const duration = parseInt(customGameDurations[i] || '30', 10)

        if (area === 'LASER') {
          laserCount++
        } else if (area === 'ACTIVE') {
          activeDuration += duration
        }
      }

      // Add laser price if any laser games
      if (laserCount > 0) {
        const laserProduct = findLaserProduct(products, laserCount)
        if (laserProduct) {
          totalUnitPrice += laserProduct.unit_price
          const laserLabel = laserCount === 1 ? '1 partie' : `${laserCount} parties`
          priceDetails.push(`${laserProduct.unit_price}₪ (${laserLabel})`)
        }
      }

      // Add active price if any active games
      if (activeDuration > 0) {
        const activeProduct = findActiveProduct(products, activeDuration)
        if (activeProduct) {
          totalUnitPrice += activeProduct.unit_price
          priceDetails.push(`${activeProduct.unit_price}₪ (${formatDuration(activeDuration)})`)
        }
      }

      if (totalUnitPrice === 0) {
        return {
          breakdown: 'Prix non configurés',
          total: 0,
          subtotal: 0,
          discountAmount: 0,
          valid: false,
          details: { participants, unitPrice: 0 }
        }
      }

      unitPrice = totalUnitPrice
      subtotal = unitPrice * participants
      unitLabel = priceDetails.join(' + ')
      breakdownParts.push(`${participants} × (${priceDetails.join(' + ')})`)
    } else {
      // No game area selected
      return {
        breakdown: '',
        total: 0,
        subtotal: 0,
        discountAmount: 0,
        valid: false,
        details: { participants, unitPrice: 0 }
      }
    }
  } else if (bookingType === 'EVENT') {
    // EVENT: use formula matching based on participants and game type from quick plan
    const eventGameType = getEventGameTypeFromPlan(eventQuickPlan)
    const formula = findMatchingEventFormula(eventFormulas, participants, eventGameType)

    if (formula) {
      unitPrice = formula.price_per_person
      subtotal = unitPrice * participants
      breakdownParts.push(`${participants} × ${unitPrice}₪`)

      // Add room price if formula has a room
      const formulaRoomId = eventRoomId || formula.room_id
      if (formulaRoomId) {
        const room = rooms.find(r => r.id === formulaRoomId)
        if (room && room.price > 0) {
          roomPrice = room.price
          roomName = getRoomName(room)
          subtotal += roomPrice
          breakdownParts.push(`${roomPrice}₪ (${roomName})`)
        }
      }
    } else {
      return {
        breakdown: 'Formule EVENT non trouvée',
        total: 0,
        subtotal: 0,
        discountAmount: 0,
        valid: false,
        details: { participants, unitPrice: 0 }
      }
    }
  }

  // Apply discount
  let discountAmount = 0
  const parsedDiscountValue = typeof discountValue === 'string'
    ? parseFloat(discountValue) || 0
    : discountValue || 0

  if (discountType && parsedDiscountValue > 0) {
    if (discountType === 'percent') {
      discountAmount = subtotal * (parsedDiscountValue / 100)
      breakdownParts.push(`-${parsedDiscountValue}%`)
    } else if (discountType === 'fixed') {
      discountAmount = Math.min(parsedDiscountValue, subtotal)
      breakdownParts.push(`-${parsedDiscountValue}₪`)
    }
  }

  const total = Math.round(subtotal - discountAmount)
  const breakdown = breakdownParts.join(' + ').replace(' + -', ' - ')

  return {
    breakdown,
    total,
    subtotal,
    discountAmount,
    valid: true,
    details: {
      participants,
      unitPrice,
      unitLabel,
      roomPrice,
      roomName,
      discountType,
      discountValue: parsedDiscountValue
    }
  }
}
</file>

<file path="src/app/admin/components/AdminHeader.tsx">
'use client'

import { useState, useEffect, useRef, memo } from 'react'
import { LogOut, User, ChevronDown, Sun, Moon, Users, Calendar, Menu, X, ShoppingCart, Shield, Globe, FileText, Lock, Crown, Settings, Trash2, BarChart3 } from 'lucide-react'
import Link from 'next/link'
import Image from 'next/image'
import { usePathname } from 'next/navigation'
import type { AuthUser } from '@/hooks/useAuth'
import type { Branch, UserRole } from '@/lib/supabase/types'
import { BranchSelector } from './BranchSelector'
import { usePendingOrdersCount } from '@/hooks/useOrders'
import { useUserPermissions } from '@/hooks/useUserPermissions'
import { useTranslation } from '@/contexts/LanguageContext'
import type { Locale } from '@/i18n'
import { ClaraButton, useClara } from '@/components/Clara'

interface AdminHeaderProps {
  user: AuthUser
  branches: Branch[]
  selectedBranch: Branch | null
  onBranchSelect: (branchId: string) => void
  onSignOut: () => void
  theme: 'light' | 'dark'
  onToggleTheme: () => void
}

const languageFlags: Record<Locale, { flag: string; label: string }> = {
  fr: { flag: '🇫🇷', label: 'Français' },
  en: { flag: '🇬🇧', label: 'English' },
  he: { flag: '🇮🇱', label: 'עברית' }
}

function AdminHeaderComponent({
  user,
  branches,
  selectedBranch,
  onBranchSelect,
  onSignOut,
  theme,
  onToggleTheme,
}: AdminHeaderProps) {
  const pathname = usePathname()
  const { t, locale, setLocale } = useTranslation()
  const [showUserMenu, setShowUserMenu] = useState(false)
  const [showMobileMenu, setShowMobileMenu] = useState(false)
  const [showLanguageMenu, setShowLanguageMenu] = useState(false)
  const [mounted, setMounted] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)
  const langMenuRef = useRef<HTMLDivElement>(null)

  // Permissions de l'utilisateur pour conditionner l'affichage des menus
  const { hasPermission } = useUserPermissions(user.role as UserRole)

  // Clara AI Assistant
  const { isOpen: isClaraOpen, toggleClara } = useClara()

  // Éviter les problèmes d'hydratation
  useEffect(() => {
    setMounted(true)
  }, [])

  // Fermer le menu quand on clique ailleurs
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setShowUserMenu(false)
      }
      if (langMenuRef.current && !langMenuRef.current.contains(event.target as Node)) {
        setShowLanguageMenu(false)
      }
    }

    if (showUserMenu || showLanguageMenu) {
      document.addEventListener('mousedown', handleClickOutside)
    }
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [showUserMenu, showLanguageMenu])

  // Compteur de commandes en attente pour le badge (visible partout)
  const pendingOrdersCount = usePendingOrdersCount(selectedBranch?.id || null)
  const hasPendingOrders = pendingOrdersCount > 0

  const getRoleBadge = () => {
    const baseClasses = "px-2 py-0.5 text-xs rounded-full"
    switch (user.role) {
      case 'super_admin':
        return (
          <span className={`${baseClasses} ${
            theme === 'dark'
              ? 'bg-purple-500/20 text-purple-400'
              : 'bg-purple-100 text-purple-700'
          }`}>
            {t('admin.roles.super_admin')}
          </span>
        )
      case 'branch_admin':
        return (
          <span className={`${baseClasses} ${
            theme === 'dark'
              ? 'bg-blue-500/20 text-blue-400'
              : 'bg-blue-100 text-blue-700'
          }`}>
            {t('admin.roles.manager')}
          </span>
        )
      case 'agent':
        return (
          <span className={`${baseClasses} ${
            theme === 'dark'
              ? 'bg-green-500/20 text-green-400'
              : 'bg-green-100 text-green-700'
          }`}>
            {t('admin.roles.employee')}
          </span>
        )
      default:
        return null
    }
  }

  return (
    <header className={`sticky top-0 z-40 ${theme === 'dark' ? 'bg-gray-900 border-gray-800' : 'bg-white border-gray-200'} border-b px-4 sm:px-6 py-4 shadow-md`}>
      <div className="flex items-center justify-between">
        {/* Logos - À gauche */}
        <div className="flex items-center min-w-0 flex-shrink-0 gap-3">
          <Link href="/admin" className="flex items-center">
            <Image
              src="/images/logo-activegames.png"
              alt="Active Games"
              width={142}
              height={54}
              className="h-14 w-auto object-contain"
              priority
            />
          </Link>
          <Link href="/admin" className="flex items-center">
            <Image
              src="/images/logo_laser_city.png"
              alt="Laser City"
              width={142}
              height={54}
              className="h-14 w-auto object-contain"
              priority
            />
          </Link>
        </div>

        {/* Navigation - Agenda, Clients, Commandes - Se rapproche du logo quand on réduit */}
        <div className="hidden min-[900px]:flex items-center gap-3 flex-1 justify-center min-w-0">
          <Link
            href="/admin"
            className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 relative ${
              pathname === '/admin'
                ? 'bg-blue-600 text-white'
                : theme === 'dark'
                  ? 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                  : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
            }`}
          >
            <Calendar className="w-4 h-4" />
            <span>{t('admin.header.agenda')}</span>
            {/* Pastille rouge critique pour commandes en attente */}
            {hasPendingOrders && pathname !== '/admin/orders' && (
              <span className="absolute -top-1 -right-1 bg-red-600 text-white text-xs font-bold w-5 h-5 rounded-full flex items-center justify-center animate-pulse shadow-lg">
                !
              </span>
            )}
          </Link>
          {hasPermission('clients', 'can_view') && (
            <Link
              href="/admin/clients"
              className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 ${
                pathname === '/admin/clients'
                  ? 'bg-blue-600 text-white'
                  : theme === 'dark'
                    ? 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
              }`}
            >
              <Users className="w-4 h-4" />
              <span>{t('admin.header.clients')}</span>
            </Link>
          )}
          {hasPermission('orders', 'can_view') && (
            <Link
              href="/admin/orders"
              className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 relative ${
                pathname === '/admin/orders'
                  ? 'bg-blue-600 text-white'
                  : theme === 'dark'
                    ? 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
              }`}
            >
              <ShoppingCart className="w-4 h-4" />
              <span>{t('admin.header.orders')}</span>
              {/* Pastille rouge critique pour commandes en attente */}
              {hasPendingOrders && (
                <span className="absolute -top-1 -right-1 bg-red-600 text-white text-xs font-bold w-5 h-5 rounded-full flex items-center justify-center animate-pulse shadow-lg">
                  {pendingOrdersCount > 9 ? '9+' : pendingOrdersCount}
                </span>
              )}
            </Link>
          )}
        </div>

        {/* Actions - À droite : Branch, Langue, Thème, Profil */}
        <div className="hidden min-[900px]:flex items-center gap-2 flex-shrink-0">
          {/* Sélecteur d'agence */}
          <BranchSelector
            branches={branches}
            selectedBranch={selectedBranch}
            onSelect={onBranchSelect}
            theme={theme}
          />

          {/* Sélecteur de langue */}
          <div ref={langMenuRef} className="relative">
            <button
              onClick={() => setShowLanguageMenu(!showLanguageMenu)}
              className={`flex items-center gap-2 px-3 py-2 rounded-lg transition-colors ${
                theme === 'dark'
                  ? 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                  : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
              }`}
              title={t('admin.layout.language')}
            >
              <Globe className="w-4 h-4" />
              <span>{languageFlags[locale].flag}</span>
              <ChevronDown className={`w-3 h-3 transition-transform ${showLanguageMenu ? 'rotate-180' : ''}`} />
            </button>

            {mounted && showLanguageMenu && (
              <div className={`absolute right-0 top-full mt-2 w-40 rounded-lg shadow-xl z-50 overflow-hidden ${
                theme === 'dark'
                  ? 'bg-gray-800 border border-gray-700'
                  : 'bg-white border border-gray-200'
              }`}>
                {(Object.keys(languageFlags) as Locale[]).map((lang) => (
                  <button
                    key={lang}
                    onClick={() => {
                      setLocale(lang)
                      setShowLanguageMenu(false)
                    }}
                    className={`w-full px-4 py-2 text-left flex items-center gap-3 transition-colors ${
                      locale === lang
                        ? theme === 'dark'
                          ? 'bg-blue-600/20 text-blue-400'
                          : 'bg-blue-50 text-blue-600'
                        : theme === 'dark'
                          ? 'text-gray-300 hover:bg-gray-700'
                          : 'text-gray-700 hover:bg-gray-100'
                    }`}
                  >
                    <span className="text-lg">{languageFlags[lang].flag}</span>
                    <span>{languageFlags[lang].label}</span>
                  </button>
                ))}
              </div>
            )}
          </div>

          {/* Clara AI Assistant Button */}
          <ClaraButton onClick={toggleClara} isOpen={isClaraOpen} />

          {/* Toggle thème */}
          <button
            onClick={onToggleTheme}
            className={`p-2 rounded-lg transition-colors ${
              theme === 'dark'
                ? 'text-gray-400 hover:text-white hover:bg-gray-800'
                : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
            }`}
          >
            {theme === 'light' ? (
              <Moon className="w-5 h-5" />
            ) : (
              <Sun className="w-5 h-5" />
            )}
          </button>

          {/* Menu utilisateur */}
          <div ref={menuRef} className="relative">
            <button
              onClick={() => setShowUserMenu(!showUserMenu)}
              className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
                theme === 'dark'
                  ? 'bg-gray-800 hover:bg-gray-700'
                  : 'bg-gray-100 hover:bg-gray-200'
              }`}
            >
              <div className="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center">
                <User className="w-4 h-4 text-white" />
              </div>
              <div className="text-left hidden min-[900px]:block">
                <div className={`text-sm font-medium ${
                  theme === 'dark' ? 'text-white' : 'text-gray-900'
                }`}>
                  {user.profile?.full_name || user.email}
                </div>
                {getRoleBadge()}
              </div>
              <ChevronDown className={`w-4 h-4 transition-transform ${
                theme === 'dark' ? 'text-gray-400' : 'text-gray-600'
              } ${showUserMenu ? 'rotate-180' : ''}`} />
            </button>

            {mounted && showUserMenu && (
              <div className={`absolute right-0 top-full mt-2 w-56 rounded-lg shadow-xl z-50 overflow-hidden ${
                theme === 'dark'
                  ? 'bg-gray-800 border border-gray-700'
                  : 'bg-white border border-gray-200'
              }`}>
                <div className={`px-4 py-3 border-b ${
                  theme === 'dark' ? 'border-gray-700' : 'border-gray-200'
                }`}>
                  <div className={`text-sm font-medium ${
                    theme === 'dark' ? 'text-white' : 'text-gray-900'
                  }`}>
                    {user.profile?.full_name || 'Utilisateur'}
                  </div>
                  <div className={`text-xs ${
                    theme === 'dark' ? 'text-gray-400' : 'text-gray-600'
                  }`}>{user.email}</div>
                </div>

                {/* Liens administration - basés sur les permissions */}
                {(hasPermission('users', 'can_view') || hasPermission('logs', 'can_view') || hasPermission('permissions', 'can_view')) && (
                  <div className={`py-2 border-b ${
                    theme === 'dark' ? 'border-gray-700' : 'border-gray-200'
                  }`}>
                    {hasPermission('users', 'can_view') && (
                      <Link
                        href="/admin/users"
                        onClick={() => setShowUserMenu(false)}
                        className={`w-full px-4 py-2 text-left flex items-center gap-2 transition-colors ${
                          pathname === '/admin/users'
                            ? 'bg-blue-600 text-white'
                            : theme === 'dark'
                              ? 'text-gray-300 hover:bg-gray-700'
                              : 'text-gray-700 hover:bg-gray-100'
                        }`}
                      >
                        <Users className="w-4 h-4" />
                        {t('admin.header.users')}
                      </Link>
                    )}
                    {hasPermission('logs', 'can_view') && (
                      <Link
                        href="/admin/logs"
                        onClick={() => setShowUserMenu(false)}
                        className={`w-full px-4 py-2 text-left flex items-center gap-2 transition-colors ${
                          pathname === '/admin/logs'
                            ? 'bg-blue-600 text-white'
                            : theme === 'dark'
                              ? 'text-gray-300 hover:bg-gray-700'
                              : 'text-gray-700 hover:bg-gray-100'
                        }`}
                      >
                        <FileText className="w-4 h-4" />
                        {t('admin.header.logs')}
                      </Link>
                    )}
                    {hasPermission('permissions', 'can_view') && (
                      <Link
                        href="/admin/permissions"
                        onClick={() => setShowUserMenu(false)}
                        className={`w-full px-4 py-2 text-left flex items-center gap-2 transition-colors ${
                          pathname === '/admin/permissions'
                            ? 'bg-blue-600 text-white'
                            : theme === 'dark'
                              ? 'text-gray-300 hover:bg-gray-700'
                              : 'text-gray-700 hover:bg-gray-100'
                        }`}
                      >
                        <Lock className="w-4 h-4" />
                        {t('admin.header.permissions')}
                      </Link>
                    )}
                  </div>
                )}

                {/* Liens super_admin uniquement */}
                {user.role === 'super_admin' && (
                  <div className={`py-2 border-b ${
                    theme === 'dark' ? 'border-gray-700' : 'border-gray-200'
                  }`}>
                    <Link
                      href="/admin/statistics"
                      onClick={() => setShowUserMenu(false)}
                      className={`w-full px-4 py-2 text-left flex items-center gap-2 transition-colors ${
                        pathname === '/admin/statistics'
                          ? 'bg-blue-600 text-white'
                          : theme === 'dark'
                            ? 'text-gray-300 hover:bg-gray-700'
                            : 'text-gray-700 hover:bg-gray-100'
                      }`}
                    >
                      <BarChart3 className="w-4 h-4" />
                      {t('admin.header.statistics') || 'Statistiques'}
                    </Link>
                    <Link
                      href="/admin/settings"
                      onClick={() => setShowUserMenu(false)}
                      className={`w-full px-4 py-2 text-left flex items-center gap-2 transition-colors ${
                        pathname === '/admin/settings'
                          ? 'bg-blue-600 text-white'
                          : theme === 'dark'
                            ? 'text-gray-300 hover:bg-gray-700'
                            : 'text-gray-700 hover:bg-gray-100'
                      }`}
                    >
                      <Settings className="w-4 h-4" />
                      {t('admin.header.settings')}
                    </Link>
                    <Link
                      href="/admin/data-management"
                      onClick={() => setShowUserMenu(false)}
                      className={`w-full px-4 py-2 text-left flex items-center gap-2 transition-colors ${
                        pathname === '/admin/data-management'
                          ? 'bg-red-600 text-white'
                          : theme === 'dark'
                            ? 'text-red-400 hover:bg-gray-700'
                            : 'text-red-600 hover:bg-gray-100'
                      }`}
                    >
                      <Trash2 className="w-4 h-4" />
                      {t('admin.header.data_management') || 'Gestion des données'}
                    </Link>
                  </div>
                )}

                <div className="py-2">
                  <button
                    onClick={() => {
                      setShowUserMenu(false)
                      onSignOut()
                    }}
                    className={`w-full px-4 py-2 text-left flex items-center gap-2 transition-colors ${
                      theme === 'dark'
                        ? 'text-red-400 hover:bg-gray-700'
                        : 'text-red-600 hover:bg-gray-100'
                    }`}
                  >
                    <LogOut className="w-4 h-4" />
                    {t('admin.layout.logout')}
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Menu Hamburger - Seulement quand il n'y a vraiment plus d'espace */}
        <div className="min-[900px]:hidden">
          <button
            onClick={() => setShowMobileMenu(!showMobileMenu)}
            className={`p-2 rounded-lg transition-colors ${
              theme === 'dark'
                ? 'text-gray-400 hover:text-white hover:bg-gray-800'
                : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
            }`}
          >
            {showMobileMenu ? (
              <X className="w-6 h-6" />
            ) : (
              <Menu className="w-6 h-6" />
            )}
          </button>
        </div>
      </div>

      {/* Menu Mobile/Tablette - Visible quand hamburger est affiché */}
      {showMobileMenu && (
        <div className={`min-[900px]:hidden border-t ${
          theme === 'dark' ? 'border-gray-800' : 'border-gray-200'
        }`}>
          <div className="px-4 py-3 space-y-3">
            {/* Sélecteur de branche mobile */}
            <div className="pb-3 border-b border-gray-200 dark:border-gray-700">
              <BranchSelector
                branches={branches}
                selectedBranch={selectedBranch}
                onSelect={(branchId) => {
                  onBranchSelect(branchId)
                  setShowMobileMenu(false)
                }}
                theme={theme}
              />
            </div>

            {/* Navigation mobile */}
            <div className="space-y-2">
              <Link
                href="/admin"
                onClick={() => setShowMobileMenu(false)}
                className={`flex items-center gap-3 px-4 py-2 rounded-lg transition-colors relative ${
                  pathname === '/admin'
                    ? 'bg-blue-600 text-white'
                    : theme === 'dark'
                      ? 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                <Calendar className="w-4 h-4" />
                <span>{t('admin.header.agenda')}</span>
                {hasPendingOrders && pathname !== '/admin/orders' && (
                  <span className="bg-red-600 text-white text-xs font-bold px-1.5 py-0.5 rounded-full ml-auto animate-pulse">
                    !
                  </span>
                )}
              </Link>
              {hasPermission('clients', 'can_view') && (
                <Link
                  href="/admin/clients"
                  onClick={() => setShowMobileMenu(false)}
                  className={`flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                    pathname === '/admin/clients'
                      ? 'bg-blue-600 text-white'
                      : theme === 'dark'
                        ? 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                        : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                  }`}
                >
                  <Users className="w-4 h-4" />
                  <span>{t('admin.header.clients')}</span>
                </Link>
              )}
              {hasPermission('orders', 'can_view') && (
                <Link
                  href="/admin/orders"
                  onClick={() => setShowMobileMenu(false)}
                  className={`flex items-center gap-3 px-4 py-2 rounded-lg transition-colors relative ${
                    pathname === '/admin/orders'
                      ? 'bg-blue-600 text-white'
                      : theme === 'dark'
                        ? 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                        : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                  }`}
                >
                  <ShoppingCart className="w-4 h-4" />
                  <span>{t('admin.header.orders')}</span>
                  {hasPendingOrders && (
                    <span className="bg-red-600 text-white text-xs font-bold px-2 py-0.5 rounded-full ml-auto animate-pulse">
                      {pendingOrdersCount}
                    </span>
                  )}
                </Link>
              )}
            </div>

            {/* Sélecteur de langue mobile */}
            <div className={`pt-3 border-t ${
              theme === 'dark' ? 'border-gray-700' : 'border-gray-200'
            }`}>
              <div className={`px-4 py-2 text-sm font-medium ${theme === 'dark' ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.layout.language')}
              </div>
              <div className="flex gap-2 px-4">
                {(Object.keys(languageFlags) as Locale[]).map((lang) => (
                  <button
                    key={lang}
                    onClick={() => {
                      setLocale(lang)
                    }}
                    className={`flex items-center gap-2 px-3 py-2 rounded-lg transition-colors ${
                      locale === lang
                        ? 'bg-blue-600 text-white'
                        : theme === 'dark'
                          ? 'bg-gray-800 text-gray-300 hover:bg-gray-700'
                          : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}
                  >
                    <span>{languageFlags[lang].flag}</span>
                    <span className="text-sm">{languageFlags[lang].label}</span>
                  </button>
                ))}
              </div>
            </div>

            {/* Utilisateur mobile */}
            <div className={`pt-3 border-t ${
              theme === 'dark' ? 'border-gray-700' : 'border-gray-200'
            }`}>
              <div className={`px-4 py-2 ${theme === 'dark' ? 'text-white' : 'text-gray-900'}`}>
                <div className="text-sm font-medium">
                  {user.profile?.full_name || user.email}
                </div>
                <div className={`text-xs mt-1 ${theme === 'dark' ? 'text-gray-400' : 'text-gray-600'}`}>
                  {user.email}
                </div>
                {getRoleBadge()}
              </div>
              {/* Liens administration mobile - basés sur les permissions */}
              {hasPermission('users', 'can_view') && (
                <Link
                  href="/admin/users"
                  onClick={() => setShowMobileMenu(false)}
                  className={`w-full flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                    pathname === '/admin/users'
                      ? 'bg-blue-600 text-white'
                      : theme === 'dark'
                        ? 'text-gray-300 hover:bg-gray-700'
                        : 'text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  <Users className="w-4 h-4" />
                  <span>{t('admin.header.users')}</span>
                </Link>
              )}
              {hasPermission('logs', 'can_view') && (
                <Link
                  href="/admin/logs"
                  onClick={() => setShowMobileMenu(false)}
                  className={`w-full flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                    pathname === '/admin/logs'
                      ? 'bg-blue-600 text-white'
                      : theme === 'dark'
                        ? 'text-gray-300 hover:bg-gray-700'
                        : 'text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  <FileText className="w-4 h-4" />
                  <span>{t('admin.header.logs')}</span>
                </Link>
              )}
              {hasPermission('permissions', 'can_view') && (
                <Link
                  href="/admin/permissions"
                  onClick={() => setShowMobileMenu(false)}
                  className={`w-full flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                    pathname === '/admin/permissions'
                      ? 'bg-blue-600 text-white'
                      : theme === 'dark'
                        ? 'text-gray-300 hover:bg-gray-700'
                        : 'text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  <Lock className="w-4 h-4" />
                  <span>{t('admin.header.permissions')}</span>
                </Link>
              )}
              {/* Liens super_admin mobile */}
              {user.role === 'super_admin' && (
                <>
                  <Link
                    href="/admin/statistics"
                    onClick={() => setShowMobileMenu(false)}
                    className={`w-full flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      pathname === '/admin/statistics'
                        ? 'bg-blue-600 text-white'
                        : theme === 'dark'
                          ? 'text-gray-300 hover:bg-gray-700'
                          : 'text-gray-700 hover:bg-gray-100'
                    }`}
                  >
                    <BarChart3 className="w-4 h-4" />
                    <span>{t('admin.header.statistics') || 'Statistiques'}</span>
                  </Link>
                  <Link
                    href="/admin/settings"
                    onClick={() => setShowMobileMenu(false)}
                    className={`w-full flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                      pathname === '/admin/settings'
                        ? 'bg-blue-600 text-white'
                        : theme === 'dark'
                          ? 'text-gray-300 hover:bg-gray-700'
                          : 'text-gray-700 hover:bg-gray-100'
                    }`}
                  >
                    <Settings className="w-4 h-4" />
                    <span>{t('admin.header.settings')}</span>
                  </Link>
                </>
              )}
              <button
                onClick={() => {
                  setShowMobileMenu(false)
                  onToggleTheme()
                }}
                className={`w-full flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                  theme === 'dark'
                    ? 'text-gray-300 hover:bg-gray-700'
                    : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                {theme === 'light' ? (
                  <Moon className="w-4 h-4" />
                ) : (
                  <Sun className="w-4 h-4" />
                )}
              </button>
              <button
                onClick={() => {
                  setShowMobileMenu(false)
                  onSignOut()
                }}
                className={`w-full flex items-center gap-3 px-4 py-2 rounded-lg transition-colors ${
                  theme === 'dark'
                    ? 'text-red-400 hover:bg-gray-700'
                    : 'text-red-600 hover:bg-gray-100'
                }`}
              >
                <LogOut className="w-4 h-4" />
                <span>{t('admin.layout.logout')}</span>
              </button>
            </div>
          </div>
        </div>
      )}
    </header>
  )
}

// Memoize pour éviter les re-renders inutiles
export const AdminHeader = memo(AdminHeaderComponent)
</file>

<file path="src/app/api/bookings/[id]/route.ts">
/**
 * API Route pour gérer une réservation individuelle
 * GET: Récupérer une réservation
 * PUT: Mettre à jour une réservation
 * DELETE: Annuler/supprimer une réservation
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logBookingAction, logOrderAction, getClientIpFromHeaders } from '@/lib/activity-logger'
// iCount offers removed - no more offer cancellation needed
import type { UserRole, Booking, BookingSlot, GameSession } from '@/lib/supabase/types'

/**
 * GET /api/bookings/[id]
 * Récupère une réservation avec ses slots et sessions
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('agenda', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // Récupérer le booking
    const { data: booking, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', id)
      .single<Booking>()

    if (error || !booking) {
      return NextResponse.json(
        { success: false, error: 'Booking not found', messageKey: 'errors.bookingNotFound' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && booking.branch_id) {
      if (!user.branchIds.includes(booking.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
          { status: 403 }
        )
      }
    }

    // Récupérer les slots et sessions
    const [slotsResult, sessionsResult] = await Promise.all([
      supabase
        .from('booking_slots')
        .select('*')
        .eq('booking_id', id)
        .order('slot_start')
        .returns<BookingSlot[]>(),
      supabase
        .from('game_sessions')
        .select('*')
        .eq('booking_id', id)
        .order('session_order')
        .returns<GameSession[]>()
    ])

    return NextResponse.json({
      success: true,
      booking: {
        ...booking,
        slots: slotsResult.data || [],
        game_sessions: sessionsResult.data || []
      }
    })

  } catch (error) {
    console.error('Error fetching booking:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}

/**
 * PUT /api/bookings/[id]
 * Met à jour une réservation (participants, datetime, customer info, etc.)
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('agenda', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body = await request.json()
    const supabase = createServiceRoleClient()
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer le booking actuel
    const { data: oldBooking, error: fetchError } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', id)
      .single<Booking>()

    if (fetchError || !oldBooking) {
      return NextResponse.json(
        { success: false, error: 'Booking not found', messageKey: 'errors.bookingNotFound' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && oldBooking.branch_id) {
      if (!user.branchIds.includes(oldBooking.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
          { status: 403 }
        )
      }
    }

    // Vérifier si l'order associée est fermée (bloquer les modifications)
    const { data: orderForStatusCheck } = await supabase
      .from('orders')
      .select('id, status')
      .eq('booking_id', id)
      .single<{ id: string; status: string }>()

    if (orderForStatusCheck?.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Cannot modify a closed order', messageKey: 'errors.orderClosed' },
        { status: 400 }
      )
    }

    // Construire les données de mise à jour
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateData: Record<string, any> = {}
    const changedFields: string[] = []

    if (body.type !== undefined && body.type !== oldBooking.type) {
      updateData.type = body.type
      changedFields.push('type')
    }
    if (body.branch_id !== undefined && body.branch_id !== oldBooking.branch_id) {
      updateData.branch_id = body.branch_id
      changedFields.push('branch_id')
    }
    if (body.start_datetime !== undefined && body.start_datetime !== oldBooking.start_datetime) {
      updateData.start_datetime = body.start_datetime
      changedFields.push('start_datetime')
    }
    if (body.end_datetime !== undefined && body.end_datetime !== oldBooking.end_datetime) {
      updateData.end_datetime = body.end_datetime
      changedFields.push('end_datetime')
    }
    if (body.game_start_datetime !== undefined) {
      updateData.game_start_datetime = body.game_start_datetime
    }
    if (body.game_end_datetime !== undefined) {
      updateData.game_end_datetime = body.game_end_datetime
    }
    if (body.participants_count !== undefined && body.participants_count !== oldBooking.participants_count) {
      updateData.participants_count = body.participants_count
      changedFields.push('participants_count')
    }
    if (body.event_room_id !== undefined) {
      updateData.event_room_id = body.event_room_id
    }
    if (body.customer_first_name !== undefined && body.customer_first_name !== oldBooking.customer_first_name) {
      updateData.customer_first_name = body.customer_first_name
      changedFields.push('customer_first_name')
    }
    if (body.customer_last_name !== undefined && body.customer_last_name !== oldBooking.customer_last_name) {
      updateData.customer_last_name = body.customer_last_name
      changedFields.push('customer_last_name')
    }
    if (body.customer_phone !== undefined && body.customer_phone !== oldBooking.customer_phone) {
      updateData.customer_phone = body.customer_phone
      changedFields.push('customer_phone')
    }
    if (body.customer_email !== undefined && body.customer_email !== oldBooking.customer_email) {
      updateData.customer_email = body.customer_email
      changedFields.push('customer_email')
    }
    if (body.notes !== undefined) {
      updateData.notes = body.notes
    }
    if (body.color !== undefined) {
      updateData.color = body.color
    }
    if (body.discount_type !== undefined) {
      updateData.discount_type = body.discount_type
    }
    if (body.discount_value !== undefined) {
      updateData.discount_value = body.discount_value
    }
    if (body.primary_contact_id !== undefined) {
      updateData.primary_contact_id = body.primary_contact_id
    }

    updateData.updated_at = new Date().toISOString()

    // Mettre à jour le booking
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: updatedBooking, error: updateError } = await (supabase as any)
      .from('bookings')
      .update(updateData)
      .eq('id', id)
      .select()
      .single() as { data: Booking | null; error: any }

    if (updateError || !updatedBooking) {
      console.error('Error updating booking:', updateError)
      return NextResponse.json(
        { success: false, error: 'Failed to update booking', messageKey: 'errors.updateFailed' },
        { status: 500 }
      )
    }

    // Si primary_contact_id a changé, mettre à jour booking_contacts
    if (body.primary_contact_id !== undefined && body.primary_contact_id !== oldBooking.primary_contact_id) {
      // Supprimer les anciennes relations
      await supabase
        .from('booking_contacts')
        .delete()
        .eq('booking_id', id)

      // Créer la nouvelle relation si fournie
      if (body.primary_contact_id) {
        await supabase
          .from('booking_contacts')
          // @ts-expect-error - Supabase typing
          .insert({
            booking_id: id,
            contact_id: body.primary_contact_id,
            is_primary: true,
            role: null
          })
      }
    }

    // Si des slots sont fournis, les recréer
    if (body.slots && Array.isArray(body.slots)) {
      // Supprimer les anciens slots
      await supabase
        .from('booking_slots')
        .delete()
        .eq('booking_id', id)

      // Créer les nouveaux slots
      if (body.slots.length > 0) {
        const slotsToInsert = body.slots.map((slot: { slot_start: string; slot_end: string; participants_count: number }) => ({
          booking_id: id,
          branch_id: updateData.branch_id || oldBooking.branch_id,
          slot_start: slot.slot_start,
          slot_end: slot.slot_end,
          participants_count: slot.participants_count,
          slot_type: 'game_zone',
        }))

        await supabase
          .from('booking_slots')
          .insert(slotsToInsert)
      }
    }

    // Si des game_sessions sont fournies, les recréer
    if (body.game_sessions && Array.isArray(body.game_sessions)) {
      // Supprimer les anciennes sessions
      await supabase
        .from('game_sessions')
        .delete()
        .eq('booking_id', id)

      // Créer les nouvelles sessions
      if (body.game_sessions.length > 0) {
        const sessionsToInsert = body.game_sessions.map((session: {
          game_area: 'ACTIVE' | 'LASER';
          start_datetime: string;
          end_datetime: string;
          laser_room_id?: string | null;
          session_order: number;
          pause_before_minutes: number;
        }) => ({
          booking_id: id,
          game_area: session.game_area,
          start_datetime: session.start_datetime,
          end_datetime: session.end_datetime,
          laser_room_id: session.laser_room_id || null,
          session_order: session.session_order,
          pause_before_minutes: session.pause_before_minutes,
        }))

        await supabase
          .from('game_sessions')
          .insert(sessionsToInsert)
      }
    }

    // Synchroniser avec l'order correspondante
    const orderUpdateData: Record<string, unknown> = {
      updated_at: new Date().toISOString(),
    }

    if (updateData.start_datetime) {
      const bookingDate = new Date(updateData.start_datetime)
      orderUpdateData.requested_date = bookingDate.toISOString().split('T')[0]
      orderUpdateData.requested_time = bookingDate.toTimeString().slice(0, 5)
    }
    if (updateData.participants_count !== undefined) {
      orderUpdateData.participants_count = updateData.participants_count
    }
    if (updateData.customer_first_name !== undefined) {
      orderUpdateData.customer_first_name = updateData.customer_first_name
    }
    if (updateData.customer_last_name !== undefined) {
      orderUpdateData.customer_last_name = updateData.customer_last_name
    }
    if (updateData.customer_phone !== undefined) {
      orderUpdateData.customer_phone = updateData.customer_phone
    }
    if (updateData.customer_email !== undefined) {
      orderUpdateData.customer_email = updateData.customer_email
    }
    if (body.game_sessions && body.game_sessions.length > 0) {
      // Determine game_area based on all sessions
      const areas = body.game_sessions.map((s: { game_area: string }) => s.game_area)
      const uniqueAreas = [...new Set(areas)]

      if (uniqueAreas.length === 1) {
        // All sessions are the same area
        orderUpdateData.game_area = uniqueAreas[0]
      } else if (uniqueAreas.includes('ACTIVE') && uniqueAreas.includes('LASER')) {
        // Mix of ACTIVE and LASER
        orderUpdateData.game_area = 'MIX'
      } else {
        // Fallback to first session's area
        orderUpdateData.game_area = body.game_sessions[0].game_area
      }
      orderUpdateData.number_of_games = body.game_sessions.length
    }

    // Récupérer l'order liée pour le log
    const { data: linkedOrder } = await supabase
      .from('orders')
      .select('id, request_reference')
      .eq('booking_id', id)
      .single<{ id: string; request_reference: string }>()

    // Mettre à jour l'order
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    await (supabase as any)
      .from('orders')
      .update(orderUpdateData)
      .eq('booking_id', id)

    // Logger la modification du booking
    await logBookingAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
      action: 'updated',
      bookingId: id,
      bookingRef: updatedBooking.reference_code,
      branchId: updatedBooking.branch_id,
      details: {
        changedFields,
        oldValues: {
          participants_count: oldBooking.participants_count,
          start_datetime: oldBooking.start_datetime,
          customer_first_name: oldBooking.customer_first_name,
          customer_last_name: oldBooking.customer_last_name
        },
        newValues: {
          participants_count: updatedBooking.participants_count,
          start_datetime: updatedBooking.start_datetime,
          customer_first_name: updatedBooking.customer_first_name,
          customer_last_name: updatedBooking.customer_last_name
        }
      },
      ipAddress
    })

    // Logger aussi la mise à jour de l'order si elle existe
    if (linkedOrder) {
      await logOrderAction({
        userId: user.id,
        userRole: user.role as UserRole,
        userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
        action: 'confirmed', // 'confirmed' pour représenter une mise à jour (pas d'action 'updated' dans le type actuel)
        orderId: linkedOrder.id,
        orderRef: linkedOrder.request_reference,
        branchId: updatedBooking.branch_id,
        details: {
          bookingUpdated: true,
          changedFields
        },
        ipAddress
      })
    }

    return NextResponse.json({ success: true, booking: updatedBooking })

  } catch (error) {
    console.error('Error updating booking:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/bookings/[id]
 * Annuler ou supprimer une réservation
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('agenda', 'delete')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const searchParams = request.nextUrl.searchParams
    const hardDelete = searchParams.get('hard') === 'true'
    const reason = searchParams.get('reason') || undefined

    const supabase = createServiceRoleClient()
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer le booking
    const { data: booking, error: fetchError } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', id)
      .single<Booking>()

    if (fetchError || !booking) {
      return NextResponse.json(
        { success: false, error: 'Booking not found', messageKey: 'errors.bookingNotFound' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && booking.branch_id) {
      if (!user.branchIds.includes(booking.branch_id)) {
        return NextResponse.json(
          { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
          { status: 403 }
        )
      }
    }

    // Vérifier si l'order associée est fermée (bloquer suppression/annulation)
    const { data: orderForDeleteCheck } = await supabase
      .from('orders')
      .select('id, status')
      .eq('booking_id', id)
      .single<{ id: string; status: string }>()

    if (orderForDeleteCheck?.status === 'closed') {
      return NextResponse.json(
        { success: false, error: 'Cannot delete/cancel a booking linked to a closed order', messageKey: 'errors.orderClosed' },
        { status: 400 }
      )
    }

    if (hardDelete) {
      // Suppression définitive
      // Mettre à jour l'order correspondante d'abord
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      await (supabase as any)
        .from('orders')
        .update({
          status: 'cancelled',
          booking_id: null,
          updated_at: new Date().toISOString(),
        })
        .eq('booking_id', id)

      // Supprimer le booking (les slots et sessions sont supprimés en cascade)
      const { error: deleteError } = await supabase
        .from('bookings')
        .delete()
        .eq('id', id)

      if (deleteError) {
        console.error('Error deleting booking:', deleteError)
        return NextResponse.json(
          { success: false, error: 'Failed to delete booking', messageKey: 'errors.deleteFailed' },
          { status: 500 }
        )
      }

      // iCount offer cancellation removed - no more offers to cancel

      // Logger la suppression
      await logBookingAction({
        userId: user.id,
        userRole: user.role as UserRole,
        userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
        action: 'deleted',
        bookingId: id,
        bookingRef: booking.reference_code,
        branchId: booking.branch_id,
        details: {
          customerName: `${booking.customer_first_name} ${booking.customer_last_name || ''}`.trim(),
          type: booking.type,
          participants: booking.participants_count
        },
        ipAddress
      })

    } else {
      // Annulation (soft delete)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { error: cancelError } = await (supabase as any)
        .from('bookings')
        .update({
          status: 'CANCELLED',
          cancelled_at: new Date().toISOString(),
          cancelled_reason: reason,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)

      if (cancelError) {
        console.error('Error cancelling booking:', cancelError)
        return NextResponse.json(
          { success: false, error: 'Failed to cancel booking', messageKey: 'errors.cancelFailed' },
          { status: 500 }
        )
      }

      // Mettre à jour l'order correspondante
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      await (supabase as any)
        .from('orders')
        .update({
          status: 'cancelled',
          updated_at: new Date().toISOString(),
        })
        .eq('booking_id', id)

      // iCount offer cancellation removed - no more offers to cancel

      // Logger l'annulation
      await logBookingAction({
        userId: user.id,
        userRole: user.role as UserRole,
        userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
        action: 'cancelled',
        bookingId: id,
        bookingRef: booking.reference_code,
        branchId: booking.branch_id,
        details: {
          reason,
          customerName: `${booking.customer_first_name} ${booking.customer_last_name || ''}`.trim(),
          type: booking.type
        },
        ipAddress
      })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Error deleting booking:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/[id]/route.ts">
/**
 * API Route pour gérer une commande individuelle
 * GET: Récupérer une commande
 * PATCH: Mettre à jour le statut (confirmer, annuler)
 * DELETE: Supprimer une commande
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { logOrderAction, logBookingAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { sendBookingConfirmationEmail } from '@/lib/email-sender'
// iCount offers removed - no more offer cancellation needed
import type { UserRole, Booking, Branch } from '@/lib/supabase/types'

/**
 * GET /api/orders/[id]
 * Récupérer une commande
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const supabase = createServiceRoleClient()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: order, error } = await (supabase as any)
      .from('orders')
      .select(`
        *,
        branch:branches(id, name, slug),
        booking:bookings(id, reference_code, status, start_datetime, end_datetime),
        contact:contacts(id, first_name, last_name, phone, email)
      `)
      .eq('id', id)
      .single()

    if (error || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found', messageKey: 'errors.orderNotFound' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          {
            success: false,
            error: 'BRANCH_ACCESS_DENIED',
            message: 'You don\'t have access to this branch',
            messageKey: 'errors.branchAccessDenied'
          },
          { status: 403 }
        )
      }
    }

    return NextResponse.json({ success: true, order })

  } catch (error) {
    console.error('Error fetching order:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}

/**
 * PATCH /api/orders/[id]
 * Mettre à jour une commande (confirmer manuellement, annuler, etc.)
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions (edit pour modifier)
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'edit')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    const body = await request.json()
    const { action } = body
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer la commande actuelle
    const { data: order, error: fetchError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !order) {
      return NextResponse.json(
        { success: false, error: 'Order not found', messageKey: 'errors.orderNotFound' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          {
            success: false,
            error: 'BRANCH_ACCESS_DENIED',
            message: 'You don\'t have access to this branch',
            messageKey: 'errors.branchAccessDenied'
          },
          { status: 403 }
        )
      }
    }

    // BLOQUER TOUTE MODIFICATION sur une commande fermée
    if (order.status === 'closed') {
      return NextResponse.json(
        {
          success: false,
          error: 'Cannot modify a closed order',
          message: 'This order has been closed and cannot be modified.',
          messageKey: 'errors.orderClosed'
        },
        { status: 400 }
      )
    }

    if (action === 'confirm') {
      // Confirmer manuellement une commande pending
      // DÉSACTIVÉ: L'utilisateur doit passer par l'agenda pour validation manuelle
      return NextResponse.json(
        {
          success: false,
          error: 'Direct confirmation disabled',
          message: 'Please use "Reactivate" button to open this order in the agenda for manual confirmation.',
          messageKey: 'errors.directConfirmDisabled'
        },
        { status: 400 }
      )

    } else if (action === 'cancel') {
      // Vérifier si la commande est déjà clôturée
      if (order.status === 'closed') {
        return NextResponse.json(
          {
            success: false,
            error: 'Cannot cancel a closed order',
            message: 'This order has been closed and cannot be cancelled.',
            messageKey: 'errors.cannotCancelClosedOrder'
          },
          { status: 400 }
        )
      }

      // Vérifier si une facture existe (ne pas annuler si facture créée)
      if (order.icount_invrec_id) {
        return NextResponse.json(
          {
            success: false,
            error: 'Cannot cancel order with invoice',
            message: 'This order has an invoice and cannot be cancelled. Please contact accounting.',
            messageKey: 'errors.cannotCancelOrderWithInvoice'
          },
          { status: 400 }
        )
      }

      // Annuler la commande
      const { error: updateError } = await supabase
        .from('orders')
        .update({
          status: 'cancelled',
          processed_at: new Date().toISOString(),
          processed_by: user.id,
        })
        .eq('id', id)

      // Si un booking existe, l'annuler aussi
      if (order.booking_id) {
        // Récupérer les infos du booking pour annuler le devis
        const { data: bookingToCancel } = await supabase
          .from('bookings')
          .select('icount_offer_id, branch_id')
          .eq('id', order.booking_id)
          .single()

        // iCount offer cancellation removed - no more offers to cancel

        await supabase
          .from('bookings')
          .update({
            status: 'CANCELLED',
            cancelled_at: new Date().toISOString(),
            cancelled_reason: 'Order cancelled',
          })
          .eq('id', order.booking_id)

        // Logger l'annulation du booking
        await logBookingAction({
          userId: user.id,
          userRole: user.role as UserRole,
          userName: `${user.profile.first_name} ${user.profile.last_name}`,
          action: 'cancelled',
          bookingId: order.booking_id,
          bookingRef: order.request_reference,
          branchId: order.branch_id,
          details: { reason: 'Order cancelled', orderId: id },
          ipAddress
        })
      }

      if (updateError) {
        return NextResponse.json(
          { success: false, error: 'Failed to cancel order', messageKey: 'errors.cancelFailed' },
          { status: 500 }
        )
      }

      // Logger l'annulation de la commande
      await logOrderAction({
        userId: user.id,
        userRole: user.role as UserRole,
        userName: `${user.profile.first_name} ${user.profile.last_name}`,
        action: 'cancelled',
        orderId: id,
        orderRef: order.request_reference,
        branchId: order.branch_id,
        details: { previousStatus: order.status },
        ipAddress
      })

      return NextResponse.json({
        success: true,
        message: 'Order cancelled successfully'
      })

    } else if (action === 'reactivate') {
      // Réactiver une commande annulée (garder la même référence)
      if (order.status !== 'cancelled') {
        return NextResponse.json(
          { success: false, error: 'Order is not cancelled', messageKey: 'errors.orderNotCancelled' },
          { status: 400 }
        )
      }

      // Utiliser la référence originale de la commande
      const originalReference = order.request_reference

      // Vérifier si le booking existe encore et est annulé
      if (order.booking_id) {
        const { data: existingBooking } = await supabase
          .from('bookings')
          .select('id, status')
          .eq('id', order.booking_id)
          .single()

        if (existingBooking && existingBooking.status === 'CANCELLED') {
          // Réactiver le booking existant
          const { error: reactivateError } = await supabase
            .from('bookings')
            .update({
              status: 'CONFIRMED',
              cancelled_at: null,
              cancelled_reason: null,
            })
            .eq('id', order.booking_id)

          if (reactivateError) {
            console.error('Error reactivating booking:', reactivateError)
            return NextResponse.json(
              { success: false, error: 'Failed to reactivate booking', messageKey: 'errors.reactivateFailed' },
              { status: 500 }
            )
          }

          // Mettre à jour la commande
          const { error: updateError } = await supabase
            .from('orders')
            .update({
              status: 'manually_confirmed',
              processed_at: new Date().toISOString(),
              processed_by: user.id,
            })
            .eq('id', id)

          if (updateError) {
            return NextResponse.json(
              { success: false, error: 'Failed to update order', messageKey: 'errors.updateFailed' },
              { status: 500 }
            )
          }

          // Logger la réactivation
          await logOrderAction({
            userId: user.id,
            userRole: user.role as UserRole,
            userName: `${user.profile.first_name} ${user.profile.last_name}`,
            action: 'confirmed',
            orderId: id,
            orderRef: originalReference,
            branchId: order.branch_id,
            details: { reactivated: true, previousStatus: 'cancelled' },
            ipAddress
          })

          await logBookingAction({
            userId: user.id,
            userRole: user.role as UserRole,
            userName: `${user.profile.first_name} ${user.profile.last_name}`,
            action: 'updated',
            bookingId: order.booking_id,
            bookingRef: originalReference,
            branchId: order.branch_id,
            details: { reactivated: true, previousStatus: 'CANCELLED' },
            ipAddress
          })

          // Envoyer l'email de confirmation si le client a un email
          if (order.customer_email) {
            // Récupérer le booking complet
            const { data: bookingData } = await supabase
              .from('bookings')
              .select('*')
              .eq('id', order.booking_id)
              .single()

            // Récupérer la branche
            const { data: branchData } = await supabase
              .from('branches')
              .select('*')
              .eq('id', order.branch_id)
              .single()

            // Récupérer la langue préférée du contact si disponible
            let contactLocale: 'he' | 'fr' | 'en' = 'he'
            if (order.contact_id) {
              const { data: contactData } = await supabase
                .from('contacts')
                .select('preferred_locale')
                .eq('id', order.contact_id)
                .single() as unknown as { data: { preferred_locale: string | null } | null }
              if (contactData?.preferred_locale) {
                contactLocale = contactData.preferred_locale as 'he' | 'fr' | 'en'
              }
            }

            if (bookingData && branchData) {
              sendBookingConfirmationEmail({
                booking: bookingData as Booking,
                branch: branchData as Branch,
                triggeredBy: user.id,
                locale: contactLocale
              }).catch(err => {
                console.error('Failed to send confirmation email on reactivation:', err)
              })
            }
          }

          return NextResponse.json({
            success: true,
            message: 'Order reactivated successfully',
            booking_reference: originalReference
          })
        }
      }

      // Si le booking n'existe plus, en créer un nouveau avec la MÊME référence
      // Récupérer les settings
      const { data: settings } = await supabase
        .from('branch_settings')
        .select('*')
        .eq('branch_id', order.branch_id)
        .single()

      const gameDuration = settings?.game_duration_minutes || 30
      const eventDuration = settings?.event_total_duration_minutes || 120
      const bufferBefore = settings?.event_buffer_before_minutes || 30

      const startDateTime = new Date(`${order.requested_date}T${order.requested_time}`)
      let endDateTime: Date
      let gameStartDateTime: Date | null = null
      let gameEndDateTime: Date | null = null

      if (order.order_type === 'EVENT') {
        endDateTime = new Date(startDateTime.getTime() + eventDuration * 60000)
        gameStartDateTime = new Date(startDateTime.getTime() + bufferBefore * 60000)
        gameEndDateTime = new Date(gameStartDateTime.getTime() + (order.number_of_games * gameDuration) * 60000)
      } else {
        endDateTime = new Date(startDateTime.getTime() + (order.number_of_games * gameDuration) * 60000)
        gameStartDateTime = startDateTime
        gameEndDateTime = endDateTime
      }

      // Créer le booking avec la MÊME référence originale
      const { data: booking, error: bookingError } = await supabase
        .from('bookings')
        .insert({
          branch_id: order.branch_id,
          type: order.order_type,
          status: 'CONFIRMED',
          start_datetime: startDateTime.toISOString(),
          end_datetime: endDateTime.toISOString(),
          game_start_datetime: gameStartDateTime?.toISOString(),
          game_end_datetime: gameEndDateTime?.toISOString(),
          participants_count: order.participants_count,
          customer_first_name: order.customer_first_name,
          customer_last_name: order.customer_last_name || '',
          customer_phone: order.customer_phone,
          customer_email: order.customer_email,
          customer_notes_at_booking: order.customer_notes,
          primary_contact_id: order.contact_id,
          reference_code: originalReference, // MÊME référence
        })
        .select('id')
        .single()

      if (bookingError) {
        console.error('Error creating booking:', bookingError)
        return NextResponse.json(
          { success: false, error: 'Failed to create booking', messageKey: 'errors.createBookingFailed' },
          { status: 500 }
        )
      }

      // Créer la liaison contact
      if (order.contact_id) {
        await supabase
          .from('booking_contacts')
          .insert({
            booking_id: booking.id,
            contact_id: order.contact_id,
            is_primary: true,
          })
      }

      // Créer les slots
      const slots = []
      let currentTime = new Date(gameStartDateTime || startDateTime)

      for (let i = 0; i < order.number_of_games; i++) {
        const slotEnd = new Date(currentTime.getTime() + gameDuration * 60000)
        slots.push({
          booking_id: booking.id,
          branch_id: order.branch_id,
          slot_start: currentTime.toISOString(),
          slot_end: slotEnd.toISOString(),
          participants_count: order.participants_count,
          slot_type: 'game_zone',
        })
        currentTime = slotEnd
      }

      if (slots.length > 0) {
        await supabase.from('booking_slots').insert(slots)
      }

      // Créer les game_sessions si c'est un GAME
      if (order.order_type === 'GAME' && order.game_area) {
        const sessions = []
        let sessionTime = new Date(gameStartDateTime || startDateTime)

        for (let i = 0; i < order.number_of_games; i++) {
          const sessionEnd = new Date(sessionTime.getTime() + gameDuration * 60000)
          sessions.push({
            booking_id: booking.id,
            game_area: order.game_area,
            start_datetime: sessionTime.toISOString(),
            end_datetime: sessionEnd.toISOString(),
            session_order: i + 1,
            pause_before_minutes: 0,
          })
          sessionTime = sessionEnd
        }

        if (sessions.length > 0) {
          await supabase.from('game_sessions').insert(sessions)
        }
      }

      // Mettre à jour la commande
      const { error: updateError } = await supabase
        .from('orders')
        .update({
          status: 'manually_confirmed',
          booking_id: booking.id,
          processed_at: new Date().toISOString(),
          processed_by: user.id,
        })
        .eq('id', id)

      if (updateError) {
        return NextResponse.json(
          { success: false, error: 'Failed to update order', messageKey: 'errors.updateFailed' },
          { status: 500 }
        )
      }

      // Logger les actions
      await logOrderAction({
        userId: user.id,
        userRole: user.role as UserRole,
        userName: `${user.profile.first_name} ${user.profile.last_name}`,
        action: 'confirmed',
        orderId: id,
        orderRef: originalReference,
        branchId: order.branch_id,
        details: { reactivated: true, newBookingId: booking.id },
        ipAddress
      })

      await logBookingAction({
        userId: user.id,
        userRole: user.role as UserRole,
        userName: `${user.profile.first_name} ${user.profile.last_name}`,
        action: 'created',
        bookingId: booking.id,
        bookingRef: originalReference,
        branchId: order.branch_id,
        details: { fromReactivatedOrder: id, orderType: order.order_type },
        ipAddress
      })

      // Envoyer l'email de confirmation si le client a un email
      if (order.customer_email) {
        // Récupérer le booking complet qu'on vient de créer
        const { data: bookingData } = await supabase
          .from('bookings')
          .select('*')
          .eq('id', booking.id)
          .single()

        // Récupérer la branche
        const { data: branchData } = await supabase
          .from('branches')
          .select('*')
          .eq('id', order.branch_id)
          .single()

        // Récupérer la langue préférée du contact si disponible
        let contactLocale: 'he' | 'fr' | 'en' = 'he'
        if (order.contact_id) {
          const { data: contactData } = await supabase
            .from('contacts')
            .select('preferred_locale')
            .eq('id', order.contact_id)
            .single()
          if (contactData?.preferred_locale) {
            contactLocale = contactData.preferred_locale as 'he' | 'fr' | 'en'
          }
        }

        if (bookingData && branchData) {
          sendBookingConfirmationEmail({
            booking: bookingData as Booking,
            branch: branchData as Branch,
            triggeredBy: user.id,
            locale: contactLocale
          }).catch(err => {
            console.error('Failed to send confirmation email on reactivation (new booking):', err)
          })
        }
      }

      return NextResponse.json({
        success: true,
        message: 'Order reactivated successfully',
        booking_reference: originalReference
      })

    } else {
      return NextResponse.json(
        { success: false, error: 'Invalid action', messageKey: 'errors.invalidAction' },
        { status: 400 }
      )
    }

  } catch (error) {
    console.error('Error updating order:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/orders/[id]
 * Supprimer une commande
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Vérifier les permissions (delete pour supprimer)
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'delete')
    if (!success || !user) {
      return errorResponse
    }

    const { id } = await params
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Récupérer la commande avant suppression pour le log
    const { data: order } = await supabase
      .from('orders')
      .select('*')
      .eq('id', id)
      .single()

    if (!order) {
      return NextResponse.json(
        { success: false, error: 'Order not found', messageKey: 'errors.orderNotFound' },
        { status: 404 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && order.branch_id) {
      if (!user.branchIds.includes(order.branch_id)) {
        return NextResponse.json(
          {
            success: false,
            error: 'BRANCH_ACCESS_DENIED',
            message: 'You don\'t have access to this branch',
            messageKey: 'errors.branchAccessDenied'
          },
          { status: 403 }
        )
      }
    }

    // BLOQUER SUPPRESSION sur une commande fermée
    if (order.status === 'closed') {
      return NextResponse.json(
        {
          success: false,
          error: 'Cannot delete a closed order',
          message: 'This order has been closed and cannot be deleted.',
          messageKey: 'errors.orderClosed'
        },
        { status: 400 }
      )
    }

    // Annuler le devis iCount si un booking est associé (en background)
    if (order.booking_id) {
      // Récupérer les infos du booking avant suppression
      // iCount offer cancellation removed - no more offers to cancel
    }

    const { error } = await supabase
      .from('orders')
      .delete()
      .eq('id', id)

    if (error) {
      return NextResponse.json(
        { success: false, error: 'Failed to delete order', messageKey: 'errors.deleteFailed' },
        { status: 500 }
      )
    }

    // Logger la suppression
    await logOrderAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`,
      action: 'deleted',
      orderId: id,
      orderRef: order.request_reference,
      branchId: order.branch_id,
      details: {
        customerName: `${order.customer_first_name} ${order.customer_last_name || ''}`.trim(),
        status: order.status,
        orderType: order.order_type
      },
      ipAddress
    })

    return NextResponse.json({
      success: true,
      message: 'Order deleted successfully'
    })

  } catch (error) {
    console.error('Error deleting order:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/reservation/page.tsx">
'use client'

import { useState, useEffect, useMemo } from 'react'
import { useRouter } from 'next/navigation'
import Link from 'next/link'
import { motion, AnimatePresence } from 'framer-motion'
import { MapPin, Calendar, Clock, ChevronRight, ChevronLeft, Check, Users, Gamepad2, User, Phone, Mail, MessageSquare, FileText, ExternalLink, X, Home, Cake, Target, Zap, AlertCircle, CreditCard, Lock, Loader2 } from 'lucide-react'
import { getTranslations, getDirection, Locale, defaultLocale } from '@/i18n'
import { Header, Footer } from '@/components'
import { validateEmail, validateIsraeliPhone, formatIsraeliPhone, VALIDATION_MESSAGES } from '@/lib/validation'

type BookingStep = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8

interface BookingData {
  branch: string | null // Nom de la branche (pour affichage)
  branchSlug: string | null // Slug de la branche (pour identification unique dans la BD)
  type: 'game' | 'event' | null
  gameArea: 'ACTIVE' | 'LASER' | 'MIX' | null // Type de jeu (pour Game)
  numberOfGames: number // Nombre de jeux (pour Game)
  players: number | null
  date: string | null
  time: string | null
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  specialRequest: string | null
  termsAccepted: boolean
  // Event specific fields
  eventType: string | null // e.g., "birthday", "bar_mitzvah", "corporate", "party", "other"
  eventAge: number | null // Age for birthday or bar/bat mitzvah (optional)
}

export default function ReservationPage() {
  const router = useRouter()
  const [locale, setLocale] = useState<Locale>(defaultLocale)
  const [translations, setTranslations] = useState(getTranslations(defaultLocale))
  const [step, setStep] = useState<BookingStep>(1)
  const [bookingData, setBookingData] = useState<BookingData>({
    branch: null,
    branchSlug: null,
    type: null,
    gameArea: null,
    numberOfGames: 2, // Par défaut 2 jeux pour Active, 1 pour Laser
    players: null,
    date: null,
    time: null,
    firstName: null,
    lastName: null,
    phone: null,
    email: null,
    specialRequest: null,
    termsAccepted: false,
    eventType: null,
    eventAge: null,
  })
  const [selectedMonth, setSelectedMonth] = useState<number>(new Date().getMonth() + 1) // 1-12, pas 0-11
  const [selectedYear, setSelectedYear] = useState<number>(new Date().getFullYear())
  const [showTermsModal, setShowTermsModal] = useState(false)
  const [reservationNumber, setReservationNumber] = useState<string | null>(null)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [validationErrors, setValidationErrors] = useState<{ phone?: string; email?: string }>({})
  const [termsContent, setTermsContent] = useState<{ game: string | null; event: string | null }>({ game: null, event: null })
  const [termsLoading, setTermsLoading] = useState(false)

  // Payment states
  const [depositInfo, setDepositInfo] = useState<{
    amount: number
    total: number
    unitPrice: number
    roomPrice: number
    roomName: string | null
    breakdown: string
    explanation: string
  } | null>(null)
  const [isLoadingDeposit, setIsLoadingDeposit] = useState(false)
  const [cardData, setCardData] = useState({
    cc_number: '',
    cc_validity: '',
    cc_cvv: '',
    cc_holder_id: '',
    cc_holder_name: '',
  })
  const [paymentError, setPaymentError] = useState<string | null>(null)
  const [isProcessingPayment, setIsProcessingPayment] = useState(false)
  const [paymentSuccess, setPaymentSuccess] = useState(false)

  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedLocale = localStorage.getItem('locale') as Locale
      if (savedLocale && ['en', 'he'].includes(savedLocale)) {
        setLocale(savedLocale)
        setTranslations(getTranslations(savedLocale))
      }
    }
  }, [])

  // Fetch terms and conditions from database
  useEffect(() => {
    const fetchTerms = async () => {
      setTermsLoading(true)
      try {
        // Map locale to language code (fr not available on public site, fallback to en)
        const langCode = locale === 'he' ? 'he' : 'en'

        const response = await fetch(`/api/terms?lang=${langCode}`)
        if (response.ok) {
          const data = await response.json()
          setTermsContent({
            game: data.game || null,
            event: data.event || null
          })
        }
      } catch (error) {
        console.error('Error fetching terms:', error)
      } finally {
        setTermsLoading(false)
      }
    }

    fetchTerms()
  }, [locale])

  // Reset deposit info when booking data changes (before step 7)
  useEffect(() => {
    if (step < 7) {
      setDepositInfo(null)
    }
  }, [step, bookingData.type, bookingData.players, bookingData.gameArea, bookingData.eventType])

  // Fetch deposit info when reaching step 7 (payment step) with all required data
  useEffect(() => {
    const fetchDepositInfo = async () => {
      if (step !== 7) return
      if (!bookingData.branchSlug || !bookingData.type || !bookingData.players) return

      // Reset before fetching new data
      setDepositInfo(null)
      setIsLoadingDeposit(true)

      try {
        // First get the branch_id from slug
        const branchesResponse = await fetch('/api/branches')
        const branchesData = await branchesResponse.json()

        if (!branchesData.success || !branchesData.branches) {
          console.error('Failed to fetch branches')
          return
        }

        const branch = branchesData.branches.find((b: { slug: string }) =>
          b.slug?.toLowerCase().trim() === bookingData.branchSlug?.toLowerCase().trim()
        )

        if (!branch) {
          console.error('Branch not found:', bookingData.branchSlug)
          return
        }

        // Build request payload
        const payload = {
          branch_id: branch.id,
          order_type: bookingData.type === 'event' ? 'EVENT' : 'GAME',
          participants_count: bookingData.players,
          game_area: bookingData.gameArea,
          number_of_games: bookingData.numberOfGames,
          event_type: bookingData.eventType,
          locale: locale,
        }

        console.log('[DEPOSIT] Calculating deposit for:', payload)

        // Calculate deposit
        const response = await fetch('/api/public/calculate-deposit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        })

        const data = await response.json()
        console.log('[DEPOSIT] API response:', data)

        if (data.success && data.deposit) {
          setDepositInfo(data.deposit)
        } else {
          console.error('[DEPOSIT] API error:', data.error)
        }
      } catch (error) {
        console.error('Error fetching deposit info:', error)
      } finally {
        setIsLoadingDeposit(false)
      }
    }

    fetchDepositInfo()
  }, [step, bookingData.branchSlug, bookingData.type, bookingData.players, bookingData.gameArea, bookingData.numberOfGames, bookingData.eventType])

  const isRTL = locale === 'he'
  const dir = getDirection(locale)

  // Branches from translations (avec slug pour identification unique)
  const branches: Array<{ name: string; slug?: string; address: string; venue: string; city?: string; phone?: string }> = translations.branches?.items || []

  // Generate available dates (next 365 days - unlimited)
  const getAvailableDates = () => {
    const dates: string[] = []
    const today = new Date()

    // Start from TODAY (i=0), not tomorrow
    for (let i = 0; i <= 365; i++) {
      const date = new Date(today)
      date.setDate(today.getDate() + i)
      
      // FORMAT LOCAL (pas ISO pour éviter décalage timezone)
      const year = date.getFullYear()
      const month = String(date.getMonth() + 1).padStart(2, '0')
      const day = String(date.getDate()).padStart(2, '0')
      dates.push(`${year}-${month}-${day}`)
    }

    return dates
  }

  // Group dates by month
  const getDatesByMonth = () => {
    const dates = getAvailableDates()
    const grouped: { [key: string]: string[] } = {}
    
    dates.forEach((date) => {
      const [year, month] = date.split('-')
      const monthKey = `${year}-${month}`
      if (!grouped[monthKey]) {
        grouped[monthKey] = []
      }
      grouped[monthKey].push(date)
    })

    return grouped
  }

  // Get available months
  const getAvailableMonths = () => {
    const dates = getAvailableDates()
    const months = new Set<string>()
    
    dates.forEach((date) => {
      const dateObj = new Date(date + 'T00:00:00')
      months.add(`${dateObj.getFullYear()}-${String(dateObj.getMonth()).padStart(2, '0')}`)
    })
    
    return Array.from(months).sort().map((key) => {
      const [year, month] = key.split('-').map(Number)
      return { year, month, key }
    })
  }

  // Get dates for selected month
  const getDatesForSelectedMonth = () => {
    const grouped = getDatesByMonth()
    const monthKey = `${selectedYear}-${String(selectedMonth).padStart(2, '0')}`
    return grouped[monthKey] || []
  }

  // Get first day of month offset (to align calendar grid)
  const getFirstDayOffset = () => {
    const dates = getDatesForSelectedMonth()
    if (dates.length === 0) return 0
    const firstDate = dates[0]
    if (!firstDate) return 0
    const dateObj = new Date(firstDate + 'T00:00:00')
    return dateObj.getDay() // 0 = Sunday, 6 = Saturday
  }

  // Generate available time slots (10:00 to 23:00, every 30 minutes)
  // FILTRE: Si date = aujourd'hui, ne montrer que les heures futures (dès maintenant, pas de marge)
  const getAvailableTimes = () => {
    const times: string[] = []
    const now = new Date()
    const selectedDateStr = bookingData.date // Format: "YYYY-MM-DD"
    const todayStr = now.toISOString().split('T')[0]
    const isToday = selectedDateStr === todayStr

    for (let hour = 10; hour <= 23; hour++) {
      // Add :00
      const time00 = `${hour.toString().padStart(2, '0')}:00`
      if (isToday) {
        // Si aujourd'hui, vérifier que l'heure est dans le futur (dès maintenant, pas de marge)
        const slotDate = new Date(now)
        slotDate.setHours(hour, 0, 0, 0)
        if (slotDate >= now) {
          times.push(time00)
        }
      } else {
        times.push(time00)
      }
      
      // Add :30
      if (hour < 23) {
        const time30 = `${hour.toString().padStart(2, '0')}:30`
        if (isToday) {
          const slotDate = new Date(now)
          slotDate.setHours(hour, 30, 0, 0)
          if (slotDate >= now) {
            times.push(time30)
          }
        } else {
          times.push(time30)
        }
      }
    }

    return times
  }

  const handleBranchSelect = (branchName: string, branchSlug?: string) => {
    setBookingData({ ...bookingData, branch: branchName, branchSlug: branchSlug || null })
    setTimeout(() => setStep(2), 300)
  }

  // Sélection du type (Game ou Event) - reste sur étape 2 pour saisir participants
  const handleTypeSelect = (type: 'game' | 'event') => {
    setBookingData({ 
      ...bookingData, 
      type, 
      gameArea: null,
      numberOfGames: type === 'game' ? 2 : 2, // 2 jeux par défaut
      players: null,
      eventType: type === 'event' ? null : null,
      eventAge: null,
    })
    // Ne pas changer d'étape - on attend que l'utilisateur saisisse le nombre de participants
  }

  const handlePlayersChange = (players: number | null) => {
    setBookingData({ ...bookingData, players })
  }

  // Continuer après avoir saisi le nombre de participants (étape 2 → 3)
  const handleContinueToStep3 = () => {
    const minPlayers = bookingData.type === 'event' ? 15 : 1
    if (bookingData.type && bookingData.players && bookingData.players >= minPlayers) {
      setTimeout(() => setStep(3), 300) // Étape 3 = type de jeu (Game) ou type d'event (Event)
    }
  }

  // Sélection du type de jeu (pour Game uniquement)
  const handleGameAreaSelect = (gameArea: 'ACTIVE' | 'LASER' | 'MIX') => {
    // Définir le nombre de jeux par défaut selon le type
    const defaultGames = gameArea === 'LASER' ? 1 : 2
    setBookingData({ ...bookingData, gameArea, numberOfGames: defaultGames })
    // Ne pas changer d'étape - on attend la sélection du nombre de jeux
  }

  // Changer le nombre de jeux
  const handleNumberOfGamesChange = (num: number) => {
    setBookingData({ ...bookingData, numberOfGames: num })
  }

  // Continuer vers la date (étape 3 → 4)
  const handleContinueToDate = () => {
    if (bookingData.gameArea) {
      setTimeout(() => setStep(4), 300)
    }
  }


  const handleDateSelect = (date: string) => {
    setBookingData({ ...bookingData, date })
    setTimeout(() => setStep(5), 300) // Étape 5 = heure
  }

  const handleTimeSelect = (time: string) => {
    setBookingData({ ...bookingData, time })
    setTimeout(() => setStep(6), 300) // Étape 6 = contact
  }

  const handleNext = () => {
    if (step < 6) {
      setStep((step + 1) as BookingStep)
    }
  }

  const handlePrevious = () => {
    if (step > 1) {
      setStep((step - 1) as BookingStep)
    }
  }

  const handleContactInfoChange = (field: 'firstName' | 'lastName' | 'phone' | 'email' | 'specialRequest', value: string | number) => {
    setBookingData({ ...bookingData, [field]: value })
    
    // Validation en temps réel
    const newErrors = { ...validationErrors }
    
    if (field === 'phone' && value) {
      const phoneStr = String(value)
      if (!validateIsraeliPhone(phoneStr)) {
        newErrors.phone = VALIDATION_MESSAGES.phone.israeliFormat
      } else {
        delete newErrors.phone
      }
    }
    
    if (field === 'email' && value) {
      const emailStr = String(value)
      if (!validateEmail(emailStr)) {
        newErrors.email = VALIDATION_MESSAGES.email.invalid
      } else {
        delete newErrors.email
      }
    }
    
    setValidationErrors(newErrors)
  }

  // État pour le message de confirmation
  const [orderStatus, setOrderStatus] = useState<'auto_confirmed' | 'pending' | null>(null)
  const [orderMessage, setOrderMessage] = useState<string>('')

  // Handler pour les changements de carte
  const handleCardChange = (field: keyof typeof cardData, value: string) => {
    let formattedValue = value

    // Format card number with spaces
    if (field === 'cc_number') {
      formattedValue = value.replace(/\D/g, '').replace(/(.{4})/g, '$1 ').trim().slice(0, 19)
    }
    // Format validity as MM/YY
    else if (field === 'cc_validity') {
      formattedValue = value.replace(/\D/g, '')
      if (formattedValue.length > 2) {
        formattedValue = formattedValue.slice(0, 2) + '/' + formattedValue.slice(2, 4)
      }
    }
    // CVV max 4 digits
    else if (field === 'cc_cvv') {
      formattedValue = value.replace(/\D/g, '').slice(0, 4)
    }
    // ID only digits
    else if (field === 'cc_holder_id') {
      formattedValue = value.replace(/\D/g, '').slice(0, 9)
    }

    setCardData(prev => ({ ...prev, [field]: formattedValue }))
    setPaymentError(null)
  }

  // Validation de la carte
  const isCardValid = () => {
    const ccNumber = cardData.cc_number.replace(/\s/g, '')
    const ccValidity = cardData.cc_validity.replace('/', '')

    return (
      ccNumber.length >= 13 &&
      ccNumber.length <= 19 &&
      ccValidity.length === 4 &&
      cardData.cc_cvv.length >= 3 &&
      cardData.cc_holder_id.length >= 7
    )
  }

  const handleConfirm = async () => {
    // Protection double-click
    if (isSubmitting || isProcessingPayment) {
      return
    }

    // Si acompte requis et pas de carte valide, erreur
    if (depositInfo && depositInfo.amount > 0 && !isCardValid()) {
      setPaymentError('Please fill in all card details')
      return
    }

    setIsSubmitting(true)
    setPaymentError(null)

    try {
      // D'abord, récupérer le branch_id depuis le nom de la branche
      const branchesResponse = await fetch('/api/branches')
      const branchesData = await branchesResponse.json()

      if (!branchesData.success || !branchesData.branches || branchesData.branches.length === 0) {
        alert('Aucune branche disponible. Veuillez contacter le support.')
        setIsSubmitting(false)
        return
      }

      if (!bookingData.branch) {
        alert('Veuillez sélectionner une branche.')
        setIsSubmitting(false)
        return
      }

      // Trouver la branche par son slug (priorité) ou nom
      let selectedBranch = null

      if (bookingData.branchSlug) {
        selectedBranch = branchesData.branches?.find((b: { name: string; slug: string }) =>
          b.slug?.toLowerCase().trim() === bookingData.branchSlug?.toLowerCase().trim()
        )
      }

      if (!selectedBranch && bookingData.branch) {
        const branchNameLower = bookingData.branch.toLowerCase().trim()
        selectedBranch = branchesData.branches?.find((b: { name: string; slug: string }) => {
          const nameMatch = b.name?.toLowerCase().trim() === branchNameLower ||
                            b.name?.toLowerCase().trim().includes(branchNameLower) ||
                            branchNameLower.includes(b.name?.toLowerCase().trim() || '')
          const slugMatch = b.slug?.toLowerCase().trim() === branchNameLower ||
                            b.slug?.toLowerCase().trim().includes(branchNameLower) ||
                            branchNameLower.includes(b.slug?.toLowerCase().trim() || '')
          return nameMatch || slugMatch
        })
      }

      if (!selectedBranch) {
        alert(`Branche "${bookingData.branch}" non trouvée. Veuillez réessayer.`)
        setIsSubmitting(false)
        return
      }

      // Utiliser le gameArea sélectionné par l'utilisateur
      let gameArea: 'ACTIVE' | 'LASER' | null = null
      let customerNotes = bookingData.specialRequest || ''

      if (bookingData.gameArea) {
        if (bookingData.gameArea === 'MIX') {
          gameArea = 'ACTIVE'
          customerNotes = `[DEMANDE MIX Active + Laser] ${customerNotes}`.trim()
        } else {
          gameArea = bookingData.gameArea
        }
      }

      // ÉTAPE 1: Créer la commande
      const response = await fetch('/api/orders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          branch_id: selectedBranch.id,
          order_type: bookingData.type === 'event' ? 'EVENT' : 'GAME',
          requested_date: bookingData.date,
          requested_time: bookingData.time,
          participants_count: bookingData.players || 1,
          customer_first_name: bookingData.firstName,
          customer_last_name: bookingData.lastName || '',
          customer_phone: bookingData.phone ? formatIsraeliPhone(bookingData.phone) : bookingData.phone,
          customer_email: bookingData.email || null,
          customer_notes: customerNotes || null,
          game_area: gameArea,
          number_of_games: bookingData.numberOfGames,
          event_type: bookingData.eventType || null,
          event_celebrant_age: bookingData.eventAge || null,
          terms_accepted: bookingData.termsAccepted,
          locale: locale === 'he' ? 'he' : 'en',
        }),
      })

      const result = await response.json()

      if (!result.success) {
        console.error('Error saving order:', result.error)
        alert(`Erreur: ${result.error || 'Erreur lors de la sauvegarde de la réservation'}`)
        setIsSubmitting(false)
        return
      }

      const orderId = result.order_id

      // ÉTAPE 2: Si acompte requis, effectuer le paiement
      if (depositInfo && depositInfo.amount > 0) {
        setIsProcessingPayment(true)

        try {
          const paymentResponse = await fetch('/api/public/pay-deposit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              order_id: orderId,
              amount: depositInfo.amount,
              card_info: {
                cc_number: cardData.cc_number.replace(/\s/g, ''),
                cc_validity: cardData.cc_validity.replace('/', ''),
                cc_cvv: cardData.cc_cvv,
                cc_holder_id: cardData.cc_holder_id,
                cc_holder_name: cardData.cc_holder_name || `${bookingData.firstName} ${bookingData.lastName || ''}`.trim(),
              },
            }),
          })

          const paymentResult = await paymentResponse.json()

          if (!paymentResult.success) {
            // Paiement échoué - la commande est créée mais pas payée
            setPaymentError(paymentResult.error || 'Payment failed. Please try again.')
            setIsSubmitting(false)
            setIsProcessingPayment(false)
            return
          }

          // Paiement réussi
          setPaymentSuccess(true)
        } catch (payError) {
          console.error('Payment error:', payError)
          setPaymentError('Payment processing error. Please try again.')
          setIsSubmitting(false)
          setIsProcessingPayment(false)
          return
        } finally {
          setIsProcessingPayment(false)
        }
      }

      // Succès final
      setReservationNumber(result.reference)
      setOrderStatus(result.status)
      setOrderMessage(result.message || 'Booking confirmed')
      setStep(8)

    } catch (error) {
      console.error('Error confirming reservation:', error)
      alert('Erreur lors de la confirmation. Veuillez réessayer.')
    } finally {
      setIsSubmitting(false)
    }
  }

  const formatDate = (dateString: string) => {
    const date = new Date(dateString + 'T00:00:00')
    const options: Intl.DateTimeFormatOptions = { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    }
    return date.toLocaleDateString(isRTL ? 'he-IL' : 'en-US', options)
  }

  const availableDates = getAvailableDates()
  const availableTimes = useMemo(() => getAvailableTimes(), [bookingData.date])

  const handleLocaleChange = (newLocale: Locale) => {
    setLocale(newLocale)
    setTranslations(getTranslations(newLocale))
    localStorage.setItem('locale', newLocale)
    document.documentElement.dir = getDirection(newLocale)
    document.documentElement.lang = newLocale
  }

  return (
    <div dir={dir}>
      <Header 
        translations={translations} 
        locale={locale} 
        onLocaleChange={handleLocaleChange} 
      />
      <div className="min-h-screen bg-dark text-white pt-24 pb-12">
        <div className="container mx-auto px-4 max-w-4xl">
          {/* Header */}
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-8"
        >
          <h1 className="section-title text-4xl md:text-5xl mb-4">
            {translations.booking?.title || 'Book your session'}
          </h1>
        </motion.div>

        {/* Progress Steps */}
        <div className="flex justify-center items-center mb-12 gap-4">
          {[1, 2, 3, 4, 5, 6].map((s) => (
            <div key={s} className="flex items-center">
              <div
                className={`w-12 h-12 rounded-full flex items-center justify-center font-bold transition-all duration-300 ${
                  step >= s
                    ? 'bg-primary text-dark shadow-[0_0_20px_rgba(0,240,255,0.5)]'
                    : 'bg-dark-200 text-gray-400'
                }`}
              >
                    {step > s ? <Check className="w-6 h-6" /> : s}
                  </div>
                  {s < 5 && (
                <div
                  className={`w-16 h-1 mx-2 transition-all duration-300 ${
                    step > s ? 'bg-primary' : 'bg-dark-200'
                  }`}
                />
              )}
            </div>
          ))}
        </div>

        {/* Steps Content */}
        <AnimatePresence mode="wait">
          {/* Step 1: Select Branch */}
          {step === 1 && (
            <motion.div
              key="step1"
              initial={{ opacity: 0, x: isRTL ? 50 : -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: isRTL ? -50 : 50 }}
              className="bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border border-primary/30"
            >
              <div className="text-center mb-8">
                <MapPin className="w-16 h-16 text-primary mx-auto mb-4" />
                <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {translations.booking?.step1?.title || 'Select branch'}
                </h2>
                <p className="text-gray-400">{translations.booking?.step1?.subtitle || 'Choose the location where you want to play'}</p>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {branches.map((branch, index) => (
                  <motion.button
                    key={index}
                    onClick={() => handleBranchSelect(branch.name, branch.slug)}
                    className="bg-dark-200/50 hover:bg-dark-200 border-2 border-primary/30 hover:border-primary/70 rounded-xl p-6 text-left transition-all duration-300 hover:shadow-[0_0_20px_rgba(0,240,255,0.3)]"
                    whileHover={{ scale: 1.02 }}
                    whileTap={{ scale: 0.98 }}
                  >
                    <div className="flex items-start gap-4">
                      <MapPin className="w-6 h-6 text-primary flex-shrink-0 mt-1" />
                      <div>
                        <h3 className="text-xl font-bold mb-2" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          {branch.name}
                        </h3>
                        <p className="text-gray-400 text-sm mb-1" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          {branch.address}
                        </p>
                        <p className="text-primary text-sm" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          {branch.venue}
                        </p>
                      </div>
                    </div>
                  </motion.button>
                ))}
              </div>
            </motion.div>
          )}

          {/* Step 2: Select Type */}
          {step === 2 && (
            <motion.div
              key="step2"
              initial={{ opacity: 0, x: isRTL ? 50 : -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: isRTL ? -50 : 50 }}
              className="bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border border-primary/30"
            >
              <div className="text-center mb-8">
                <Users className="w-16 h-16 text-primary mx-auto mb-4" />
                <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {translations.booking?.step2?.title || 'Reservation Type'}
                </h2>
                <p className="text-gray-400">{translations.booking?.step2?.subtitle || 'Choose the type of activity'}</p>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                {/* Game */}
                <motion.button
                  onClick={() => handleTypeSelect('game')}
                  className={`border-2 rounded-xl p-6 text-left transition-all duration-300 ${
                    bookingData.type === 'game'
                      ? 'bg-dark-200 border-primary/70 shadow-[0_0_20px_rgba(0,240,255,0.3)]'
                      : 'bg-dark-200/50 border-primary/30 hover:border-primary/70 hover:shadow-[0_0_20px_rgba(0,240,255,0.3)]'
                  }`}
                  whileHover={{ scale: bookingData.type === 'game' ? 1 : 1.02 }}
                  whileTap={{ scale: 0.98 }}
                >
                  <div className="flex items-start gap-4">
                    <Gamepad2 className={`w-8 h-8 flex-shrink-0 mt-1 ${
                      bookingData.type === 'game' ? 'text-primary' : 'text-primary/70'
                    }`} />
                    <div>
                      <h3 className="text-xl font-bold mb-2" style={{ fontFamily: 'Poppins, sans-serif' }}>
                        {translations.booking?.type?.game?.title || 'Game'}
                      </h3>
                      <p className="text-gray-400 text-sm" style={{ fontFamily: 'Poppins, sans-serif' }}>
                        {translations.booking?.type?.game?.description || 'Unlimited games for one hour'}
                      </p>
                    </div>
                  </div>
                </motion.button>

                {/* Event */}
                <motion.button
                  onClick={() => handleTypeSelect('event')}
                  className={`border-2 rounded-xl p-6 text-left transition-all duration-300 ${
                    bookingData.type === 'event'
                      ? 'bg-dark-200 border-primary/70 shadow-[0_0_20px_rgba(0,240,255,0.3)]'
                      : 'bg-dark-200/50 border-primary/30 hover:border-primary/70 hover:shadow-[0_0_20px_rgba(0,240,255,0.3)]'
                  }`}
                  whileHover={{ scale: bookingData.type === 'event' ? 1 : 1.02 }}
                  whileTap={{ scale: 0.98 }}
                >
                  <div className="flex items-start gap-4">
                    <Users className={`w-8 h-8 flex-shrink-0 mt-1 ${
                      bookingData.type === 'event' ? 'text-primary' : 'text-primary/70'
                    }`} />
                    <div>
                      <h3 className="text-xl font-bold mb-2" style={{ fontFamily: 'Poppins, sans-serif' }}>
                        {translations.booking?.type?.event?.title || 'Event'}
                      </h3>
                      <p className="text-gray-400 text-sm" style={{ fontFamily: 'Poppins, sans-serif' }}>
                        {translations.booking?.type?.event?.description || 'Event package with private room'}
                      </p>
                    </div>
                  </div>
                </motion.button>
              </div>

              {/* Number of Players - Appears when Game or Event is selected */}
              {(bookingData.type === 'game' || bookingData.type === 'event') && (
                <motion.div
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mb-6"
                >
                  <label className="block text-white mb-3 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {translations.booking?.type?.players?.label || 'Number of players'}
                  </label>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div className="relative">
                      <input
                        type="number"
                        min={bookingData.type === 'event' ? 15 : 1}
                        max="100"
                        value={bookingData.players || ''}
                        onChange={(e) => {
                          // Allow empty input or any number, validation happens on continue
                          const value = e.target.value === '' ? null : (e.target.value ? parseInt(e.target.value) : null)
                          handlePlayersChange(value)
                        }}
                        placeholder={translations.booking?.type?.players?.placeholder || 'Enter number of players'}
                        className="w-full border border-primary/30 rounded-lg px-4 py-3 pr-12 font-medium hover:border-primary/70 transition-all backdrop-blur-sm"
                        style={{ 
                          fontFamily: 'Poppins, sans-serif',
                          backgroundColor: 'rgba(50, 50, 70, 0.7)',
                          color: '#00f0ff',
                          outline: 'none'
                        }}
                      />
                      <div className="absolute right-2 top-1/2 transform -translate-y-1/2 flex flex-col gap-0.5">
                        <button
                          type="button"
                          onClick={() => {
                            const minValue = bookingData.type === 'event' ? 15 : 1
                            const current = bookingData.players || minValue
                            if (current < 100) handlePlayersChange(current + 1)
                          }}
                          className="p-1 hover:bg-primary/20 rounded transition-colors"
                          style={{ color: '#00f0ff' }}
                        >
                          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 3L9 6H3L6 3Z" fill="currentColor" />
                          </svg>
                        </button>
                        <button
                          type="button"
                          onClick={() => {
                            const minValue = bookingData.type === 'event' ? 15 : 1
                            const current = bookingData.players || minValue
                            if (current > minValue) {
                              const newValue = current - 1
                              handlePlayersChange(newValue >= minValue ? newValue : null)
                            }
                          }}
                          className="p-1 hover:bg-primary/20 rounded transition-colors"
                          style={{ color: '#00f0ff' }}
                        >
                          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 9L3 6H9L6 9Z" fill="currentColor" />
                          </svg>
                        </button>
                      </div>
                    </div>
                    <div></div>
                  </div>
                  {/* Info text below input - en dehors du wrapper relatif */}
                  {bookingData.type === 'event' && (
                    <p className="mt-2 text-xs text-gray-400 text-center" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      {translations.booking?.type?.players?.info_event || 'Minimum 15 players required'}
                    </p>
                  )}
                  
                  {/* Continue button */}
                  {bookingData.players && bookingData.players >= (bookingData.type === 'event' ? 15 : 1) && (
                    <div className="mt-6 text-center">
                      <button
                        onClick={handleContinueToStep3}
                        className="glow-button inline-flex items-center gap-2"
                      >
                        {translations.booking?.next || 'Next'}
                        <ChevronRight className="w-5 h-5" />
                      </button>
                    </div>
                  )}
                  {bookingData.type === 'event' && bookingData.players && bookingData.players < 15 && (
                    <p className="mt-2 text-sm text-primary text-center" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      {translations.booking?.type?.event?.min_players_note || 'Minimum 15 players required for events'}
                    </p>
                  )}
                </motion.div>
              )}
            </motion.div>
          )}

          {/* Step 3: Game Type + Number of Games (for Game) OR Event Type (for Event) */}
          {step === 3 && (
            <motion.div
              key="step3"
              initial={{ opacity: 0, x: isRTL ? 50 : -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: isRTL ? -50 : 50 }}
              className="bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border border-primary/30"
            >
              {/* Pour les GAMES */}
              {bookingData.type === 'game' && (
                <>
                  <div className="text-center mb-8">
                    <Gamepad2 className="w-16 h-16 text-primary mx-auto mb-4" />
                    <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                      Type de jeu
                    </h2>
                    <p className="text-gray-400">Choisissez votre activité</p>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    {/* Active Games - Zap bleu comme dans l'admin */}
                    <motion.button
                      onClick={() => handleGameAreaSelect('ACTIVE')}
                      className={`border-2 rounded-xl p-6 text-center transition-all duration-300 ${
                        bookingData.gameArea === 'ACTIVE'
                          ? 'bg-dark-200 border-blue-500/70 shadow-[0_0_20px_rgba(59,130,246,0.3)]'
                          : 'bg-dark-200/50 border-primary/30 hover:border-blue-500/70 hover:shadow-[0_0_20px_rgba(59,130,246,0.3)]'
                      }`}
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <Zap className="w-12 h-12 mx-auto mb-3 text-blue-500" />
                      <h3 className="text-xl font-bold mb-2">Active Games</h3>
                      <p className="text-gray-400 text-sm">Jeux interactifs et challenges</p>
                    </motion.button>

                    {/* Laser - Target violet comme dans l'admin */}
                    <motion.button
                      onClick={() => handleGameAreaSelect('LASER')}
                      className={`border-2 rounded-xl p-6 text-center transition-all duration-300 ${
                        bookingData.gameArea === 'LASER'
                          ? 'bg-dark-200 border-purple-500/70 shadow-[0_0_20px_rgba(168,85,247,0.3)]'
                          : 'bg-dark-200/50 border-primary/30 hover:border-purple-500/70 hover:shadow-[0_0_20px_rgba(168,85,247,0.3)]'
                      }`}
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <Target className="w-12 h-12 mx-auto mb-3 text-purple-500" />
                      <h3 className="text-xl font-bold mb-2">Laser City</h3>
                      <p className="text-gray-400 text-sm">Labyrinthe laser</p>
                    </motion.button>

                    {/* Mix/Sur mesure - Gamepad2 cyan */}
                    <motion.button
                      onClick={() => handleGameAreaSelect('MIX')}
                      className={`border-2 rounded-xl p-6 text-center transition-all duration-300 ${
                        bookingData.gameArea === 'MIX'
                          ? 'bg-dark-200 border-cyan-500/70 shadow-[0_0_20px_rgba(6,182,212,0.3)]'
                          : 'bg-dark-200/50 border-primary/30 hover:border-cyan-500/70 hover:shadow-[0_0_20px_rgba(6,182,212,0.3)]'
                      }`}
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <Gamepad2 className="w-12 h-12 mx-auto mb-3 text-cyan-500" />
                      <h3 className="text-xl font-bold mb-2">Sur mesure</h3>
                      <p className="text-gray-400 text-sm">Combinaison Active + Laser</p>
                    </motion.button>
                  </div>

                  {/* Durée/Parties - apparaît après sélection du type */}
                  {bookingData.gameArea && (
                    <motion.div
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      className="border-t border-primary/20 pt-6"
                    >
                      {/* Active Games = durée en heures */}
                      {bookingData.gameArea === 'ACTIVE' && (
                        <>
                          <h3 className="text-lg font-bold text-center mb-4">Durée de jeu</h3>
                          <div className="flex justify-center gap-4 mb-6">
                            {[
                              { value: 2, label: '1h' },
                              { value: 3, label: '1h30' },
                              { value: 4, label: '2h' },
                            ].map((option) => (
                              <motion.button
                                key={option.value}
                                onClick={() => handleNumberOfGamesChange(option.value)}
                                className={`px-6 py-4 rounded-xl border-2 text-xl font-bold transition-all ${
                                  bookingData.numberOfGames === option.value
                                    ? 'bg-primary text-dark border-primary shadow-[0_0_15px_rgba(0,240,255,0.5)]'
                                    : 'bg-dark-200/50 border-primary/30 text-white hover:border-primary/70'
                                }`}
                                whileHover={{ scale: 1.05 }}
                                whileTap={{ scale: 0.95 }}
                              >
                                {option.label}
                              </motion.button>
                            ))}
                          </div>
                          <p className="text-center text-gray-400 text-sm mb-6">
                            Jeux illimités pendant la durée choisie
                          </p>
                        </>
                      )}

                      {/* Laser = nombre de parties */}
                      {bookingData.gameArea === 'LASER' && (
                        <>
                          <h3 className="text-lg font-bold text-center mb-4">Nombre de parties</h3>
                          <div className="flex justify-center gap-4 mb-6">
                            {[1, 2, 3].map((num) => (
                              <motion.button
                                key={num}
                                onClick={() => handleNumberOfGamesChange(num)}
                                className={`w-16 h-16 rounded-xl border-2 text-xl font-bold transition-all ${
                                  bookingData.numberOfGames === num
                                    ? 'bg-primary text-dark border-primary shadow-[0_0_15px_rgba(0,240,255,0.5)]'
                                    : 'bg-dark-200/50 border-primary/30 text-white hover:border-primary/70'
                                }`}
                                whileHover={{ scale: 1.05 }}
                                whileTap={{ scale: 0.95 }}
                              >
                                {num}
                              </motion.button>
                            ))}
                          </div>
                          <p className="text-center text-gray-400 text-sm mb-6">
                            {bookingData.numberOfGames} partie{bookingData.numberOfGames > 1 ? 's' : ''} de laser
                          </p>
                        </>
                      )}

                      {/* Mix = message explicatif */}
                      {bookingData.gameArea === 'MIX' && (
                        <>
                          <h3 className="text-lg font-bold text-center mb-4">Formule Sur Mesure</h3>
                          <div className={`p-4 rounded-xl bg-purple-500/10 border border-purple-500/30 mb-6`}>
                            <p className="text-center text-purple-300">
                              Combinaison Active Games + Laser City<br/>
                              <span className="text-sm text-gray-400">Nous vous contacterons pour personnaliser votre expérience</span>
                            </p>
                          </div>
                        </>
                      )}
                      
                      <div className="text-center">
                        <button
                          onClick={handleContinueToDate}
                          className="glow-button inline-flex items-center gap-2"
                        >
                          Continuer
                          <ChevronRight className="w-5 h-5" />
                        </button>
                      </div>
                    </motion.div>
                  )}
                </>
              )}

              {/* Pour les EVENTS - Choix du type de jeu */}
              {bookingData.type === 'event' && (
                <>
                  <div className="text-center mb-8">
                    <Cake className="w-16 h-16 text-primary mx-auto mb-4" />
                    <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                      Type de jeux
                    </h2>
                    <p className="text-gray-400">Quelle activité pour votre événement ?</p>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                    {/* Active Games 1h - Zap bleu comme dans l'admin */}
                    <motion.button
                      onClick={() => {
                        setBookingData({ ...bookingData, gameArea: 'ACTIVE', numberOfGames: 2, eventType: 'event_active' })
                      }}
                      className={`border-2 rounded-xl p-6 text-center transition-all duration-300 ${
                        bookingData.gameArea === 'ACTIVE'
                          ? 'bg-dark-200 border-blue-500/70 shadow-[0_0_20px_rgba(59,130,246,0.3)]'
                          : 'bg-dark-200/50 border-primary/30 hover:border-blue-500/70 hover:shadow-[0_0_20px_rgba(59,130,246,0.3)]'
                      }`}
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <Zap className="w-12 h-12 mx-auto mb-3 text-blue-500" />
                      <h3 className="text-xl font-bold mb-2">Active Games</h3>
                      <p className="text-gray-400 text-sm">1 heure de jeux</p>
                    </motion.button>

                    {/* Laser 2 parties - Target violet comme dans l'admin */}
                    <motion.button
                      onClick={() => {
                        setBookingData({ ...bookingData, gameArea: 'LASER', numberOfGames: 2, eventType: 'event_laser' })
                      }}
                      className={`border-2 rounded-xl p-6 text-center transition-all duration-300 ${
                        bookingData.gameArea === 'LASER'
                          ? 'bg-dark-200 border-purple-500/70 shadow-[0_0_20px_rgba(168,85,247,0.3)]'
                          : 'bg-dark-200/50 border-primary/30 hover:border-purple-500/70 hover:shadow-[0_0_20px_rgba(168,85,247,0.3)]'
                      }`}
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <Target className="w-12 h-12 mx-auto mb-3 text-purple-500" />
                      <h3 className="text-xl font-bold mb-2">Laser City</h3>
                      <p className="text-gray-400 text-sm">2 parties de laser</p>
                    </motion.button>

                    {/* Mix - Gamepad2 cyan */}
                    <motion.button
                      onClick={() => {
                        setBookingData({ ...bookingData, gameArea: 'MIX', numberOfGames: 2, eventType: 'event_mix' })
                      }}
                      className={`border-2 rounded-xl p-6 text-center transition-all duration-300 ${
                        bookingData.gameArea === 'MIX'
                          ? 'bg-dark-200 border-cyan-500/70 shadow-[0_0_20px_rgba(6,182,212,0.3)]'
                          : 'bg-dark-200/50 border-primary/30 hover:border-cyan-500/70 hover:shadow-[0_0_20px_rgba(6,182,212,0.3)]'
                      }`}
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <Gamepad2 className="w-12 h-12 mx-auto mb-3 text-cyan-500" />
                      <h3 className="text-xl font-bold mb-2">Mix</h3>
                      <p className="text-gray-400 text-sm">30min Active + 1 Laser</p>
                    </motion.button>
                  </div>

                  {/* Bouton Continuer */}
                  {bookingData.gameArea && (
                    <motion.div
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      className="text-center"
                    >
                      <button
                        onClick={handleContinueToDate}
                        className="glow-button inline-flex items-center gap-2"
                      >
                        Continuer
                        <ChevronRight className="w-5 h-5" />
                      </button>
                    </motion.div>
                  )}
                </>
              )}
            </motion.div>
          )}

          {/* Step 4: Select Date */}
          {step === 4 && (
            <motion.div
              key="step4"
              initial={{ opacity: 0, x: isRTL ? 50 : -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: isRTL ? -50 : 50 }}
              className="bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border border-primary/30"
            >
              <div className="text-center mb-6">
                <Calendar className="w-16 h-16 text-primary mx-auto mb-4" />
                <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {translations.booking?.step3?.title || 'Select date'}
                </h2>
                <p className="text-gray-400">{translations.booking?.step3?.subtitle || 'Choose the day for your session'}</p>
              </div>

              {/* Month/Year Selector */}
              <div className="mb-6 flex items-center justify-center gap-4">
                {(() => {
                  const availableMonths = getAvailableMonths()
                  const currentMonthKey = `${selectedYear}-${String(selectedMonth).padStart(2, '0')}`
                  const currentIndex = availableMonths.findIndex(m => m.key === currentMonthKey)
                  
                  return (
                    <>
                      <button
                        onClick={() => {
                          if (currentIndex > 0) {
                            const prevMonth = availableMonths[currentIndex - 1]
                            setSelectedYear(prevMonth.year)
                            setSelectedMonth(prevMonth.month)
                          }
                        }}
                        disabled={currentIndex === 0}
                        className="p-2 rounded-lg bg-dark-200/50 hover:bg-dark-200 border border-primary/30 hover:border-primary/70 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        <ChevronLeft className="w-5 h-5 text-primary" />
                      </button>

                      <button
                        onClick={() => {
                          if (currentIndex < availableMonths.length - 1) {
                            const nextMonth = availableMonths[currentIndex + 1]
                            setSelectedYear(nextMonth.year)
                            setSelectedMonth(nextMonth.month)
                          }
                        }}
                        disabled={currentIndex === availableMonths.length - 1}
                        className="p-2 rounded-lg bg-dark-200/50 hover:bg-dark-200 border border-primary/30 hover:border-primary/70 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        <ChevronRight className="w-5 h-5 text-primary" />
                      </button>
                    </>
                  )
                })()}
              </div>

              {/* Current Month Display */}
              <div className="text-center mb-4">
                <h3 className="text-xl font-bold text-primary" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {new Date(selectedYear, selectedMonth - 1, 1).toLocaleDateString(isRTL ? 'he-IL' : 'en-US', { 
                    month: 'long', 
                    year: 'numeric' 
                  })}
                </h3>
              </div>

              {/* Week header - More visible */}
              <div className="grid grid-cols-7 gap-2 mb-3">
                {[0, 1, 2, 3, 4, 5, 6].map((dayIndex) => {
                  const dayNames = isRTL 
                    ? ['א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ש']
                    : ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
                  return (
                    <div 
                      key={dayIndex} 
                      className="text-center text-sm font-bold text-primary py-2 border-b border-primary/30" 
                      style={{ fontFamily: 'Poppins, sans-serif' }}
                    >
                      {dayNames[dayIndex]}
                    </div>
                  )
                })}
              </div>

              {/* Calendar grid - 7 days per row with proper alignment */}
              <div className="grid grid-cols-7 gap-2 max-h-[500px] overflow-y-auto pr-2">
                {/* Empty cells for days before month starts */}
                {Array.from({ length: getFirstDayOffset() }).map((_, i) => (
                  <div key={`empty-${i}`} className="p-2" />
                ))}
                
                {/* Dates for selected month */}
                {getDatesForSelectedMonth().map((date) => {
                  const dateObj = new Date(date + 'T00:00:00')
                  
                  return (
                    <motion.button
                      key={date}
                      onClick={() => handleDateSelect(date)}
                      className={`rounded-lg p-3 border-2 transition-all duration-300 ${
                        bookingData.date === date
                          ? 'bg-primary text-dark border-primary shadow-[0_0_15px_rgba(0,240,255,0.5)]'
                          : 'bg-dark-200/50 border-primary/30 hover:border-primary/70 text-white'
                      }`}
                      whileHover={{ scale: 1.05 }}
                      whileTap={{ scale: 0.95 }}
                    >
                      <div className="text-center">
                        <div className="text-xs text-gray-400 mb-1" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          {dateObj.toLocaleDateString(isRTL ? 'he-IL' : 'en-US', { weekday: 'short' })}
                        </div>
                        <div className="text-base font-bold" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          {dateObj.getDate()}
                        </div>
                      </div>
                    </motion.button>
                  )
                })}
              </div>

              {bookingData.date && (
                <div className="mt-6 text-center">
                  <button
                    onClick={handleNext}
                    className="glow-button inline-flex items-center gap-2"
                  >
                    {translations.booking?.next || 'Next'}
                    <ChevronRight className="w-5 h-5" />
                  </button>
                </div>
              )}
            </motion.div>
          )}

          {/* Step 5: Select Time */}
          {step === 5 && (
            <motion.div
              key="step5"
              initial={{ opacity: 0, x: isRTL ? 50 : -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: isRTL ? -50 : 50 }}
              className="bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border border-primary/30"
            >
              <div className="text-center mb-8">
                <Clock className="w-16 h-16 text-primary mx-auto mb-4" />
                <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {translations.booking?.step4?.title || 'Select time'}
                </h2>
                <p className="text-gray-400">{translations.booking?.step4?.subtitle || 'Choose the time slot'}</p>
              </div>

              <div className="grid grid-cols-4 md:grid-cols-6 gap-3 mb-4">
                {availableTimes.map((time) => (
                  <motion.button
                    key={time}
                    onClick={() => handleTimeSelect(time)}
                    className={`rounded-lg p-3 border-2 transition-all duration-300 ${
                      bookingData.time === time
                        ? 'bg-primary text-dark border-primary shadow-[0_0_15px_rgba(0,240,255,0.5)]'
                        : 'bg-dark-200/50 border-primary/30 hover:border-primary/70 text-white'
                    }`}
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                  >
                    <div className="text-center font-bold text-sm" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      {time}
                    </div>
                  </motion.button>
                ))}
              </div>

              {/* Note about arriving 10 minutes early */}
              <div className="bg-primary/10 border border-primary/30 rounded-lg p-4 mb-6">
                <p className="text-sm text-primary text-center" style={{ fontFamily: 'Poppins, sans-serif' }}>
                  {translations.booking?.arrival_note || 'Please arrive at least 10 minutes before your scheduled time'}
                </p>
              </div>


              {bookingData.time && (
                <div className="mt-6 text-center">
                  <button
                    onClick={handleNext}
                    className="glow-button inline-flex items-center gap-2"
                  >
                    {translations.booking?.next || 'Next'}
                    <ChevronRight className="w-5 h-5" />
                  </button>
                </div>
              )}
            </motion.div>
          )}

          {/* Step 6: Contact Information */}
          {step === 6 && (
            <motion.div
              key="step6"
              initial={{ opacity: 0, x: isRTL ? 50 : -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: isRTL ? -50 : 50 }}
              className="bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border border-primary/30"
            >
              <div className="text-center mb-8">
                <User className="w-16 h-16 text-primary mx-auto mb-4" />
                <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {bookingData.type === 'event' 
                    ? (translations.booking?.step5?.title_event || 'Event Information & Contact')
                    : (translations.booking?.step5?.title || 'Contact Information')}
                </h2>
                <p className="text-gray-400">
                  {bookingData.type === 'event'
                    ? (translations.booking?.step5?.subtitle_event || 'Please fill in your contact details and event order information')
                    : (translations.booking?.step5?.subtitle || 'Please fill in your details')}
                </p>
              </div>

              <div className="space-y-6">
                {/* First Name and Last Name on same line */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* First Name */}
                  <div>
                    <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      {translations.booking?.contact?.first_name || 'First Name'}
                      <span className="text-primary ml-1">*</span>
                    </label>
                    <input
                      type="text"
                      value={bookingData.firstName || ''}
                      onChange={(e) => handleContactInfoChange('firstName', e.target.value)}
                      placeholder={translations.booking?.contact?.first_name_placeholder || 'Enter first name'}
                      className="w-full border border-primary/30 rounded-lg px-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm"
                      style={{ 
                        fontFamily: 'Poppins, sans-serif',
                        backgroundColor: 'rgba(50, 50, 70, 0.7)',
                        color: '#00f0ff',
                        outline: 'none'
                      }}
                      required
                    />
                  </div>

                  {/* Last Name */}
                  <div>
                    <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      {translations.booking?.contact?.last_name || 'Last Name'}
                      <span className="text-primary ml-1">*</span>
                    </label>
                    <input
                      type="text"
                      value={bookingData.lastName || ''}
                      onChange={(e) => handleContactInfoChange('lastName', e.target.value)}
                      placeholder={translations.booking?.contact?.last_name_placeholder || 'Enter last name'}
                      className="w-full border border-primary/30 rounded-lg px-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm"
                      style={{ 
                        fontFamily: 'Poppins, sans-serif',
                        backgroundColor: 'rgba(50, 50, 70, 0.7)',
                        color: '#00f0ff',
                        outline: 'none'
                      }}
                      required
                    />
                  </div>
                </div>

                {/* Phone */}
                <div>
                  <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {translations.booking?.contact?.phone || 'Phone Number'}
                    <span className="text-primary ml-1">*</span>
                  </label>
                  <div className="relative">
                    <Phone className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-primary" />
                    <input
                      type="tel"
                      value={bookingData.phone || ''}
                      onChange={(e) => handleContactInfoChange('phone', e.target.value)}
                      placeholder="05XXXXXXXX"
                      className={`w-full border ${validationErrors.phone ? 'border-red-500' : 'border-primary/30'} rounded-lg pl-12 pr-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm`}
                      style={{ 
                        fontFamily: 'Poppins, sans-serif',
                        backgroundColor: 'rgba(50, 50, 70, 0.7)',
                        color: '#00f0ff',
                        outline: 'none'
                      }}
                      required
                    />
                    {validationErrors.phone && (
                      <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                        <AlertCircle className="w-4 h-4" />
                        <span>{validationErrors.phone}</span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Email - Optional */}
                <div>
                  <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {translations.booking?.contact?.email || 'Email'}
                    {bookingData.type === 'event' && <span className="text-red-500 ml-1">*</span>}
                  </label>
                  <div className="relative">
                    <Mail className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-primary" />
                    <input
                      type="email"
                      value={bookingData.email || ''}
                      onChange={(e) => handleContactInfoChange('email', e.target.value)}
                      placeholder="example@email.com"
                      className={`w-full border ${validationErrors.email ? 'border-red-500' : 'border-primary/30'} rounded-lg pl-12 pr-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm`}
                      style={{
                        fontFamily: 'Poppins, sans-serif',
                        backgroundColor: 'rgba(50, 50, 70, 0.7)',
                        color: '#00f0ff',
                        outline: 'none'
                      }}
                      required={bookingData.type === 'event'}
                    />
                    {validationErrors.email && (
                      <div className="flex items-center gap-1 mt-1 text-red-500 text-sm">
                        <AlertCircle className="w-4 h-4" />
                        <span>{validationErrors.email}</span>
                      </div>
                    )}
                  </div>
                </div>


                {/* Special Request - Optional */}
                <div>
                  <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {translations.booking?.contact?.special_request || 'Special Request'}
                  </label>
                  <div className="relative">
                    <MessageSquare className="absolute left-3 top-4 w-5 h-5 text-primary" />
                    <textarea
                      value={bookingData.specialRequest || ''}
                      onChange={(e) => handleContactInfoChange('specialRequest', e.target.value)}
                      placeholder={translations.booking?.contact?.special_request_placeholder || 'If you have any special requests, please mention them here (optional)'}
                      rows={4}
                      className="w-full border border-primary/30 rounded-lg pl-12 pr-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm resize-none"
                      style={{ 
                        fontFamily: 'Poppins, sans-serif',
                        backgroundColor: 'rgba(50, 50, 70, 0.7)',
                        color: '#00f0ff',
                        outline: 'none'
                      }}
                    />
                  </div>
                </div>
              </div>
            </motion.div>
          )}

          {/* Step 7: Summary, Terms & Payment */}
          {step === 7 && (
            <motion.div
              key="step7"
              initial={{ opacity: 0, x: isRTL ? 50 : -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: isRTL ? -50 : 50 }}
              className="bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border border-primary/30"
            >
              <div className="text-center mb-8">
                <Check className="w-16 h-16 text-primary mx-auto mb-4" />
                <h2 className="text-2xl font-bold mb-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {translations.booking?.step7?.title || 'Review & Payment'}
                </h2>
                <p className="text-gray-400">
                  {translations.booking?.step7?.subtitle || 'Please review your booking and complete the payment'}
                </p>
              </div>

              {/* Booking Summary */}
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                className="bg-dark-200/50 rounded-xl p-6 border border-primary/30"
              >
                <h3 className="text-xl font-bold mb-4" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {translations.booking?.summary?.title || 'Booking Summary'}
                </h3>
                <div className="space-y-2" style={{ fontFamily: 'Poppins, sans-serif' }}>
                  <div className="flex justify-between">
                    <span className="text-gray-400">{translations.booking?.summary?.branch || 'Branch:'}</span>
                    <span className="font-bold">{bookingData.branch}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">{translations.booking?.summary?.type || 'Type:'}</span>
                    <span className="font-bold">
                      {bookingData.type === 'game'
                        ? (translations.booking?.type?.game?.title || 'Game')
                        : (translations.booking?.type?.event?.title || 'Event')}
                    </span>
                  </div>
                  {/* Activity type (Laser/Active/Mix) */}
                  {bookingData.gameArea && (
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.summary?.activity || 'Activity:'}</span>
                      <span className="font-bold">
                        {bookingData.gameArea === 'ACTIVE' && (translations.booking?.game_area?.active?.title || 'Active Games')}
                        {bookingData.gameArea === 'LASER' && (translations.booking?.game_area?.laser?.title || 'Laser City')}
                        {bookingData.gameArea === 'MIX' && (translations.booking?.game_area?.mix?.title || 'Mix Active + Laser')}
                      </span>
                    </div>
                  )}
                  {/* Duration/parties for GAME */}
                  {bookingData.type === 'game' && bookingData.gameArea && bookingData.numberOfGames && (
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.summary?.duration || 'Duration:'}</span>
                      <span className="font-bold">
                        {bookingData.gameArea === 'ACTIVE' && (
                          bookingData.numberOfGames === 1 ? '30min' :
                          bookingData.numberOfGames === 2 ? '1h' :
                          bookingData.numberOfGames === 3 ? '1h30' :
                          bookingData.numberOfGames === 4 ? '2h' :
                          `${bookingData.numberOfGames} games`
                        )}
                        {bookingData.gameArea === 'LASER' && (
                          `${bookingData.numberOfGames} ${bookingData.numberOfGames === 1
                            ? (translations.booking?.game_area?.laser?.party || 'party')
                            : (translations.booking?.game_area?.laser?.parties || 'parties')}`
                        )}
                        {bookingData.gameArea === 'MIX' && '30min Active + 1 Laser'}
                      </span>
                    </div>
                  )}
                  {bookingData.players && (
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.type?.players?.label || 'Players:'}</span>
                      <span className="font-bold">{bookingData.players}</span>
                    </div>
                  )}
                  <div className="flex justify-between">
                    <span className="text-gray-400">{translations.booking?.summary?.date || 'Date:'}</span>
                    <span className="font-bold">{bookingData.date && formatDate(bookingData.date)}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">{translations.booking?.summary?.time || 'Time:'}</span>
                    <span className="font-bold">{bookingData.time}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">{translations.booking?.summary?.name || 'Name:'}</span>
                    <span className="font-bold">{bookingData.firstName} {bookingData.lastName}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">{translations.booking?.summary?.phone || 'Phone:'}</span>
                    <span className="font-bold">{bookingData.phone}</span>
                  </div>
                  {bookingData.email && (
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.summary?.email || 'Email:'}</span>
                      <span className="font-bold">{bookingData.email}</span>
                    </div>
                  )}
                </div>
              </motion.div>

              {/* Terms and Conditions Checkbox */}
              <div className="mt-6 p-4 bg-dark-200/30 rounded-lg border border-primary/20">
                <div className="flex items-start gap-3">
                  <input
                    type="checkbox"
                    id="terms-checkbox"
                    checked={bookingData.termsAccepted}
                    onChange={(e) => setBookingData({ ...bookingData, termsAccepted: e.target.checked })}
                    className="mt-0.5 w-5 h-5 rounded border-primary/30 bg-dark-200/50 text-primary focus:ring-primary focus:ring-2 cursor-pointer"
                    style={{ 
                      accentColor: '#00f0ff',
                      flexShrink: 0
                    }}
                  />
                  <div className="flex-1">
                    <label htmlFor="terms-checkbox" className="text-white text-sm cursor-pointer flex items-center" style={{ fontFamily: 'Poppins, sans-serif', lineHeight: '1.5' }}>
                      {translations.booking?.contact?.terms?.label || 'I have read and agree to the terms and rules'}
                    </label>
                    <button
                      type="button"
                      onClick={() => setShowTermsModal(true)}
                      className="mt-3 ml-0 inline-flex items-center gap-2 text-primary hover:text-primary/80 transition-colors text-sm underline"
                      style={{ fontFamily: 'Poppins, sans-serif' }}
                    >
                      <FileText className="w-4 h-4" />
                      {translations.booking?.contact?.terms?.read_terms || 'Read terms and rules'}
                      <ExternalLink className="w-3 h-3" />
                    </button>
                  </div>
                </div>
              </div>

              {/* Price Summary & Deposit Section */}
              {depositInfo && (
                <motion.div
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="bg-dark-200/50 rounded-xl p-6 mt-6 border border-primary/30"
                >
                  <h3 className="text-xl font-bold mb-4 flex items-center gap-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                    <CreditCard className="w-5 h-5 text-primary" />
                    {translations.booking?.payment?.title || 'Price Summary'}
                  </h3>

                  {/* Price breakdown */}
                  <div className="space-y-3 mb-6" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.payment?.breakdown || 'Breakdown:'}</span>
                      <span className="font-bold text-white">{depositInfo.breakdown}</span>
                    </div>
                    <div className="flex justify-between text-lg">
                      <span className="text-gray-400">{translations.booking?.payment?.total || 'Total:'}</span>
                      <span className="font-bold text-primary">{depositInfo.total}₪</span>
                    </div>
                    <div className="border-t border-primary/20 pt-3">
                      <div className="flex justify-between items-center">
                        <div>
                          <span className="text-gray-400">{translations.booking?.payment?.deposit || 'Deposit to pay now:'}</span>
                          <p className="text-xs text-gray-500 mt-1">{depositInfo.explanation}</p>
                        </div>
                        <span className="font-bold text-2xl text-primary">{depositInfo.amount}₪</span>
                      </div>
                    </div>
                  </div>

                  {/* Credit Card Form */}
                  {depositInfo.amount > 0 && (
                    <div className="border-t border-primary/20 pt-6">
                      <h4 className="text-lg font-bold mb-4 flex items-center gap-2" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                        <Lock className="w-4 h-4 text-green-400" />
                        {translations.booking?.payment?.card_title || 'Secure Payment'}
                      </h4>

                      <div className="space-y-4">
                        {/* Card Number */}
                        <div>
                          <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                            {translations.booking?.payment?.card_number || 'Card Number'}
                            <span className="text-primary ml-1">*</span>
                          </label>
                          <input
                            type="text"
                            value={cardData.cc_number}
                            onChange={(e) => handleCardChange('cc_number', e.target.value)}
                            placeholder="1234 5678 9012 3456"
                            maxLength={19}
                            className="w-full border border-primary/30 rounded-lg px-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm"
                            style={{
                              fontFamily: 'monospace',
                              backgroundColor: 'rgba(50, 50, 70, 0.7)',
                              color: '#00f0ff',
                              outline: 'none',
                              letterSpacing: '2px'
                            }}
                          />
                        </div>

                        {/* Validity and CVV on same line */}
                        <div className="grid grid-cols-2 gap-4">
                          <div>
                            <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                              {translations.booking?.payment?.expiry || 'Expiry'}
                              <span className="text-primary ml-1">*</span>
                            </label>
                            <input
                              type="text"
                              value={cardData.cc_validity}
                              onChange={(e) => handleCardChange('cc_validity', e.target.value)}
                              placeholder="MM/YY"
                              maxLength={5}
                              className="w-full border border-primary/30 rounded-lg px-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm"
                              style={{
                                fontFamily: 'monospace',
                                backgroundColor: 'rgba(50, 50, 70, 0.7)',
                                color: '#00f0ff',
                                outline: 'none',
                                letterSpacing: '2px'
                              }}
                            />
                          </div>
                          <div>
                            <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                              CVV
                              <span className="text-primary ml-1">*</span>
                            </label>
                            <input
                              type="text"
                              value={cardData.cc_cvv}
                              onChange={(e) => handleCardChange('cc_cvv', e.target.value)}
                              placeholder="123"
                              maxLength={4}
                              className="w-full border border-primary/30 rounded-lg px-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm"
                              style={{
                                fontFamily: 'monospace',
                                backgroundColor: 'rgba(50, 50, 70, 0.7)',
                                color: '#00f0ff',
                                outline: 'none',
                                letterSpacing: '2px'
                              }}
                            />
                          </div>
                        </div>

                        {/* Card Holder ID */}
                        <div>
                          <label className="block text-white mb-2 text-sm font-medium" style={{ fontFamily: 'Poppins, sans-serif' }}>
                            {translations.booking?.payment?.holder_id || 'ID Number (Teudat Zehut)'}
                            <span className="text-primary ml-1">*</span>
                          </label>
                          <input
                            type="text"
                            value={cardData.cc_holder_id}
                            onChange={(e) => handleCardChange('cc_holder_id', e.target.value)}
                            placeholder="123456789"
                            maxLength={9}
                            className="w-full border border-primary/30 rounded-lg px-4 py-3 font-medium hover:border-primary/70 transition-all backdrop-blur-sm"
                            style={{
                              fontFamily: 'monospace',
                              backgroundColor: 'rgba(50, 50, 70, 0.7)',
                              color: '#00f0ff',
                              outline: 'none'
                            }}
                          />
                        </div>

                        {/* Payment Error */}
                        {paymentError && (
                          <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                            <div className="flex items-center gap-2 text-red-500">
                              <AlertCircle className="w-5 h-5" />
                              <span style={{ fontFamily: 'Poppins, sans-serif' }}>{paymentError}</span>
                            </div>
                          </div>
                        )}

                        {/* Security Notice */}
                        <div className="flex items-center gap-2 text-gray-400 text-xs" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          <Lock className="w-3 h-3" />
                          {translations.booking?.payment?.secure_notice || 'Your payment information is encrypted and secure'}
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Loading state */}
                  {isLoadingDeposit && (
                    <div className="flex items-center justify-center py-4">
                      <Loader2 className="w-6 h-6 text-primary animate-spin" />
                      <span className="ml-2 text-gray-400">{translations.booking?.payment?.loading || 'Calculating...'}</span>
                    </div>
                  )}
                </motion.div>
              )}
            </motion.div>
          )}

          {/* Step 8: Confirmation */}
          {step === 8 && reservationNumber && (
            <motion.div
              key="step8"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              className={`bg-dark-100/50 backdrop-blur-sm rounded-2xl p-8 border-2 shadow-[0_0_30px_rgba(0,240,255,0.3)] ${
                orderStatus === 'pending' 
                  ? 'border-yellow-500/50' 
                  : 'border-primary/50'
              }`}
            >
              <div className="text-center">
                {/* Success/Pending Icon */}
                <motion.div
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ delay: 0.2, type: "spring", stiffness: 200 }}
                  className={`w-20 h-20 mx-auto mb-6 rounded-full flex items-center justify-center ${
                    orderStatus === 'pending' 
                      ? 'bg-yellow-500/20' 
                      : 'bg-primary/20'
                  }`}
                >
                  {orderStatus === 'pending' ? (
                    <Clock className="w-12 h-12 text-yellow-500" />
                  ) : (
                    <Check className="w-12 h-12 text-primary" />
                  )}
                </motion.div>

                {/* Title */}
                <h2 className={`text-3xl font-bold mb-2 ${orderStatus === 'pending' ? 'text-yellow-500' : 'text-primary'}`} style={{ fontFamily: 'Orbitron, sans-serif' }}>
                  {orderStatus === 'pending' 
                    ? 'Request Received!'
                    : (translations.booking?.confirmation?.title || 'Reservation Confirmed!')}
                </h2>
                <p className="text-gray-300 mb-8" style={{ fontFamily: 'Poppins, sans-serif' }}>
                  {orderStatus === 'pending'
                    ? 'We will contact you shortly to confirm your reservation'
                    : (translations.booking?.confirmation?.subtitle || 'Thank you for your reservation')}
                </p>

                {/* Pending Message */}
                {orderStatus === 'pending' && (
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4 mb-6">
                    <p className="text-yellow-500" style={{ fontFamily: 'Poppins, sans-serif' }}>
                      {orderMessage || 'Your request has been received. We will contact you shortly to confirm your reservation.'}
                    </p>
                  </div>
                )}

                {/* Reservation/Request Number */}
                <div className={`border rounded-lg p-4 mb-8 ${
                  orderStatus === 'pending'
                    ? 'bg-yellow-500/10 border-yellow-500/30'
                    : 'bg-primary/10 border-primary/30'
                }`}>
                  <p className="text-gray-400 text-sm mb-2" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    {orderStatus === 'pending'
                      ? 'Request Number'
                      : (translations.booking?.confirmation?.reservation_number || 'Reservation Number')}
                  </p>
                  <p className={`text-2xl font-bold ${orderStatus === 'pending' ? 'text-yellow-500' : 'text-primary'}`} style={{ fontFamily: 'Orbitron, sans-serif', letterSpacing: '2px' }}>
                    {reservationNumber}
                  </p>
                </div>

                {/* Payment Success Banner */}
                {paymentSuccess && depositInfo && depositInfo.amount > 0 && (
                  <motion.div
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="bg-green-500/10 border border-green-500/30 rounded-lg p-4 mb-8"
                  >
                    <div className="flex items-center justify-center gap-3">
                      <div className="w-10 h-10 bg-green-500/20 rounded-full flex items-center justify-center">
                        <Check className="w-6 h-6 text-green-500" />
                      </div>
                      <div className="text-left">
                        <p className="text-green-500 font-bold" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          {translations.booking?.confirmation?.payment_success || 'Payment Successful!'}
                        </p>
                        <p className="text-green-400 text-sm" style={{ fontFamily: 'Poppins, sans-serif' }}>
                          {translations.booking?.confirmation?.deposit_paid || 'Deposit paid:'} {depositInfo.amount}₪
                        </p>
                      </div>
                    </div>
                  </motion.div>
                )}

                {/* Booking Summary */}
                <div className="bg-dark-200/50 rounded-xl p-6 mb-8 border border-primary/30 text-left max-w-2xl mx-auto">
                  <h3 className="text-xl font-bold mb-4 text-primary" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                    {translations.booking?.summary?.title || 'Booking Summary'}
                  </h3>
                  <div className="space-y-3" style={{ fontFamily: 'Poppins, sans-serif' }}>
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.summary?.branch || 'Branch:'}</span>
                      <span className="font-bold text-white">{bookingData.branch}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.summary?.type || 'Type:'}</span>
                      <span className="font-bold text-white">
                        {bookingData.type === 'game' 
                          ? (translations.booking?.type?.game?.title || 'Game')
                          : (translations.booking?.type?.event?.title || 'Event')}
                      </span>
                    </div>
                    {bookingData.players && (
                      <div className="flex justify-between">
                        <span className="text-gray-400">{translations.booking?.type?.players?.label || 'Players:'}</span>
                        <span className="font-bold text-white">{bookingData.players}</span>
                      </div>
                    )}
                    {/* Activity type (Laser/Active/Mix) */}
                    {bookingData.gameArea && (
                      <div className="flex justify-between">
                        <span className="text-gray-400">{translations.booking?.summary?.activity || 'Activity:'}</span>
                        <span className="font-bold text-white">
                          {bookingData.gameArea === 'ACTIVE' && (translations.booking?.game_area?.active?.title || 'Active Games')}
                          {bookingData.gameArea === 'LASER' && (translations.booking?.game_area?.laser?.title || 'Laser City')}
                          {bookingData.gameArea === 'MIX' && (translations.booking?.game_area?.mix?.title || 'Mix Active + Laser')}
                        </span>
                      </div>
                    )}
                    {/* Duration/parties for GAME */}
                    {bookingData.type === 'game' && bookingData.gameArea && bookingData.numberOfGames && (
                      <div className="flex justify-between">
                        <span className="text-gray-400">{translations.booking?.summary?.duration || 'Duration:'}</span>
                        <span className="font-bold text-white">
                          {bookingData.gameArea === 'ACTIVE' && (
                            bookingData.numberOfGames === 1 ? '30min' :
                            bookingData.numberOfGames === 2 ? '1h' :
                            bookingData.numberOfGames === 3 ? '1h30' :
                            bookingData.numberOfGames === 4 ? '2h' :
                            `${bookingData.numberOfGames} games`
                          )}
                          {bookingData.gameArea === 'LASER' && (
                            `${bookingData.numberOfGames} ${bookingData.numberOfGames === 1
                              ? (translations.booking?.game_area?.laser?.party || 'party')
                              : (translations.booking?.game_area?.laser?.parties || 'parties')}`
                          )}
                          {bookingData.gameArea === 'MIX' && '30min Active + 1 Laser'}
                        </span>
                      </div>
                    )}
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.summary?.date || 'Date:'}</span>
                      <span className="font-bold text-white">{bookingData.date && formatDate(bookingData.date)}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">{translations.booking?.summary?.time || 'Time:'}</span>
                      <span className="font-bold text-white">{bookingData.time}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Name:</span>
                      <span className="font-bold text-white">{bookingData.firstName} {bookingData.lastName}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Phone:</span>
                      <span className="font-bold text-white">{bookingData.phone}</span>
                    </div>
                    {bookingData.email && (
                      <div className="flex justify-between">
                        <span className="text-gray-400">Email:</span>
                        <span className="font-bold text-white">{bookingData.email}</span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Back to Site Button */}
                <Link
                  href="/"
                  className="glow-button inline-flex items-center gap-2"
                >
                  <Home className="w-5 h-5" />
                  {translations.booking?.confirmation?.back_to_site || 'Back to Site'}
                </Link>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Navigation Buttons */}
        {step !== 8 && (
        <div className="flex justify-between mt-8">
          <button
            onClick={handlePrevious}
            disabled={step === 1}
            className={`inline-flex items-center gap-2 px-6 py-3 rounded-xl transition-all duration-300 ${
              step === 1
                ? 'bg-dark-200/50 text-gray-500 cursor-not-allowed'
                : 'bg-dark-200/50 hover:bg-dark-200 text-white border border-primary/30 hover:border-primary/70'
            }`}
          >
            <ChevronLeft className="w-5 h-5" />
            {translations.booking?.previous || 'Previous'}
          </button>

          {/* Step 6: Next button to go to payment step */}
          {step === 6 && (
            <button
              onClick={() => setStep(7)}
              disabled={
                !bookingData.firstName ||
                !bookingData.lastName ||
                !bookingData.phone ||
                !!validationErrors.phone ||
                !!(bookingData.email && validationErrors.email) ||
                (bookingData.type === 'event' && !bookingData.email)
              }
              className={`inline-flex items-center gap-2 px-6 py-3 rounded-xl transition-all duration-300 ${
                bookingData.firstName &&
                bookingData.lastName &&
                bookingData.phone &&
                !validationErrors.phone &&
                (!bookingData.email || !validationErrors.email) &&
                (bookingData.type !== 'event' || bookingData.email)
                  ? 'glow-button'
                  : 'bg-dark-200 border-2 border-primary/30 text-gray-300 cursor-not-allowed hover:border-primary/40'
              }`}
            >
              {translations.booking?.next || 'Next'}
              <ChevronRight className="w-5 h-5" />
            </button>
          )}

          {/* Step 7: Pay and confirm button */}
          {step === 7 && (
            <button
              onClick={handleConfirm}
              disabled={
                isSubmitting ||
                isProcessingPayment ||
                !bookingData.termsAccepted ||
                !!(depositInfo && depositInfo.amount > 0 && !isCardValid())
              }
              className={`inline-flex items-center gap-2 px-6 py-3 rounded-xl transition-all duration-300 ${
                !isSubmitting &&
                !isProcessingPayment &&
                bookingData.termsAccepted &&
                (!depositInfo || depositInfo.amount === 0 || isCardValid())
                  ? 'glow-button'
                  : 'bg-dark-200 border-2 border-primary/30 text-gray-300 cursor-not-allowed hover:border-primary/40'
              }`}
              style={{
                opacity: (
                  bookingData.termsAccepted &&
                  (!depositInfo || depositInfo.amount === 0 || isCardValid())
                ) ? 1 : 0.75
              }}
            >
              {isSubmitting || isProcessingPayment ? (
                <>
                  <Loader2 className="w-5 h-5 animate-spin" />
                  {isProcessingPayment
                    ? (translations.booking?.payment?.processing || 'Processing payment...')
                    : (translations.booking?.submitting || 'Submitting...')}
                </>
              ) : (
                <>
                  {depositInfo && depositInfo.amount > 0 ? (
                    <>
                      <CreditCard className="w-5 h-5" />
                      {translations.booking?.pay_and_confirm || `Pay ${depositInfo.amount}₪ and confirm`}
                    </>
                  ) : (
                    <>
                      {translations.booking?.confirm || 'Confirm booking'}
                      <Check className="w-5 h-5" />
                    </>
                  )}
                </>
              )}
            </button>
          )}
        </div>
        )}
        </div>
      </div>
      <Footer translations={translations} />

      {/* Terms and Conditions Modal */}
      {showTermsModal && (
        <div 
          className="fixed inset-0 z-50 flex items-center justify-center p-4"
          style={{ backgroundColor: 'rgba(0, 0, 0, 0.9)', backdropFilter: 'blur(5px)' }}
          onClick={() => setShowTermsModal(false)}
        >
          <motion.div
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.9 }}
            className="bg-dark-100 rounded-2xl border border-primary/30 max-w-3xl w-full max-h-[80vh] overflow-hidden flex flex-col"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Modal Header */}
            <div className="flex items-center justify-between p-6 border-b border-primary/30">
              <h2 className="text-2xl font-bold text-white" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                {translations.booking?.contact?.terms?.title || 'Terms and Rules'}
              </h2>
              <button
                onClick={() => setShowTermsModal(false)}
                className="p-2 hover:bg-dark-200 rounded-lg transition-colors"
                style={{ color: '#00f0ff' }}
              >
                <X className="w-6 h-6" />
              </button>
            </div>

            {/* Modal Content */}
            <div className="flex-1 overflow-y-auto p-6" style={{ fontFamily: 'Poppins, sans-serif' }}>
              {termsLoading ? (
                <div className="flex items-center justify-center py-12">
                  <div className="w-8 h-8 border-2 border-primary/30 border-t-primary rounded-full animate-spin" />
                </div>
              ) : (
                <div className="terms-content-wrapper">
                  {/* Display HTML content from database based on booking type */}
                  {bookingData.type === 'event' && termsContent.event ? (
                    <div
                      className="terms-html-content"
                      dangerouslySetInnerHTML={{ __html: termsContent.event }}
                    />
                  ) : termsContent.game ? (
                    <div
                      className="terms-html-content"
                      dangerouslySetInnerHTML={{ __html: termsContent.game }}
                    />
                  ) : (
                    /* Fallback if no content from database */
                    <div className="text-gray-400 text-center py-8">
                      {translations.booking?.contact?.terms?.loading_error || 'Terms and conditions are being loaded...'}
                    </div>
                  )}
                </div>
              )}
              <style jsx global>{`
                .terms-html-content {
                  color: #d1d5db;
                  line-height: 1.7;
                }
                .terms-html-content h2 {
                  color: #00f0ff;
                  font-size: 1.5rem;
                  font-weight: bold;
                  margin-bottom: 1rem;
                  margin-top: 1.5rem;
                  font-family: 'Orbitron', sans-serif;
                }
                .terms-html-content h2:first-child {
                  margin-top: 0;
                }
                .terms-html-content h3 {
                  color: #00f0ff;
                  font-size: 1.25rem;
                  font-weight: 600;
                  margin-bottom: 0.75rem;
                  margin-top: 1.25rem;
                }
                .terms-html-content ul {
                  list-style-type: disc;
                  padding-left: 1.5rem;
                  margin-bottom: 1rem;
                }
                .terms-html-content li {
                  margin-bottom: 0.5rem;
                }
                .terms-html-content p {
                  margin-bottom: 0.75rem;
                }
                .terms-html-content strong {
                  color: #00f0ff;
                  font-weight: 600;
                }
                .terms-html-content hr {
                  border-color: rgba(0, 240, 255, 0.3);
                  margin: 1.5rem 0;
                }
              `}</style>
            </div>

            {/* Modal Footer */}
            <div className="p-6 border-t border-primary/30 flex justify-end">
              <button
                onClick={() => setShowTermsModal(false)}
                className="glow-button inline-flex items-center gap-2"
              >
                {translations.booking?.contact?.terms?.close || 'Close'}
              </button>
            </div>
          </motion.div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/admin/orders/components/OrderDetailModal.tsx">
'use client'

import { useState } from 'react'
import {
  X,
  Calendar,
  Clock,
  Users,
  Phone,
  Mail,
  MessageSquare,
  Gamepad2,
  Target,
  PartyPopper,
  ExternalLink,
  User,
  CheckCircle,
  XCircle,
  AlertCircle,
  Zap,
  RefreshCw,
  Send,
  Loader2,
  FileText,
  FileCheck,
  AlertTriangle,
  Receipt
} from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { OrderWithRelations } from '@/lib/supabase/types'

interface OrderDetailModalProps {
  order: OrderWithRelations
  onClose: () => void
  onCancel: (orderId: string) => void
  onRecreate?: (orderId: string) => void
  onResendEmail?: (orderId: string) => Promise<{ success: boolean; error?: string }>
  onResendCgvReminder?: (orderId: string) => Promise<{ success: boolean; error?: string }>
  onGoToAgenda: (date: string, bookingId?: string) => void
  onGoToClient: (contactId: string) => void
  onOpenAccounting?: (orderId: string) => void
  isDark: boolean
  canEdit?: boolean // Permission de modifier (recréer, renvoyer email)
  canDelete?: boolean // Permission d'annuler une commande
}

export function OrderDetailModal({
  order,
  onClose,
  onCancel,
  onRecreate,
  onResendEmail,
  onResendCgvReminder,
  onGoToAgenda,
  onGoToClient,
  onOpenAccounting,
  isDark,
  canEdit = true,
  canDelete = true,
}: OrderDetailModalProps) {
  const { t, locale } = useTranslation()
  const [sendingEmail, setSendingEmail] = useState(false)
  const [emailSent, setEmailSent] = useState(false)
  const [emailError, setEmailError] = useState<string | null>(null)
  const [sendingCgv, setSendingCgv] = useState(false)
  const [cgvSent, setCgvSent] = useState(false)
  const [cgvError, setCgvError] = useState<string | null>(null)

  const handleResendEmail = async () => {
    if (!onResendEmail || !order.customer_email) return

    setSendingEmail(true)
    setEmailError(null)

    try {
      const result = await onResendEmail(order.id)
      if (result.success) {
        setEmailSent(true)
        setTimeout(() => setEmailSent(false), 3000)
      } else {
        setEmailError(result.error || t('admin.orders.resend_email_error'))
      }
    } catch {
      setEmailError(t('admin.orders.resend_email_error'))
    } finally {
      setSendingEmail(false)
    }
  }

  const handleResendCgvReminder = async () => {
    if (!onResendCgvReminder || !order.customer_email) return

    setSendingCgv(true)
    setCgvError(null)

    try {
      const result = await onResendCgvReminder(order.id)
      if (result.success) {
        setCgvSent(true)
        setTimeout(() => setCgvSent(false), 3000)
      } else {
        setCgvError(result.error || t('admin.orders.resend_cgv_error') || 'Erreur lors de l\'envoi')
      }
    } catch {
      setCgvError(t('admin.orders.resend_cgv_error') || 'Erreur lors de l\'envoi')
    } finally {
      setSendingCgv(false)
    }
  }

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }

  const formatDate = (date: string) => {
    return new Date(date).toLocaleDateString(getDateLocale(), {
      weekday: 'long',
      day: 'numeric',
      month: 'long',
      year: 'numeric'
    })
  }

  const formatTime = (time: string) => {
    return time.slice(0, 5)
  }

  const getStatusInfo = () => {
    switch (order.status) {
      case 'pending':
        return {
          icon: AlertCircle,
          color: 'text-amber-500',
          bg: 'bg-amber-500/10',
          border: 'border-amber-500/30',
          label: t('admin.orders.status.pending')
        }
      case 'auto_confirmed':
        return {
          icon: CheckCircle,
          color: 'text-green-500',
          bg: 'bg-green-500/10',
          border: 'border-green-500/30',
          label: t('admin.orders.status.auto_confirmed')
        }
      case 'manually_confirmed':
        return {
          icon: CheckCircle,
          color: 'text-blue-500',
          bg: 'bg-blue-500/10',
          border: 'border-blue-500/30',
          label: t('admin.orders.status.manually_confirmed')
        }
      case 'cancelled':
        return {
          icon: XCircle,
          color: 'text-gray-500',
          bg: 'bg-gray-500/10',
          border: 'border-gray-500/30',
          label: t('admin.orders.status.cancelled')
        }
      default:
        return { icon: AlertCircle, color: 'text-gray-500', bg: 'bg-gray-500/10', border: 'border-gray-500/30', label: order.status }
    }
  }

  const getGameIcon = () => {
    if (order.order_type === 'EVENT') return PartyPopper
    if (order.game_area === 'LASER') return Target
    return Zap // Active Games (ACTIVE par défaut)
  }

  const getGameLabel = () => {
    if (order.order_type === 'EVENT') {
      // Nouveaux types d'événements (basés sur le type de jeu)
      if (order.game_area === 'ACTIVE' || order.event_type === 'event_active') return 'Événement Active Games'
      if (order.game_area === 'LASER' || order.event_type === 'event_laser') return 'Événement Laser City'
      if (order.event_type === 'event_mix') return 'Événement Mix'
      // Anciens types (compatibilité)
      switch (order.event_type) {
        case 'birthday': return 'Anniversaire'
        case 'bar_mitzvah': return 'Bar/Bat Mitzvah'
        case 'corporate': return 'Team Building'
        case 'other': return 'Événement privé'
        default: return 'Événement'
      }
    }
    if (order.game_area === 'LASER') return 'Laser City'
    return 'Active Games'
  }

  const getGameColor = () => {
    if (order.order_type === 'EVENT') return 'text-green-500'
    if (order.game_area === 'LASER') return 'text-purple-500'
    return 'text-blue-500'
  }

  const statusInfo = getStatusInfo()
  const StatusIcon = statusInfo.icon
  const GameIcon = getGameIcon()

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm" onClick={onClose}>
      <div 
        className={`relative w-full max-w-4xl mx-4 rounded-2xl shadow-2xl overflow-hidden ${
          isDark ? 'bg-gray-900' : 'bg-white'
        }`}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header avec gradient */}
        <div className={`relative p-6 ${
          order.status === 'pending' 
            ? 'bg-gradient-to-r from-amber-600 to-orange-600' 
            : order.status === 'cancelled'
            ? 'bg-gradient-to-r from-gray-600 to-gray-700'
            : 'bg-gradient-to-r from-blue-600 to-cyan-600'
        }`}>
          <button
            onClick={onClose}
            className="absolute top-4 right-4 p-2 rounded-full bg-white/20 hover:bg-white/30 transition-colors"
          >
            <X className="w-5 h-5 text-white" />
          </button>

          <div className="flex items-start gap-4">
            {/* Icône type */}
            <div className="w-16 h-16 rounded-2xl bg-white/20 flex items-center justify-center">
              <GameIcon className="w-8 h-8 text-white" />
            </div>
            
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <span className="px-3 py-1 bg-white/20 rounded-full text-white text-sm font-medium">
                  {getGameLabel()}
                </span>
                {order.number_of_games && order.order_type === 'GAME' && (
                  <span className="px-3 py-1 bg-white/20 rounded-full text-white text-sm">
                    {order.number_of_games} {order.number_of_games > 1 ? t('admin.orders.games_plural') : t('admin.orders.game_singular')}
                  </span>
                )}
              </div>
              <h2 className="text-2xl font-bold text-white mb-1">
                {order.customer_first_name} {order.customer_last_name || ''}
              </h2>
              <p className="text-white/80 text-sm">
                {t('admin.orders.order_ref')} {order.booking?.reference_code || order.request_reference}
              </p>
            </div>
          </div>
        </div>

        {/* Statut - compact */}
        <div className={`mx-6 mt-4 inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm ${statusInfo.bg} ${statusInfo.border} border`}>
          <StatusIcon className={`w-4 h-4 ${statusInfo.color}`} />
          <span className={`font-medium ${statusInfo.color}`}>{statusInfo.label}</span>
        </div>
        {order.pending_reason && (
          <p className={`mx-6 mt-2 text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
            {t('admin.orders.reason')}: {order.pending_details || order.pending_reason}
          </p>
        )}

        {/* Contenu principal */}
        <div className="p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
          {/* Colonne gauche - Infos réservation */}
          <div className="md:col-span-2 space-y-6">
            {/* Date & Heure */}
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-gray-50'}`}>
              <h3 className={`text-sm font-semibold uppercase tracking-wider mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.orders.table.date')} & {t('admin.orders.table.time')}
              </h3>
              <div className="flex items-center gap-6">
                <div className="flex items-center gap-3">
                  <div className={`p-3 rounded-xl ${isDark ? 'bg-gray-700' : 'bg-white'}`}>
                    <Calendar className="w-5 h-5 text-blue-500" />
                  </div>
                  <div>
                    <p className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                      {formatDate(order.requested_date)}
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <div className={`p-3 rounded-xl ${isDark ? 'bg-gray-700' : 'bg-white'}`}>
                    <Clock className="w-5 h-5 text-green-500" />
                  </div>
                  <div>
                    <p className={`font-medium text-2xl ${isDark ? 'text-white' : 'text-gray-900'}`}>
                      {formatTime(order.requested_time)}
                    </p>
                  </div>
                </div>
              </div>
            </div>

            {/* Participants */}
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-gray-50'}`}>
              <h3 className={`text-sm font-semibold uppercase tracking-wider mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.orders.table.players')}
              </h3>
              <div className="flex items-center gap-3">
                <div className={`p-3 rounded-xl ${isDark ? 'bg-gray-700' : 'bg-white'}`}>
                  <Users className="w-5 h-5 text-purple-500" />
                </div>
                <p className={`font-bold text-3xl ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  {order.participants_count}
                </p>
                <span className={isDark ? 'text-gray-400' : 'text-gray-600'}>{t('admin.common.players')}</span>
              </div>
            </div>

            {/* Contact */}
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-gray-50'}`}>
              <h3 className={`text-sm font-semibold uppercase tracking-wider mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                Contact
              </h3>
              <div className="space-y-3">
                <div className="flex items-center gap-3">
                  <Phone className="w-4 h-4 text-gray-400" />
                  <a href={`tel:${order.customer_phone}`} className="text-blue-500 hover:underline">
                    {order.customer_phone}
                  </a>
                </div>
                {order.customer_email && (
                  <div className="flex items-center gap-3">
                    <Mail className="w-4 h-4 text-gray-400" />
                    <a href={`mailto:${order.customer_email}`} className="text-blue-500 hover:underline">
                      {order.customer_email}
                    </a>
                  </div>
                )}
              </div>
            </div>

            {/* CGV Status - pour toutes les commandes */}
            <div className={`p-4 rounded-xl ${
              order.cgv_validated_at
                  ? isDark ? 'bg-green-900/20 border border-green-700/30' : 'bg-green-50 border border-green-200'
                  : isDark ? 'bg-amber-900/20 border border-amber-700/30' : 'bg-amber-50 border border-amber-200'
              }`}>
                <h3 className={`text-sm font-semibold uppercase tracking-wider mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.orders.cgv.title') || 'Conditions Générales de Vente'}
                </h3>
                <div className="flex items-center gap-3">
                  {order.cgv_validated_at ? (
                    <>
                      <div className={`p-2 rounded-lg ${isDark ? 'bg-green-900/30' : 'bg-green-100'}`}>
                        <FileCheck className="w-5 h-5 text-green-500" />
                      </div>
                      <div>
                        <p className={`font-medium ${isDark ? 'text-green-400' : 'text-green-700'}`}>
                          {t('admin.orders.cgv.validated') || 'CGV Validées'}
                        </p>
                        <p className={`text-xs ${isDark ? 'text-green-400/70' : 'text-green-600'}`}>
                          {new Date(order.cgv_validated_at).toLocaleDateString(getDateLocale(), {
                            day: '2-digit',
                            month: 'long',
                            year: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                          })}
                        </p>
                      </div>
                    </>
                  ) : (
                    <>
                      <div className={`p-2 rounded-lg ${isDark ? 'bg-amber-900/30' : 'bg-amber-100'}`}>
                        <AlertTriangle className="w-5 h-5 text-amber-500" />
                      </div>
                      <div>
                        <p className={`font-medium ${isDark ? 'text-amber-400' : 'text-amber-700'}`}>
                          {t('admin.orders.cgv.pending') || 'En attente de validation'}
                        </p>
                        <p className={`text-xs ${isDark ? 'text-amber-400/70' : 'text-amber-600'}`}>
                          {t('admin.orders.cgv.pending_desc') || 'Le client n\'a pas encore validé les CGV'}
                        </p>
                      </div>
                    </>
                  )}
                </div>
              </div>

            {/* Notes */}
            {order.customer_notes && (
              <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-gray-50'}`}>
                <h3 className={`text-sm font-semibold uppercase tracking-wider mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.orders.table.notes')}
                </h3>
                <div className="flex items-start gap-3">
                  <MessageSquare className="w-4 h-4 text-gray-400 mt-1" />
                  <p className={`whitespace-pre-wrap ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {order.customer_notes}
                  </p>
                </div>
              </div>
            )}
          </div>

          {/* Colonne droite - Actions */}
          <div className="space-y-4">
            {/* Actions rapides */}
            <div className={`p-4 rounded-xl border-2 border-dashed ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
              <h3 className={`text-sm font-semibold uppercase tracking-wider mb-4 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.orders.quick_access')}
              </h3>
              
              {/* Bouton vers Agenda - grisé si annulé */}
              {order.status === 'cancelled' || !order.booking_id ? (
                <>
                  <div
                    className={`w-full mb-3 flex items-center gap-3 p-3 rounded-xl cursor-not-allowed ${
                      isDark 
                        ? 'bg-gray-700/50 text-gray-500' 
                        : 'bg-gray-100 text-gray-400'
                    }`}
                  >
                    <Calendar className="w-5 h-5" />
                    <div className="text-left flex-1">
                      <p className="font-medium">{t('admin.orders.view_in_agenda')}</p>
                      <p className={`text-xs ${isDark ? 'text-gray-600' : 'text-gray-400'}`}>
                        {t('admin.orders.booking_cancelled_or_deleted')}
                      </p>
                    </div>
                  </div>
                  
                  {/* Bouton Réactiver - seulement si annulé */}
                  {order.status === 'cancelled' && onRecreate && (
                    <button
                      onClick={() => canEdit && onRecreate(order.id)}
                      disabled={!canEdit}
                      title={!canEdit ? t('admin.common.no_permission') : undefined}
                      className={`w-full mb-3 flex items-center gap-3 p-3 rounded-xl transition-colors ${
                        !canEdit
                          ? 'opacity-50 cursor-not-allowed bg-gray-200 dark:bg-gray-700 text-gray-400'
                          : isDark
                            ? 'bg-green-600/20 hover:bg-green-600/30 text-green-400'
                            : 'bg-green-50 hover:bg-green-100 text-green-600'
                      }`}
                    >
                      <RefreshCw className="w-5 h-5" />
                      <div className="text-left flex-1">
                        <p className="font-medium">{t('admin.orders.reactivate_booking')}</p>
                        <p className={`text-xs ${isDark ? 'text-green-400/70' : 'text-green-500/70'}`}>
                          {t('admin.orders.reactivate_description')}
                        </p>
                      </div>
                    </button>
                  )}
                </>
              ) : (
                <button
                  onClick={() => onGoToAgenda(order.requested_date, order.booking?.id)}
                  className={`w-full mb-3 flex items-center gap-3 p-3 rounded-xl transition-colors ${
                    isDark 
                      ? 'bg-blue-600/20 hover:bg-blue-600/30 text-blue-400' 
                      : 'bg-blue-50 hover:bg-blue-100 text-blue-600'
                  }`}
                >
                  <Calendar className="w-5 h-5" />
                  <div className="text-left flex-1">
                    <p className="font-medium">{t('admin.orders.view_in_agenda')}</p>
                    <p className={`text-xs ${isDark ? 'text-blue-400/70' : 'text-blue-500/70'}`}>
                      {t('admin.orders.open_booking')}
                    </p>
                  </div>
                  <ExternalLink className="w-4 h-4" />
                </button>
              )}

              {/* Bouton vers Client */}
              {order.contact_id && (
                <button
                  onClick={() => onGoToClient(order.contact_id!)}
                  className={`w-full mb-3 flex items-center gap-3 p-3 rounded-xl transition-colors ${
                    isDark
                      ? 'bg-purple-600/20 hover:bg-purple-600/30 text-purple-400'
                      : 'bg-purple-50 hover:bg-purple-100 text-purple-600'
                  }`}
                >
                  <User className="w-5 h-5" />
                  <div className="text-left flex-1">
                    <p className="font-medium">{t('admin.orders.client_card')}</p>
                    <p className={`text-xs ${isDark ? 'text-purple-400/70' : 'text-purple-500/70'}`}>
                      {t('admin.orders.view_in_crm')}
                    </p>
                  </div>
                  <ExternalLink className="w-4 h-4" />
                </button>
              )}

              {/* Bouton vers Devis iCount */}
              {order.booking?.icount_offer_url && (
                <a
                  href={order.booking.icount_offer_url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className={`w-full mb-3 flex items-center gap-3 p-3 rounded-xl transition-colors ${
                    isDark
                      ? 'bg-emerald-600/20 hover:bg-emerald-600/30 text-emerald-400'
                      : 'bg-emerald-50 hover:bg-emerald-100 text-emerald-600'
                  }`}
                >
                  <FileText className="w-5 h-5" />
                  <div className="text-left flex-1">
                    <p className="font-medium">{t('admin.orders.view_offer')}</p>
                    <p className={`text-xs ${isDark ? 'text-emerald-400/70' : 'text-emerald-500/70'}`}>
                      {t('admin.orders.open_icount_offer')}
                    </p>
                  </div>
                  <ExternalLink className="w-4 h-4" />
                </a>
              )}

              {/* Bouton Fiche Comptable */}
              {onOpenAccounting && (
                <button
                  onClick={() => onOpenAccounting(order.id)}
                  className={`w-full mb-3 flex items-center gap-3 p-3 rounded-xl transition-colors ${
                    isDark
                      ? 'bg-cyan-600/20 hover:bg-cyan-600/30 text-cyan-400'
                      : 'bg-cyan-50 hover:bg-cyan-100 text-cyan-600'
                  }`}
                >
                  <Receipt className="w-5 h-5" />
                  <div className="text-left flex-1">
                    <p className="font-medium">{t('admin.accounting.title')}</p>
                    <p className={`text-xs ${isDark ? 'text-cyan-400/70' : 'text-cyan-500/70'}`}>
                      {t('admin.accounting.price_breakdown')}
                    </p>
                  </div>
                </button>
              )}

              {/* Bouton Renvoyer Email de confirmation */}
              {onResendEmail && order.status !== 'cancelled' && (
                <button
                  onClick={handleResendEmail}
                  disabled={sendingEmail || !order.customer_email}
                  className={`w-full mb-3 flex items-center gap-3 p-3 rounded-xl transition-colors ${
                    !order.customer_email
                      ? isDark
                        ? 'bg-gray-700/50 text-gray-500 cursor-not-allowed'
                        : 'bg-gray-100 text-gray-400 cursor-not-allowed'
                      : emailSent
                        ? isDark
                          ? 'bg-green-600/20 text-green-400'
                          : 'bg-green-50 text-green-600'
                        : emailError
                          ? isDark
                            ? 'bg-red-600/20 text-red-400'
                            : 'bg-red-50 text-red-600'
                          : isDark
                            ? 'bg-orange-600/20 hover:bg-orange-600/30 text-orange-400'
                            : 'bg-orange-50 hover:bg-orange-100 text-orange-600'
                  }`}
                >
                  {sendingEmail ? (
                    <Loader2 className="w-5 h-5 animate-spin" />
                  ) : emailSent ? (
                    <CheckCircle className="w-5 h-5" />
                  ) : (
                    <Send className="w-5 h-5" />
                  )}
                  <div className="text-left flex-1">
                    <p className="font-medium">
                      {emailSent
                        ? t('admin.orders.resend_email_success')
                        : t('admin.orders.resend_confirmation_email') || 'Renvoyer email de confirmation'
                      }
                    </p>
                    <p className={`text-xs ${
                      !order.customer_email
                        ? isDark ? 'text-gray-600' : 'text-gray-400'
                        : emailError
                          ? isDark ? 'text-red-400/70' : 'text-red-500/70'
                          : isDark ? 'text-orange-400/70' : 'text-orange-500/70'
                    }`}>
                      {!order.customer_email
                        ? t('admin.orders.no_email_address')
                        : emailError
                          ? emailError
                          : t('admin.orders.resend_confirmation_desc') || 'Inclut le lien de validation CGV'
                      }
                    </p>
                  </div>
                </button>
              )}

              {/* Bouton Renvoyer Rappel CGV - seulement pour orders admin avec CGV non validées et non fermées */}
              {onResendCgvReminder && order.status !== 'cancelled' && order.status !== 'closed' && order.source === 'admin_agenda' && !order.cgv_validated_at && (
                <button
                  onClick={handleResendCgvReminder}
                  disabled={sendingCgv || !order.customer_email}
                  className={`w-full flex items-center gap-3 p-3 rounded-xl transition-colors ${
                    !order.customer_email
                      ? isDark
                        ? 'bg-gray-700/50 text-gray-500 cursor-not-allowed'
                        : 'bg-gray-100 text-gray-400 cursor-not-allowed'
                      : cgvSent
                        ? isDark
                          ? 'bg-green-600/20 text-green-400'
                          : 'bg-green-50 text-green-600'
                        : cgvError
                          ? isDark
                            ? 'bg-red-600/20 text-red-400'
                            : 'bg-red-50 text-red-600'
                          : isDark
                            ? 'bg-amber-600/20 hover:bg-amber-600/30 text-amber-400'
                            : 'bg-amber-50 hover:bg-amber-100 text-amber-600'
                  }`}
                >
                  {sendingCgv ? (
                    <Loader2 className="w-5 h-5 animate-spin" />
                  ) : cgvSent ? (
                    <CheckCircle className="w-5 h-5" />
                  ) : (
                    <FileCheck className="w-5 h-5" />
                  )}
                  <div className="text-left flex-1">
                    <p className="font-medium">
                      {cgvSent
                        ? t('admin.orders.resend_cgv_success') || 'Rappel CGV envoyé'
                        : t('admin.orders.resend_cgv_reminder') || 'Envoyer rappel CGV'
                      }
                    </p>
                    <p className={`text-xs ${
                      !order.customer_email
                        ? isDark ? 'text-gray-600' : 'text-gray-400'
                        : cgvError
                          ? isDark ? 'text-red-400/70' : 'text-red-500/70'
                          : isDark ? 'text-amber-400/70' : 'text-amber-500/70'
                    }`}>
                      {!order.customer_email
                        ? t('admin.orders.no_email_address')
                        : cgvError
                          ? cgvError
                          : t('admin.orders.resend_cgv_desc') || 'Relancer le client pour valider les CGV'
                      }
                    </p>
                  </div>
                </button>
              )}
            </div>

            {/* Action Confirmer pour commandes pending */}
            {order.status === 'pending' && onRecreate && (
              <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-gray-50'}`}>
                <h3 className={`text-sm font-semibold uppercase tracking-wider mb-4 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.common.actions')}
                </h3>
                <button
                  onClick={() => {
                    if (!canEdit) return
                    onRecreate(order.id)
                    onClose()
                  }}
                  disabled={!canEdit}
                  title={!canEdit ? t('admin.common.no_permission') : undefined}
                  className={`w-full py-3 px-4 rounded-xl font-medium transition-colors flex items-center justify-center gap-2 ${
                    !canEdit
                      ? 'bg-gray-400 cursor-not-allowed opacity-50 text-white'
                      : 'bg-green-600 hover:bg-green-700 text-white'
                  }`}
                >
                  <RefreshCw className="w-5 h-5" />
                  {t('admin.orders.actions.confirm')}
                </button>
              </div>
            )}

            {/* Infos supplémentaires */}
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-gray-50'}`}>
              <h3 className={`text-sm font-semibold uppercase tracking-wider mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.orders.informations')}
              </h3>
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>{t('admin.orders.created_on')}</span>
                  <span className={isDark ? 'text-white' : 'text-gray-900'}>
                    {new Date(order.created_at).toLocaleDateString(getDateLocale())}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>{t('admin.orders.table.source')}</span>
                  <span className={`px-2 py-0.5 rounded text-xs ${
                    order.source === 'admin_agenda'
                      ? 'bg-orange-100 text-orange-700 dark:bg-orange-900/30 dark:text-orange-400'
                      : 'bg-teal-100 text-teal-700 dark:bg-teal-900/30 dark:text-teal-400'
                  }`}>
                    {order.source === 'admin_agenda' ? 'Admin' : t('admin.orders.source_website')}
                  </span>
                </div>
                {order.branch?.name && (
                  <div className="flex justify-between">
                    <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>{t('admin.orders.branch')}</span>
                    <span className={isDark ? 'text-white' : 'text-gray-900'}>
                      {order.branch.name}
                    </span>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Footer avec bouton d'annulation - masqué si annulé ou fermé */}
        {order.status !== 'cancelled' && order.status !== 'closed' && (
          <div className={`px-6 py-4 border-t ${isDark ? 'border-gray-700 bg-gray-900' : 'border-gray-200 bg-gray-50'}`}>
            <button
              onClick={() => {
                if (!canDelete) return
                onCancel(order.id)
                onClose()
              }}
              disabled={!canDelete}
              title={!canDelete ? t('admin.common.no_permission') : undefined}
              className={`py-2 px-4 rounded-lg font-medium transition-colors flex items-center gap-2 text-sm ${
                !canDelete
                  ? 'bg-gray-400 cursor-not-allowed opacity-50 text-white'
                  : 'bg-red-600 hover:bg-red-700 text-white'
              }`}
            >
              <XCircle className="w-4 h-4" />
              {t('admin.orders.actions.cancel')}
            </button>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/settings/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import {
  Loader2,
  AlertCircle,
  Settings,
  FileText,
  ChevronRight,
  CreditCard,
  Package,
  Wrench
} from 'lucide-react'
import { useAuth } from '@/hooks/useAuth'
import { useBranches } from '@/hooks/useBranches'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { TemplatesSection } from './components/TemplatesSection'
import { CredentialsSection } from './components/CredentialsSection'
import { ICountCatalogSection } from './components/ICountCatalogSection'
import { MaintenanceSection } from './components/MaintenanceSection'
import { createClient } from '@/lib/supabase/client'

type SettingsSection = 'templates' | 'credentials' | 'catalog' | 'maintenance'

export default function SettingsPage() {
  const router = useRouter()
  const { t } = useTranslation()
  const { user, loading: authLoading } = useAuth()
  const { branches, selectedBranch, selectBranch, loading: branchesLoading } = useBranches()

  // Theme state
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')
  const [activeSection, setActiveSection] = useState<SettingsSection>('templates')

  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const isDark = theme === 'dark'

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  // Only super_admin can access settings
  if (user && user.role !== 'super_admin') {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <div className="text-center">
          <AlertCircle className="w-16 h-16 text-red-500 mx-auto mb-4" />
          <h1 className={`text-2xl font-bold mb-2 ${isDark ? 'text-white' : 'text-gray-900'}`}>
            {t('admin.settings.access_denied')}
          </h1>
          <p className={isDark ? 'text-gray-400' : 'text-gray-600'}>
            {t('admin.settings.access_denied_message')}
          </p>
        </div>
      </div>
    )
  }

  // Loading state
  if (authLoading || branchesLoading || !user || !selectedBranch) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
        <Loader2 className={`w-8 h-8 animate-spin ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
      </div>
    )
  }

  const sections: { id: SettingsSection; icon: typeof FileText; label: string; description: string }[] = [
    {
      id: 'templates',
      icon: FileText,
      label: t('admin.settings.sections.templates'),
      description: t('admin.settings.sections.templates_desc')
    },
    {
      id: 'credentials',
      icon: CreditCard,
      label: t('admin.settings.sections.credentials'),
      description: t('admin.settings.sections.credentials_desc')
    },
    {
      id: 'catalog',
      icon: Package,
      label: 'Catalogue iCount',
      description: 'Produits et formules'
    },
    {
      id: 'maintenance',
      icon: Wrench,
      label: 'Maintenance',
      description: 'Outils de maintenance'
    }
  ]

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'}`}>
      {/* Header */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch}
        onBranchSelect={selectBranch}
        onSignOut={handleSignOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      {/* Sub-header with title */}
      <div className={`${isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border-b px-6 py-4`}>
        <div className="flex items-center gap-3">
          <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
            isDark ? 'bg-orange-500/20' : 'bg-orange-100'
          }`}>
            <Settings className={`w-6 h-6 ${isDark ? 'text-orange-400' : 'text-orange-600'}`} />
          </div>
          <div>
            <h1 className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {t('admin.settings.title')}
            </h1>
            <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
              {t('admin.settings.subtitle')}
            </p>
          </div>
        </div>
      </div>

      {/* Main content with sidebar */}
      <div className="flex">
        {/* Sidebar */}
        <div className={`w-64 min-h-[calc(100vh-140px)] border-r ${
          isDark ? 'bg-gray-800/50 border-gray-700' : 'bg-white border-gray-200'
        }`}>
          <nav className="p-4 space-y-1">
            {sections.map((section) => {
              const Icon = section.icon
              const isActive = activeSection === section.id

              return (
                <button
                  key={section.id}
                  onClick={() => setActiveSection(section.id)}
                  className={`w-full flex items-center gap-3 px-3 py-3 rounded-lg text-left transition-colors ${
                    isActive
                      ? isDark
                        ? 'bg-orange-500/20 text-orange-400'
                        : 'bg-orange-100 text-orange-700'
                      : isDark
                        ? 'hover:bg-gray-700 text-gray-300'
                        : 'hover:bg-gray-100 text-gray-700'
                  }`}
                >
                  <Icon className="w-5 h-5 flex-shrink-0" />
                  <div className="flex-1 min-w-0">
                    <p className="font-medium">{section.label}</p>
                    <p className={`text-xs truncate ${
                      isActive
                        ? isDark ? 'text-orange-300/70' : 'text-orange-600/70'
                        : isDark ? 'text-gray-500' : 'text-gray-400'
                    }`}>
                      {section.description}
                    </p>
                  </div>
                  <ChevronRight className={`w-4 h-4 flex-shrink-0 ${
                    isActive ? 'opacity-100' : 'opacity-0'
                  }`} />
                </button>
              )
            })}
          </nav>
        </div>

        {/* Content area */}
        <div className="flex-1 p-6">
          {activeSection === 'templates' && (
            <TemplatesSection isDark={isDark} />
          )}
          {activeSection === 'credentials' && (
            <CredentialsSection isDark={isDark} />
          )}
          {activeSection === 'catalog' && (
            <ICountCatalogSection isDark={isDark} />
          )}
          {activeSection === 'maintenance' && (
            <MaintenanceSection isDark={isDark} />
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/api/admin/statistics/ask/route.ts">
/**
 * API pour l'assistant IA Clara
 * - Répond naturellement aux questions
 * - Garde une mémoire de conversation via Supabase
 * - N'utilise les tools que pour les vraies ACTIONS (fermer, annuler, etc.)
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { verifyApiPermission } from '@/lib/permissions'
import { CLARA_SCHEMA_SUMMARY } from '@/lib/clara/supabase-schema'

// Tools UNIQUEMENT pour les vraies actions (pas pour les questions!)
const ACTION_TOOLS = [
  {
    name: 'close_orders',
    description: 'Fermer des commandes terminées. Utiliser SEULEMENT si l\'utilisateur demande explicitement de fermer des commandes.',
    input_schema: {
      type: 'object' as const,
      properties: {
        order_ids: { type: 'array', items: { type: 'string' }, description: 'IDs des commandes à fermer' },
        reason: { type: 'string', description: 'Raison' }
      },
      required: ['order_ids']
    }
  },
  {
    name: 'cancel_orders',
    description: 'Annuler des commandes. Utiliser SEULEMENT si l\'utilisateur demande explicitement d\'annuler.',
    input_schema: {
      type: 'object' as const,
      properties: {
        order_ids: { type: 'array', items: { type: 'string' }, description: 'IDs des commandes' },
        reason: { type: 'string', description: 'Raison' }
      },
      required: ['order_ids', 'reason']
    }
  },
  {
    name: 'fix_payment_status',
    description: 'Corriger les statuts de paiement incohérents. Utiliser SEULEMENT si demandé.',
    input_schema: {
      type: 'object' as const,
      properties: {
        order_ids: { type: 'array', items: { type: 'string' }, description: 'IDs des commandes' }
      },
      required: ['order_ids']
    }
  }
]

interface ActionResult {
  success: boolean
  message: string
  details?: Record<string, unknown>
}

// Exécuter une action
async function executeAction(
  actionName: string,
  params: Record<string, unknown>,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  supabase: any,
  userId: string
): Promise<ActionResult> {
  console.log(`[Clara] Executing ${actionName}:`, params)

  switch (actionName) {
    case 'close_orders': {
      const orderIds = params.order_ids as string[]
      const reason = params.reason as string || 'Fermé par Clara'
      const { data, error } = await supabase
        .from('orders')
        .update({ status: 'closed', closed_at: new Date().toISOString(), closed_by: userId, notes: reason })
        .in('id', orderIds)
        .select()
      if (error) return { success: false, message: `Erreur: ${error.message}` }
      return { success: true, message: `${data?.length || 0} commande(s) fermée(s).`, details: { closed: data?.length || 0 } }
    }

    case 'cancel_orders': {
      const orderIds = params.order_ids as string[]
      const reason = params.reason as string
      const { data, error } = await supabase
        .from('orders')
        .update({ status: 'cancelled', cancelled_at: new Date().toISOString(), cancellation_reason: reason })
        .in('id', orderIds)
        .select()
      if (error) return { success: false, message: `Erreur: ${error.message}` }
      return { success: true, message: `${data?.length || 0} commande(s) annulée(s).`, details: { cancelled: data?.length || 0 } }
    }

    case 'fix_payment_status': {
      const orderIds = params.order_ids as string[]
      let fixed = 0
      for (const orderId of orderIds) {
        const { data: order } = await supabase
          .from('orders')
          .select('id, total_amount, paid_amount, payment_status')
          .eq('id', orderId)
          .single()
        if (order) {
          let newStatus = 'unpaid'
          if (order.paid_amount >= order.total_amount && order.total_amount > 0) newStatus = 'fully_paid'
          else if (order.paid_amount > 0) newStatus = 'deposit_paid'
          if (newStatus !== order.payment_status) {
            await supabase.from('orders').update({ payment_status: newStatus }).eq('id', orderId)
            fixed++
          }
        }
      }
      return { success: true, message: `${fixed} statut(s) corrigé(s).`, details: { fixed } }
    }

    default:
      return { success: false, message: `Action inconnue: ${actionName}` }
  }
}

// Récupérer les données business pour le contexte
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function getBusinessContext(supabase: any, branchId?: string): Promise<string> {
  const now = new Date()
  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1)
  const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate())
  const startOfYesterday = new Date(startOfToday)
  startOfYesterday.setDate(startOfYesterday.getDate() - 1)

  // Commandes du mois
  let ordersQuery = supabase
    .from('orders')
    .select('id, request_reference, total_amount, paid_amount, payment_status, status, order_type, created_at, customer_first_name, customer_last_name')
    .gte('created_at', startOfMonth.toISOString())
    .order('created_at', { ascending: false })
    .limit(100)
  if (branchId && branchId !== 'all') ordersQuery = ordersQuery.eq('branch_id', branchId)
  const { data: orders } = await ordersQuery

  // Stats calculées
  const totalOrders = orders?.length || 0
  const totalRevenue = orders?.reduce((s: number, o: { total_amount: number | null }) => s + (o.total_amount || 0), 0) || 0
  const paidRevenue = orders?.reduce((s: number, o: { paid_amount: number | null }) => s + (o.paid_amount || 0), 0) || 0

  const todayOrders = orders?.filter((o: { created_at: string }) => new Date(o.created_at) >= startOfToday) || []
  const yesterdayOrders = orders?.filter((o: { created_at: string }) => {
    const d = new Date(o.created_at)
    return d >= startOfYesterday && d < startOfToday
  }) || []

  const todayCA = todayOrders.reduce((s: number, o: { total_amount: number | null }) => s + (o.total_amount || 0), 0)
  const yesterdayCA = yesterdayOrders.reduce((s: number, o: { total_amount: number | null }) => s + (o.total_amount || 0), 0)

  // Problèmes détectés
  const unpaidOld = orders?.filter((o: { payment_status: string; status: string; created_at: string }) => {
    const days = (Date.now() - new Date(o.created_at).getTime()) / (1000 * 60 * 60 * 24)
    return o.payment_status === 'unpaid' && ['pending', 'confirmed'].includes(o.status) && days > 7
  }) || []

  const statusMismatch = orders?.filter((o: { total_amount: number | null; paid_amount: number | null; payment_status: string }) => {
    if ((o.paid_amount || 0) >= (o.total_amount || 0) && (o.total_amount || 0) > 0 && o.payment_status !== 'fully_paid') return true
    if ((o.paid_amount || 0) > 0 && (o.paid_amount || 0) < (o.total_amount || 0) && o.payment_status !== 'deposit_paid') return true
    return false
  }) || []

  const fullyPaidNotClosed = orders?.filter((o: { payment_status: string; status: string }) =>
    o.payment_status === 'fully_paid' && o.status === 'confirmed'
  ) || []

  return `
DONNÉES ACTUELLES (${now.toLocaleDateString('fr-FR')}):

📊 CE MOIS:
- Commandes: ${totalOrders}
- CA total: ${totalRevenue.toLocaleString()}₪
- Encaissé: ${paidRevenue.toLocaleString()}₪
- En attente: ${(totalRevenue - paidRevenue).toLocaleString()}₪

📅 AUJOURD'HUI: ${todayOrders.length} commandes, ${todayCA.toLocaleString()}₪
📅 HIER: ${yesterdayOrders.length} commandes, ${yesterdayCA.toLocaleString()}₪

⚠️ PROBLÈMES DÉTECTÉS:
- Commandes non payées +7j: ${unpaidOld.length}
- Incohérences paiement: ${statusMismatch.length}
- Payées non fermées: ${fullyPaidNotClosed.length}

${unpaidOld.length > 0 ? `\nCommandes impayées (+7j):\n${unpaidOld.slice(0, 5).map((o: { request_reference: string; total_amount: number | null; id: string }) => `- ${o.request_reference}: ${o.total_amount}₪ (ID: ${o.id})`).join('\n')}` : ''}
${statusMismatch.length > 0 ? `\nIncohérences:\n${statusMismatch.slice(0, 5).map((o: { request_reference: string; paid_amount: number | null; total_amount: number | null; payment_status: string; id: string }) => `- ${o.request_reference}: payé ${o.paid_amount}/${o.total_amount}₪, statut "${o.payment_status}" (ID: ${o.id})`).join('\n')}` : ''}
${fullyPaidNotClosed.length > 0 ? `\nÀ fermer:\n${fullyPaidNotClosed.slice(0, 5).map((o: { request_reference: string; total_amount: number | null; id: string }) => `- ${o.request_reference}: ${o.total_amount}₪ (ID: ${o.id})`).join('\n')}` : ''}

DERNIÈRES COMMANDES:
${orders?.slice(0, 10).map((o: { request_reference: string; total_amount: number | null; paid_amount: number | null; payment_status: string; status: string; created_at: string; customer_first_name: string; customer_last_name: string }) =>
  `- ${o.request_reference}: ${o.total_amount}₪ (payé: ${o.paid_amount || 0}₪) - ${o.status} - ${o.customer_first_name} ${o.customer_last_name}`
).join('\n') || 'Aucune'}
`
}

// Appeler Claude avec l'historique de conversation
async function callClaude(
  systemPrompt: string,
  messages: Array<{ role: 'user' | 'assistant'; content: string }>,
  useTools: boolean = false
) {
  const apiKey = process.env.ANTHROPIC_API_KEY
  if (!apiKey) throw new Error('ANTHROPIC_API_KEY non configurée')

  const body: Record<string, unknown> = {
    model: 'claude-3-5-haiku-20241022',
    max_tokens: 1024,
    system: systemPrompt,
    messages: messages.map(m => ({ role: m.role, content: m.content }))
  }

  // N'ajouter les tools que si explicitement demandé
  if (useTools) {
    body.tools = ACTION_TOOLS
  }

  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify(body)
  })

  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(`Anthropic API error: ${response.status} - ${errorText}`)
  }

  return response.json()
}

// Détecter si le message demande une action
function isActionRequest(message: string): boolean {
  const actionKeywords = [
    'ferme', 'fermer', 'close',
    'annule', 'annuler', 'cancel',
    'corrige', 'corriger', 'fix',
    'nettoie', 'nettoyer', 'clean',
    'supprime', 'supprimer', 'delete',
    'exécute', 'execute', 'fais-le', 'fais le', 'vas-y', 'ok fais', 'oui fais'
  ]
  const lower = message.toLowerCase()
  return actionKeywords.some(k => lower.includes(k))
}

export async function POST(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success || !user) return errorResponse

    const body = await request.json()
    const {
      question,
      conversationId,
      branchId,
      executeActions = false,
      pendingAction = null
    } = body

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any

    // Exécution d'une action en attente
    if (pendingAction && executeActions) {
      const result = await executeAction(pendingAction.name, pendingAction.params, supabase, user.id)

      // Sauvegarder le résultat dans la conversation
      if (conversationId) {
        await supabase.from('ai_messages').insert({
          conversation_id: conversationId,
          role: 'assistant',
          content: result.message,
          metadata: { actionResult: result }
        })
      }

      return NextResponse.json({ success: true, actionExecuted: true, actionResult: result })
    }

    if (!question) {
      return NextResponse.json({ success: false, error: 'Question requise' }, { status: 400 })
    }

    // Récupérer ou créer une conversation
    let convId = conversationId
    if (!convId) {
      // Chercher une conversation active ou en créer une
      const { data: activeConv } = await supabase
        .from('ai_conversations')
        .select('id')
        .eq('user_id', user.id)
        .eq('is_active', true)
        .order('updated_at', { ascending: false })
        .limit(1)
        .single()

      if (activeConv) {
        convId = activeConv.id
      } else {
        // Créer une nouvelle conversation
        const { data: newConv } = await supabase
          .from('ai_conversations')
          .insert({ user_id: user.id, title: question.substring(0, 50) })
          .select()
          .single()
        convId = newConv?.id
      }
    }

    // Récupérer l'historique de la conversation (limité aux 20 derniers messages)
    const { data: history } = await supabase
      .from('ai_messages')
      .select('role, content')
      .eq('conversation_id', convId)
      .order('created_at', { ascending: true })
      .limit(20)

    const conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }> =
      history?.map((m: { role: string; content: string }) => ({
        role: m.role as 'user' | 'assistant',
        content: m.content
      })) || []

    // Ajouter le message utilisateur
    conversationHistory.push({ role: 'user', content: question })

    // Sauvegarder le message utilisateur
    await supabase.from('ai_messages').insert({
      conversation_id: convId,
      role: 'user',
      content: question
    })

    // Récupérer le contexte business
    const businessContext = await getBusinessContext(supabase, branchId)

    // Construire le prompt système
    const systemPrompt = `Tu es Clara, l'assistante IA d'ActiveLaser. Tu es chaleureuse, naturelle et efficace.

PERSONNALITÉ:
- Parle de façon naturelle, comme une collègue sympathique
- Sois concise mais complète
- Utilise des emojis avec modération pour être plus vivante
- Tutoie l'utilisateur naturellement

RÈGLES IMPORTANTES:
1. Pour les QUESTIONS (stats, infos, aide): Réponds directement et naturellement, SANS utiliser de tools
2. Pour les ACTIONS (fermer, annuler, corriger): Utilise les tools appropriés
3. Utilise les données fournies pour répondre précisément
4. Si tu ne sais pas, dis-le honnêtement

${businessContext}

STRUCTURE DE LA BASE DE DONNÉES:
${CLARA_SCHEMA_SUMMARY}

AIDE SUR LE LOGICIEL:
- Agenda: Page principale avec calendrier, cliquer sur un créneau pour créer une réservation
- Commandes: Liste des commandes en ligne, filtrable par statut/date/branche
- Clients: Base de contacts avec historique des réservations
- Équipe: Gestion des utilisateurs et permissions par rôle
- Statistiques: Tableaux de bord avec KPIs et graphiques
- Paramètres: Configuration branche, salles, tarifs, emails

WORKFLOW COMMANDES:
1. Client fait une demande → status "pending"
2. Agent confirme → status "confirmed", booking créé
3. Client paie → payment_status "fully_paid"
4. Événement terminé → status "closed"

AIDE TECHNIQUE:
- Créer commande: Cliquer sur un créneau dans l'agenda
- Paiement: Section "Paiements" dans la fiche commande
- Remboursement: Icône à côté du paiement
- Fermer commande: Bouton "Fermer" quand payé et terminé
- Voir logs: Menu Logs pour l'historique des actions`

    // Détecter si c'est une demande d'action
    const wantsAction = isActionRequest(question)

    // Appeler Claude
    const response = await callClaude(systemPrompt, conversationHistory, wantsAction)

    // Traiter la réponse
    let answer = ''
    let proposedAction: { name: string; params: Record<string, unknown>; description: string } | null = null

    for (const content of response.content) {
      if (content.type === 'text') {
        answer += content.text
      } else if (content.type === 'tool_use') {
        proposedAction = {
          name: content.name,
          params: content.input as Record<string, unknown>,
          description: getActionDescription(content.name, content.input as Record<string, unknown>)
        }
      }
    }

    // Si pas de réponse texte mais une action, générer un message
    if (!answer && proposedAction) {
      answer = `Je vais ${proposedAction.description.toLowerCase()}. Tu veux que je procède ?`
    }

    // Sauvegarder la réponse de Clara
    await supabase.from('ai_messages').insert({
      conversation_id: convId,
      role: 'assistant',
      content: answer,
      metadata: proposedAction ? { proposedAction } : {}
    })

    return NextResponse.json({
      success: true,
      answer,
      proposedAction,
      conversationId: convId
    })

  } catch (error) {
    console.error('[Clara] Error:', error)
    return NextResponse.json(
      { success: false, error: 'Erreur interne', answer: "Désolée, j'ai eu un souci. Réessaie !" },
      { status: 500 }
    )
  }
}

function getActionDescription(actionName: string, params: Record<string, unknown>): string {
  switch (actionName) {
    case 'close_orders':
      return `Fermer ${(params.order_ids as string[])?.length || 0} commande(s)`
    case 'cancel_orders':
      return `Annuler ${(params.order_ids as string[])?.length || 0} commande(s)`
    case 'fix_payment_status':
      return `Corriger le statut de ${(params.order_ids as string[])?.length || 0} commande(s)`
    default:
      return actionName
  }
}

// Endpoint pour récupérer l'historique d'une conversation
export async function GET(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success || !user) return errorResponse

    const { searchParams } = new URL(request.url)
    const conversationId = searchParams.get('conversationId')

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any

    if (conversationId) {
      // Récupérer les messages d'une conversation spécifique
      const { data: messages } = await supabase
        .from('ai_messages')
        .select('id, role, content, metadata, created_at')
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: true })

      return NextResponse.json({ success: true, messages })
    } else {
      // Récupérer la conversation active
      const { data: activeConv } = await supabase
        .from('ai_conversations')
        .select('id, title, created_at')
        .eq('user_id', user.id)
        .eq('is_active', true)
        .order('updated_at', { ascending: false })
        .limit(1)
        .single()

      if (activeConv) {
        const { data: messages } = await supabase
          .from('ai_messages')
          .select('id, role, content, metadata, created_at')
          .eq('conversation_id', activeConv.id)
          .order('created_at', { ascending: true })

        return NextResponse.json({
          success: true,
          conversationId: activeConv.id,
          title: activeConv.title,
          messages
        })
      }

      return NextResponse.json({ success: true, conversationId: null, messages: [] })
    }
  } catch (error) {
    console.error('[Clara] GET Error:', error)
    return NextResponse.json({ success: false, error: 'Erreur' }, { status: 500 })
  }
}

// Endpoint pour créer une nouvelle conversation
export async function DELETE(request: NextRequest) {
  try {
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success || !user) return errorResponse

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const supabase = createServiceRoleClient() as any

    // Désactiver toutes les conversations existantes
    await supabase
      .from('ai_conversations')
      .update({ is_active: false })
      .eq('user_id', user.id)

    return NextResponse.json({ success: true, message: 'Nouvelle conversation prête' })
  } catch (error) {
    console.error('[Clara] DELETE Error:', error)
    return NextResponse.json({ success: false, error: 'Erreur' }, { status: 500 })
  }
}
</file>

<file path="package.json">
{
  "name": "active-games-world",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "lsof -ti:3000 | xargs kill -9 2>/dev/null; next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@getbrevo/brevo": "^3.0.1",
    "@supabase/ssr": "^0.8.0",
    "@supabase/supabase-js": "^2.90.1",
    "clsx": "^2.1.1",
    "framer-motion": "^11.15.0",
    "lucide-react": "^0.468.0",
    "next": "^15.1.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "recharts": "^3.7.0"
  },
  "devDependencies": {
    "@types/node": "^22.10.0",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "autoprefixer": "^10.4.0",
    "dotenv": "^17.2.3",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.7.0"
  }
}
</file>

<file path="vercel.json">
{
  "crons": [
    {
      "path": "/api/cron/check-email-status",
      "schedule": "0 9 * * *"
    },
    {
      "path": "/api/cron/cgv-reminders",
      "schedule": "0 10 * * *"
    },
    {
      "path": "/api/cron/backup",
      "schedule": "0 0 * * *"
    }
  ]
}
</file>

<file path="src/app/admin/orders/components/OrdersTable.tsx">
'use client'

import React, { useState, useMemo, useRef } from 'react'
import {
  Clock,
  CheckCircle,
  Users,
  ChevronUp,
  ChevronDown,
  ChevronDown as FilterIcon,
  X,
  Gamepad2,
  Target,
  PartyPopper,
  Zap,
  XCircle,
  FileCheck,
  AlertTriangle,
  Receipt,
  CheckCheck,
  Lock
} from 'lucide-react'
import { useTranslation } from '@/contexts/LanguageContext'
import type { OrderWithRelations, OrderStatus, GameArea } from '@/lib/supabase/types'

type SortField = 'date' | 'time' | 'client' | 'status' | 'participants' | 'type' | 'created' | 'source'
type SortDirection = 'asc' | 'desc'

interface OrdersTableProps {
  orders: OrderWithRelations[]
  isDark: boolean
  onCancel: (orderId: string) => void
  onViewOrder: (order: OrderWithRelations) => void
  onViewClient: (contactId: string) => void
  onOpenAccounting?: (orderId: string) => void
  onCloseOrder?: (orderId: string) => void
  canDelete?: boolean // Permission d'annuler une commande
}

// Composant Dropdown pour les filtres (position fixed pour éviter overflow)
function FilterDropdown({ 
  label, 
  options, 
  value, 
  onChange, 
  isDark 
}: { 
  label: string
  options: { value: string; label: string; color?: string }[]
  value: string
  onChange: (value: string) => void
  isDark: boolean
}) {
  const [isOpen, setIsOpen] = useState(false)
  const [position, setPosition] = useState({ top: 0, left: 0 })
  const buttonRef = React.useRef<HTMLButtonElement>(null)
  const selectedOption = options.find(o => o.value === value)
  
  const handleOpen = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect()
      setPosition({ top: rect.bottom + 4, left: rect.left })
    }
    setIsOpen(!isOpen)
  }
  
  return (
    <div className="relative">
      <button
        ref={buttonRef}
        onClick={handleOpen}
        className={`flex items-center gap-1 text-xs font-semibold uppercase tracking-wider ${
          value !== 'all' 
            ? 'text-blue-500' 
            : isDark ? 'text-gray-400' : 'text-gray-600'
        } hover:text-blue-500`}
      >
        {label}
        {value !== 'all' && (
          <span className="text-[10px] bg-blue-500 text-white px-1 rounded">
            {selectedOption?.label}
          </span>
        )}
        <FilterIcon className="w-3 h-3" />
      </button>
      
      {isOpen && (
        <>
          <div className="fixed inset-0 z-40" onClick={() => setIsOpen(false)} />
          <div 
            className={`fixed z-50 rounded-lg shadow-lg border min-w-[140px] ${
              isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
            }`}
            style={{ top: position.top, left: position.left }}
          >
            {options.map((option) => (
              <button
                key={option.value}
                onClick={(e) => {
                  e.stopPropagation()
                  onChange(option.value)
                  setIsOpen(false)
                }}
                className={`w-full text-left px-3 py-2 text-sm first:rounded-t-lg last:rounded-b-lg ${
                  value === option.value
                    ? 'bg-blue-500 text-white'
                    : isDark
                      ? 'text-gray-300 hover:bg-gray-700'
                      : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                {option.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  )
}

const PAGE_SIZE_OPTIONS = [10, 20, 50, 100, 200, 500, 1000]

export function OrdersTable({ orders, isDark, onCancel, onViewOrder, onViewClient, onOpenAccounting, onCloseOrder, canDelete = true }: OrdersTableProps) {
  const { t, locale } = useTranslation()
  const [sortField, setSortField] = useState<SortField>('created')
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc')

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }
  const [currentPage, setCurrentPage] = useState(1)
  const [itemsPerPage, setItemsPerPage] = useState(50)

  // Filtres
  const [typeFilter, setTypeFilter] = useState<string>('all')
  const [statusFilter, setStatusFilter] = useState<string>('all')
  const [gameAreaFilter, setGameAreaFilter] = useState<string>('all')
  const [sourceFilter, setSourceFilter] = useState<string>('all')
  const [cgvFilter, setCgvFilter] = useState<string>('all')

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')
    } else {
      setSortField(field)
      setSortDirection('desc')
    }
  }

  // Appliquer les filtres
  const filteredOrders = useMemo(() => {
    return orders.filter(order => {
      if (typeFilter !== 'all' && order.order_type !== typeFilter) return false
      if (statusFilter !== 'all' && order.status !== statusFilter) return false
      if (gameAreaFilter !== 'all') {
        // MIX filter should also match CUSTOM
        if (gameAreaFilter === 'MIX') {
          if (order.game_area !== 'MIX' && order.game_area !== 'CUSTOM') return false
        } else if (order.game_area !== gameAreaFilter) {
          return false
        }
      }
      if (sourceFilter !== 'all' && order.source !== sourceFilter) return false
      // Filtre CGV (pour toutes les commandes)
      if (cgvFilter !== 'all') {
        if (cgvFilter === 'pending' && order.cgv_validated_at) return false
        if (cgvFilter === 'validated' && !order.cgv_validated_at) return false
      }
      return true
    })
  }, [orders, typeFilter, statusFilter, gameAreaFilter, sourceFilter, cgvFilter])

  // Trier
  const sortedOrders = useMemo(() => {
    return [...filteredOrders].sort((a, b) => {
      let comparison = 0
      switch (sortField) {
        case 'date':
          comparison = new Date(a.requested_date).getTime() - new Date(b.requested_date).getTime()
          break
        case 'time':
          comparison = a.requested_time.localeCompare(b.requested_time)
          break
        case 'client':
          comparison = (a.customer_first_name || '').localeCompare(b.customer_first_name || '')
          break
        case 'status':
          comparison = a.status.localeCompare(b.status)
          break
        case 'participants':
          comparison = a.participants_count - b.participants_count
          break
        case 'type':
          comparison = a.order_type.localeCompare(b.order_type)
          break
        case 'created':
          comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
          break
        case 'source':
          comparison = (a.source || '').localeCompare(b.source || '')
          break
      }
      return sortDirection === 'asc' ? comparison : -comparison
    })
  }, [filteredOrders, sortField, sortDirection])

  // Pagination
  const totalPages = Math.ceil(sortedOrders.length / itemsPerPage)
  const paginatedOrders = useMemo(() => {
    const start = (currentPage - 1) * itemsPerPage
    return sortedOrders.slice(start, start + itemsPerPage)
  }, [sortedOrders, currentPage, itemsPerPage])

  // Reset page when filters change
  React.useEffect(() => {
    setCurrentPage(1)
  }, [typeFilter, statusFilter, gameAreaFilter, sourceFilter, cgvFilter, itemsPerPage])

  const SortIcon = ({ field }: { field: SortField }) => {
    if (sortField !== field) return null
    return sortDirection === 'asc' 
      ? <ChevronUp className="w-3 h-3 inline ml-1" />
      : <ChevronDown className="w-3 h-3 inline ml-1" />
  }
  
  const formatDate = (date: string) => {
    return new Date(date).toLocaleDateString(getDateLocale(), {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    })
  }

  const formatTime = (time: string) => {
    return time.slice(0, 5)
  }

  const getStatusDisplay = (status: OrderStatus) => {
    switch (status) {
      case 'pending':
        return { icon: Clock, color: 'text-red-600', bg: 'bg-red-100 dark:bg-red-900/30', label: t('admin.orders.status.pending') }
      case 'auto_confirmed':
        return { icon: CheckCircle, color: 'text-green-600', bg: 'bg-green-100 dark:bg-green-900/30', label: t('admin.orders.status.auto_confirmed') }
      case 'manually_confirmed':
        return { icon: CheckCircle, color: 'text-blue-600', bg: 'bg-blue-100 dark:bg-blue-900/30', label: t('admin.orders.status.manually_confirmed') }
      case 'closed':
        return { icon: Lock, color: 'text-gray-600', bg: 'bg-gray-200 dark:bg-gray-600', label: t('admin.orders.status.closed') }
      case 'cancelled':
        return { icon: XCircle, color: 'text-red-600', bg: 'bg-gray-100 dark:bg-gray-700', label: t('admin.orders.status.cancelled') }
      default:
        return { icon: Clock, color: 'text-gray-500', bg: 'bg-gray-100', label: status }
    }
  }

  const getGameIcon = (orderType: string, gameArea: string | null) => {
    if (orderType === 'EVENT') return PartyPopper
    if (gameArea === 'LASER') return Target
    return Zap // Active Games (ACTIVE par défaut)
  }

  // Options des filtres
  const typeOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'GAME', label: t('admin.orders.type.game') },
    { value: 'EVENT', label: t('admin.orders.type.event') },
  ]

  const statusOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'pending', label: t('admin.orders.status.pending') },
    { value: 'auto_confirmed', label: t('admin.orders.status.auto_confirmed') },
    { value: 'manually_confirmed', label: t('admin.orders.status.manually_confirmed') },
    { value: 'closed', label: t('admin.orders.status.closed') },
    { value: 'cancelled', label: t('admin.orders.status.cancelled') },
  ]

  const gameAreaOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'ACTIVE', label: 'Active' },
    { value: 'LASER', label: 'Laser' },
    { value: 'MIX', label: 'Mix' },
  ]

  const sourceOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'admin_agenda', label: 'Admin' },
    { value: 'website', label: t('admin.orders.source_website') },
  ]

  const cgvOptions = [
    { value: 'all', label: t('admin.common.all') },
    { value: 'pending', label: t('admin.orders.cgv.pending') || 'En attente' },
    { value: 'validated', label: t('admin.orders.cgv.validated') || 'Validées' },
  ]

  // Vérifier si des filtres sont actifs
  const hasActiveFilters = typeFilter !== 'all' || statusFilter !== 'all' || gameAreaFilter !== 'all' || sourceFilter !== 'all' || cgvFilter !== 'all'

  const clearAllFilters = () => {
    setTypeFilter('all')
    setStatusFilter('all')
    setGameAreaFilter('all')
    setSourceFilter('all')
    setCgvFilter('all')
  }

  if (orders.length === 0) {
    return (
      <div className={`text-center py-12 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
        {t('admin.orders.no_orders')}
      </div>
    )
  }

  return (
    <div className={`${isDark ? 'bg-gray-800' : 'bg-white'} rounded-xl border ${isDark ? 'border-gray-700' : 'border-gray-200'} overflow-hidden`}>
      {/* Header avec filtres */}
      <div className={`grid grid-cols-12 gap-2 px-4 py-3 border-b ${isDark ? 'border-gray-700 bg-gray-900' : 'border-gray-200 bg-gray-50'}`}>
        <div className="col-span-1">
          <FilterDropdown
            label={t('admin.orders.table.type')}
            options={typeOptions}
            value={typeFilter}
            onChange={setTypeFilter}
            isDark={isDark}
          />
        </div>
        <div className="col-span-1">
          <FilterDropdown
            label={t('admin.orders.table.status')}
            options={statusOptions}
            value={statusFilter}
            onChange={setStatusFilter}
            isDark={isDark}
          />
        </div>
        <div className="col-span-2">
          <button
            onClick={() => handleSort('client')}
            className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'} hover:text-blue-500`}
          >
            {t('admin.orders.table.customer')}<SortIcon field="client" />
          </button>
        </div>
        <div className="col-span-1">
          <button
            onClick={() => handleSort('date')}
            className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'} hover:text-blue-500`}
          >
            {t('admin.orders.table.date')}<SortIcon field="date" />
          </button>
        </div>
        <div className="col-span-1">
          <button
            onClick={() => handleSort('time')}
            className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'} hover:text-blue-500`}
          >
            {t('admin.orders.table.time')}<SortIcon field="time" />
          </button>
        </div>
        <div className="col-span-1">
          <button
            onClick={() => handleSort('created')}
            className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'} hover:text-blue-500`}
          >
            {t('admin.orders.table.created')}<SortIcon field="created" />
          </button>
        </div>
        <div className="col-span-1">
          <button
            onClick={() => handleSort('participants')}
            className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'} hover:text-blue-500`}
          >
            {t('admin.orders.table.players')}<SortIcon field="participants" />
          </button>
        </div>
        <div className="col-span-1">
          <FilterDropdown
            label={t('admin.orders.table.zone')}
            options={gameAreaOptions}
            value={gameAreaFilter}
            onChange={setGameAreaFilter}
            isDark={isDark}
          />
        </div>
        <div className="col-span-1">
          <FilterDropdown
            label={t('admin.orders.table.source')}
            options={sourceOptions}
            value={sourceFilter}
            onChange={setSourceFilter}
            isDark={isDark}
          />
        </div>
        <div className="col-span-1">
          <FilterDropdown
            label="CGV"
            options={cgvOptions}
            value={cgvFilter}
            onChange={setCgvFilter}
            isDark={isDark}
          />
        </div>
        <div className="col-span-1 flex items-center justify-between">
          <span className={`text-xs font-semibold uppercase tracking-wider ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
            {t('admin.orders.table.reference')}
          </span>
          {hasActiveFilters && (
            <button
              onClick={clearAllFilters}
              className="flex items-center gap-1 text-xs text-red-500 hover:text-red-600"
            >
              <X className="w-3 h-3" />
              Reset
            </button>
          )}
        </div>
      </div>

      {/* Compteur résultats */}
      {hasActiveFilters && (
        <div className={`px-4 py-2 text-xs ${isDark ? 'bg-gray-800/50 text-gray-400' : 'bg-gray-50 text-gray-500'} border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          {sortedOrders.length} {t('admin.orders.results')} {t('admin.common.of')} {orders.length} {t('admin.orders.orders_count')}
        </div>
      )}

      {/* Rows - hauteur minimale */}
      <div className="divide-y divide-gray-200 dark:divide-gray-700 min-h-[300px]">
        {paginatedOrders.length === 0 ? (
          <div className={`text-center py-8 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
            {t('admin.orders.no_matching_orders')}
          </div>
        ) : (
          paginatedOrders.map((order) => {
            const statusDisplay = getStatusDisplay(order.status)
            const StatusIcon = statusDisplay.icon
            const GameIcon = getGameIcon(order.order_type, order.game_area)
            
            return (
              <div 
                key={order.id}
                className={`grid grid-cols-12 gap-2 px-4 py-3 items-center hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors cursor-pointer ${
                  order.status === 'pending' ? 'bg-red-50/30 dark:bg-red-900/10' : ''
                } ${order.status === 'cancelled' ? 'opacity-60' : ''}`}
                onClick={() => onViewOrder(order)}
              >
                {/* Type */}
                <div className="col-span-1 flex items-center">
                  <div className={`p-2 rounded-lg ${isDark ? 'bg-gray-700' : 'bg-gray-100'}`}>
                    <GameIcon className={`w-4 h-4 ${
                      order.order_type === 'EVENT' ? 'text-green-500' :
                      order.game_area === 'LASER' ? 'text-purple-500' :
                      'text-blue-500'
                    }`} />
                  </div>
                </div>

                {/* Statut */}
                <div className="col-span-1">
                  <div className={`inline-flex items-center gap-1 px-2 py-1 rounded text-xs font-medium ${statusDisplay.bg} ${statusDisplay.color}`}>
                    <StatusIcon className="w-3 h-3" />
                  </div>
                </div>

                {/* Client */}
                <div 
                  className="col-span-2"
                  onClick={(e) => {
                    e.stopPropagation()
                    if (order.contact_id) {
                      onViewClient(order.contact_id)
                    }
                  }}
                >
                  <span className={`font-medium hover:underline cursor-pointer ${
                    order.contact_id ? (isDark ? 'text-blue-400' : 'text-blue-600') : (isDark ? 'text-gray-400' : 'text-gray-600')
                  }`}>
                    {order.customer_first_name} {order.customer_last_name || ''}
                  </span>
                  <div className="text-xs text-gray-500 mt-0.5">{order.customer_phone}</div>
                </div>

                {/* Date */}
                <div className={`col-span-1 text-sm ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {order.booking?.start_datetime 
                    ? formatDate(order.booking.start_datetime.split('T')[0])
                    : formatDate(order.requested_date)}
                </div>

                {/* Heure */}
                <div className={`col-span-1 text-sm font-mono ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {order.booking?.start_datetime
                    ? new Date(order.booking.start_datetime).toLocaleTimeString(getDateLocale(), { hour: '2-digit', minute: '2-digit' })
                    : formatTime(order.requested_time)}
                </div>

                {/* Date création */}
                <div className={`col-span-1 text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {new Date(order.created_at).toLocaleDateString(getDateLocale(), {
                    day: '2-digit',
                    month: '2-digit'
                  })}
                </div>

                {/* Personnes */}
                <div className="col-span-1 flex items-center gap-1 text-sm">
                  <Users className="w-3 h-3 text-gray-400" />
                  <span className={isDark ? 'text-gray-300' : 'text-gray-700'}>{order.participants_count}</span>
                </div>

                {/* Zone */}
                <div className="col-span-1">
                  {order.game_area && (
                    <span className={`text-xs px-2 py-0.5 rounded ${
                      order.game_area === 'LASER'
                        ? 'bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-400'
                        : order.game_area === 'MIX' || order.game_area === 'CUSTOM'
                        ? 'bg-gradient-to-r from-blue-100 to-purple-100 text-indigo-700 dark:from-blue-900/30 dark:to-purple-900/30 dark:text-indigo-400'
                        : 'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400'
                    }`}>
                      {order.game_area === 'CUSTOM' ? 'MIX' : order.game_area}
                    </span>
                  )}
                </div>

                {/* Source */}
                <div className="col-span-1">
                  <span className={`text-xs px-2 py-0.5 rounded w-fit ${
                    order.source === 'admin_agenda'
                      ? 'bg-orange-100 text-orange-700 dark:bg-orange-900/30 dark:text-orange-400'
                      : 'bg-teal-100 text-teal-700 dark:bg-teal-900/30 dark:text-teal-400'
                  }`}>
                    {order.source === 'admin_agenda' ? 'Admin' : 'Site'}
                  </span>
                </div>

                {/* CGV Badge - pour toutes les commandes */}
                <div className="col-span-1">
                  <span className={`text-xs px-1.5 py-0.5 rounded flex items-center gap-1 w-fit ${
                    order.cgv_validated_at
                      ? 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400'
                      : 'bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400'
                  }`}>
                    {order.cgv_validated_at ? (
                      <><FileCheck className="w-3 h-3" /> CGV</>
                    ) : (
                      <><AlertTriangle className="w-3 h-3" /> CGV</>
                    )}
                  </span>
                </div>

                {/* Référence + Actions */}
                <div className="col-span-1 flex items-center justify-between gap-1">
                  <span className={`text-xs font-mono truncate ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                    {order.booking?.reference_code || order.request_reference}
                  </span>
                  {onOpenAccounting && (
                    <button
                      onClick={(e) => {
                        e.stopPropagation()
                        onOpenAccounting(order.id)
                      }}
                      className={`p-1.5 rounded-lg transition-colors flex-shrink-0 ${
                        isDark
                          ? 'hover:bg-cyan-600/30 text-cyan-400'
                          : 'hover:bg-cyan-100 text-cyan-600'
                      }`}
                      title={t('admin.accounting.title')}
                    >
                      <Receipt className="w-4 h-4" />
                    </button>
                  )}
                  {onCloseOrder && order.status !== 'closed' && order.status !== 'cancelled' && (
                    <button
                      onClick={(e) => {
                        e.stopPropagation()
                        onCloseOrder(order.id)
                      }}
                      className={`p-1.5 rounded-lg transition-colors flex-shrink-0 ${
                        isDark
                          ? 'hover:bg-green-600/30 text-green-400'
                          : 'hover:bg-green-100 text-green-600'
                      }`}
                      title={t('admin.orders.close_order')}
                    >
                      <CheckCheck className="w-4 h-4" />
                    </button>
                  )}
                </div>
              </div>
            )
          })
        )}
      </div>

      {/* Pagination */}
      <div className={`flex items-center justify-between px-4 py-3 border-t ${isDark ? 'border-gray-700 bg-gray-900' : 'border-gray-200 bg-gray-50'}`}>
        <div className="flex items-center gap-4">
          <div className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
            {sortedOrders.length} {t('admin.orders.orders_count')}
            {totalPages > 1 && ` • ${t('admin.common.page')} ${currentPage}/${totalPages}`}
          </div>

          {/* Sélecteur nombre de lignes */}
          <div className="flex items-center gap-2">
            <span className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>{t('admin.common.show')}</span>
            <select
              value={itemsPerPage}
              onChange={(e) => setItemsPerPage(Number(e.target.value))}
              className={`px-2 py-1 rounded text-sm border ${
                isDark 
                  ? 'bg-gray-800 border-gray-700 text-gray-300' 
                  : 'bg-white border-gray-300 text-gray-700'
              }`}
            >
              {PAGE_SIZE_OPTIONS.map(size => (
                <option key={size} value={size}>{size}</option>
              ))}
            </select>
            <span className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>{t('admin.common.rows')}</span>
          </div>
        </div>
        
        {/* Navigation pages */}
        {totalPages > 1 && (
          <div className="flex items-center gap-2">
            <button
              onClick={() => setCurrentPage(1)}
              disabled={currentPage === 1}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              ««
            </button>
            <button
              onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
              disabled={currentPage === 1}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              «
            </button>
            <span className={`px-3 py-1 ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {currentPage}
            </span>
            <button
              onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
              disabled={currentPage === totalPages}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              »
            </button>
            <button
              onClick={() => setCurrentPage(totalPages)}
              disabled={currentPage === totalPages}
              className={`px-3 py-1 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed ${
                isDark ? 'bg-gray-800 hover:bg-gray-700 text-gray-300' : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              »»
            </button>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/admin/orders/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import Link from 'next/link'
import {
  ShoppingCart,
  Clock,
  CheckCircle,
  XCircle,
  AlertCircle,
  Search,
  X,
  PartyPopper,
  Target,
  Gamepad2,
  Mail
} from 'lucide-react'
import { useOrders } from '@/hooks/useOrders'
import { useBranches } from '@/hooks/useBranches'
import { useAuth } from '@/hooks/useAuth'
import { useUserPermissions } from '@/hooks/useUserPermissions'
import type { UserRole } from '@/hooks/useUserPermissions'
import { useTranslation } from '@/contexts/LanguageContext'
import { AdminHeader } from '../components/AdminHeader'
import { OrdersTable } from './components/OrdersTable'
import { OrderDetailModal } from './components/OrderDetailModal'
import type { OrderStatus } from '@/lib/supabase/types'
import { ContactDetailsModal } from '../components/ContactDetailsModal'
import { ConfirmationModal } from '../components/ConfirmationModal'
import { AccountingModal } from '../components/AccountingModal'
import { createClient } from '@/lib/supabase/client'
import type { OrderWithRelations } from '@/lib/supabase/types'

interface ConfirmModalState {
  isOpen: boolean
  title: string
  message: string
  type: 'warning' | 'info' | 'success'
  onConfirm: () => void
}

type Theme = 'light' | 'dark'

export default function OrdersPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const { t, locale } = useTranslation()
  const { user, loading: authLoading, signOut } = useAuth()

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }
  const branchesHook = useBranches()
  const branches = branchesHook.branches
  const branchesLoading = branchesHook.loading
  const selectedBranchIdFromHook = branchesHook.selectedBranchId
  
  // Calculer effectiveSelectedBranchId avec fallback
  const effectiveSelectedBranchId = selectedBranchIdFromHook || (branches.length > 0 ? branches[0]?.id : null)
  
  // Synchroniser avec le hook si nécessaire
  useEffect(() => {
    if (effectiveSelectedBranchId && !selectedBranchIdFromHook && branches.length === 1) {
      branchesHook.selectBranch(effectiveSelectedBranchId)
    }
  }, [effectiveSelectedBranchId, selectedBranchIdFromHook, branches.length, branchesHook.selectBranch])
  
  const selectedBranchId = effectiveSelectedBranchId
  const [searchQuery, setSearchQuery] = useState('')
  const [quickStatusFilter, setQuickStatusFilter] = useState<string>('all')
  const [theme, setTheme] = useState<Theme>('light')
  const [selectedOrder, setSelectedOrder] = useState<OrderWithRelations | null>(null)
  const [selectedContactId, setSelectedContactId] = useState<string | null>(null)
  const [accountingOrderId, setAccountingOrderId] = useState<string | null>(null)
  const [confirmModal, setConfirmModal] = useState<ConfirmModalState>({
    isOpen: false,
    title: '',
    message: '',
    type: 'warning',
    onConfirm: () => {}
  })
  
  const {
    orders,
    loading,
    error,
    stats,
    pendingCount,
    cancelOrder
  } = useOrders(selectedBranchId)

  // Permissions
  const { hasPermission } = useUserPermissions(user?.role as UserRole || null)
  const canEditOrder = hasPermission('orders', 'can_edit')
  const canDeleteOrder = hasPermission('orders', 'can_delete')

  // Charger le thème depuis localStorage
  useEffect(() => {
    const savedTheme = localStorage.getItem('admin-theme') as Theme | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  // Toggle thème
  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin-theme', newTheme)
  }

  // Note: L'auth est gérée par le layout parent, pas de redirection ici

  // Sélectionner la première branche par défaut si aucune n'est sélectionnée
  useEffect(() => {
    if (branches.length > 0 && !selectedBranchId) {
      branchesHook.selectBranch(branches[0].id)
    }
  }, [branches, selectedBranchId, branchesHook.selectBranch])

  // Gérer le paramètre order dans l'URL pour ouvrir une commande spécifique
  useEffect(() => {
    const orderId = searchParams?.get('order')
    if (orderId && orders.length > 0) {
      const order = orders.find(o => o.id === orderId)
      if (order) {
        setSelectedOrder(order)
        // Nettoyer l'URL
        router.replace('/admin/orders')
      }
    }
  }, [searchParams, orders, router])

  // Filtrer les commandes par recherche et statut rapide
  const filteredOrders = orders.filter(order => {
    // Filtre par statut rapide (en haut de page)
    if (quickStatusFilter !== 'all' && order.status !== quickStatusFilter) {
      return false
    }
    
    // Filtre par recherche
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase()
      const matchesName = `${order.customer_first_name} ${order.customer_last_name}`.toLowerCase().includes(query)
      const matchesPhone = order.customer_phone.toLowerCase().includes(query)
      const matchesEmail = order.customer_email?.toLowerCase().includes(query)
      const matchesReference = order.request_reference.toLowerCase().includes(query)
      const matchesBookingRef = order.booking?.reference_code?.toLowerCase().includes(query)
      
      return matchesName || matchesPhone || matchesEmail || matchesReference || matchesBookingRef
    }
    
    return true
  })

  // Formater la date
  const formatDate = (date: string) => {
    return new Date(date).toLocaleDateString(getDateLocale(), {
      weekday: 'short',
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    })
  }

  // Formater l'heure
  const formatTime = (time: string) => {
    return time.slice(0, 5)
  }

  // Obtenir l'icône et la couleur du statut
  const getStatusDisplay = (status: OrderStatus) => {
    switch (status) {
      case 'pending':
        return {
          icon: Clock,
          color: 'text-yellow-500',
          bg: 'bg-yellow-500/10',
          border: 'border-yellow-500/30',
          label: t('admin.orders.status.pending')
        }
      case 'auto_confirmed':
        return {
          icon: CheckCircle,
          color: 'text-green-500',
          bg: 'bg-green-500/10',
          border: 'border-green-500/30',
          label: t('admin.orders.status.auto_confirmed')
        }
      case 'manually_confirmed':
        return {
          icon: CheckCircle,
          color: 'text-blue-500',
          bg: 'bg-blue-500/10',
          border: 'border-blue-500/30',
          label: t('admin.orders.status.manually_confirmed')
        }
      case 'cancelled':
        return {
          icon: XCircle,
          color: 'text-red-500',
          bg: 'bg-red-500/10',
          border: 'border-red-500/30',
          label: t('admin.orders.status.cancelled')
        }
      case 'closed':
        return {
          icon: CheckCircle,
          color: 'text-purple-500',
          bg: 'bg-purple-500/10',
          border: 'border-purple-500/30',
          label: t('admin.orders.status.closed')
        }
      default:
        return {
          icon: AlertCircle,
          color: 'text-gray-500',
          bg: 'bg-gray-500/10',
          border: 'border-gray-500/30',
          label: status
        }
    }
  }

  // Obtenir l'icône du type de commande
  const getTypeIcon = (orderType: string, gameArea: string | null) => {
    if (orderType === 'EVENT') return PartyPopper
    if (gameArea === 'LASER') return Target
    return Gamepad2
  }

  const handleCancel = (orderId: string) => {
    setConfirmModal({
      isOpen: true,
      title: t('admin.orders.modal.cancel_title'),
      message: t('admin.orders.modal.cancel_message'),
      type: 'warning',
      onConfirm: async () => {
        await cancelOrder(orderId)
        closeOrderModal()
      }
    })
  }

  // Clôturer une commande (créer facture iCount)
  const handleCloseOrder = (orderId: string) => {
    console.log('[CLOSE ORDER - Orders Page] Called with orderId:', orderId)
    setConfirmModal({
      isOpen: true,
      title: t('admin.orders.modal.close_title'),
      message: t('admin.orders.modal.close_message'),
      type: 'warning',
      onConfirm: async () => {
        console.log('[CLOSE ORDER - Orders Page] Confirmed, calling API for orderId:', orderId)
        try {
          const response = await fetch(`/api/orders/${orderId}/close`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          })
          const result = await response.json()
          console.log('[CLOSE ORDER - Orders Page] API response:', result)
          if (result.success) {
            // Construire le message de succès avec les détails
            let successMessage = t('admin.orders.close_order_success')
            if (result.data?.icountInvrecId) {
              successMessage += `\n\n📄 ${t('admin.accounting.invoice')}: #${result.data.icountInvrecId}`
            }
            if (result.data?.totalPaidAmount) {
              successMessage += `\n💰 ${t('admin.accounting.total')}: ₪${result.data.totalPaidAmount}`
            }

            // Afficher le message de succès
            setConfirmModal({
              isOpen: true,
              title: t('admin.common.success'),
              message: successMessage,
              type: 'success',
              onConfirm: () => {
                // Rafraîchir la liste des commandes
                window.location.reload()
              }
            })
          } else {
            setConfirmModal({
              isOpen: true,
              title: t('admin.common.error'),
              message: result.error || 'Erreur lors de la clôture',
              type: 'warning',
              onConfirm: () => {}
            })
          }
        } catch (error) {
          console.error('Error closing order:', error)
          setConfirmModal({
            isOpen: true,
            title: t('admin.common.error'),
            message: 'Erreur réseau',
            type: 'warning',
            onConfirm: () => {}
          })
        }
      }
    })
  }

  const handleViewOrder = (order: OrderWithRelations) => {
    setSelectedOrder(order)
  }

  // Ouvrir la fiche client dans une modal (comme dans la section Clients)
  const handleViewClient = (contactId: string) => {
    setSelectedContactId(contactId)
  }

  const closeClientModal = () => {
    setSelectedContactId(null)
  }

  const closeOrderModal = () => {
    setSelectedOrder(null)
  }


  // Navigation vers l'agenda avec la date et booking
  const handleGoToAgenda = (date: string, bookingId?: string) => {
    if (bookingId) {
      router.push(`/admin?date=${date}&booking=${bookingId}`)
    } else {
      router.push(`/admin?date=${date}`)
    }
  }

  // Navigation vers le CRM
  const handleGoToCRM = (contactId: string) => {
    router.push(`/admin/clients?contact=${contactId}`)
  }

  // Renvoyer l'email de confirmation
  const handleResendEmail = async (orderId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/orders/${orderId}/resend-email`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      })

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error resending email:', error)
      return { success: false, error: 'Network error' }
    }
  }

  // Renvoyer un rappel CGV
  const handleResendCgvReminder = async (orderId: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await fetch(`/api/orders/${orderId}/resend-cgv`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      })

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error resending CGV reminder:', error)
      return { success: false, error: 'Network error' }
    }
  }

  // Réactiver une réservation annulée - redirige vers l'agenda pour vérifier les disponibilités
  const handleReactivate = (orderId: string) => {
    const order = orders.find(o => o.id === orderId)
    if (!order) return

    setConfirmModal({
      isOpen: true,
      title: t('admin.orders.modal.reactivate_title'),
      message: t('admin.orders.modal.reactivate_message'),
      type: 'success',
      onConfirm: () => {
        // Construire les query params avec les données de la commande
        const params = new URLSearchParams({
          reactivate: 'true',
          orderId: order.id,
          date: order.requested_date,
          time: order.requested_time,
          type: order.order_type,
          participants: order.participants_count.toString(),
          firstName: order.customer_first_name,
          lastName: order.customer_last_name || '',
          phone: order.customer_phone,
          email: order.customer_email || '',
          reference: order.request_reference
        })
        
        if (order.game_area) {
          params.set('gameArea', order.game_area)
        }
        if (order.number_of_games) {
          params.set('numberOfGames', order.number_of_games.toString())
        }
        if (order.contact_id) {
          params.set('contactId', order.contact_id)
        }
        
        closeOrderModal()
        router.push(`/admin?${params.toString()}`)
      }
    })
  }

  const isDark = theme === 'dark'

  if (authLoading || branchesLoading || !user) {
    return (
      <div className={`min-h-screen flex items-center justify-center ${isDark ? 'bg-gray-900' : 'bg-gray-50'}`}>
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-cyan-500"></div>
      </div>
    )
  }

  const selectedBranch = branches.find(b => b.id === selectedBranchId) || (branches.length > 0 ? branches[0] : null)

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900'}`}>
      {/* Header */}
      <AdminHeader
        user={user}
        branches={branches}
        selectedBranch={selectedBranch || branches[0] || null}
        onBranchSelect={(branchId) => branchesHook.selectBranch(branchId)}
        onSignOut={signOut}
        theme={theme}
        onToggleTheme={toggleTheme}
      />

      <main className="p-6">
        {/* Barre de recherche */}
        <div className={`${isDark ? 'bg-gray-800' : 'bg-white'} rounded-xl p-4 border ${isDark ? 'border-gray-700' : 'border-gray-200'} mb-6`}>
          <div className="flex items-center gap-4">
            <div className="flex-1 relative">
              <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 ${isDark ? 'text-gray-400' : 'text-gray-600'}`} />
              <input
                type="text"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                placeholder={t('admin.orders.search_placeholder')}
                className={`w-full pl-10 pr-4 py-3 ${isDark ? 'bg-gray-700 border-gray-600 text-white' : 'bg-gray-50 border-gray-300 text-gray-900'} border rounded-lg text-base placeholder-gray-500 focus:border-blue-500 focus:outline-none`}
              />
            </div>
          </div>
        </div>

        {/* Stats Cards */}
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
          <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <div className="text-2xl font-bold">{stats.total}</div>
            <div className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.orders.stats.total')}</div>
          </div>
          <div className={`p-4 rounded-xl bg-yellow-500/10 border border-yellow-500/30`}>
            <div className="text-2xl font-bold text-yellow-500">{stats.pending}</div>
            <div className="text-sm text-yellow-500/70">{t('admin.orders.stats.pending')}</div>
          </div>
          <div className={`p-4 rounded-xl bg-green-500/10 border border-green-500/30`}>
            <div className="text-2xl font-bold text-green-500">{stats.auto_confirmed}</div>
            <div className="text-sm text-green-500/70">{t('admin.orders.stats.auto_confirmed')}</div>
          </div>
          <div className={`p-4 rounded-xl bg-blue-500/10 border border-blue-500/30`}>
            <div className="text-2xl font-bold text-blue-500">{stats.manually_confirmed}</div>
            <div className="text-sm text-blue-500/70">{t('admin.orders.stats.manually_confirmed')}</div>
          </div>
          <div className={`p-4 rounded-xl bg-red-500/10 border border-red-500/30`}>
            <div className="text-2xl font-bold text-red-500">{stats.cancelled}</div>
            <div className="text-sm text-red-500/70">{t('admin.orders.stats.cancelled')}</div>
          </div>
        </div>

        {/* Conversion Rate */}
        {stats.total > 0 && (
          <div className={`p-4 rounded-xl mb-6 ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
            <div className="flex items-center justify-between">
              <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>{t('admin.orders.stats.conversion_rate')}</span>
              <span className="text-2xl font-bold text-cyan-500">
                {Math.round(((stats.auto_confirmed + stats.manually_confirmed) / stats.total) * 100)}%
              </span>
            </div>
            <div className="mt-2 h-2 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className="h-full bg-gradient-to-r from-green-500 to-cyan-500 rounded-full"
                style={{ width: `${((stats.auto_confirmed + stats.manually_confirmed) / stats.total) * 100}%` }}
              />
            </div>
          </div>
        )}

        {/* Filtres rapides par statut */}
        <div className="flex flex-wrap items-center gap-2 mb-4">
          <span className={`text-sm font-medium ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.orders.filter.label')}</span>

          <button
            onClick={() => setQuickStatusFilter('all')}
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
              quickStatusFilter === 'all'
                ? 'bg-blue-600 text-white'
                : isDark ? 'bg-gray-800 text-gray-300 hover:bg-gray-700' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            {t('admin.orders.filter.all')} ({stats.total})
          </button>

          <button
            onClick={() => setQuickStatusFilter('pending')}
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2 ${
              quickStatusFilter === 'pending'
                ? 'bg-red-600 text-white'
                : stats.pending > 0
                  ? 'bg-red-500/20 text-red-500 hover:bg-red-500/30 border-2 border-red-500'
                  : isDark ? 'bg-gray-800 text-gray-300 hover:bg-gray-700' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            <Clock className="w-4 h-4" />
            {t('admin.orders.filter.pending')}
            {stats.pending > 0 && (
              <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${
                quickStatusFilter === 'pending' ? 'bg-white text-red-600' : 'bg-red-500 text-white'
              }`}>
                {stats.pending}
              </span>
            )}
          </button>

          <button
            onClick={() => setQuickStatusFilter('auto_confirmed')}
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2 ${
              quickStatusFilter === 'auto_confirmed'
                ? 'bg-green-600 text-white'
                : isDark ? 'bg-gray-800 text-gray-300 hover:bg-gray-700' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            <CheckCircle className="w-4 h-4" />
            {t('admin.orders.filter.auto_confirmed')} ({stats.auto_confirmed})
          </button>

          <button
            onClick={() => setQuickStatusFilter('manually_confirmed')}
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2 ${
              quickStatusFilter === 'manually_confirmed'
                ? 'bg-blue-600 text-white'
                : isDark ? 'bg-gray-800 text-gray-300 hover:bg-gray-700' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            <CheckCircle className="w-4 h-4" />
            {t('admin.orders.filter.manually_confirmed')} ({stats.manually_confirmed})
          </button>

          <button
            onClick={() => setQuickStatusFilter('cancelled')}
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2 ${
              quickStatusFilter === 'cancelled'
                ? 'bg-gray-600 text-white'
                : isDark ? 'bg-gray-800 text-gray-300 hover:bg-gray-700' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            <XCircle className="w-4 h-4" />
            {t('admin.orders.filter.cancelled')} ({stats.cancelled})
          </button>

          {/* Spacer */}
          <div className="flex-1" />

          {/* Bouton Emails */}
          <Link
            href="/admin/emails"
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2 ${
              isDark
                ? 'bg-purple-600 hover:bg-purple-700 text-white'
                : 'bg-purple-500 hover:bg-purple-600 text-white'
            }`}
          >
            <Mail className="w-4 h-4" />
            {t('admin.orders.emails_button')}
          </Link>
        </div>

        {/* Orders List */}
        {loading ? (
          <div className="flex justify-center py-12">
            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-cyan-500"></div>
          </div>
        ) : error ? (
          <div className="text-center py-12 text-red-500">{error}</div>
        ) : (
          <OrdersTable
            orders={filteredOrders}
            isDark={isDark}
            onCancel={handleCancel}
            onViewOrder={handleViewOrder}
            onViewClient={handleViewClient}
            onOpenAccounting={(orderId) => setAccountingOrderId(orderId)}
            onCloseOrder={handleCloseOrder}
            canDelete={canDeleteOrder}
          />
        )}
      </main>

      {/* Modal Détail Commande */}
      {selectedOrder && (
        <OrderDetailModal
          order={selectedOrder}
          onClose={closeOrderModal}
          onCancel={handleCancel}
          onRecreate={handleReactivate}
          onResendEmail={handleResendEmail}
          onResendCgvReminder={handleResendCgvReminder}
          onGoToAgenda={handleGoToAgenda}
          onGoToClient={handleViewClient}
          onOpenAccounting={(orderId) => setAccountingOrderId(orderId)}
          isDark={isDark}
          canEdit={canEditOrder}
          canDelete={canDeleteOrder}
        />
      )}

      {/* Modal Fiche Comptable */}
      {accountingOrderId && selectedBranchId && (
        <AccountingModal
          orderId={accountingOrderId}
          branchId={selectedBranchId}
          onClose={() => setAccountingOrderId(null)}
          onCloseOrder={handleCloseOrder}
          isDark={isDark}
        />
      )}

      {/* Modal Fiche Client - Identique à section Clients */}
      {selectedContactId && (
        <ContactDetailsModal
          contactId={selectedContactId}
          onClose={closeClientModal}
          isDark={isDark}
        />
      )}

      {/* Modal de confirmation stylisée */}
      <ConfirmationModal
        isOpen={confirmModal.isOpen}
        onClose={() => setConfirmModal(prev => ({ ...prev, isOpen: false }))}
        onConfirm={confirmModal.onConfirm}
        title={confirmModal.title}
        message={confirmModal.message}
        type={confirmModal.type}
        isDark={isDark}
      />
    </div>
  )
}
</file>

<file path="src/app/admin/layout.tsx">
'use client'

import { useEffect, useState, useRef } from 'react'
import { useRouter, usePathname } from 'next/navigation'
import { getClient } from '@/lib/supabase/client'
import { Loader2 } from 'lucide-react'
import { LanguageProvider, useTranslation } from '@/contexts/LanguageContext'
import { useSessionPersistence } from '@/hooks/useSessionPersistence'
import { useInactivityTimeout } from '@/hooks/useInactivityTimeout'
import { ClaraProvider } from '@/components/Clara'

function AdminLayoutContent({
  children,
}: {
  children: React.ReactNode
}) {
  const { t } = useTranslation()
  const router = useRouter()
  const pathname = usePathname()
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null)
  const [isChecking, setIsChecking] = useState(true)
  const [theme, setTheme] = useState<'light' | 'dark'>('dark')
  const hasCheckedRef = useRef(false)
  const subscriptionRef = useRef<{ unsubscribe: () => void } | null>(null)
  const isLoginPage = pathname === '/admin/login'

  // Écouter les changements de thème depuis localStorage
  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
    if (savedTheme) setTheme(savedTheme)

    // Écouter les changements de storage (si le thème change dans une autre page)
    const handleStorage = (e: StorageEvent) => {
      if (e.key === 'admin_theme' && e.newValue) {
        setTheme(e.newValue as 'light' | 'dark')
      }
    }
    window.addEventListener('storage', handleStorage)

    // Observer les changements de localStorage dans la même page
    const interval = setInterval(() => {
      const currentTheme = localStorage.getItem('admin_theme') as 'light' | 'dark' | null
      if (currentTheme && currentTheme !== theme) {
        setTheme(currentTheme)
      }
    }, 500)

    return () => {
      window.removeEventListener('storage', handleStorage)
      clearInterval(interval)
    }
  }, [theme])

  // Maintenir la session active en arrière-plan
  useSessionPersistence()

  // Déconnexion automatique après 5 minutes d'inactivité (sauf sur page login)
  useInactivityTimeout()

  // Vérification initiale - UNE SEULE FOIS au montage
  useEffect(() => {
    // Skip si page login
    if (isLoginPage) {
      setIsAuthenticated(true)
      setIsChecking(false)
      return
    }

    // Skip si déjà vérifié
    if (hasCheckedRef.current) {
      setIsChecking(false)
      return
    }

    const checkAuth = async () => {
      const supabase = getClient()

      try {
        const { data: { user }, error } = await supabase.auth.getUser()

        if (error || !user) {
          setIsAuthenticated(false)
        } else {
          setIsAuthenticated(true)
          hasCheckedRef.current = true
        }
      } catch {
        setIsAuthenticated(false)
      } finally {
        setIsChecking(false)
      }
    }

    checkAuth()
  }, [isLoginPage])

  // Écouter les changements d'authentification (login/logout) - UNE SEULE FOIS
  useEffect(() => {
    // Skip si page login ou déjà souscrit
    if (isLoginPage || subscriptionRef.current) {
      return
    }

    const supabase = getClient()

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event) => {
        if (event === 'SIGNED_IN') {
          setIsAuthenticated(true)
          hasCheckedRef.current = true
          setIsChecking(false)
        } else if (event === 'SIGNED_OUT') {
          setIsAuthenticated(false)
          hasCheckedRef.current = false
        }
        // Ne pas réagir à TOKEN_REFRESHED pour éviter les déconnexions intempestives
      }
    )

    subscriptionRef.current = subscription

    return () => {
      subscription.unsubscribe()
      subscriptionRef.current = null
    }
  }, [isLoginPage])

  // Redirection vers login si non authentifié
  useEffect(() => {
    if (!isChecking && isAuthenticated === false && !isLoginPage) {
      router.push('/admin/login')
    }
  }, [isChecking, isAuthenticated, isLoginPage, router])

  // Pendant la vérification de l'auth ou redirection en cours
  if (isChecking || isAuthenticated === false) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-900">
        <div className="flex flex-col items-center gap-4">
          <Loader2 className="w-8 h-8 animate-spin text-cyan-500" />
          <p className="text-gray-400">{t('admin.common.loading')}</p>
        </div>
      </div>
    )
  }

  // Authentifié - afficher le contenu avec Clara disponible
  return (
    <ClaraProvider theme={theme}>
      {children}
    </ClaraProvider>
  )
}

export default function AdminLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <LanguageProvider isAdmin={true}>
      <AdminLayoutContent>{children}</AdminLayoutContent>
    </LanguageProvider>
  )
}
</file>

<file path="src/hooks/useBookings.ts">
'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { getClient } from '@/lib/supabase/client'
import { useRealtimeRefresh } from './useRealtimeSubscription'
import {
  getCachedBookings,
  setCachedBookings,
  updateCachedBooking,
  removeCachedBooking,
  setLastSyncTime,
} from '@/lib/cache'
import type {
  Booking,
  BookingSlot,
  BookingType,
  Contact,
  GameSession,
  BookingUpdate,
  GameArea,
} from '@/lib/supabase/types'

// Type étendu avec les slots, contacts et game_sessions
export interface BookingWithSlots extends Booking {
  slots: BookingSlot[]
  game_sessions?: GameSession[]
  primaryContact?: Contact | null
  allContacts?: Contact[]
}

// Données pour créer une réservation
export interface CreateBookingData {
  branch_id: string
  type: BookingType
  start_datetime: string
  end_datetime: string
  game_start_datetime?: string
  game_end_datetime?: string
  participants_count: number
  event_room_id?: string
  customer_first_name: string
  customer_last_name: string
  customer_phone: string
  customer_email?: string
  customer_notes_at_booking?: string // Snapshot des notes client au moment de la réservation
  primary_contact_id?: string // ID du contact principal (CRM)
  notes?: string
  color?: string
  // Discount (remise)
  discount_type?: 'percent' | 'fixed' | null
  discount_value?: number | null
  slots: {
    slot_start: string
    slot_end: string
    participants_count: number
  }[]
  game_sessions?: {
    game_area: GameArea
    start_datetime: string
    end_datetime: string
    laser_room_id?: string | null
    session_order: number
    pause_before_minutes: number
  }[]
  // Pour réactiver une commande annulée
  reactivateOrderId?: string
  reactivateReference?: string // Référence à réutiliser
  // Langue préférée du contact pour les emails
  locale?: 'he' | 'fr' | 'en'
}

export function useBookings(branchId: string | null, date?: string) {
  const [bookings, setBookings] = useState<BookingWithSlots[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const lastFetchKeyRef = useRef<string | null>(null)
  const isFetchingRef = useRef(false)
  const initialCacheLoadedRef = useRef(false)

  // Charger depuis le cache au démarrage (affichage instantané)
  useEffect(() => {
    if (!branchId || !date || initialCacheLoadedRef.current) return

    const cached = getCachedBookings(branchId, date)
    if (cached && cached.length > 0) {
      setBookings(cached)
      setLoading(false) // Affichage instantané !
      initialCacheLoadedRef.current = true
    }
  }, [branchId, date])

  // Charger les réservations
  const fetchBookings = useCallback(async (force = false) => {
    if (!branchId) {
      setBookings([])
      setLoading(false)
      return
    }

    // Éviter les appels concurrents
    if (isFetchingRef.current && !force) {
      return
    }

    const supabase = getClient()
    isFetchingRef.current = true

    // Ne montrer le loading que si pas de cache
    const cached = date ? getCachedBookings(branchId, date) : null
    if (!cached || cached.length === 0) {
      setLoading(true)
    }
    setError(null)

    try {
      // Construire la requête
      let query = supabase
        .from('bookings')
        .select('*')
        .eq('branch_id', branchId)
        .neq('status', 'CANCELLED')
        .order('start_datetime', { ascending: true })

      // Filtrer par date si fournie
      if (date) {
        const startOfDay = `${date}T00:00:00.000Z`
        const endOfDay = `${date}T23:59:59.999Z`
        query = query
          .gte('start_datetime', startOfDay)
          .lte('start_datetime', endOfDay)
      }

      const { data: bookingsData, error: bookingsError } = await query.returns<Booking[]>()

      if (bookingsError) throw bookingsError

      if (!bookingsData || bookingsData.length === 0) {
        setBookings([])
        setLoading(false)
        return
      }

      // Charger les slots et game_sessions pour chaque booking
      const bookingIds = bookingsData.map(b => b.id)
      const [slotsResult, sessionsResult] = await Promise.all([
        supabase
          .from('booking_slots')
          .select('*')
          .in('booking_id', bookingIds)
          .order('slot_start')
          .returns<BookingSlot[]>(),
        supabase
          .from('game_sessions')
          .select('*')
          .in('booking_id', bookingIds)
          .order('session_order')
          .returns<GameSession[]>()
      ])

      const { data: slotsData, error: slotsError } = slotsResult
      const { data: sessionsData, error: sessionsError } = sessionsResult
      
      // Gérer les erreurs silencieusement si les tables n'existent pas encore
      if (slotsError) {
        console.warn('Error loading slots (table may not exist yet):', slotsError)
      }
      if (sessionsError) {
        // Code 42P01 = table does not exist
        if (sessionsError.code === '42P01' || sessionsError.message?.includes('does not exist') || sessionsError.message?.includes('n\'existe pas')) {
          console.warn('Table game_sessions does not exist yet. Please run migration 006_add_laser_support.sql')
        } else {
          console.warn('Error loading game_sessions:', sessionsError)
        }
      }

      // CRM: Charger les contacts liés pour chaque booking
      const { data: bookingContactsData } = await supabase
        .from('booking_contacts')
        .select('*, contact:contacts(*)')
        .in('booking_id', bookingIds)

      // Créer un map des contacts par booking_id
      const contactsByBooking = new Map<string, { primary: Contact | null; all: Contact[] }>()

      interface BookingContactRow {
        booking_id: string
        contact_id: string
        is_primary: boolean
        role: string | null
        contact: Contact | null
      }

      (bookingContactsData as BookingContactRow[] | null)?.forEach((bc) => {
        if (!bc.contact) return

        const contact = bc.contact
        const bookingId = bc.booking_id

        if (!contactsByBooking.has(bookingId)) {
          contactsByBooking.set(bookingId, { primary: null, all: [] })
        }

        const contacts = contactsByBooking.get(bookingId)!
        contacts.all.push(contact)

        if (bc.is_primary) {
          contacts.primary = contact
        }
      })

      // Charger les contacts principaux via primary_contact_id (fallback pour anciennes données)
      const primaryContactIds = bookingsData
        .filter(b => b.primary_contact_id && !contactsByBooking.has(b.id))
        .map(b => b.primary_contact_id!)

      let primaryContactsMap = new Map<string, Contact>()
      if (primaryContactIds.length > 0) {
        const { data: primaryContactsData } = await supabase
          .from('contacts')
          .select('*')
          .in('id', primaryContactIds)
          .eq('status', 'active')
          .returns<Contact[]>()

        primaryContactsData?.forEach(contact => {
          primaryContactsMap.set(contact.id, contact)
        })
      }

      // Associer les slots, game_sessions et contacts à chaque booking
      const bookingsWithSlots: BookingWithSlots[] = bookingsData.map(booking => {
        const slots = slotsData?.filter(s => s.booking_id === booking.id) || []
        const game_sessions = sessionsData?.filter(s => s.booking_id === booking.id) || []
        const contacts = contactsByBooking.get(booking.id)
        
        // Contact principal : depuis booking_contacts en priorité, sinon depuis primary_contact_id
        let primaryContact: Contact | null = null
        if (contacts?.primary) {
          primaryContact = contacts.primary
        } else if (booking.primary_contact_id) {
          primaryContact = primaryContactsMap.get(booking.primary_contact_id) || null
        }

        return {
          ...booking,
          slots,
          game_sessions,
          primaryContact,
          allContacts: contacts?.all || (primaryContact ? [primaryContact] : []),
        }
      })

      setBookings(bookingsWithSlots)

      // Sauvegarder en cache pour affichage instantané au prochain chargement
      if (date && branchId) {
        setCachedBookings(branchId, date, bookingsWithSlots)
        setLastSyncTime(branchId)
      }
    } catch (err) {
      console.error('Error fetching bookings:', err)
      setError('Erreur lors du chargement des réservations')
    } finally {
      setLoading(false)
      isFetchingRef.current = false
    }
  }, [branchId, date])

  // Charger quand branchId ou date change (avec déduplication)
  useEffect(() => {
    const fetchKey = `${branchId || ''}-${date || ''}`
    if (fetchKey === lastFetchKeyRef.current) {
      return
    }
    lastFetchKeyRef.current = fetchKey
    fetchBookings()
  }, [branchId, date, fetchBookings])

  // Realtime: écouter les changements sur bookings et game_sessions
  // Remplace le polling de 30 secondes - mise à jour instantanée
  useRealtimeRefresh(
    'bookings',
    branchId,
    fetchBookings,
    ['game_sessions', 'booking_slots'] // Tables liées qui déclenchent aussi un refresh
  )

  // Créer une réservation via l'API (garantit les logs et l'email)
  const createBooking = useCallback(async (data: CreateBookingData): Promise<BookingWithSlots | null> => {
    setError(null)

    try {
      // Appeler l'API qui gère tout : création, logs, email
      const response = await fetch('/api/bookings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          branch_id: data.branch_id,
          type: data.type,
          start_datetime: data.start_datetime,
          end_datetime: data.end_datetime,
          game_start_datetime: data.game_start_datetime,
          game_end_datetime: data.game_end_datetime,
          participants_count: data.participants_count,
          event_room_id: data.event_room_id,
          customer_first_name: data.customer_first_name,
          customer_last_name: data.customer_last_name,
          customer_phone: data.customer_phone,
          customer_email: data.customer_email,
          customer_notes_at_booking: data.customer_notes_at_booking,
          primary_contact_id: data.primary_contact_id,
          notes: data.notes,
          color: data.color,
          discount_type: data.discount_type,
          discount_value: data.discount_value,
          reactivateReference: data.reactivateReference,
          reactivateOrderId: data.reactivateOrderId,
          slots: data.slots,
          game_sessions: data.game_sessions,
          locale: data.locale || 'he', // Langue préférée du contact pour l'email
        }),
      })

      const result = await response.json()

      if (!response.ok || !result.success) {
        // Erreur de validation (400) = erreur métier, pas une erreur technique
        // On affiche le message à l'utilisateur sans console.error pour éviter l'overlay Next.js
        const errorMessage = result.error || 'Failed to create booking'
        setError(errorMessage)
        return null
      }

      // Rafraîchir la liste
      await fetchBookings()

      return result.booking as BookingWithSlots
    } catch (err: unknown) {
      // Vraie erreur technique (réseau, etc.)
      const errorMessage = err instanceof Error
        ? err.message
        : typeof err === 'object' && err !== null
          ? JSON.stringify(err, Object.getOwnPropertyNames(err))
          : String(err)
      console.error('Error creating booking:', errorMessage, err)
      setError(`Erreur technique: ${errorMessage}`)
      return null
    }
  }, [fetchBookings])

  // Mettre à jour une réservation (via API route pour permissions et logging)
  const updateBooking = useCallback(async (
    id: string,
    data: Partial<CreateBookingData>
  ): Promise<BookingWithSlots | null> => {
    setError(null)

    try {
      // Construire le body pour l'API
      const apiBody: Record<string, unknown> = {}

      if (data.type !== undefined) apiBody.type = data.type
      if (data.branch_id !== undefined) apiBody.branch_id = data.branch_id
      if (data.start_datetime !== undefined) apiBody.start_datetime = data.start_datetime
      if (data.end_datetime !== undefined) apiBody.end_datetime = data.end_datetime
      if (data.game_start_datetime !== undefined) apiBody.game_start_datetime = data.game_start_datetime
      if (data.game_end_datetime !== undefined) apiBody.game_end_datetime = data.game_end_datetime
      if (data.participants_count !== undefined) apiBody.participants_count = data.participants_count
      if (data.event_room_id !== undefined) apiBody.event_room_id = data.event_room_id
      if (data.customer_first_name !== undefined) apiBody.customer_first_name = data.customer_first_name
      if (data.customer_last_name !== undefined) apiBody.customer_last_name = data.customer_last_name
      if (data.customer_phone !== undefined) apiBody.customer_phone = data.customer_phone
      if (data.customer_email !== undefined) apiBody.customer_email = data.customer_email
      if (data.notes !== undefined) apiBody.notes = data.notes
      if (data.color !== undefined) apiBody.color = data.color
      if (data.discount_type !== undefined) apiBody.discount_type = data.discount_type
      if (data.discount_value !== undefined) apiBody.discount_value = data.discount_value
      if (data.primary_contact_id !== undefined) apiBody.primary_contact_id = data.primary_contact_id
      if (data.slots !== undefined) apiBody.slots = data.slots
      if (data.game_sessions !== undefined) apiBody.game_sessions = data.game_sessions

      const response = await fetch(`/api/bookings/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(apiBody)
      })

      const result = await response.json()

      if (!response.ok || !result.success) {
        const errorMsg = result.error || 'Failed to update booking'
        setError(errorMsg)
        return null
      }

      await fetchBookings()
      return result.booking as BookingWithSlots
    } catch (err) {
      console.error('Error updating booking:', err)
      setError('Erreur lors de la mise à jour de la réservation')
      return null
    }
  }, [fetchBookings])

  // Annuler une réservation (via API route pour permissions et logging)
  const cancelBooking = useCallback(async (id: string, reason?: string): Promise<boolean> => {
    setError(null)

    try {
      const url = new URL(`/api/bookings/${id}`, window.location.origin)
      if (reason) url.searchParams.set('reason', reason)

      const response = await fetch(url.toString(), {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' }
      })

      const result = await response.json()

      if (!response.ok || !result.success) {
        setError(result.error || 'Erreur lors de l\'annulation')
        return false
      }

      await fetchBookings()
      return true
    } catch (err) {
      console.error('Error cancelling booking:', err)
      setError('Erreur lors de l\'annulation de la réservation')
      return false
    }
  }, [fetchBookings])

  // Supprimer définitivement une réservation (via API route pour permissions et logging)
  const deleteBooking = useCallback(async (id: string): Promise<boolean> => {
    setError(null)

    try {
      const url = new URL(`/api/bookings/${id}`, window.location.origin)
      url.searchParams.set('hard', 'true')

      const response = await fetch(url.toString(), {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' }
      })

      const result = await response.json()

      if (!response.ok || !result.success) {
        setError(result.error || 'Erreur lors de la suppression')
        return false
      }

      await fetchBookings()
      return true
    } catch (err) {
      console.error('Error deleting booking:', err)
      setError('Erreur lors de la suppression de la réservation')
      return false
    }
  }, [fetchBookings])

  // Supprimer toutes les réservations (pour remettre le système à zéro)
  const deleteAllBookings = useCallback(async (): Promise<boolean> => {
    const supabase = getClient()
    setError(null)

    try {
      if (!branchId) {
        setError('Aucune branche sélectionnée')
        return false
      }

      // Supprimer toutes les réservations de la branche
      // Les slots seront supprimés automatiquement grâce à ON DELETE CASCADE
      const { error: deleteError } = await supabase
        .from('bookings')
        .delete()
        .eq('branch_id', branchId)

      if (deleteError) throw deleteError

      await fetchBookings()
      return true
    } catch (err) {
      console.error('Error deleting all bookings:', err)
      setError('Erreur lors de la suppression de toutes les réservations')
      return false
    }
  }, [branchId, fetchBookings])

  return {
    bookings,
    loading,
    error,
    createBooking,
    updateBooking,
    cancelBooking,
    deleteBooking,
    deleteAllBookings,
    refresh: fetchBookings,
  }
}
</file>

<file path="src/app/admin/components/AccountingModal.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import {
  X,
  Loader2,
  Receipt,
  ExternalLink,
  CheckCircle,
  AlertCircle,
  Clock,
  FileText,
  CreditCard,
  Users,
  Calendar,
  Hash,
  Plus,
  Banknote,
  ShieldCheck,
  CheckCheck,
  Send
} from 'lucide-react'
import { createClient } from '@/lib/supabase/client'
import { useTranslation } from '@/contexts/LanguageContext'
import { usePricingData } from '@/hooks/usePricingData'
import { calculateBookingPrice, type PriceCalculationResult } from '@/lib/price-calculator'
import { PaymentModal, type PaymentData, type PaymentMode } from './PaymentModal'
import { ConfirmationModal } from './ConfirmationModal'
import type { OrderWithRelations, Payment } from '@/lib/supabase/types'

interface AccountingModalProps {
  orderId: string
  onClose: () => void
  onCloseOrder?: (orderId: string) => void
  isDark: boolean
  branchId: string
}

type PaymentStatus = 'unpaid' | 'partial' | 'paid' | 'guaranteed'

export function AccountingModal({
  orderId,
  onClose,
  onCloseOrder,
  isDark,
  branchId,
}: AccountingModalProps) {
  const { t, locale } = useTranslation()
  const [order, setOrder] = useState<OrderWithRelations | null>(null)
  const [payments, setPayments] = useState<Payment[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [showPaymentModal, setShowPaymentModal] = useState(false)
  const [sendingInvoice, setSendingInvoice] = useState(false)
  const [notification, setNotification] = useState<{
    isOpen: boolean
    type: 'success' | 'warning' | 'info'
    title: string
    message: string
  }>({ isOpen: false, type: 'info', title: '', message: '' })

  const { products, eventFormulas, rooms, loading: loadingPricing } = usePricingData(branchId)

  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }

  const loadOrder = useCallback(async () => {
    setLoading(true)
    setError(null)
    const supabase = createClient()

    // Load order with relations
    const { data, error: fetchError } = await supabase
      .from('orders')
      .select(`
        *,
        contact:contacts(*),
        booking:bookings(
          *,
          slots:booking_slots(*)
        )
      `)
      .eq('id', orderId)
      .single()

    if (fetchError) {
      console.error('Error loading order:', fetchError)
      setError(t('admin.orders.loading_error'))
    } else {
      setOrder(data as OrderWithRelations)
    }

    // Load payments for this order
    const { data: paymentsData } = await supabase
      .from('payments')
      .select('*')
      .eq('order_id', orderId)
      .order('created_at', { ascending: false })

    if (paymentsData) {
      setPayments(paymentsData as Payment[])
    }

    setLoading(false)
  }, [orderId, t])

  useEffect(() => {
    loadOrder()
  }, [loadOrder])

  // Calcul du prix basé sur les données de la commande
  const getPriceCalculation = (): PriceCalculationResult | null => {
    try {
      if (!order || loadingPricing) return null
      if (!products || !Array.isArray(products) || products.length === 0) return null

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const booking = order.booking as any
      if (!booking) return null

      const bookingType = order.order_type as 'GAME' | 'EVENT'
      if (!bookingType) return null

      const gameArea = (order.game_area || 'ACTIVE') as 'ACTIVE' | 'LASER' | 'CUSTOM'
      const participants = order.participants_count || 0

      if (participants < 1) return null

      let laserGames = 0
      let activeDuration = 0

      const slots = booking?.slots
      if (slots && Array.isArray(slots) && slots.length > 0) {
        slots.forEach((slot: any) => {
          if (slot?.area === 'LASER') {
            laserGames++
          } else if (slot?.area === 'ACTIVE') {
            activeDuration += slot?.duration_minutes || 30
          }
        })
      } else {
        if (gameArea === 'LASER' || gameArea === 'CUSTOM') {
          laserGames = (order as any).laser_games_count || 1
        }
        if (gameArea === 'ACTIVE' || gameArea === 'CUSTOM') {
          activeDuration = (order as any).active_duration || 60
        }
      }

      const safeProducts = products || []
      const safeEventFormulas = eventFormulas || []
      const safeRooms = rooms || []

      let eventQuickPlan = 'AA'
      if (bookingType === 'EVENT') {
        if (gameArea === 'LASER') eventQuickPlan = 'LL'
        else if (gameArea === 'ACTIVE') eventQuickPlan = 'AA'
        else eventQuickPlan = 'AL'
      }

      return calculateBookingPrice({
        bookingType,
        gameArea,
        participants,
        numberOfGames: laserGames || 1,
        gameDurations: activeDuration > 0 ? [String(activeDuration)] : ['60'],
        eventQuickPlan,
        eventRoomId: null, // Laisser le calcul utiliser formula.room_id (icount_rooms)
        products: safeProducts,
        eventFormulas: safeEventFormulas,
        rooms: safeRooms,
      })
    } catch (error) {
      console.error('Error calculating price:', error)
      return null
    }
  }

  // Helper pour afficher le type de jeu avec la zone
  const getGameLabel = (): string => {
    if (!order) return ''

    // Même logique pour GAME et EVENT
    if (order.game_area === 'LASER') return 'Laser City'
    if (order.game_area === 'MIX' || order.game_area === 'CUSTOM') return 'Active + Laser'
    if (order.game_area === 'ACTIVE') return 'Active Games'

    // Fallback sur event_type pour les anciennes commandes EVENT
    if (order.order_type === 'EVENT') {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const orderAny = order as any
      if (orderAny.event_type === 'event_active') return 'Active Games'
      if (orderAny.event_type === 'event_laser') return 'Laser City'
      if (orderAny.event_type === 'event_mix') return 'Active + Laser'
    }

    return 'Active Games'
  }

  const getPaymentStatus = (): PaymentStatus => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const orderAny = order as any

    // Si la commande est clôturée, elle est considérée comme payée
    if (orderAny?.status === 'closed') return 'paid'

    // Check payment_status field first
    if (orderAny?.payment_status === 'fully_paid') return 'paid'
    if (orderAny?.payment_status === 'deposit_paid') return 'partial'
    if (orderAny?.payment_status === 'card_authorized') return 'guaranteed'

    // Fallback to legacy check - check icount_invrec_id on order itself
    if (orderAny?.icount_invrec_id) return 'paid'
    return 'unpaid'
  }

  // Calculate totals from payments
  const totalPaid = payments.reduce((sum, p) => {
    if (p.status === 'completed') return sum + (p.amount || 0)
    return sum
  }, 0)

  // Handle payment submission
  const handlePaymentSubmit = async (data: PaymentData): Promise<{ success: boolean; error?: string }> => {
    try {
      // Si mode pré-autorisation, appeler l'API preauth
      if (data.mode === 'preauth') {
        const response = await fetch(`/api/orders/${orderId}/preauth`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            amount: data.amount,
            cardInfo: data.cardInfo,
            saveCard: data.saveCard,
          }),
        })

        const result = await response.json()

        if (result.success) {
          // Ne pas recharger immédiatement - laisser l'utilisateur voir le message de succès
          return { success: true }
        } else {
          return { success: false, error: result.error }
        }
      }

      // Mode paiement normal
      const response = await fetch(`/api/orders/${orderId}/payment`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      })

      const result = await response.json()

      if (result.success) {
        // Ne pas recharger immédiatement - laisser l'utilisateur voir le message de succès
        // Le rechargement se fera quand le modal se ferme
        return { success: true }
      } else {
        return { success: false, error: result.error }
      }
    } catch (err) {
      console.error('Payment error:', err)
      return { success: false, error: 'Network error' }
    }
  }

  // Handle send invoice email
  const handleSendInvoice = async () => {
    if (sendingInvoice) return

    setSendingInvoice(true)
    try {
      const response = await fetch(`/api/orders/${orderId}/send-invoice`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })

      const result = await response.json()

      if (result.success) {
        setNotification({
          isOpen: true,
          type: 'success',
          title: t('admin.invoice.success_title') || 'Facture envoyée',
          message: t('admin.invoice.success') || 'La facture a été envoyée avec succès au client.',
        })
      } else {
        const errorMsg = result.messageKey ? t(result.messageKey) : result.error
        setNotification({
          isOpen: true,
          type: 'warning',
          title: t('admin.common.error') || 'Erreur',
          message: errorMsg || 'Échec de l\'envoi de la facture',
        })
      }
    } catch (err) {
      console.error('Send invoice error:', err)
      setNotification({
        isOpen: true,
        type: 'warning',
        title: t('admin.common.error') || 'Erreur',
        message: t('errors.networkError') || 'Erreur réseau',
      })
    } finally {
      setSendingInvoice(false)
    }
  }

  const getPaymentStatusConfig = (status: PaymentStatus) => {
    switch (status) {
      case 'paid':
        return {
          label: t('admin.accounting.status.paid'),
          icon: CheckCircle,
          color: 'text-green-500',
          bgColor: isDark ? 'bg-green-500/10' : 'bg-green-50',
          borderColor: 'border-green-500/20'
        }
      case 'partial':
        return {
          label: t('admin.accounting.status.partial'),
          icon: Clock,
          color: 'text-amber-500',
          bgColor: isDark ? 'bg-amber-500/10' : 'bg-amber-50',
          borderColor: 'border-amber-500/20'
        }
      case 'guaranteed':
        return {
          label: t('admin.accounting.status.guaranteed'),
          icon: CreditCard,
          color: 'text-blue-500',
          bgColor: isDark ? 'bg-blue-500/10' : 'bg-blue-50',
          borderColor: 'border-blue-500/20'
        }
      default:
        return {
          label: t('admin.accounting.status.unpaid'),
          icon: AlertCircle,
          color: 'text-red-500',
          bgColor: isDark ? 'bg-red-500/10' : 'bg-red-50',
          borderColor: 'border-red-500/20'
        }
    }
  }

  if (loading || loadingPricing) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
        <div className={`rounded-2xl border p-8 ${
          isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
        }`}>
          <Loader2 className={`w-8 h-8 animate-spin ${
            isDark ? 'text-blue-400' : 'text-blue-600'
          }`} />
        </div>
      </div>
    )
  }

  if (error || !order) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
        <div className={`rounded-2xl border p-6 max-w-md ${
          isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
        }`}>
          <div className="flex items-center gap-3 text-red-400">
            <AlertCircle className="w-6 h-6" />
            <span>{error || t('admin.common.error')}</span>
          </div>
          <button
            onClick={onClose}
            className={`mt-4 w-full px-4 py-2 rounded-lg transition-colors ${
              isDark
                ? 'bg-gray-700 hover:bg-gray-600 text-white'
                : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
            }`}
          >
            {t('admin.common.close')}
          </button>
        </div>
      </div>
    )
  }

  const priceCalculation = getPriceCalculation()
  const paymentStatus = getPaymentStatus()
  const statusConfig = getPaymentStatusConfig(paymentStatus)
  const StatusIcon = statusConfig.icon
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const booking = order.booking as any

  const participants = order.participants_count || 0
  const unitPrice = priceCalculation?.details?.unitPrice || 0
  const unitLabel = priceCalculation?.details?.unitLabel || ''
  const roomPrice = priceCalculation?.details?.roomPrice
  const roomName = priceCalculation?.details?.roomName

  // Format date for display
  const bookingDate = booking?.start_datetime
    ? new Date(booking.start_datetime).toLocaleDateString(getDateLocale(), {
        weekday: 'short',
        day: 'numeric',
        month: 'short',
        year: 'numeric'
      })
    : null

  const bookingTime = booking?.start_datetime
    ? new Date(booking.start_datetime).toLocaleTimeString(getDateLocale(), {
        hour: '2-digit',
        minute: '2-digit'
      })
    : null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
      <div className={`rounded-2xl border w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col ${
        isDark ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
      }`}>
        {/* Header */}
        <div className={`px-6 py-4 border-b flex items-center justify-between ${
          isDark ? 'border-gray-700 bg-gray-800/50' : 'border-gray-200 bg-gray-50'
        }`}>
          <div className="flex items-center gap-4">
            <div className={`p-2 rounded-xl ${isDark ? 'bg-blue-500/20' : 'bg-blue-100'}`}>
              <Receipt className={`w-6 h-6 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
            </div>
            <div>
              <h2 className={`text-lg font-semibold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.accounting.title')}
              </h2>
              <div className="flex items-center gap-2 mt-0.5">
                <Hash className={`w-3 h-3 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
                <span className={`text-sm font-mono ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {order.request_reference || booking?.reference_code || 'N/A'}
                </span>
              </div>
            </div>
          </div>
          <button
            onClick={onClose}
            className={`p-2 rounded-lg transition-colors ${
              isDark
                ? 'text-gray-400 hover:text-white hover:bg-gray-700'
                : 'text-gray-500 hover:text-gray-900 hover:bg-gray-100'
            }`}
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Content - Layout horizontal */}
        <div className="flex-1 overflow-y-auto">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-0 lg:gap-px lg:bg-gray-200 dark:lg:bg-gray-700">

            {/* COLONNE GAUCHE - Détails & Prix */}
            <div className={`p-6 space-y-6 ${isDark ? 'bg-gray-800' : 'bg-white'}`}>

              {/* Infos rapides */}
              <div className="grid grid-cols-2 gap-4">
                <div className={`p-3 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
                  <div className="flex items-center gap-2 mb-1">
                    <Calendar className={`w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
                    <span className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.orders.table.date')}
                    </span>
                  </div>
                  <p className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {bookingDate || '-'}
                  </p>
                  {bookingTime && (
                    <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                      {bookingTime}
                    </p>
                  )}
                </div>
                <div className={`p-3 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
                  <div className="flex items-center gap-2 mb-1">
                    <Users className={`w-4 h-4 ${isDark ? 'text-gray-500' : 'text-gray-400'}`} />
                    <span className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                      {t('admin.orders.table.players')}
                    </span>
                  </div>
                  <p className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                    {participants}
                  </p>
                </div>
              </div>

              {/* Tableau des lignes - Style iCount */}
              <div>
                <h3 className={`text-sm font-medium mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.accounting.price_breakdown')}
                </h3>

                {priceCalculation && priceCalculation.valid ? (
                  <div className={`rounded-xl border overflow-hidden ${
                    isDark ? 'border-gray-700' : 'border-gray-200'
                  }`}>
                    {/* Header du tableau */}
                    <div className={`grid grid-cols-12 gap-2 px-4 py-2 text-xs font-medium ${
                      isDark ? 'bg-gray-700/50 text-gray-400' : 'bg-gray-50 text-gray-500'
                    }`}>
                      <div className="col-span-6">{t('admin.accounting.description')}</div>
                      <div className="col-span-2 text-center">{t('admin.accounting.qty')}</div>
                      <div className="col-span-2 text-right">{t('admin.accounting.unit_price')}</div>
                      <div className="col-span-2 text-right">{t('admin.common.total')}</div>
                    </div>

                    {/* Lignes */}
                    <div className={`divide-y ${isDark ? 'divide-gray-700' : 'divide-gray-100'}`}>
                      {/* Ligne principale - Participants */}
                      <div className={`grid grid-cols-12 gap-2 px-4 py-3 ${
                        isDark ? 'text-gray-300' : 'text-gray-700'
                      }`}>
                        <div className="col-span-6">
                          <span className="font-medium">
                            {getGameLabel()}
                          </span>
                          {unitLabel && (
                            <span className={`block text-xs mt-0.5 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                              {unitLabel}
                            </span>
                          )}
                        </div>
                        <div className="col-span-2 text-center">{participants}</div>
                        <div className="col-span-2 text-right">{unitPrice.toLocaleString()} ₪</div>
                        <div className={`col-span-2 text-right font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                          {(participants * unitPrice).toLocaleString()} ₪
                        </div>
                      </div>

                      {/* Ligne Salle si EVENT */}
                      {roomPrice && roomPrice > 0 && (
                        <div className={`grid grid-cols-12 gap-2 px-4 py-3 ${
                          isDark ? 'text-gray-300' : 'text-gray-700'
                        }`}>
                          <div className="col-span-6">
                            <span className="font-medium">{t('admin.accounting.room')}</span>
                            {roomName && (
                              <span className={`block text-xs mt-0.5 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                                {roomName}
                              </span>
                            )}
                          </div>
                          <div className="col-span-2 text-center">1</div>
                          <div className="col-span-2 text-right">{roomPrice.toLocaleString()} ₪</div>
                          <div className={`col-span-2 text-right font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                            {roomPrice.toLocaleString()} ₪
                          </div>
                        </div>
                      )}
                    </div>

                    {/* Footer - Totaux */}
                    <div className={`px-4 py-3 space-y-2 ${isDark ? 'bg-gray-700/30' : 'bg-gray-50'}`}>
                      {/* Sous-total si remise */}
                      {priceCalculation.discountAmount > 0 && (
                        <>
                          <div className="flex justify-between text-sm">
                            <span className={isDark ? 'text-gray-400' : 'text-gray-500'}>
                              {t('admin.accounting.subtotal')}
                            </span>
                            <span className={isDark ? 'text-gray-300' : 'text-gray-600'}>
                              {priceCalculation.subtotal.toLocaleString()} ₪
                            </span>
                          </div>
                          <div className="flex justify-between text-sm text-green-500">
                            <span>
                              {t('admin.accounting.discount')}
                              {priceCalculation.details?.discountType === 'percent' && priceCalculation.details?.discountValue && (
                                <span className="ml-1">({priceCalculation.details.discountValue}%)</span>
                              )}
                            </span>
                            <span>-{priceCalculation.discountAmount.toLocaleString()} ₪</span>
                          </div>
                        </>
                      )}

                      {/* Total final */}
                      <div className={`flex justify-between items-center pt-2 ${
                        priceCalculation.discountAmount > 0 ? `border-t ${isDark ? 'border-gray-600' : 'border-gray-200'}` : ''
                      }`}>
                        <span className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                          {t('admin.common.total')}
                        </span>
                        <span className={`text-2xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                          {priceCalculation.total.toLocaleString()} ₪
                        </span>
                      </div>
                    </div>
                  </div>
                ) : (
                  <div className={`p-6 rounded-xl border text-center ${
                    isDark ? 'bg-gray-700/30 border-gray-600 text-gray-400' : 'bg-gray-50 border-gray-200 text-gray-500'
                  }`}>
                    {t('admin.accounting.no_price_data')}
                  </div>
                )}
              </div>
            </div>

            {/* COLONNE DROITE - Statut & Actions */}
            <div className={`p-6 space-y-6 ${isDark ? 'bg-gray-800' : 'bg-white'}`}>

              {/* Statut de paiement - Card principale */}
              <div className={`p-4 rounded-xl border-2 ${statusConfig.bgColor} ${statusConfig.borderColor}`}>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <div className={`p-2 rounded-lg ${isDark ? 'bg-gray-800/50' : 'bg-white/80'}`}>
                      <StatusIcon className={`w-6 h-6 ${statusConfig.color}`} />
                    </div>
                    <div>
                      <p className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                        {t('admin.accounting.payment_status')}
                      </p>
                      <p className={`text-lg font-semibold ${statusConfig.color}`}>
                        {statusConfig.label}
                      </p>
                    </div>
                  </div>
                  {/* Bouton Ajouter paiement */}
                  {paymentStatus !== 'paid' && priceCalculation?.valid && (
                    <button
                      onClick={() => setShowPaymentModal(true)}
                      className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-medium transition-colors ${
                        isDark
                          ? 'bg-green-600 hover:bg-green-700 text-white'
                          : 'bg-green-600 hover:bg-green-700 text-white'
                      }`}
                    >
                      <Plus className="w-4 h-4" />
                      {t('admin.payment.add_payment')}
                    </button>
                  )}
                </div>

                {/* Montant payé / restant */}
                {priceCalculation?.valid && (
                  <div className={`mt-4 pt-4 border-t space-y-2 ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
                    {totalPaid > 0 && (
                      <div className="flex justify-between items-center">
                        <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                          {t('admin.payment.already_paid')}
                        </span>
                        <span className="text-green-500 font-medium">
                          {totalPaid.toLocaleString()} ₪
                        </span>
                      </div>
                    )}
                    <div className="flex justify-between items-center">
                      <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                        {t('admin.accounting.amount_due')}
                      </span>
                      <span className={`text-xl font-bold ${
                        paymentStatus === 'paid' ? 'text-green-500' : isDark ? 'text-white' : 'text-gray-900'
                      }`}>
                        {Math.max(0, priceCalculation.total - totalPaid).toLocaleString()} ₪
                      </span>
                    </div>
                  </div>
                )}

                {/* Indicateur de pré-autorisation existante */}
                {Boolean((order as unknown as Record<string, unknown>).preauth_code) && (
                  <div className={`mt-4 p-4 rounded-xl border ${
                    isDark ? 'border-blue-500/30 bg-blue-500/10' : 'border-blue-200 bg-blue-50'
                  }`}>
                    <div className="flex items-center gap-3">
                      <div className={`p-2 rounded-lg ${isDark ? 'bg-blue-500/20' : 'bg-blue-100'}`}>
                        <ShieldCheck className={`w-5 h-5 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
                      </div>
                      <div className="flex-1">
                        <p className={`font-medium ${isDark ? 'text-blue-300' : 'text-blue-700'}`}>
                          {t('admin.payment.preauth_info_title')}
                        </p>
                        <div className="flex items-center gap-4 mt-1">
                          <span className={`text-sm ${isDark ? 'text-blue-400/70' : 'text-blue-600/70'}`}>
                            {((order as unknown as Record<string, unknown>).preauth_amount as number)?.toLocaleString()} ₪
                          </span>
                          <span className={`text-xs font-mono ${isDark ? 'text-blue-400/50' : 'text-blue-600/50'}`}>
                            •••• {(order as unknown as Record<string, unknown>).preauth_cc_last4 as string}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>

              {/* Historique des paiements */}
              {payments.length > 0 && (
                <div>
                  <h3 className={`text-sm font-medium mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.payment.title')}
                  </h3>
                  <div className="space-y-2">
                    {payments.map((payment) => (
                      <div
                        key={payment.id}
                        className={`flex items-center gap-3 p-3 rounded-xl border ${
                          isDark ? 'bg-gray-700/50 border-gray-600' : 'bg-gray-50 border-gray-200'
                        }`}
                      >
                        <div className={`p-2 rounded-lg ${
                          payment.payment_method === 'card'
                            ? isDark ? 'bg-blue-500/20' : 'bg-blue-100'
                            : payment.payment_method === 'cash'
                              ? isDark ? 'bg-green-500/20' : 'bg-green-100'
                              : isDark ? 'bg-gray-600' : 'bg-gray-200'
                        }`}>
                          {payment.payment_method === 'card' ? (
                            <CreditCard className={`w-4 h-4 ${isDark ? 'text-blue-400' : 'text-blue-600'}`} />
                          ) : payment.payment_method === 'cash' ? (
                            <Banknote className={`w-4 h-4 ${isDark ? 'text-green-400' : 'text-green-600'}`} />
                          ) : (
                            <Receipt className={`w-4 h-4 ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
                          )}
                        </div>
                        <div className="flex-1 min-w-0">
                          <div className="flex items-center justify-between">
                            <p className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                              {payment.amount.toLocaleString()} ₪
                            </p>
                            {payment.status === 'completed' && (
                              <CheckCircle className="w-4 h-4 text-green-500" />
                            )}
                          </div>
                          <p className={`text-xs ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                            {new Date(payment.created_at).toLocaleDateString(getDateLocale(), {
                              day: 'numeric',
                              month: 'short',
                              hour: '2-digit',
                              minute: '2-digit'
                            })}
                            {payment.cc_last4 && (
                              <span className="ml-2 font-mono">•••• {payment.cc_last4}</span>
                            )}
                          </p>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Indicateur de commande clôturée */}
              {(order as unknown as Record<string, unknown>).status === 'closed' && (
                <div className={`p-4 rounded-xl border-2 ${
                  isDark ? 'bg-purple-500/10 border-purple-500/30' : 'bg-purple-50 border-purple-200'
                }`}>
                  <div className="flex items-center gap-3">
                    <div className={`p-2 rounded-lg ${isDark ? 'bg-purple-500/20' : 'bg-purple-100'}`}>
                      <CheckCheck className={`w-5 h-5 ${isDark ? 'text-purple-400' : 'text-purple-600'}`} />
                    </div>
                    <div>
                      <p className={`font-semibold ${isDark ? 'text-purple-300' : 'text-purple-700'}`}>
                        {t('admin.orders.status.closed')}
                      </p>
                      <p className={`text-xs ${isDark ? 'text-purple-400/70' : 'text-purple-600/70'}`}>
                        {(order as unknown as Record<string, unknown>).closed_at
                          ? new Date((order as unknown as Record<string, unknown>).closed_at as string).toLocaleDateString(getDateLocale(), {
                              day: 'numeric',
                              month: 'short',
                              year: 'numeric',
                              hour: '2-digit',
                              minute: '2-digit'
                            })
                          : ''}
                      </p>
                    </div>
                  </div>
                </div>
              )}

              {/* Documents iCount */}
              <div>
                <h3 className={`text-sm font-medium mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.accounting.documents')}
                </h3>

                <div className="space-y-2">
                  {/* Facture+Reçu iCount - depuis l'order */}
                  {(order as unknown as Record<string, unknown>).icount_invrec_id ? (
                    (order as unknown as Record<string, unknown>).icount_invrec_url ? (
                      <a
                        href={(order as unknown as Record<string, unknown>).icount_invrec_url as string}
                        target="_blank"
                        rel="noopener noreferrer"
                        className={`flex items-center gap-3 p-3 rounded-xl border transition-all ${
                          isDark
                            ? 'bg-green-500/10 border-green-500/20 hover:bg-green-500/20'
                            : 'bg-green-50 border-green-200 hover:bg-green-100'
                        }`}
                      >
                        <div className={`p-2 rounded-lg ${isDark ? 'bg-green-500/20' : 'bg-green-100'}`}>
                          <Receipt className={`w-4 h-4 ${isDark ? 'text-green-400' : 'text-green-600'}`} />
                        </div>
                        <div className="flex-1">
                          <p className={`font-medium ${isDark ? 'text-green-400' : 'text-green-700'}`}>
                            {t('admin.accounting.invoice')}
                          </p>
                          <p className={`text-xs font-mono ${isDark ? 'text-green-500/70' : 'text-green-600/70'}`}>
                            #{String((order as unknown as Record<string, unknown>).icount_invrec_id)}
                          </p>
                        </div>
                        <ExternalLink className={`w-4 h-4 ${isDark ? 'text-green-400' : 'text-green-600'}`} />
                      </a>
                    ) : (
                      <div className={`flex items-center gap-3 p-3 rounded-xl border ${
                        isDark ? 'bg-green-500/10 border-green-500/20' : 'bg-green-50 border-green-200'
                      }`}>
                        <div className={`p-2 rounded-lg ${isDark ? 'bg-green-500/20' : 'bg-green-100'}`}>
                          <Receipt className={`w-4 h-4 ${isDark ? 'text-green-400' : 'text-green-600'}`} />
                        </div>
                        <div className="flex-1">
                          <p className={`font-medium ${isDark ? 'text-green-400' : 'text-green-700'}`}>
                            {t('admin.accounting.invoice')}
                          </p>
                          <p className={`text-xs font-mono ${isDark ? 'text-green-500/70' : 'text-green-600/70'}`}>
                            #{String((order as unknown as Record<string, unknown>).icount_invrec_id)}
                          </p>
                        </div>
                        <CheckCircle className={`w-5 h-5 ${isDark ? 'text-green-400' : 'text-green-600'}`} />
                      </div>
                    )
                  ) : (
                    <div className={`flex items-center gap-3 p-3 rounded-xl border ${
                      isDark ? 'bg-gray-700/30 border-gray-700 text-gray-500' : 'bg-gray-50 border-gray-200 text-gray-400'
                    }`}>
                      <div className={`p-2 rounded-lg ${isDark ? 'bg-gray-700' : 'bg-gray-200'}`}>
                        <Receipt className="w-4 h-4" />
                      </div>
                      <div className="flex-1">
                        <p className="font-medium">{t('admin.accounting.invoice')}</p>
                        <p className="text-xs">{t('admin.accounting.not_generated')}</p>
                      </div>
                    </div>
                  )}
                </div>
              </div>

              {/* Section Actions rapides - Placeholder pour le futur */}
              {/*
              <div>
                <h3 className={`text-sm font-medium mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  Actions rapides
                </h3>
                <div className="grid grid-cols-2 gap-2">
                  <button className="...">Envoyer rappel</button>
                  <button className="...">Marquer payé</button>
                  <button className="...">Générer facture</button>
                  <button className="...">Ajouter paiement</button>
                </div>
              </div>
              */}

              {/* Section Historique - Placeholder pour le futur */}
              {/*
              <div>
                <h3 className={`text-sm font-medium mb-3 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  Historique
                </h3>
                <div className="space-y-2">
                  Timeline des événements: création, envoi devis, paiement, etc.
                </div>
              </div>
              */}

            </div>
          </div>
        </div>

        {/* Footer */}
        <div className={`px-6 py-4 border-t flex justify-between ${
          isDark ? 'border-gray-700 bg-gray-800/50' : 'border-gray-200 bg-gray-50'
        }`}>
          {/* Boutons à gauche */}
          <div className="flex items-center gap-2">
            {/* Bouton Clôturer - visible uniquement si commande non fermée */}
            {onCloseOrder && order?.status !== 'closed' && order?.status !== 'cancelled' && (
              <button
                onClick={() => {
                  onClose()
                  onCloseOrder(orderId)
                }}
                className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 ${
                  isDark
                    ? 'bg-green-600 hover:bg-green-700 text-white'
                    : 'bg-green-500 hover:bg-green-600 text-white'
                }`}
              >
                <CheckCheck className="w-4 h-4" />
                {t('admin.orders.close_order')}
              </button>
            )}
            {/* Bouton Envoyer facture - visible uniquement si commande fermée avec facture */}
            {order?.status === 'closed' && Boolean((order as unknown as Record<string, unknown>).icount_invrec_url) && (
              <button
                onClick={handleSendInvoice}
                disabled={sendingInvoice}
                className={`px-4 py-2 rounded-lg transition-colors flex items-center gap-2 ${
                  sendingInvoice
                    ? 'bg-gray-400 cursor-not-allowed text-white'
                    : isDark
                      ? 'bg-blue-600 hover:bg-blue-700 text-white'
                      : 'bg-blue-500 hover:bg-blue-600 text-white'
                }`}
              >
                {sendingInvoice ? (
                  <Loader2 className="w-4 h-4 animate-spin" />
                ) : (
                  <Send className="w-4 h-4" />
                )}
                {t('admin.invoice.send_invoice')}
              </button>
            )}
          </div>
          {/* Bouton Fermer - à droite */}
          <button
            onClick={onClose}
            className={`px-6 py-2 rounded-lg transition-colors ${
              isDark
                ? 'bg-gray-700 hover:bg-gray-600 text-white'
                : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
            }`}
          >
            {t('admin.common.close')}
          </button>
        </div>
      </div>

      {/* PaymentModal */}
      {showPaymentModal && priceCalculation?.valid && (
        <PaymentModal
          isOpen={showPaymentModal}
          onClose={() => {
            setShowPaymentModal(false)
            loadOrder() // Recharger les données après fermeture du modal
          }}
          onSubmit={handlePaymentSubmit}
          orderId={orderId}
          orderRef={order.request_reference || booking?.reference_code || ''}
          totalAmount={priceCalculation.total}
          paidAmount={totalPaid}
          isDark={isDark}
          existingPreauth={
            (order as unknown as Record<string, unknown>).preauth_code
              ? {
                  code: (order as unknown as Record<string, unknown>).preauth_code as string,
                  amount: ((order as unknown as Record<string, unknown>).preauth_amount as number) || 0,
                  ccLast4: ((order as unknown as Record<string, unknown>).preauth_cc_last4 as string) || '',
                }
              : null
          }
          storedCard={
            (order.contact as unknown as Record<string, unknown>)?.icount_cc_token_id
              ? {
                  tokenId: (order.contact as unknown as Record<string, unknown>).icount_cc_token_id as number,
                  last4: ((order.contact as unknown as Record<string, unknown>).cc_last4 as string) || '',
                  type: ((order.contact as unknown as Record<string, unknown>).cc_type as string) || 'card',
                }
              : null
          }
        />
      )}

      {/* Notification Modal */}
      <ConfirmationModal
        isOpen={notification.isOpen}
        onClose={() => setNotification(prev => ({ ...prev, isOpen: false }))}
        onConfirm={() => setNotification(prev => ({ ...prev, isOpen: false }))}
        title={notification.title}
        message={notification.message}
        type={notification.type}
        isDark={isDark}
      />
    </div>
  )
}
</file>

<file path="src/app/api/bookings/route.ts">
/**
 * API Route pour créer une réservation depuis l'admin
 * POST: Crée un booking avec slots, sessions, order, contact et envoie l'email
 *
 * Cette API centralise TOUTE la logique de création pour garantir:
 * - Les logs d'activité (booking, contact, order)
 * - L'envoi d'email avec log
 * - La cohérence des données
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { verifyApiPermission } from '@/lib/permissions'
import { validateBookingPrice } from '@/lib/booking-validation'
import { logBookingAction, logContactAction, logOrderAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { sendBookingConfirmationEmail } from '@/lib/email-sender'
import { calculateBookingPrice } from '@/lib/price-calculator'
import type { ICountProduct, ICountEventFormula, ICountRoom } from '@/hooks/usePricingData'
// iCount offers removed - invoice+receipt created only at order close
import type {
  UserRole,
  Booking,
  Branch,
  BookingType,
  BookingStatus,
} from '@/lib/supabase/types'

// Client Supabase avec service role pour bypass RLS
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

// Générer un code de référence unique
function generateReferenceCode(): string {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'
  let code = ''
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return code
}

// Générer un token CGV sécurisé (64 caractères hex)
function generateCgvToken(): string {
  const chars = 'abcdef0123456789'
  let token = ''
  for (let i = 0; i < 64; i++) {
    token += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return token
}

// Calculer la game_area basée sur les sessions (MIX si mélange ACTIVE+LASER)
function calculateGameArea(sessions?: Array<{ game_area: string }>): string | null {
  if (!sessions || sessions.length === 0) return null

  const areas = sessions.map(s => s.game_area)
  const uniqueAreas = [...new Set(areas)]

  if (uniqueAreas.length === 1) {
    return uniqueAreas[0]
  } else if (uniqueAreas.includes('ACTIVE') && uniqueAreas.includes('LASER')) {
    return 'MIX'
  }
  return sessions[0].game_area
}

interface CreateBookingBody {
  branch_id: string
  type: BookingType
  start_datetime: string
  end_datetime: string
  game_start_datetime?: string
  game_end_datetime?: string
  participants_count: number
  event_room_id?: string
  customer_first_name: string
  customer_last_name: string
  customer_phone: string
  customer_email?: string
  customer_notes_at_booking?: string
  primary_contact_id?: string
  notes?: string
  color?: string
  discount_type?: 'percent' | 'fixed' | null
  discount_value?: number | null
  reactivateReference?: string
  reactivateOrderId?: string
  slots: Array<{
    slot_start: string
    slot_end: string
    participants_count: number
  }>
  game_sessions?: Array<{
    game_area: 'ACTIVE' | 'LASER'
    start_datetime: string
    end_datetime: string
    laser_room_id?: string | null
    session_order: number
    pause_before_minutes: number
  }>
  locale?: string
}

/**
 * POST /api/bookings
 * Crée une réservation complète depuis l'admin
 */
export async function POST(request: NextRequest) {
  try {
    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('agenda', 'create')
    if (!success || !user) {
      return errorResponse
    }

    const body: CreateBookingBody = await request.json()
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Validation basique
    if (!body.branch_id || !body.type || !body.start_datetime || !body.end_datetime) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(body.branch_id)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied' },
        { status: 403 }
      )
    }

    // === VALIDATION PRIX OBLIGATOIRE ===
    // Vérifier qu'une formule/produit existe AVANT de créer le booking
    if (body.game_sessions && body.game_sessions.length > 0) {
      const priceValidation = await validateBookingPrice(
        supabase,
        body.type,
        body.branch_id,
        body.participants_count,
        body.game_sessions.map(s => ({
          game_area: s.game_area,
          start_datetime: s.start_datetime,
          end_datetime: s.end_datetime
        }))
      )

      if (!priceValidation.valid) {
        console.error('[BOOKINGS API] Price validation failed:', priceValidation.error)
        return NextResponse.json({
          success: false,
          error: priceValidation.error,
          errorKey: priceValidation.errorKey
        }, { status: 400 })
      }
      console.log('[BOOKINGS API] Price validation passed')
    }
    // === FIN VALIDATION PRIX ===

    // 1. CRÉER OU TROUVER LE CONTACT
    let contactId = body.primary_contact_id
    let contactWasCreated = false

    if (!contactId && body.customer_phone) {
      // Chercher un contact existant par téléphone
      const { data: existingContact } = await supabase
        .from('contacts')
        .select('id')
        .eq('branch_id_main', body.branch_id)
        .eq('phone', body.customer_phone)
        .single() as { data: { id: string } | null }

      if (existingContact) {
        contactId = existingContact.id
      } else {
        // Créer un nouveau contact
        const { data: newContact, error: contactError } = await supabase
          .from('contacts')
          .insert({
            branch_id_main: body.branch_id,
            first_name: body.customer_first_name,
            last_name: body.customer_last_name || '',
            phone: body.customer_phone,
            email: body.customer_email || null,
            notes_client: body.customer_notes_at_booking || null,
            source: 'admin'
          })
          .select('id')
          .single() as { data: { id: string } | null; error: unknown }

        if (!contactError && newContact) {
          contactId = newContact.id
          contactWasCreated = true

          // LOG: Contact créé
          await logContactAction({
            userId: user.id,
            userRole: user.role as UserRole,
            userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
            action: 'created',
            contactId: newContact.id,
            contactName: `${body.customer_first_name} ${body.customer_last_name || ''}`.trim(),
            branchId: body.branch_id,
            details: {
              source: 'admin',
              phone: body.customer_phone,
              email: body.customer_email
            },
            ipAddress
          })
        }
      }
    }

    // 2. CRÉER LE BOOKING
    const referenceCode = body.reactivateReference || generateReferenceCode()

    const bookingData: Record<string, unknown> = {
      branch_id: body.branch_id,
      type: body.type,
      status: 'CONFIRMED' as BookingStatus,
      start_datetime: body.start_datetime,
      end_datetime: body.end_datetime,
      game_start_datetime: body.game_start_datetime,
      game_end_datetime: body.game_end_datetime,
      participants_count: body.participants_count,
      event_room_id: body.event_room_id || null,
      customer_first_name: body.customer_first_name,
      customer_last_name: body.customer_last_name || '',
      customer_phone: body.customer_phone,
      customer_email: body.customer_email || null,
      customer_notes_at_booking: body.customer_notes_at_booking || null,
      primary_contact_id: contactId || null,
      reference_code: referenceCode,
      notes: body.notes || null,
    }

    if (body.color) {
      bookingData.color = body.color
    }

    if (body.discount_type) {
      bookingData.discount_type = body.discount_type
      bookingData.discount_value = body.discount_value || 0
    }

    const { data: newBooking, error: bookingError } = await supabase
      .from('bookings')
      .insert(bookingData)
      .select()
      .single<Booking>()

    if (bookingError || !newBooking) {
      console.error('Booking insert error:', bookingError)
      return NextResponse.json(
        { success: false, error: 'Failed to create booking', details: bookingError?.message },
        { status: 500 }
      )
    }

    // LOG: Booking créé
    await logBookingAction({
      userId: user.id,
      userRole: user.role as UserRole,
      userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
      action: 'created',
      bookingId: newBooking.id,
      bookingRef: referenceCode,
      branchId: body.branch_id,
      details: {
        source: 'admin',
        type: body.type,
        participants: body.participants_count,
        customerName: `${body.customer_first_name} ${body.customer_last_name || ''}`.trim(),
        contactCreated: contactWasCreated
      },
      ipAddress
    })

    // 3. CRÉER LA LIAISON BOOKING_CONTACTS
    if (contactId) {
      await supabase
        .from('booking_contacts')
        .insert({
          booking_id: newBooking.id,
          contact_id: contactId,
          is_primary: true,
          role: null,
        })
    }

    // 4. CRÉER LES SLOTS
    if (body.slots && body.slots.length > 0) {
      const slotsToInsert = body.slots.map(slot => ({
        booking_id: newBooking.id,
        branch_id: body.branch_id,
        slot_start: slot.slot_start,
        slot_end: slot.slot_end,
        participants_count: slot.participants_count,
        slot_type: 'game_zone',
      }))

      const { error: slotsError } = await supabase
        .from('booking_slots')
        .insert(slotsToInsert)

      if (slotsError) {
        console.error('Slots insert error:', slotsError)
      }
    }

    // 5. CRÉER LES GAME_SESSIONS
    if (body.game_sessions && body.game_sessions.length > 0) {
      const sessionsToInsert = body.game_sessions.map(session => ({
        booking_id: newBooking.id,
        game_area: session.game_area,
        start_datetime: session.start_datetime,
        end_datetime: session.end_datetime,
        laser_room_id: session.laser_room_id || null,
        session_order: session.session_order,
        pause_before_minutes: session.pause_before_minutes,
      }))

      const { error: sessionsError } = await supabase
        .from('game_sessions')
        .insert(sessionsToInsert)

      if (sessionsError) {
        console.error('Sessions insert error:', sessionsError)
      }
    }

    // 6. CRÉER L'ORDER
    const bookingDate = new Date(body.start_datetime)
    let orderId: string | null = null
    let orderCgvToken: string | null = null

    // Récupérer les données de pricing pour calculer le total_amount
    const [productsResult, formulasResult, roomsResult] = await Promise.all([
      supabase.from('icount_products').select('*').eq('branch_id', body.branch_id).eq('is_active', true),
      supabase.from('icount_event_formulas').select('*').eq('branch_id', body.branch_id).eq('is_active', true),
      supabase.from('icount_rooms').select('*').eq('branch_id', body.branch_id).eq('is_active', true)
    ])

    const products = (productsResult.data || []) as ICountProduct[]
    const eventFormulas = (formulasResult.data || []) as ICountEventFormula[]
    const rooms = (roomsResult.data || []) as ICountRoom[]

    // Calculer le total_amount
    let totalAmount: number | null = null
    const gameArea = calculateGameArea(body.game_sessions) as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null

    if (body.participants_count >= 1 && products.length > 0) {
      // Calculer les paramètres de jeu depuis les sessions
      let laserGames = 0
      let activeDurations: string[] = []
      let customGameAreas: ('ACTIVE' | 'LASER')[] = []
      let customGameDurations: string[] = []

      if (body.game_sessions && body.game_sessions.length > 0) {
        for (const session of body.game_sessions) {
          const startTime = new Date(session.start_datetime)
          const endTime = new Date(session.end_datetime)
          const durationMinutes = Math.round((endTime.getTime() - startTime.getTime()) / 60000)

          if (session.game_area === 'LASER') {
            laserGames++
          } else if (session.game_area === 'ACTIVE') {
            activeDurations.push(String(durationMinutes))
          }

          // Pour CUSTOM/MIX
          customGameAreas.push(session.game_area)
          customGameDurations.push(String(durationMinutes))
        }
      }

      // Déterminer le quick plan pour les événements
      let eventQuickPlan = 'AA'
      if (body.type === 'EVENT') {
        if (gameArea === 'LASER') eventQuickPlan = 'LL'
        else if (gameArea === 'ACTIVE') eventQuickPlan = 'AA'
        else eventQuickPlan = 'AL'
      }

      const priceCalculation = calculateBookingPrice({
        bookingType: body.type as 'GAME' | 'EVENT',
        participants: body.participants_count,
        gameArea: gameArea || 'ACTIVE',
        numberOfGames: laserGames || body.game_sessions?.length || 1,
        gameDurations: activeDurations.length > 0 ? activeDurations : ['60'],
        customGameAreas: gameArea === 'MIX' || gameArea === 'CUSTOM' ? customGameAreas : undefined,
        customGameDurations: gameArea === 'MIX' || gameArea === 'CUSTOM' ? customGameDurations : undefined,
        eventQuickPlan,
        eventRoomId: body.event_room_id || null,
        discountType: body.discount_type,
        discountValue: body.discount_value ?? undefined,
        products,
        eventFormulas,
        rooms,
      })

      if (priceCalculation.valid) {
        totalAmount = priceCalculation.total
      }
    }

    if (body.reactivateOrderId) {
      // Réactivation: mettre à jour l'order existant
      const { data: updatedOrder } = await supabase
        .from('orders')
        .update({
          booking_id: newBooking.id,
          status: 'manually_confirmed',
          requested_date: bookingDate.toISOString().split('T')[0],
          requested_time: bookingDate.toTimeString().slice(0, 5),
          participants_count: body.participants_count,
          customer_first_name: body.customer_first_name || 'Client',
          customer_last_name: body.customer_last_name || '',
          customer_phone: body.customer_phone || '0000000000',
          customer_email: body.customer_email || null,
          game_area: calculateGameArea(body.game_sessions),
          number_of_games: body.game_sessions?.length || 1,
          processed_at: new Date().toISOString(),
          total_amount: totalAmount,
        })
        .eq('id', body.reactivateOrderId)
        .select('id')
        .single()

      orderId = updatedOrder?.id || body.reactivateOrderId
    } else {
      // Nouvelle création - générer un token CGV pour que le client puisse valider
      const cgvToken = generateCgvToken()

      const { data: newOrder, error: orderError } = await supabase
        .from('orders')
        .insert({
          branch_id: body.branch_id,
          booking_id: newBooking.id,
          contact_id: contactId || null,
          source: 'admin_agenda',
          status: 'auto_confirmed',
          order_type: body.type,
          game_area: calculateGameArea(body.game_sessions),
          number_of_games: body.game_sessions?.length || 1,
          requested_date: bookingDate.toISOString().split('T')[0],
          requested_time: bookingDate.toTimeString().slice(0, 5),
          participants_count: body.participants_count,
          customer_first_name: body.customer_first_name || 'Client',
          customer_last_name: body.customer_last_name || '',
          customer_phone: body.customer_phone || '0000000000',
          customer_email: body.customer_email || null,
          customer_notes: body.customer_notes_at_booking || null,
          request_reference: referenceCode,
          total_amount: totalAmount,
          // CGV non acceptées - le client doit valider via le lien email
          terms_accepted: false,
          terms_accepted_at: null,
          cgv_token: cgvToken,
          cgv_validated_at: null,
        })
        .select('id, cgv_token')
        .single()

      if (!orderError && newOrder) {
        orderId = newOrder.id
        orderCgvToken = newOrder.cgv_token

        // LOG: Order créé
        await logOrderAction({
          userId: user.id,
          userRole: user.role as UserRole,
          userName: `${user.profile.first_name} ${user.profile.last_name}`.trim(),
          action: 'created',
          orderId: newOrder.id,
          orderRef: referenceCode,
          branchId: body.branch_id,
          details: {
            source: 'admin_agenda',
            status: 'auto_confirmed',
            type: body.type,
            participants: body.participants_count
          },
          ipAddress
        })
      }
    }

    // Récupérer les slots et sessions créés pour la réponse
    const { data: slots } = await supabase
      .from('booking_slots')
      .select('*')
      .eq('booking_id', newBooking.id)

    const { data: sessions } = await supabase
      .from('game_sessions')
      .select('*')
      .eq('booking_id', newBooking.id)

    // iCount offer creation removed - invoice+receipt created at order close

    // Envoyer l'email de confirmation
    let emailSent = false
    let emailLogId: string | undefined

    if (body.customer_email) {
      // Récupérer la branche pour l'email
      const { data: branch } = await supabase
        .from('branches')
        .select('*')
        .eq('id', body.branch_id)
        .single<Branch>()

      if (branch) {
        try {
          const emailResult = await sendBookingConfirmationEmail({
            booking: newBooking,
            branch,
            triggeredBy: user.id,
            locale: body.locale || 'he',
            cgvToken: orderCgvToken // Lien de validation CGV pour les orders admin
          })

          emailSent = emailResult.success
          emailLogId = emailResult.emailLogId

          if (!emailResult.success) {
            console.error('Email send failed:', emailResult.error)
          }
        } catch (emailErr) {
          console.error('Email send exception:', emailErr)
        }
      }
    }

    return NextResponse.json({
      success: true,
      booking: {
        ...newBooking,
        slots: slots || [],
        game_sessions: sessions || [],
      },
      orderId,
      contactId,
      contactCreated: contactWasCreated,
      emailSent,
      emailLogId,
    })

  } catch (error) {
    console.error('Error in POST /api/bookings:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', details: String(error) },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/cgv/[token]/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { calculateBookingPrice, type PriceCalculationResult } from '@/lib/price-calculator'
import type { Database } from '@/lib/supabase/types'
import type { ICountProduct, ICountEventFormula, ICountRoom } from '@/hooks/usePricingData'

type OrderRow = Database['public']['Tables']['orders']['Row']
type BranchRow = Database['public']['Tables']['branches']['Row']

// GET: Récupérer les infos de la commande pour affichage
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ token: string }> }
) {
  try {
    const { token } = await params
    const supabase = createServiceRoleClient()

    // Récupérer la commande par token
    // D'abord on récupère l'order sans la jointure booking
    const { data: orderData, error } = await supabase
      .from('orders')
      .select(`
        id,
        request_reference,
        customer_first_name,
        customer_last_name,
        requested_date,
        requested_time,
        participants_count,
        event_type,
        cgv_validated_at,
        branch_id,
        contact_id,
        order_type,
        booking_id,
        game_area,
        number_of_games
      `)
      .eq('cgv_token', token)
      .single()

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const order = orderData as any

    if (error || !order) {
      return NextResponse.json(
        { success: false, error: 'Lien invalide ou expiré' },
        { status: 404 }
      )
    }

    // Récupérer le nom de la branche
    let branchName = 'Laser City'
    if (order.branch_id) {
      const { data: branchData } = await supabase
        .from('branches')
        .select('name')
        .eq('id', order.branch_id)
        .single()
      const branch = branchData as Pick<BranchRow, 'name'> | null
      if (branch) branchName = branch.name
    }

    // Récupérer la langue préférée du contact
    let preferredLocale: 'he' | 'fr' | 'en' = 'he'
    if (order.contact_id) {
      const { data: contactData } = await supabase
        .from('contacts')
        .select('preferred_locale')
        .eq('id', order.contact_id)
        .single<{ preferred_locale: string | null }>()
      if (contactData?.preferred_locale) {
        preferredLocale = contactData.preferred_locale as 'he' | 'fr' | 'en'
      }
    }

    // Récupérer le booking si booking_id existe
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let booking: any = null
    if (order.booking_id) {
      const { data: bookingData } = await supabase
        .from('bookings')
        .select(`
          id,
          room_id,
          booking_slots(
            id,
            room_id,
            start_time,
            end_time,
            participants,
            games_count,
            formula_id,
            product_id,
            unit_price,
            total_price
          )
        `)
        .eq('id', order.booking_id)
        .single()
      booking = bookingData
    }

    // Fetch pricing data: icount_products, icount_event_formulas, icount_rooms
    // (même tables que usePricingData utilisé par AccountingModal)
    const [productsResult, formulasResult, roomsResult] = await Promise.all([
      supabase.from('icount_products').select('*').eq('branch_id', order.branch_id).eq('is_active', true),
      supabase.from('icount_event_formulas').select('*').eq('branch_id', order.branch_id).eq('is_active', true),
      supabase.from('icount_rooms').select('*').eq('branch_id', order.branch_id).eq('is_active', true)
    ])

    const products = (productsResult.data || []) as ICountProduct[]
    const eventFormulas = (formulasResult.data || []) as ICountEventFormula[]
    const rooms = (roomsResult.data || []) as ICountRoom[]

    console.log('[CGV API] Products count:', products.length)
    console.log('[CGV API] EventFormulas count:', eventFormulas.length)
    console.log('[CGV API] Rooms count:', rooms.length)
    console.log('[CGV API] Order type:', order.order_type)
    console.log('[CGV API] Participants:', order.participants_count)
    console.log('[CGV API] Game area:', order.game_area)

    // Calculer le prix avec la même logique que AccountingModal
    let priceCalculation: PriceCalculationResult | null = null
    const bookingType = order.order_type as 'GAME' | 'EVENT'
    const participants = order.participants_count || 0
    const gameArea = (order.game_area || 'ACTIVE') as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM'

    if (participants >= 1 && products.length > 0) {
      // Determine game parameters from booking slots or order data
      let laserGames = 0
      let activeDuration = 0

      const slots = booking?.booking_slots || []
      if (slots && Array.isArray(slots) && slots.length > 0) {
        slots.forEach((slot: { area?: string; duration_minutes?: number }) => {
          if (slot?.area === 'LASER') {
            laserGames++
          } else if (slot?.area === 'ACTIVE') {
            activeDuration += slot?.duration_minutes || 30
          }
        })
      }

      // Fallback to order fields if no slot data
      if (laserGames === 0 && activeDuration === 0) {
        if (gameArea === 'LASER' || gameArea === 'CUSTOM') {
          laserGames = (order as { laser_games_count?: number }).laser_games_count ||
                       order.number_of_games || 1
        }
        if (gameArea === 'ACTIVE' || gameArea === 'CUSTOM') {
          activeDuration = (order as { active_duration?: number }).active_duration || 60
        }
      }

      // Determine event quick plan
      let eventQuickPlan = 'AA'
      if (bookingType === 'EVENT') {
        if (gameArea === 'LASER') eventQuickPlan = 'LL'
        else if (gameArea === 'ACTIVE') eventQuickPlan = 'AA'
        else eventQuickPlan = 'AL'
      }

      priceCalculation = calculateBookingPrice({
        bookingType,
        gameArea,
        participants,
        numberOfGames: laserGames || order.number_of_games || 1,
        gameDurations: activeDuration > 0 ? [String(activeDuration)] : ['60'],
        eventQuickPlan,
        eventRoomId: booking?.room_id || null,
        products,
        eventFormulas,
        rooms,
      })
    }

    // Build price breakdown for display (same format as AccountingModal)
    const priceBreakdown: Array<{
      description: string
      label?: string
      quantity: number
      unitPrice: number
      totalPrice: number
    }> = []

    // Translations for price breakdown labels based on contact's preferred locale
    const priceLabels: Record<string, Record<string, string>> = {
      he: {
        laser: 'Laser City',
        active: 'Active Games',
        laser_active: 'Active + Laser',
        game: 'משחק',
        event: 'אירוע',
        room: 'חדר'
      },
      en: {
        laser: 'Laser City',
        active: 'Active Games',
        laser_active: 'Active + Laser',
        game: 'Game',
        event: 'Event',
        room: 'Room'
      },
      fr: {
        laser: 'Laser City',
        active: 'Active Games',
        laser_active: 'Active + Laser',
        game: 'Jeu',
        event: 'Événement',
        room: 'Salle'
      }
    }

    const getLabel = (key: string) => {
      return priceLabels[preferredLocale]?.[key] || priceLabels['en'][key] || key
    }

    // Determine the game type label based on gameArea
    const getGameTypeLabel = (): string => {
      if (gameArea === 'LASER') return getLabel('laser')
      if (gameArea === 'ACTIVE') return getLabel('active')
      if (gameArea === 'MIX' || gameArea === 'CUSTOM') return getLabel('laser_active')
      // Fallback based on booking type
      return bookingType === 'EVENT' ? getLabel('event') : getLabel('game')
    }

    if (priceCalculation?.valid) {
      // Main line - participants × price with actual game type
      const typeLabel = getGameTypeLabel()
      priceBreakdown.push({
        description: typeLabel,
        label: priceCalculation.details.unitLabel,
        quantity: participants,
        unitPrice: priceCalculation.details.unitPrice,
        totalPrice: participants * priceCalculation.details.unitPrice
      })

      // Room line if applicable
      if (priceCalculation.details.roomPrice && priceCalculation.details.roomPrice > 0) {
        priceBreakdown.push({
          description: getLabel('room'),
          label: priceCalculation.details.roomName,
          quantity: 1,
          unitPrice: priceCalculation.details.roomPrice,
          totalPrice: priceCalculation.details.roomPrice
        })
      }
    }

    const totalAmount = priceCalculation?.total || 0
    const subtotal = priceCalculation?.subtotal || 0
    const discountAmount = priceCalculation?.discountAmount || 0

    return NextResponse.json({
      success: true,
      order: {
        id: order.id,
        request_reference: order.request_reference,
        customer_first_name: order.customer_first_name,
        customer_last_name: order.customer_last_name,
        requested_date: order.requested_date,
        requested_time: order.requested_time,
        participants_count: order.participants_count,
        event_type: order.event_type,
        cgv_validated_at: order.cgv_validated_at,
        branch_name: branchName,
        booking_type: order.order_type === 'EVENT' ? 'event' : 'game',
        preferred_locale: preferredLocale,
        // Price breakdown data (same format as AccountingModal)
        priceBreakdown,
        subtotal,
        discountAmount,
        totalAmount,
      }
    })

  } catch (error) {
    console.error('[CGV] Error fetching order:', error)
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}

// POST: Valider les CGV
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ token: string }> }
) {
  try {
    const { token } = await params
    const body = await request.json()

    if (!body.accepted) {
      return NextResponse.json(
        { success: false, error: 'Vous devez accepter les CGV' },
        { status: 400 }
      )
    }

    const supabase = createServiceRoleClient()

    // Vérifier que la commande existe et n'est pas déjà validée
    const { data: orderData, error: fetchError } = await supabase
      .from('orders')
      .select('id, cgv_validated_at, request_reference, branch_id')
      .eq('cgv_token', token)
      .single()

    const order = orderData as Pick<OrderRow, 'id' | 'cgv_validated_at' | 'request_reference' | 'branch_id'> | null

    if (fetchError || !order) {
      return NextResponse.json(
        { success: false, error: 'Lien invalide ou expiré' },
        { status: 404 }
      )
    }

    if (order.cgv_validated_at) {
      return NextResponse.json({
        success: true,
        message: 'CGV déjà validées'
      })
    }

    // Mettre à jour la commande
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { error: updateError } = await (supabase as any)
      .from('orders')
      .update({
        cgv_validated_at: new Date().toISOString(),
        terms_accepted: true,
        terms_accepted_at: new Date().toISOString()
      })
      .eq('id', order.id)

    if (updateError) {
      console.error('[CGV] Error updating order:', updateError)
      return NextResponse.json(
        { success: false, error: 'Erreur lors de la validation' },
        { status: 500 }
      )
    }

    // Logger l'action
    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      await (supabase as any).from('activity_logs').insert({
        user_id: null,
        user_role: 'agent',
        user_name: 'Client',
        action_type: 'order_updated',
        target_type: 'order',
        target_id: order.id,
        target_name: order.request_reference,
        branch_id: order.branch_id,
        details: {
          action: 'cgv_accepted',
          validated_at: new Date().toISOString()
        }
      })
    } catch (logError) {
      console.error('[CGV] Error logging action:', logError)
    }

    return NextResponse.json({
      success: true,
      message: 'CGV validées avec succès'
    })

  } catch (error) {
    console.error('[CGV] Error validating CGV:', error)
    return NextResponse.json(
      { success: false, error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/orders/route.ts">
/**
 * API Orders - Version 2.1 (EVENTS REFACTORISÉS)
 *
 * PHILOSOPHIE:
 * - Déléguer TOUT à des fonctions partagées avec l'admin
 * - Pas de calculs séparés
 * - Aussi simple qu'un appel depuis l'admin
 *
 * Cette API est comme si l'utilisateur créait une réservation manuellement dans l'admin,
 * mais via l'interface du site public.
 *
 * VERSION 2.1: Gestion complète des EVENTS
 * - event_room_id allocation
 * - Séparation room timing vs game timing (15 min setup)
 * - game_sessions selon event_type (AA, LL, AL)
 */

import { NextRequest, NextResponse } from 'next/server'
import crypto from 'crypto'
import { createClient } from '@supabase/supabase-js'
import { createIsraelDateTime } from '@/lib/dates'
import { validateIsraeliPhone, formatIsraeliPhone } from '@/lib/validation'
import { validateBookingPrice } from '@/lib/booking-validation'
import { logOrderAction, logBookingAction, logContactAction, getClientIpFromHeaders } from '@/lib/activity-logger'
import { sendBookingConfirmationEmail } from '@/lib/email-sender'
import { syncContactToICountBackground } from '@/lib/icount-sync'
import { calculateBookingPrice } from '@/lib/price-calculator'
import type { ICountProduct, ICountEventFormula, ICountRoom } from '@/hooks/usePricingData'
// iCount offers removed - invoice+receipt created only at order close
import type { EventRoom, LaserRoom, UserRole, Booking, Branch, Contact } from '@/lib/supabase/types'

// Generate CGV token
function generateCgvToken(): string {
  return crypto.randomUUID()
}

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

// Générer une référence courte unique (6 caractères)
function generateShortReference(): string {
  return Math.random().toString(36).substring(2, 8).toUpperCase()
}

// Mapper event_type vers le plan de jeu (comme dans l'admin)
// event_active = Active + Active (AA)
// event_laser = Laser + Laser (LL)
// event_mix = Active + Laser (AL)
function getGameAreasForEventType(eventType: string | null): Array<'ACTIVE' | 'LASER'> {
  switch (eventType) {
    case 'event_active':
      return ['ACTIVE', 'ACTIVE'] // AA
    case 'event_laser':
      return ['LASER', 'LASER'] // LL
    case 'event_mix':
      return ['ACTIVE', 'LASER'] // AL
    default:
      return ['ACTIVE', 'ACTIVE'] // Défaut AA
  }
}

// Calculer le total_amount pour une commande
async function calculateOrderTotalAmount(params: {
  branchId: string
  orderType: 'GAME' | 'EVENT'
  participants: number
  gameArea: 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null
  numberOfGames: number
  gameSessions?: Array<{ game_area: string; start_datetime: string; end_datetime: string }>
  eventRoomId?: string | null
  eventType?: string | null
}): Promise<number | null> {
  const { branchId, orderType, participants, gameArea, numberOfGames, gameSessions, eventRoomId, eventType } = params

  // Récupérer les données de pricing
  const [productsResult, formulasResult, roomsResult] = await Promise.all([
    supabase.from('icount_products').select('*').eq('branch_id', branchId).eq('is_active', true),
    supabase.from('icount_event_formulas').select('*').eq('branch_id', branchId).eq('is_active', true),
    supabase.from('icount_rooms').select('*').eq('branch_id', branchId).eq('is_active', true)
  ])

  const products = (productsResult.data || []) as ICountProduct[]
  const eventFormulas = (formulasResult.data || []) as ICountEventFormula[]
  const rooms = (roomsResult.data || []) as ICountRoom[]

  if (participants < 1 || products.length === 0) {
    return null
  }

  // Calculer les paramètres de jeu depuis les sessions
  let laserGames = 0
  let activeDurations: string[] = []
  let customGameAreas: ('ACTIVE' | 'LASER')[] = []
  let customGameDurations: string[] = []

  if (gameSessions && gameSessions.length > 0) {
    for (const session of gameSessions) {
      const startTime = new Date(session.start_datetime)
      const endTime = new Date(session.end_datetime)
      const durationMinutes = Math.round((endTime.getTime() - startTime.getTime()) / 60000)

      if (session.game_area === 'LASER') {
        laserGames++
      } else if (session.game_area === 'ACTIVE') {
        activeDurations.push(String(durationMinutes))
      }

      customGameAreas.push(session.game_area as 'ACTIVE' | 'LASER')
      customGameDurations.push(String(durationMinutes))
    }
  }

  // Déterminer le quick plan pour les événements
  let eventQuickPlan = 'AA'
  if (orderType === 'EVENT') {
    if (eventType === 'event_laser' || gameArea === 'LASER') eventQuickPlan = 'LL'
    else if (eventType === 'event_active' || gameArea === 'ACTIVE') eventQuickPlan = 'AA'
    else eventQuickPlan = 'AL'
  }

  const priceCalculation = calculateBookingPrice({
    bookingType: orderType,
    participants,
    gameArea: gameArea || 'ACTIVE',
    numberOfGames: laserGames || numberOfGames || 1,
    gameDurations: activeDurations.length > 0 ? activeDurations : ['60'],
    customGameAreas: gameArea === 'MIX' || gameArea === 'CUSTOM' ? customGameAreas : undefined,
    customGameDurations: gameArea === 'MIX' || gameArea === 'CUSTOM' ? customGameDurations : undefined,
    eventQuickPlan,
    eventRoomId: eventRoomId || null,
    products,
    eventFormulas,
    rooms,
  })

  return priceCalculation.valid ? priceCalculation.total : null
}

// Trouver la meilleure salle d'événement disponible
// IDENTIQUE à findBestAvailableRoom dans admin/page.tsx
async function findBestEventRoom(
  branchId: string,
  participants: number,
  startDateTime: Date,
  endDateTime: Date
): Promise<string | null> {
  // Récupérer les event_rooms de la branche
  const { data: eventRooms } = await supabase
    .from('event_rooms')
    .select('*')
    .eq('branch_id', branchId)
    .eq('is_active', true)
    .order('sort_order')

  if (!eventRooms || eventRooms.length === 0) {
    return null
  }

  // Récupérer les bookings EVENT existants sur cette période
  const { data: existingBookings } = await supabase
    .from('bookings')
    .select('id, event_room_id, start_datetime, end_datetime')
    .eq('branch_id', branchId)
    .eq('type', 'EVENT')
    .neq('status', 'CANCELLED')

  // Trier les salles par capacité croissante (plus petite salle adaptée en premier)
  const sortedRooms = [...eventRooms]
    .filter(room => room.capacity >= participants)
    .sort((a, b) => {
      if (a.capacity !== b.capacity) {
        return a.capacity - b.capacity
      }
      return a.sort_order - b.sort_order
    })

  // Trouver la première salle disponible
  for (const room of sortedRooms) {
    let isAvailable = true

    for (const booking of (existingBookings || [])) {
      if (booking.event_room_id === room.id) {
        const bookingStart = new Date(booking.start_datetime)
        const bookingEnd = new Date(booking.end_datetime)

        // Vérifier le chevauchement
        if (
          (startDateTime >= bookingStart && startDateTime < bookingEnd) ||
          (endDateTime > bookingStart && endDateTime <= bookingEnd) ||
          (startDateTime <= bookingStart && endDateTime >= bookingEnd)
        ) {
          isAvailable = false
          break
        }
      }
    }

    if (isAvailable) {
      return room.id
    }
  }

  return null
}

// Trouver ou créer un contact
async function findOrCreateContact(
  branchId: string,
  firstName: string,
  lastName: string | null,
  phone: string,
  email: string | null,
  notes: string | null,
  ipAddress?: string,
  locale?: 'he' | 'fr' | 'en'
): Promise<{ contactId: string; wasCreated: boolean }> {

  console.log("[ORDER API] findOrCreateContact - phone:", phone, "branchId:", branchId, "locale:", locale)

  // Chercher un contact existant par téléphone
  const { data: existing } = await supabase
    .from('contacts')
    .select('id, preferred_locale')
    .eq('branch_id_main', branchId)
    .eq('phone', phone)
    .single()

  if (existing) {
    console.log("[ORDER API] Existing contact found:", existing.id)
    // Mettre à jour la langue préférée si fournie et différente
    if (locale && existing.preferred_locale !== locale) {
      await supabase
        .from('contacts')
        .update({ preferred_locale: locale })
        .eq('id', existing.id)
      console.log("[ORDER API] Updated contact preferred_locale to:", locale)
    }
    return { contactId: existing.id, wasCreated: false }
  }

  console.log("[ORDER API] Creating new contact...")

  // Créer un nouveau contact - récupérer toutes les données pour le sync iCount
  const { data: newContact, error } = await supabase
    .from('contacts')
    .insert({
      branch_id_main: branchId,
      first_name: firstName,
      last_name: lastName || '',
      phone,
      email: email || null,
      notes_client: notes || null,
      source: 'website',
      preferred_locale: locale || 'he'
    })
    .select('*')
    .single()

  if (error || !newContact) {
    throw new Error('Failed to create contact')
  }

  // Logger la création du contact
  const contactName = `${firstName} ${lastName || ''}`.trim()
  await logContactAction({
    userId: null,
    userRole: 'website' as UserRole,
    userName: 'Website',
    action: 'created',
    contactId: newContact.id,
    contactName,
    branchId,
    details: {
      source: 'website',
      phone,
      email
    },
    ipAddress
  })

  // Sync to iCount in background (non-blocking)
  console.log("[ORDER API] Syncing new contact to iCount...")
  syncContactToICountBackground(newContact as Contact, branchId)

  return { contactId: newContact.id, wasCreated: true }
}

/**
 * POST /api/orders
 * Créer une commande depuis le site public
 *
 * NOUVELLE ARCHITECTURE:
 * 1. Valider les données
 * 2. Trouver/créer le contact
 * 3. Utiliser session-builder (même logique que admin)
 * 4. Créer booking + sessions
 * 5. Créer l'order
 */
export async function POST(request: NextRequest) {
  console.log('[ORDER API] POST called')
  try {
    const body = await request.json()
    console.log('[ORDER API] Body received:', { order_type: body.order_type, customer_email: body.customer_email })

    // Validation
    const requiredFields = [
      'branch_id', 'order_type', 'requested_date', 'requested_time',
      'participants_count', 'customer_first_name', 'customer_phone', 'terms_accepted'
    ]

    const missingFields = requiredFields.filter(field => !body[field])
    if (missingFields.length > 0) {
      return NextResponse.json(
        { success: false, error: `Missing required fields: ${missingFields.join(', ')}` },
        { status: 400 }
      )
    }

    if (!body.terms_accepted) {
      return NextResponse.json(
        { success: false, error: 'Terms must be accepted' },
        { status: 400 }
      )
    }

    const {
      branch_id,
      order_type,
      requested_date,
      requested_time,
      participants_count,
      customer_first_name,
      customer_last_name,
      customer_phone,
      customer_email,
      customer_notes,
      game_area,
      number_of_games = 1,
      event_type = null, // event_active, event_laser, event_mix
      event_celebrant_age = null,
      locale = 'en' // 'fr' | 'en' | 'he' - langue pour l'email de confirmation
    } = body

    // Récupérer l'adresse IP pour le logging
    const ipAddress = getClientIpFromHeaders(request.headers)

    // Valider le format téléphone israélien
    if (!validateIsraeliPhone(customer_phone)) {
      return NextResponse.json(
        { success: false, error: 'Invalid phone format. Expected Israeli format: 05XXXXXXXX', messageKey: 'errors.invalidPhoneFormat' },
        { status: 400 }
      )
    }

    // Formater le téléphone
    const formattedPhone = formatIsraeliPhone(customer_phone)

    // 1. Trouver ou créer le contact (avec la langue préférée du site)
    const { contactId } = await findOrCreateContact(
      branch_id,
      customer_first_name,
      customer_last_name || null,
      formattedPhone,
      customer_email || null,
      customer_notes || null,
      ipAddress,
      locale as 'he' | 'fr' | 'en'
    )

    // 2. Récupérer les settings
    const { data: settings } = await supabase
      .from('branch_settings')
      .select('*')
      .eq('branch_id', branch_id)
      .single()

    if (!settings) {
      return NextResponse.json(
        { success: false, error: 'Branch settings not found' },
        { status: 500 }
      )
    }

    const gameDuration = settings.game_duration_minutes || 30
    const pauseDuration = 30 // 30 min de pause entre les jeux (comme admin)
    const eventSetupPause = 15 // 15 min de pause entre début salle et premier jeu (comme admin)

    // 3. Construire les dates/heures du booking
    // Utiliser createIsraelDateTime pour interpreter correctement l'heure Israel
    const requestedStartDateTime = createIsraelDateTime(requested_date, requested_time)

    // ========================================================================
    // GESTION DES ÉVÉNEMENTS (EVENT) - IDENTIQUE À L'ADMIN
    // ========================================================================
    if (order_type === 'EVENT') {
      // Pour EVENT :
      // - Durée de salle fixe = 2h (120 min) par défaut
      // - 15 min de setup avant le premier jeu
      // - 2 jeux de 30 min chacun avec 30 min de pause entre eux
      // - Plan de jeu selon event_type: AA (event_active), LL (event_laser), AL (event_mix)

      const roomDuration = 120 // 2 heures de salle par défaut
      const eventNumberOfGames = 2 // Toujours 2 jeux pour les événements
      const gameAreas = getGameAreasForEventType(event_type)

      // Timing de la salle (start/end du booking)
      const roomStartDateTime = new Date(requestedStartDateTime)
      const roomEndDateTime = new Date(roomStartDateTime.getTime() + roomDuration * 60000)

      // Timing des jeux (game_start/game_end) : 15 min après le début de la salle
      const gameStartDateTime = new Date(roomStartDateTime.getTime() + eventSetupPause * 60000)

      // Calculer la fin des jeux : jeux × durée + pauses entre jeux
      // 2 jeux de 30 min + 1 pause de 30 min = 90 min total de jeu
      const totalGameDuration = (eventNumberOfGames * gameDuration) + ((eventNumberOfGames - 1) * pauseDuration)
      const gameEndDateTime = new Date(gameStartDateTime.getTime() + totalGameDuration * 60000)

      // Trouver une salle d'événement disponible
      const eventRoomId = await findBestEventRoom(
        branch_id,
        participants_count,
        roomStartDateTime,
        roomEndDateTime
      )

      if (!eventRoomId) {
        // Pas de salle disponible → créer order en pending
        const referenceCode = generateShortReference()

        // === VALIDATION PRIX EVENT AVANT PENDING ===
        // Même si pending, on vérifie que le prix pourra être calculé
        const gameAreasForValidation = getGameAreasForEventType(event_type)
        const priceValidation = await validateBookingPrice(
          supabase,
          'EVENT',
          branch_id,
          participants_count,
          gameAreasForValidation.map((area, idx) => ({ game_area: area }))
        )

        if (!priceValidation.valid) {
          return NextResponse.json({
            success: false,
            error: priceValidation.error,
            errorKey: priceValidation.errorKey
          }, { status: 400 })
        }
        // === FIN VALIDATION PRIX ===

        // Calculer le total_amount
        const totalAmount = await calculateOrderTotalAmount({
          branchId: branch_id,
          orderType: 'EVENT',
          participants: participants_count,
          gameArea: game_area as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null,
          numberOfGames: eventNumberOfGames,
          eventType: event_type
        })

        const { data: order, error: orderError } = await supabase
          .from('orders')
          .insert({
            branch_id,
            order_type,
            source: 'website',
            status: 'pending',
            contact_id: contactId,
            request_reference: referenceCode,
            customer_first_name,
            customer_last_name: customer_last_name || '',
            customer_phone: formattedPhone,
            customer_email: customer_email || null,
            customer_notes: customer_notes || null,
            requested_date,
            requested_time,
            participants_count,
            game_area: game_area || null,
            number_of_games: eventNumberOfGames,
            pending_reason: 'room_unavailable',
            pending_details: 'No event room available for this time slot',
            total_amount: totalAmount,
            terms_accepted: true,
            terms_accepted_at: new Date().toISOString(),
            cgv_validated_at: new Date().toISOString()
          })
          .select('id, request_reference')
          .single()

        if (orderError) {
          return NextResponse.json(
            { success: false, error: 'Failed to create order' },
            { status: 500 }
          )
        }

        // Logger la création de l'order (pending - room unavailable)
        await logOrderAction({
          userId: null,
          userRole: 'website' as UserRole,
          userName: 'Website',
          action: 'created',
          orderId: order.id,
          orderRef: order.request_reference,
          branchId: branch_id,
          details: {
            source: 'website',
            status: 'pending',
            reason: 'room_unavailable',
            orderType: order_type,
            participants: participants_count,
            customerName: `${customer_first_name} ${customer_last_name || ''}`.trim()
          },
          ipAddress
        })

        return NextResponse.json({
          success: true,
          order_id: order.id,
          reference: order.request_reference,
          status: 'pending',
          message: 'Your request has been received and is pending confirmation'
        })
      }

      // Générer les game_sessions pour EVENT (comme dans BookingModal)
      const eventGameSessions: Array<{
        game_area: 'ACTIVE' | 'LASER'
        start_datetime: string
        end_datetime: string
        laser_room_id: string | null
        session_order: number
        pause_before_minutes: number
      }> = []

      let currentStart = new Date(gameStartDateTime)

      // Charger les données pour allocation laser si nécessaire
      let laserRooms: LaserRoom[] = []
      let allBookings: any[] = []

      const hasLaserSession = gameAreas.some(area => area === 'LASER')
      if (hasLaserSession) {
        const { data: rooms } = await supabase
          .from('laser_rooms')
          .select('*')
          .eq('branch_id', branch_id)
          .eq('is_active', true)
          .order('sort_order')

        laserRooms = rooms || []

        const { data: bookings } = await supabase
          .from('bookings')
          .select(`
            id,
            branch_id,
            participants_count,
            status,
            game_sessions (
              id,
              game_area,
              laser_room_id,
              start_datetime,
              end_datetime
            )
          `)
          .eq('branch_id', branch_id)
          .neq('status', 'CANCELLED')

        allBookings = bookings || []
      }

      for (let i = 0; i < eventNumberOfGames; i++) {
        const area = gameAreas[i]
        const sessionStart = new Date(currentStart)
        const sessionEnd = new Date(sessionStart.getTime() + gameDuration * 60000)

        let laserRoomId: string | null = null

        if (area === 'LASER') {
          // Allocation Laser (comme dans BookingModal)
          const { findBestLaserRoomsForBooking } = await import('@/lib/laser-allocation')

          const allocation = await findBestLaserRoomsForBooking({
            participants: participants_count,
            startDateTime: sessionStart,
            endDateTime: sessionEnd,
            branchId: branch_id,
            laserRooms,
            settings: {
              laser_exclusive_threshold: settings.laser_exclusive_threshold || 10,
              laser_total_vests: settings.laser_total_vests || 30,
              laser_spare_vests: settings.laser_spare_vests || 0
            },
            allBookings,
            allocationMode: 'auto'
          })

          if (allocation && allocation.roomIds.length > 0) {
            laserRoomId = allocation.roomIds[0]
          } else {
            // Pas de salle laser disponible → créer order en pending
            const referenceCode = generateShortReference()

            // Calculer le total_amount
            const totalAmount = await calculateOrderTotalAmount({
              branchId: branch_id,
              orderType: 'EVENT',
              participants: participants_count,
              gameArea: game_area as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null,
              numberOfGames: eventNumberOfGames,
              eventType: event_type
            })

            const { data: order, error: orderError } = await supabase
              .from('orders')
              .insert({
                branch_id,
                order_type,
                source: 'website',
                status: 'pending',
                contact_id: contactId,
                request_reference: referenceCode,
                customer_first_name,
                customer_last_name: customer_last_name || '',
                customer_phone: formattedPhone,
                customer_email: customer_email || null,
                customer_notes: customer_notes || null,
                requested_date,
                requested_time,
                participants_count,
                game_area: game_area || null,
                number_of_games: eventNumberOfGames,
                pending_reason: 'laser_unavailable',
                pending_details: `No laser room available for game ${i + 1}`,
                total_amount: totalAmount,
                terms_accepted: true,
                terms_accepted_at: new Date().toISOString(),
                cgv_validated_at: new Date().toISOString()
              })
              .select('id, request_reference')
              .single()

            if (orderError) {
              return NextResponse.json(
                { success: false, error: 'Failed to create order' },
                { status: 500 }
              )
            }

            // Logger la création de l'order (pending - laser unavailable)
            await logOrderAction({
              userId: null,
              userRole: 'website' as UserRole,
              userName: 'Website',
              action: 'created',
              orderId: order.id,
              orderRef: order.request_reference,
              branchId: branch_id,
              details: {
                source: 'website',
                status: 'pending',
                reason: 'laser_unavailable',
                orderType: order_type,
                participants: participants_count,
                customerName: `${customer_first_name} ${customer_last_name || ''}`.trim()
              },
              ipAddress
            })

            return NextResponse.json({
              success: true,
              order_id: order.id,
              reference: order.request_reference,
              status: 'pending',
              message: 'Your request has been received and is pending confirmation'
            })
          }
        }

        eventGameSessions.push({
          game_area: area,
          start_datetime: sessionStart.toISOString(),
          end_datetime: sessionEnd.toISOString(),
          laser_room_id: laserRoomId,
          session_order: i + 1,
          pause_before_minutes: i === 0 ? eventSetupPause : pauseDuration
        })

        // Préparer le début du prochain jeu (après la pause)
        if (i < eventNumberOfGames - 1) {
          currentStart = new Date(sessionEnd.getTime() + pauseDuration * 60000)
        }
      }

      // === VALIDATION PRIX EVENT OBLIGATOIRE ===
      // Vérifier qu'une formule et un produit existent AVANT de créer le booking
      const eventPriceValidation = await validateBookingPrice(
        supabase,
        'EVENT',
        branch_id,
        participants_count,
        eventGameSessions.map(s => ({ game_area: s.game_area, start_datetime: s.start_datetime, end_datetime: s.end_datetime }))
      )

      if (!eventPriceValidation.valid) {
        console.error('[ORDER API EVENT] Price validation failed:', eventPriceValidation.error)
        return NextResponse.json({
          success: false,
          error: eventPriceValidation.error,
          errorKey: eventPriceValidation.errorKey
        }, { status: 400 })
      }
      console.log('[ORDER API EVENT] Price validation passed, formula:', eventPriceValidation.formula?.name)
      // === FIN VALIDATION PRIX ===

      // Créer le booking EVENT
      const referenceCode = generateShortReference()
      const color = '#22C55E' // Vert pour EVENT (comme dans l'admin)

      // Notes avec alias si event_celebrant_age fourni
      const eventNotes = event_celebrant_age
        ? `Age: ${event_celebrant_age}${customer_notes ? '\n' + customer_notes : ''}`
        : customer_notes || null

      const { data: booking, error: bookingError } = await supabase
        .from('bookings')
        .insert({
          branch_id,
          type: 'EVENT',
          status: 'CONFIRMED',
          // Room timing (salle complète)
          start_datetime: roomStartDateTime.toISOString(),
          end_datetime: roomEndDateTime.toISOString(),
          // Game timing (jeux uniquement)
          game_start_datetime: gameStartDateTime.toISOString(),
          game_end_datetime: gameEndDateTime.toISOString(),
          participants_count,
          event_room_id: eventRoomId, // CRITIQUE : allocation de la salle
          customer_first_name,
          customer_last_name: customer_last_name || '',
          customer_phone: formattedPhone,
          customer_email: customer_email || null,
          customer_notes_at_booking: eventNotes,
          primary_contact_id: contactId,
          reference_code: referenceCode,
          color
        })
        .select('id')
        .single()

      if (bookingError) {
        console.error('Booking creation error:', bookingError)
        return NextResponse.json(
          { success: false, error: 'Failed to create booking' },
          { status: 500 }
        )
      }

      // Créer booking_contacts
      await supabase.from('booking_contacts').insert({
        booking_id: booking.id,
        contact_id: contactId,
        is_primary: true
      })

      // Créer les slots (uniquement pour les sessions ACTIVE, comme dans l'admin)
      const eventSlots = eventGameSessions
        .filter(session => session.game_area === 'ACTIVE')
        .map(session => ({
          booking_id: booking.id,
          branch_id,
          slot_start: session.start_datetime,
          slot_end: session.end_datetime,
          participants_count,
          slot_type: 'game_zone'
        }))

      if (eventSlots.length > 0) {
        await supabase.from('booking_slots').insert(eventSlots)
      }

      // Créer les game_sessions
      const sessionsToInsert = eventGameSessions.map(s => ({
        ...s,
        booking_id: booking.id
      }))

      const { error: sessionsError } = await supabase
        .from('game_sessions')
        .insert(sessionsToInsert)

      if (sessionsError) {
        // Rollback booking
        await supabase.from('bookings').delete().eq('id', booking.id)
        console.error('Sessions creation error:', sessionsError)
        return NextResponse.json(
          { success: false, error: 'Failed to create game sessions' },
          { status: 500 }
        )
      }

      // Créer l'order avec cgv_token pour le lien récapitulatif
      const eventCgvToken = generateCgvToken()

      // Calculer le total_amount avec les game sessions créées
      const totalAmount = await calculateOrderTotalAmount({
        branchId: branch_id,
        orderType: 'EVENT',
        participants: participants_count,
        gameArea: game_area as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null,
        numberOfGames: eventNumberOfGames,
        gameSessions: eventGameSessions,
        eventRoomId: eventRoomId || null,
        eventType: event_type
      })

      const { data: order, error: orderError } = await supabase
        .from('orders')
        .insert({
          branch_id,
          order_type: 'EVENT',
          source: 'website',
          status: 'auto_confirmed',
          booking_id: booking.id,
          contact_id: contactId,
          request_reference: referenceCode,
          customer_first_name,
          customer_last_name: customer_last_name || '',
          customer_phone: formattedPhone,
          customer_email: customer_email || null,
          customer_notes: customer_notes || null,
          requested_date,
          requested_time,
          participants_count,
          game_area: game_area || null,
          number_of_games: eventNumberOfGames,
          total_amount: totalAmount,
          terms_accepted: true,
          terms_accepted_at: new Date().toISOString(),
          cgv_validated_at: new Date().toISOString(),
          cgv_token: eventCgvToken
        })
        .select('id, request_reference, cgv_token')
        .single()

      if (orderError) {
        // Rollback booking
        await supabase.from('bookings').delete().eq('id', booking.id)
        return NextResponse.json(
          { success: false, error: 'Failed to create order' },
          { status: 500 }
        )
      }

      // Logger la création de l'order (EVENT confirmé)
      await logOrderAction({
        userId: null,
        userRole: 'website' as UserRole,
        userName: 'Website',
        action: 'created',
        orderId: order.id,
        orderRef: order.request_reference,
        branchId: branch_id,
        details: {
          source: 'website',
          status: 'auto_confirmed',
          orderType: 'EVENT',
          eventType: event_type,
          participants: participants_count,
          customerName: `${customer_first_name} ${customer_last_name || ''}`.trim(),
          bookingId: booking.id
        },
        ipAddress
      })

      // Logger aussi la création du booking
      await logBookingAction({
        userId: null,
        userRole: 'website' as UserRole,
        userName: 'Website',
        action: 'created',
        bookingId: booking.id,
        bookingRef: referenceCode,
        branchId: branch_id,
        details: {
          source: 'website',
          type: 'EVENT',
          participants: participants_count,
          customerName: `${customer_first_name} ${customer_last_name || ''}`.trim()
        },
        ipAddress
      })

      // Créer un objet booking complet (utilisé pour email et iCount)
      const eventBookingData: Booking = {
        id: booking.id,
        branch_id,
        type: 'EVENT',
        status: 'CONFIRMED',
        start_datetime: roomStartDateTime.toISOString(),
        end_datetime: roomEndDateTime.toISOString(),
        game_start_datetime: gameStartDateTime.toISOString(),
        game_end_datetime: gameEndDateTime.toISOString(),
        participants_count,
        event_room_id: eventRoomId,
        customer_first_name,
        customer_last_name: customer_last_name || '',
        customer_phone: formattedPhone,
        customer_email: customer_email || null,
        customer_notes_at_booking: eventNotes,
        reference_code: referenceCode,
        total_price: null,
        notes: null,
        color,
        primary_contact_id: contactId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        cancelled_at: null,
        cancelled_reason: null,
        icount_offer_id: null,
        icount_offer_url: null,
        icount_invrec_id: null
      }

      // iCount offer creation removed - invoice+receipt created at order close

      // Envoyer l'email de confirmation si le client a un email
      console.log('[ORDER API EVENT] === EMAIL SECTION START ===')
      console.log('[ORDER API EVENT] customer_email:', customer_email)
      console.log('[ORDER API EVENT] booking.id:', booking.id)
      console.log('[ORDER API EVENT] referenceCode:', referenceCode)

      if (customer_email) {
        console.log('[ORDER API EVENT] Email provided, fetching branch...')
        // Récupérer la branche pour l'email
        const { data: branch, error: branchError } = await supabase
          .from('branches')
          .select('*')
          .eq('id', branch_id)
          .single()

        console.log('[ORDER API EVENT] Branch fetch result - name:', branch?.name, 'error:', branchError?.message)

        if (branch) {
          console.log('[ORDER API EVENT] Calling sendBookingConfirmationEmail with locale:', locale, 'cgvToken:', order.cgv_token)
          // Envoyer l'email (attendre pour que le status soit mis à jour)
          try {
            const emailResult = await sendBookingConfirmationEmail({
              booking: eventBookingData,
              branch: branch as Branch,
              locale,
              cgvToken: order.cgv_token
            })
            console.log('[ORDER API EVENT] Email result:', emailResult)
          } catch (err) {
            console.error('[ORDER API EVENT] Email exception:', err)
          }
        } else {
          console.log('[ORDER API EVENT] Branch not found, skipping email')
        }
      } else {
        console.log('[ORDER API EVENT] No customer email provided, skipping email')
      }
      console.log('[ORDER API EVENT] === EMAIL SECTION END ===')

      return NextResponse.json({
        success: true,
        order_id: order.id,
        booking_id: booking.id,
        reference: order.request_reference,
        status: 'confirmed',
        message: 'Event booking confirmed successfully'
      })
    }

    // ========================================================================
    // GESTION DES GAMES (GAME) - Code existant
    // ========================================================================
    const startDateTime = requestedStartDateTime

    // Calculer la durée totale incluant les pauses
    // Pour LASER : jeux × durée + (jeux - 1) × pause
    // Pour ACTIVE : jeux × durée (pas de pause par défaut dans l'admin)
    let totalDuration: number
    if (game_area === 'LASER' && number_of_games > 1) {
      totalDuration = (number_of_games * gameDuration) + ((number_of_games - 1) * pauseDuration)
    } else {
      totalDuration = number_of_games * gameDuration
    }

    const endDateTime = new Date(startDateTime.getTime() + (totalDuration * 60000))

    // 4. VÉRIFICATION OVERBOOKING ACTIVE
    // Si ACTIVE, vérifier si ajouter ces participants cause un overbooking
    if (game_area === 'ACTIVE') {
      const maxPlayers = settings.max_concurrent_players || 84 // 14 slots × 6 joueurs par défaut

      // Récupérer tous les bookings ACTIVE existants sur ce créneau
      const { data: existingBookings } = await supabase
        .from('bookings')
        .select(`
          id,
          participants_count,
          game_sessions (
            id,
            game_area,
            start_datetime,
            end_datetime
          )
        `)
        .eq('branch_id', branch_id)
        .neq('status', 'CANCELLED')

      // Pour chaque tranche de 15 min du nouveau booking, calculer le total de participants
      let hasOverbooking = false
      let overbookingDetails = ''

      // Générer les tranches de 15 min couvertes par le nouveau booking
      const SLOT_DURATION = 15 // minutes
      let checkTime = new Date(startDateTime)

      while (checkTime < endDateTime) {
        const slotStart = new Date(checkTime)
        const slotEnd = new Date(slotStart.getTime() + SLOT_DURATION * 60000)

        // Compter les participants existants sur ce créneau (sessions ACTIVE uniquement)
        let existingParticipants = 0

        for (const booking of (existingBookings || [])) {
          if (!booking.game_sessions || booking.game_sessions.length === 0) continue

          // Vérifier si une session ACTIVE de ce booking chevauche ce créneau
          const hasOverlap = booking.game_sessions.some((session: { game_area: string; start_datetime: string; end_datetime: string }) => {
            if (session.game_area !== 'ACTIVE') return false
            const sessionStart = new Date(session.start_datetime)
            const sessionEnd = new Date(session.end_datetime)
            return sessionStart < slotEnd && sessionEnd > slotStart
          })

          if (hasOverlap) {
            existingParticipants += booking.participants_count
          }
        }

        // Vérifier si overbooking
        const totalParticipants = existingParticipants + participants_count
        if (totalParticipants > maxPlayers) {
          hasOverbooking = true
          const timeStr = `${String(slotStart.getHours()).padStart(2, '0')}:${String(slotStart.getMinutes()).padStart(2, '0')}`
          overbookingDetails = `Overbooking at ${timeStr}: ${totalParticipants}/${maxPlayers} players`
          break
        }

        checkTime = slotEnd
      }

      // Si overbooking → créer order en pending
      if (hasOverbooking) {
        const referenceCode = generateShortReference()

        // Calculer le total_amount
        const totalAmount = await calculateOrderTotalAmount({
          branchId: branch_id,
          orderType: 'GAME',
          participants: participants_count,
          gameArea: game_area as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null,
          numberOfGames: number_of_games
        })

        const { data: order, error: orderError } = await supabase
          .from('orders')
          .insert({
            branch_id,
            order_type,
            source: 'website',
            status: 'pending',
            contact_id: contactId,
            request_reference: referenceCode,
            customer_first_name,
            customer_last_name: customer_last_name || '',
            customer_phone: formattedPhone,
            customer_email: customer_email || null,
            customer_notes: customer_notes || null,
            requested_date,
            requested_time,
            participants_count,
            game_area: game_area || null,
            number_of_games,
            pending_reason: 'overbooking',
            pending_details: overbookingDetails,
            total_amount: totalAmount,
            terms_accepted: true,
            terms_accepted_at: new Date().toISOString(),
            cgv_validated_at: new Date().toISOString()
          })
          .select('id, request_reference')
          .single()

        if (orderError) {
          return NextResponse.json(
            { success: false, error: 'Failed to create order' },
            { status: 500 }
          )
        }

        // Logger la création de l'order (pending - overbooking)
        await logOrderAction({
          userId: null,
          userRole: 'website' as UserRole,
          userName: 'Website',
          action: 'created',
          orderId: order.id,
          orderRef: order.request_reference,
          branchId: branch_id,
          details: {
            source: 'website',
            status: 'pending',
            reason: 'overbooking',
            overbookingDetails,
            orderType: order_type,
            gameArea: game_area,
            participants: participants_count,
            customerName: `${customer_first_name} ${customer_last_name || ''}`.trim()
          },
          ipAddress
        })

        return NextResponse.json({
          success: true,
          order_id: order.id,
          reference: order.request_reference,
          status: 'pending',
          message: 'Your request has been received and is pending confirmation due to capacity limits'
        })
      }
    }

    // 5. Construire les sessions avec session-builder (LASER uniquement vérifie dispo)
    const { buildGameSessionsForAPI } = await import('@/lib/session-builder')

    let sessionResult
    try {
      sessionResult = await buildGameSessionsForAPI({
        gameArea: game_area as 'ACTIVE' | 'LASER' | null,
        numberOfGames: number_of_games,
        participants: participants_count,
        startDateTime,
        branchId: branch_id,
        gameDuration,
        supabase
      })
    } catch (err) {
      return NextResponse.json(
        { success: false, error: 'Failed to allocate game sessions', details: String(err) },
        { status: 500 }
      )
    }

    if (sessionResult.error) {
      // Pas de salles disponibles ou autre erreur
      // Créer une order en pending
      const referenceCode = generateShortReference()

      // Calculer le total_amount
      const totalAmount = await calculateOrderTotalAmount({
        branchId: branch_id,
        orderType: 'GAME',
        participants: participants_count,
        gameArea: game_area as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null,
        numberOfGames: number_of_games
      })

      const { data: order, error: orderError } = await supabase
        .from('orders')
        .insert({
          branch_id,
          order_type,
          source: 'website',
          status: 'pending',
          contact_id: contactId,
          request_reference: referenceCode,
          customer_first_name,
          customer_last_name: customer_last_name || '',
          customer_phone: formattedPhone,
          customer_email: customer_email || null,
          customer_notes: customer_notes || null,
          requested_date,
          requested_time,
          participants_count,
          game_area: game_area || null,
          number_of_games,
          pending_reason: 'slot_unavailable',
          pending_details: sessionResult.error,
          total_amount: totalAmount,
          terms_accepted: true,
          terms_accepted_at: new Date().toISOString(),
          cgv_validated_at: new Date().toISOString()
        })
        .select('id, request_reference')
        .single()

      if (orderError) {
        return NextResponse.json(
          { success: false, error: 'Failed to create order' },
          { status: 500 }
        )
      }

      // Logger la création de l'order (pending - slot unavailable)
      await logOrderAction({
        userId: null,
        userRole: 'website' as UserRole,
        userName: 'Website',
        action: 'created',
        orderId: order.id,
        orderRef: order.request_reference,
        branchId: branch_id,
        details: {
          source: 'website',
          status: 'pending',
          reason: 'slot_unavailable',
          errorDetails: sessionResult.error,
          orderType: order_type,
          gameArea: game_area,
          participants: participants_count,
          customerName: `${customer_first_name} ${customer_last_name || ''}`.trim()
        },
        ipAddress
      })

      return NextResponse.json({
        success: true,
        order_id: order.id,
        reference: order.request_reference,
        status: 'pending',
        message: 'Your request has been received and is pending confirmation'
      })
    }

    // === VALIDATION PRIX GAME OBLIGATOIRE ===
    // Vérifier que les produits iCount existent AVANT de créer le booking
    const gamePriceValidation = await validateBookingPrice(
      supabase,
      'GAME',
      branch_id,
      participants_count,
      sessionResult.game_sessions.map(s => ({
        game_area: s.game_area as 'ACTIVE' | 'LASER',
        start_datetime: s.start_datetime,
        end_datetime: s.end_datetime
      }))
    )

    if (!gamePriceValidation.valid) {
      console.error('[ORDER API GAME] Price validation failed:', gamePriceValidation.error)
      return NextResponse.json({
        success: false,
        error: gamePriceValidation.error,
        errorKey: gamePriceValidation.errorKey
      }, { status: 400 })
    }
    console.log('[ORDER API GAME] Price validation passed')
    // === FIN VALIDATION PRIX ===

    // 5. Créer le booking
    const referenceCode = generateShortReference()
    const color = order_type === 'GAME' ? '#3B82F6' : '#22C55E'

    const { data: booking, error: bookingError } = await supabase
      .from('bookings')
      .insert({
        branch_id,
        type: order_type,
        status: 'CONFIRMED',
        start_datetime: startDateTime.toISOString(),
        end_datetime: endDateTime.toISOString(),
        game_start_datetime: startDateTime.toISOString(),
        game_end_datetime: endDateTime.toISOString(),
        participants_count,
        customer_first_name,
        customer_last_name: customer_last_name || '',
        customer_phone: formattedPhone,
        customer_email: customer_email || null,
        customer_notes_at_booking: customer_notes || null,
        primary_contact_id: contactId,
        reference_code: referenceCode,
        color
      })
      .select('id')
      .single()

    if (bookingError) {
      return NextResponse.json(
        { success: false, error: 'Failed to create booking' },
        { status: 500 }
      )
    }

    // 6. Créer booking_contacts
    await supabase.from('booking_contacts').insert({
      booking_id: booking.id,
      contact_id: contactId,
      is_primary: true
    })

    // 7. Créer les slots (basés sur les sessions créées)
    // Pour être cohérent, on utilise les sessions pour définir les slots
    const slots = []

    if (sessionResult.game_sessions.length > 0) {
      // Grouper les sessions par session_order (chaque jeu)
      const sessionsByOrder = new Map<number, typeof sessionResult.game_sessions>()
      for (const session of sessionResult.game_sessions) {
        if (!sessionsByOrder.has(session.session_order)) {
          sessionsByOrder.set(session.session_order, [])
        }
        sessionsByOrder.get(session.session_order)!.push(session)
      }

      // Créer un slot par jeu (session_order)
      for (const [, sessions] of sessionsByOrder) {
        if (sessions.length > 0) {
          const firstSession = sessions[0]
          slots.push({
            booking_id: booking.id,
            branch_id,
            slot_start: firstSession.start_datetime,
            slot_end: firstSession.end_datetime,
            participants_count,
            slot_type: 'game_zone'
          })
        }
      }
    }

    if (slots.length > 0) {
      await supabase.from('booking_slots').insert(slots)
    }

    // 8. Créer les game_sessions
    if (sessionResult.game_sessions.length > 0) {
      const sessionsToInsert = sessionResult.game_sessions.map(s => ({
        ...s,
        booking_id: booking.id
      }))

      const { error: sessionsError } = await supabase
        .from('game_sessions')
        .insert(sessionsToInsert)

      if (sessionsError) {
        // Rollback booking
        await supabase.from('bookings').delete().eq('id', booking.id)
        return NextResponse.json(
          { success: false, error: 'Failed to create game sessions' },
          { status: 500 }
        )
      }
    }

    // 9. Créer l'order
    // Créer l'order avec cgv_token pour le lien récapitulatif
    const gameCgvToken = generateCgvToken()

    // Calculer le total_amount avec les game sessions créées
    const totalAmount = await calculateOrderTotalAmount({
      branchId: branch_id,
      orderType: 'GAME',
      participants: participants_count,
      gameArea: game_area as 'ACTIVE' | 'LASER' | 'MIX' | 'CUSTOM' | null,
      numberOfGames: number_of_games,
      gameSessions: sessionResult.game_sessions.map(s => ({
        game_area: s.game_area,
        start_datetime: s.start_datetime,
        end_datetime: s.end_datetime
      }))
    })

    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert({
        branch_id,
        order_type,
        source: 'website',
        status: 'auto_confirmed',
        booking_id: booking.id,
        contact_id: contactId,
        request_reference: referenceCode,
        customer_first_name,
        customer_last_name: customer_last_name || '',
        customer_phone: formattedPhone,
        customer_email: customer_email || null,
        customer_notes: customer_notes || null,
        requested_date,
        requested_time,
        participants_count,
        game_area: game_area || null,
        number_of_games,
        total_amount: totalAmount,
        terms_accepted: true,
        terms_accepted_at: new Date().toISOString(),
        cgv_validated_at: new Date().toISOString(),
        cgv_token: gameCgvToken
      })
      .select('id, request_reference, cgv_token')
      .single()

    if (orderError) {
      // Rollback booking
      await supabase.from('bookings').delete().eq('id', booking.id)
      return NextResponse.json(
        { success: false, error: 'Failed to create order' },
        { status: 500 }
      )
    }

    // Logger la création de l'order (GAME confirmé)
    await logOrderAction({
      userId: null,
      userRole: 'website' as UserRole,
      userName: 'Website',
      action: 'created',
      orderId: order.id,
      orderRef: order.request_reference,
      branchId: branch_id,
      details: {
        source: 'website',
        status: 'auto_confirmed',
        orderType: order_type,
        gameArea: game_area,
        numberOfGames: number_of_games,
        participants: participants_count,
        customerName: `${customer_first_name} ${customer_last_name || ''}`.trim(),
        bookingId: booking.id
      },
      ipAddress
    })

    // Logger aussi la création du booking
    await logBookingAction({
      userId: null,
      userRole: 'website' as UserRole,
      userName: 'Website',
      action: 'created',
      bookingId: booking.id,
      bookingRef: referenceCode,
      branchId: branch_id,
      details: {
        source: 'website',
        type: order_type,
        gameArea: game_area,
        participants: participants_count,
        customerName: `${customer_first_name} ${customer_last_name || ''}`.trim()
      },
      ipAddress
    })

    // Envoyer l'email de confirmation si le client a un email
    console.log('[ORDER API GAME] === EMAIL SECTION START ===')
    console.log('[ORDER API GAME] customer_email:', customer_email)
    console.log('[ORDER API GAME] booking.id:', booking.id)
    console.log('[ORDER API GAME] referenceCode:', referenceCode)

    if (customer_email) {
      console.log('[ORDER API GAME] Email provided, fetching branch...')
      // Récupérer la branche pour l'email
      const { data: branch, error: branchError } = await supabase
        .from('branches')
        .select('*')
        .eq('id', branch_id)
        .single()

      console.log('[ORDER API GAME] Branch fetch result - name:', branch?.name, 'error:', branchError?.message)

      if (branch) {
        // Créer un objet booking complet pour l'envoi d'email
        const bookingForEmail: Booking = {
          id: booking.id,
          branch_id,
          type: order_type,
          status: 'CONFIRMED',
          start_datetime: startDateTime.toISOString(),
          end_datetime: endDateTime.toISOString(),
          game_start_datetime: startDateTime.toISOString(),
          game_end_datetime: endDateTime.toISOString(),
          participants_count,
          event_room_id: null,
          customer_first_name,
          customer_last_name: customer_last_name || '',
          customer_phone: formattedPhone,
          customer_email,
          customer_notes_at_booking: customer_notes || null,
          reference_code: referenceCode,
          total_price: null,
          notes: null,
          color,
          primary_contact_id: contactId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          cancelled_at: null,
          cancelled_reason: null,
          icount_offer_id: null,
          icount_offer_url: null,
          icount_invrec_id: null
        }

        console.log('[ORDER API GAME] Calling sendBookingConfirmationEmail with locale:', locale, 'cgvToken:', order.cgv_token)
        // Envoyer l'email (attendre pour que le status soit mis à jour)
        try {
          const emailResult = await sendBookingConfirmationEmail({
            booking: bookingForEmail,
            branch: branch as Branch,
            locale,
            cgvToken: order.cgv_token
          })
          console.log('[ORDER API GAME] Email result:', emailResult)
        } catch (err) {
          console.error('[ORDER API GAME] Email exception:', err)
        }
      } else {
        console.log('[ORDER API GAME] Branch not found, skipping email')
      }
    } else {
      console.log('[ORDER API GAME] No customer email provided, skipping email')
    }
    console.log('[ORDER API GAME] === EMAIL SECTION END ===')

    // iCount offer creation removed - invoice+receipt created at order close

    return NextResponse.json({
      success: true,
      order_id: order.id,
      booking_id: booking.id,
      reference: order.request_reference,
      status: 'confirmed',
      message: 'Booking confirmed successfully'
    })

  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Internal server error', details: String(error) },
      { status: 500 }
    )
  }
}

/**
 * GET /api/orders
 * Liste des orders pour l'admin
 */
export async function GET(request: NextRequest) {
  try {
    // Importer la vérification de permissions
    const { verifyApiPermission } = await import('@/lib/permissions')

    // Vérifier les permissions
    const { success, user, errorResponse } = await verifyApiPermission('orders', 'view')
    if (!success || !user) {
      return errorResponse
    }

    const searchParams = request.nextUrl.searchParams
    const branchId = searchParams.get('branch_id')
    const status = searchParams.get('status')

    if (!branchId) {
      return NextResponse.json(
        { success: false, error: 'branch_id required', messageKey: 'errors.branchRequired' },
        { status: 400 }
      )
    }

    // Vérifier l'accès à la branche
    if (user.role !== 'super_admin' && !user.branchIds.includes(branchId)) {
      return NextResponse.json(
        { success: false, error: 'Branch access denied', messageKey: 'errors.branchAccessDenied' },
        { status: 403 }
      )
    }

    let query = supabase
      .from('orders')
      .select(`
        *,
        contact:contacts(*),
        booking:bookings(*),
        branch:branches(*)
      `)
      .eq('branch_id', branchId)
      .order('created_at', { ascending: false })

    if (status) {
      query = query.eq('status', status)
    }

    const { data: orders, error } = await query

    if (error) {
      return NextResponse.json(
        { success: false, error: error.message, messageKey: 'errors.fetchFailed' },
        { status: 500 }
      )
    }

    // Compter les pending
    const pendingCount = orders?.filter(o => o.status === 'pending').length || 0

    return NextResponse.json({
      success: true,
      orders,
      pending_count: pendingCount
    })
  } catch (error) {
    console.error('Error in GET /api/orders:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error', messageKey: 'errors.internalError' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/admin/page.tsx">
'use client'

import { useState, useEffect, Fragment, useMemo } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { Loader2, ChevronLeft, ChevronRight, Calendar, Settings, Sliders } from 'lucide-react'
import { createClient } from '@/lib/supabase/client'
import { useBookings, type BookingWithSlots, type CreateBookingData } from '@/hooks/useBookings'
import { BookingModal } from './components/BookingModal'
import { AccountingModal } from './components/AccountingModal'
import { OrderDetailModalWrapper } from './components/OrderDetailModalWrapper'
import { AdminHeader } from './components/AdminHeader'
import { ConfirmationModal } from './components/ConfirmationModal'
import { SettingsModal } from './components/SettingsModal'
import { AgendaStats } from './components/AgendaStats'
import { GridSettingsPopup } from './components/GridSettingsPopup'
import { AgendaSearch } from './components/AgendaSearch'
import { useBranches } from '@/hooks/useBranches'
import { useAuth } from '@/hooks/useAuth'
import { useUserPermissions } from '@/hooks/useUserPermissions'
import { useLaserRooms } from '@/hooks/useLaserRooms'
import { useTranslation } from '@/contexts/LanguageContext'
import type { Profile, UserBranch, GameArea, GameSession, UserRole, BookingContact, BookingSlot, Contact } from '@/lib/supabase/types'

type Theme = 'light' | 'dark'

interface UserData {
  id: string
  email: string
  profile: { id: string; role: string; full_name: string | null } | null
  branches: Array<{ id: string; name: string; slug: string }>
  role: string
}

export default function AdminPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const { t, tArray, locale } = useTranslation()

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }
  const [loading, setLoading] = useState(true)
  const [userData, setUserData] = useState<UserData | null>(null)
  // Utiliser useBranches pour partager la branche sélectionnée avec le CRM
  const branchesHook = useBranches()
  const branches = branchesHook.branches
  const selectedBranchIdFromHook = branchesHook.selectedBranchId

  // Permissions pour l'agenda - Hook appelé tôt pour respecter l'ordre des hooks
  const { hasPermission } = useUserPermissions(userData?.role as UserRole || null)
  const canViewAgenda = hasPermission('agenda', 'can_view')
  const canCreateAgenda = hasPermission('agenda', 'can_create')
  const canEditAgenda = hasPermission('agenda', 'can_edit')
  const canDeleteAgenda = hasPermission('agenda', 'can_delete')

  // Calculer effectiveSelectedBranchId AVANT useBookings pour éviter les problèmes de timing
  // Si selectedBranchId n'est pas défini, utiliser la première branche disponible
  const effectiveSelectedBranchId = selectedBranchIdFromHook || (branches.length > 0 ? branches[0]?.id : null)
  
  // Vérifier que selectedBranchIdFromHook est bien dans les branches autorisées
  const isValidBranchId = selectedBranchIdFromHook && branches.some(b => b.id === selectedBranchIdFromHook)
  const finalSelectedBranchId = isValidBranchId ? selectedBranchIdFromHook : (branches.length > 0 ? branches[0]?.id : null)
  
  // Synchroniser avec le hook si nécessaire
  useEffect(() => {
    if (finalSelectedBranchId && !selectedBranchIdFromHook && branches.length > 0) {
      branchesHook.selectBranch(finalSelectedBranchId)
    } else if (selectedBranchIdFromHook && !isValidBranchId && branches.length > 0) {
      // Si la branche sauvegardée n'est plus autorisée, réinitialiser avec la première
      branchesHook.selectBranch(branches[0].id)
    }
  }, [finalSelectedBranchId, selectedBranchIdFromHook, isValidBranchId, branches.length, branchesHook.selectBranch])
  
  const selectedBranchId = finalSelectedBranchId
  const setSelectedBranchId = (branchId: string | null) => {
    if (branchId) {
      branchesHook.selectBranch(branchId)
    }
  }
  const [theme, setTheme] = useState<Theme>('light')
  const [selectedDate, setSelectedDate] = useState(() => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    return today
  })
  const [currentWeekStart, setCurrentWeekStart] = useState(() => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const day = today.getDay()
    const diff = today.getDate() - day + (day === 0 ? -6 : 1) // Lundi
    const monday = new Date(today)
    monday.setDate(diff)
    monday.setHours(0, 0, 0, 0)
    return monday
  })
  const [showBranchMenu, setShowBranchMenu] = useState(false)
  const [showUserMenu, setShowUserMenu] = useState(false)
  const [showBookingModal, setShowBookingModal] = useState(false)
  const [modalInitialHour, setModalInitialHour] = useState(10)
  const [modalInitialMinute, setModalInitialMinute] = useState(0)
  const [modalDefaultBookingType, setModalDefaultBookingType] = useState<'GAME' | 'EVENT'>('GAME')
  const [modalDefaultGameArea, setModalDefaultGameArea] = useState<'ACTIVE' | 'LASER' | undefined>(undefined)
  const [editingBooking, setEditingBooking] = useState<BookingWithSlots | null>(null)
  const [editingBookingOrderId, setEditingBookingOrderId] = useState<string | null>(null)
  const [editingBookingOrderStatus, setEditingBookingOrderStatus] = useState<string | null>(null)
  const [accountingOrderId, setAccountingOrderId] = useState<string | null>(null)
  const [orderDetailId, setOrderDetailId] = useState<string | null>(null)
  const [agendaSearchQuery, setAgendaSearchQuery] = useState('')
  const [showCalendarModal, setShowCalendarModal] = useState(false)
  const [calendarMonth, setCalendarMonth] = useState(new Date().getMonth())
  const [calendarYear, setCalendarYear] = useState(new Date().getFullYear())
  
  // Paramètres d'affichage du texte (chargés depuis localStorage)
  const [displayTextSize, setDisplayTextSize] = useState<'xs' | 'sm' | 'base' | 'lg'>('sm')
  const [displayTextWeight, setDisplayTextWeight] = useState<'normal' | 'semibold' | 'bold'>('bold')
  const [displayTextAlign, setDisplayTextAlign] = useState<'left' | 'center' | 'right'>('left')
  
  // État pour gérer la visibilité des grilles
  const [visibleGrids, setVisibleGrids] = useState({
    active: true,
    laser: true,
    rooms: true
  })
  
  // État pour gérer les dimensions des grilles
  const [showGridSettingsModal, setShowGridSettingsModal] = useState(false)
  const [showBranchSettingsModal, setShowBranchSettingsModal] = useState(false)
  const [gridWidths, setGridWidths] = useState({
    active: 100,  // Pourcentage par défaut
    laser: 100,
    rooms: 100
  })
  const [rowHeight, setRowHeight] = useState(20) // Hauteur des lignes en px (défaut 20px)

  // Heures visibles de l'agenda (0-23) - par défaut 10h-23h
  const [visibleHoursStart, setVisibleHoursStart] = useState(10)
  const [visibleHoursEnd, setVisibleHoursEnd] = useState(23)
  
  // Modal de confirmation
  const [confirmationModal, setConfirmationModal] = useState<{
    isOpen: boolean
    title: string
    message: string
    type?: 'warning' | 'info' | 'success'
    onConfirm: () => void
  }>({
    isOpen: false,
    title: '',
    message: '',
    type: 'warning',
    onConfirm: () => {},
  })

  // Charger les paramètres d'affichage depuis localStorage (doit être avant les autres hooks)
  useEffect(() => {
    if (selectedBranchId) {
      const storageKey = `displaySettings_${selectedBranchId}`
      const saved = localStorage.getItem(storageKey)
      if (saved) {
        try {
          const parsed = JSON.parse(saved)
          if (parsed.textSize) setDisplayTextSize(parsed.textSize)
          if (parsed.textWeight) setDisplayTextWeight(parsed.textWeight)
          if (parsed.textAlign) setDisplayTextAlign(parsed.textAlign)
        } catch (e) {
          console.error('Error loading display settings:', e)
        }
      }
      
      // Charger les paramètres de grille
      const gridStorageKey = `gridSettings_${selectedBranchId}`
      const savedGrid = localStorage.getItem(gridStorageKey)
      if (savedGrid) {
        try {
          const parsed = JSON.parse(savedGrid)
          if (parsed.gridWidths) setGridWidths(parsed.gridWidths)
          if (parsed.rowHeight) setRowHeight(parsed.rowHeight)
          if (parsed.visibleHoursStart !== undefined) setVisibleHoursStart(parsed.visibleHoursStart)
          if (parsed.visibleHoursEnd !== undefined) setVisibleHoursEnd(parsed.visibleHoursEnd)
        } catch (e) {
          console.error('Error loading grid settings:', e)
        }
      }
    }
  }, [selectedBranchId])

  // Fonction utilitaire pour formater une date en YYYY-MM-DD (sans conversion UTC)
  const formatDateToString = (date: Date): string => {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  // Fonction utilitaire pour extraire la date locale d'une date ISO (sans conversion UTC)
  const extractLocalDateFromISO = (isoString: string): string => {
    const date = new Date(isoString)
    return formatDateToString(date)
  }

  // Format de date pour l'API (format simple YYYY-MM-DD, sans UTC)
  const dateString = formatDateToString(selectedDate)

  // Hook pour TOUTES les réservations (utilisé pour l'agenda ET les statistiques)
  // On charge tout et on filtre côté client pour éviter les problèmes de synchronisation
  const {
    bookings: allBookings,
    loading: bookingsLoading,
    error: bookingsError,
    createBooking,
    updateBooking,
    deleteBooking,
    deleteAllBookings,
    refresh: refreshAllBookings
  } = useBookings(selectedBranchId, undefined) // undefined = pas de filtre par date, on charge tout

  // branches déjà défini plus haut
  const refreshBranches = branchesHook.refresh

  // Filtrer les réservations pour l'agenda du jour sélectionné (MEMOIZED pour performance)
  // IMPORTANT : Pour les réservations LASER, vérifier aussi les dates des game_sessions LASER
  // car un EVENT peut avoir une salle à une date mais des sessions LASER à une autre date
  const dateStr = formatDateToString(selectedDate)
  const bookings = useMemo(() => {
    return allBookings.filter(b => {
      // Vérifier d'abord la date du booking (start_datetime)
      const bookingDate = extractLocalDateFromISO(b.start_datetime)
      if (bookingDate === dateStr) return true

      // Si le booking a des game_sessions LASER, vérifier si une session LASER est sur cette date
      if (b.game_sessions && b.game_sessions.length > 0) {
        const hasLaserSessionOnDate = b.game_sessions.some(session => {
          if (session.game_area !== 'LASER') return false
          const sessionDate = extractLocalDateFromISO(session.start_datetime)
          return sessionDate === dateStr
        })
        if (hasLaserSessionOnDate) return true
      }

      // Sinon, ne pas inclure cette réservation pour cette date
      return false
    })
  }, [allBookings, dateStr])

  // Calculer les heures effectives à afficher (config + extension automatique si réservations hors plage)
  const effectiveHours = useMemo(() => {
    let minHour = visibleHoursStart
    let maxHour = visibleHoursEnd

    // Scanner les réservations du jour pour étendre si nécessaire
    for (const booking of bookings) {
      // Utiliser game_start_datetime si disponible, sinon start_datetime
      const startStr = booking.game_start_datetime || booking.start_datetime
      const endStr = booking.game_end_datetime || booking.end_datetime

      const startDate = new Date(startStr)
      const endDate = new Date(endStr)

      // Vérifier que la réservation est bien sur le jour sélectionné
      const bookingDate = new Date(startDate)
      bookingDate.setHours(0, 0, 0, 0)
      const selectedDateNormalized = new Date(selectedDate)
      selectedDateNormalized.setHours(0, 0, 0, 0)

      if (bookingDate.getTime() !== selectedDateNormalized.getTime()) continue

      const startHour = startDate.getHours()
      const endHour = endDate.getHours()
      const endMinute = endDate.getMinutes()

      // Étendre si la réservation commence avant l'heure de début visible
      if (startHour < minHour) {
        minHour = startHour
      }

      // Étendre si la réservation finit après l'heure de fin visible
      // Gérer minuit (0h) et après minuit
      if (endHour === 0 && endMinute > 0) {
        // Finit après minuit - étendre jusqu'à minuit (23h45 = dernière tranche visible)
        maxHour = 23
      } else if (endHour > maxHour || (endHour === maxHour && endMinute > 0)) {
        maxHour = Math.min(23, endHour) // Max 23 car on affiche jusqu'à 23:45
      }
    }

    return { minHour, maxHour }
  }, [bookings, selectedDate, visibleHoursStart, visibleHoursEnd])

  // Générer les créneaux horaires (toutes les 15 minutes pour la précision)
  // Utilise les heures effectives (config + extension automatique)
  const timeSlots: { hour: number; minute: number; label: string }[] = useMemo(() => {
    const slots: { hour: number; minute: number; label: string }[] = []
    for (let h = effectiveHours.minHour; h <= effectiveHours.maxHour; h++) {
      for (const m of [0, 15, 30, 45]) {
        slots.push({
          hour: h,
          minute: m,
          label: `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`,
        })
      }
    }
    return slots
  }, [effectiveHours])

  // CRM: Gérer les query params pour deep-link vers une réservation ou réactivation
  useEffect(() => {
    const bookingId = searchParams?.get('booking')
    const dateParam = searchParams?.get('date')
    const isReactivate = searchParams?.get('reactivate') === 'true'
    
    // Cas 1: Réactivation d'une commande annulée
    if (isReactivate && dateParam) {
      const timeParam = searchParams?.get('time') || '10:00'
      const [hours, minutes] = timeParam.split(':').map(Number)
      
      // Naviguer vers la date demandée
      const targetDate = new Date(dateParam)
      setSelectedDate(targetDate)
      
      // Configurer le modal
      setModalInitialHour(hours || 10)
      setModalInitialMinute(minutes || 0)
      setEditingBooking(null) // Nouvelle réservation (pas d'édition)
      
      const bookingType = searchParams?.get('type') as 'GAME' | 'EVENT' || 'GAME'
      setModalDefaultBookingType(bookingType)
      
      const gameArea = searchParams?.get('gameArea') as 'ACTIVE' | 'LASER' | undefined
      if (gameArea) {
        setModalDefaultGameArea(gameArea)
      }
      
      // Stocker les données de pré-remplissage pour le BookingModal
      const reactivateData = {
        isReactivate: true,
        orderId: searchParams?.get('orderId') || '',
        firstName: searchParams?.get('firstName') || '',
        lastName: searchParams?.get('lastName') || '',
        phone: searchParams?.get('phone') || '',
        email: searchParams?.get('email') || '',
        participants: searchParams?.get('participants') || '2',
        numberOfGames: searchParams?.get('numberOfGames') || '1',
        contactId: searchParams?.get('contactId') || '',
        reference: searchParams?.get('reference') || ''
      }
      localStorage.setItem('booking-reactivate-data', JSON.stringify(reactivateData))
      
      // Ouvrir le modal
      setShowBookingModal(true)
      
      // Nettoyer l'URL
      router.replace('/admin')
      return
    }
    
    // Cas 2: Deep-link vers une réservation existante
    if (bookingId && allBookings.length > 0) {
      // Trouver la réservation
      const booking = allBookings.find(b => b.id === bookingId)
      
      if (booking) {
        // Si une date est fournie, naviguer vers cette date
        if (dateParam) {
          const targetDate = new Date(dateParam)
          setSelectedDate(targetDate)
        } else {
          // Sinon, utiliser la date de la réservation
          const bookingDate = extractLocalDateFromISO(booking.start_datetime)
          const targetDate = new Date(bookingDate)
          setSelectedDate(targetDate)
        }

        // Ouvrir le modal avec cette réservation
        const startTime = booking.game_start_datetime ? new Date(booking.game_start_datetime) : new Date(booking.start_datetime)
        setModalInitialHour(startTime.getHours())
        setModalInitialMinute(startTime.getMinutes())
        setEditingBooking(booking)
        setModalDefaultBookingType(booking.type as 'GAME' | 'EVENT')
        setShowBookingModal(true)

        // Chercher l'order_id correspondant
        const supabase = createClient()
        supabase
          .from('orders')
          .select('id')
          .eq('booking_id', booking.id)
          .single()
          .then(({ data: orderData }) => {
            const order = orderData as { id: string } | null
            if (order) {
              setEditingBookingOrderId(order.id)
            }
          })

        // Nettoyer l'URL
        router.replace('/admin')
      }
    }
  }, [searchParams, allBookings, router])

  // CRM: Helper pour obtenir les données du contact (live avec fallback snapshot)
  const getContactDisplayData = (booking: BookingWithSlots) => {
    // Utiliser les données live du contact si disponible
    if (booking.primaryContact) {
      return {
        firstName: booking.primaryContact.first_name || '',
        lastName: booking.primaryContact.last_name || '',
        phone: booking.primaryContact.phone || '',
        email: booking.primaryContact.email || '',
        notes: booking.primaryContact.notes_client || '',
      }
    }
    
    // Fallback sur les snapshot si le contact n'est pas disponible (archivé ou non lié)
    return {
      firstName: booking.customer_first_name || '',
      lastName: booking.customer_last_name || '',
      phone: booking.customer_phone || '',
      email: booking.customer_email || '',
      notes: booking.customer_notes_at_booking || '',
    }
  }

  // Type pour un segment UI (uniquement pour l'affichage)
  interface UISegment {
    segmentId: string
    bookingId: string
    booking: BookingWithSlots
    start: Date
    end: Date
    slotStart: number
    slotEnd: number
    slotsKey: string // Clé pour identifier les slots (pour regrouper les segments contigus)
    isOverbooked: boolean // Overbooking sur la tranche de 15 min correspondante
  }

  // Type pour les données OB par tranche de 15 min
  interface OBData {
    totalParticipants: number
    capacity: number
    isOverbooked: boolean
    overbookedCount: number
    slotsOver: number // Nombre de slots en surplus
    totalSlotsUsed: number // Nombre total de slots utilisés
  }

  // Récupérer la branche sélectionnée (définie plus bas mais on en a besoin ici)
  const branchForSettings = branches.find(b => b.id === selectedBranchId)
  
  // Constantes configurables - Lecture depuis branch_settings
  const MAX_PLAYERS_PER_SLOT = branchForSettings?.settings?.max_players_per_slot || 6
  const SLOT_DURATION = 15 // minutes
  const TOTAL_SLOTS = branchForSettings?.settings?.total_slots || 14 // Défini ici pour être accessible dans buildUISegments()
  
  // Calculer le nombre de salles actives pour la branche sélectionnée
  const TOTAL_ROOMS = branchForSettings?.rooms?.filter(r => r.is_active).length || 0

  // Générer toutes les tranches de 15 minutes pour la journée (pour les calculs de segments)
  const timeSlotDates: Date[] = []
  for (let h = 10; h <= 22; h++) {
    for (const m of [0, 15, 30, 45]) {
      const slotDate = new Date(selectedDate)
      slotDate.setHours(h, m, 0, 0)
      timeSlotDates.push(slotDate)
    }
  }

  // Pré-calculer les données OB pour toutes les tranches de 15 min (une fois par date)
  // Note: capacity sera passé en paramètre car CAPACITY n'est pas encore défini ici
  const calculateOBMapForDate = (capacity: number): Map<number, OBData> => {
    const obByTimeKey = new Map<number, OBData>()

    for (const timeSlotStart of timeSlotDates) {
      const timeSlotEnd = new Date(timeSlotStart)
      timeSlotEnd.setMinutes(timeSlotEnd.getMinutes() + SLOT_DURATION)

      // Calculer totalParticipants = somme des participants actifs sur cette tranche
      // Calculer totalSlotsUsed = somme des slots utilisés pour cette tranche
      // IMPORTANT : Ne prendre en compte que les sessions ACTIVE (pas LASER)
      let totalParticipants = 0
      let totalSlotsUsed = 0
      for (const booking of bookings) {
        if (booking.type !== 'GAME' && booking.type !== 'EVENT') continue
        
        // Si le booking a des game_sessions, utiliser celles-ci (filtrer ACTIVE uniquement)
        if (booking.game_sessions && booking.game_sessions.length > 0) {
          for (const session of booking.game_sessions) {
            // Ne prendre en compte que les sessions ACTIVE pour la grille Active
            if (session.game_area !== 'ACTIVE') continue
            
            const sessionStart = new Date(session.start_datetime)
            const sessionEnd = new Date(session.end_datetime)
            
            // Vérifier si cette session est active sur cette tranche
            if (sessionStart < timeSlotEnd && sessionEnd > timeSlotStart) {
              totalParticipants += booking.participants_count
              totalSlotsUsed += Math.ceil(booking.participants_count / MAX_PLAYERS_PER_SLOT)
            }
          }
        } else {
          // Fallback pour anciens bookings sans game_sessions : utiliser game_start_datetime/end_datetime
          const bookingStart = booking.game_start_datetime ? new Date(booking.game_start_datetime) : new Date(booking.start_datetime)
          const bookingEnd = booking.game_end_datetime ? new Date(booking.game_end_datetime) : new Date(booking.end_datetime)
          
          // Vérifier si ce booking est actif sur cette tranche
          if (bookingStart < timeSlotEnd && bookingEnd > timeSlotStart) {
            totalParticipants += booking.participants_count
            totalSlotsUsed += Math.ceil(booking.participants_count / MAX_PLAYERS_PER_SLOT)
          }
        }
      }

      const isOverbooked = totalParticipants > capacity
      const overbookedCount = isOverbooked ? totalParticipants - capacity : 0
      
      // Calculer le nombre de slots en surplus (overSlots)
      // overSlots = ceil(overPeople / MAX_PLAYERS_PER_SLOT)
      const overSlots = isOverbooked ? Math.ceil(overbookedCount / MAX_PLAYERS_PER_SLOT) : 0

      // Clé = timestamp arrondi à 15 min
      const timeKey = Math.floor(timeSlotStart.getTime() / (SLOT_DURATION * 60 * 1000)) * (SLOT_DURATION * 60 * 1000)

      obByTimeKey.set(timeKey, {
        totalParticipants,
        capacity,
        isOverbooked,
        overbookedCount,
        slotsOver: overSlots,
        totalSlotsUsed
      })
    }

    return obByTimeKey
  }

  // Construire les segments UI à partir des bookings (uniquement pour l'affichage)
  const buildUISegments = (): UISegment[] => {
    const segments: UISegment[] = []

    // Fonction pour calculer quels slots sont occupés pour une tranche de 15 minutes
    const getOccupiedSlotsForTimeSlot = (timeSlotStart: Date): Map<string, { slotStart: number; slotEnd: number }> => {
      const occupiedSlots = new Map<string, { slotStart: number; slotEnd: number }>()
      const timeSlotEnd = new Date(timeSlotStart)
      timeSlotEnd.setMinutes(timeSlotEnd.getMinutes() + SLOT_DURATION)

      // Trier les bookings par ordre d'arrivée (created_at) pour maintenir la stabilité des slots
      // Une réservation qui arrive en premier garde ses slots, les nouvelles se placent après
      // IMPORTANT : Ne prendre en compte que les sessions ACTIVE (pas LASER)
      const relevantBookings = bookings
        .filter(b => {
          if (b.type !== 'GAME' && b.type !== 'EVENT') return false
          
          // Si le booking a des game_sessions, vérifier s'il y a une session ACTIVE sur ce créneau
          if (b.game_sessions && b.game_sessions.length > 0) {
            return b.game_sessions.some(session => {
              if (session.game_area !== 'ACTIVE') return false
              const sessionStart = new Date(session.start_datetime)
              const sessionEnd = new Date(session.end_datetime)
              return sessionStart < timeSlotEnd && sessionEnd > timeSlotStart
            })
          }
          
          // Fallback pour anciens bookings sans game_sessions
          const bookingStart = b.game_start_datetime ? new Date(b.game_start_datetime) : new Date(b.start_datetime)
          const bookingEnd = b.game_end_datetime ? new Date(b.game_end_datetime) : new Date(b.end_datetime)
          return bookingStart < timeSlotEnd && bookingEnd > timeSlotStart
        })
        .sort((a, b) => {
          // Trier par ordre d'arrivée (created_at) pour maintenir la stabilité
          // Les réservations existantes gardent leurs slots, les nouvelles se placent après
          const createdA = new Date(a.created_at || 0).getTime()
          const createdB = new Date(b.created_at || 0).getTime()
          if (createdA !== createdB) {
            return createdA - createdB
          }
          // En cas d'égalité, utiliser l'ID pour un tri stable
          return a.id.localeCompare(b.id)
        })

      // Assigner les slots de gauche à droite
      let nextAvailableSlot = 0
      for (const booking of relevantBookings) {
        const slotsNeeded = Math.ceil(booking.participants_count / MAX_PLAYERS_PER_SLOT)
        occupiedSlots.set(booking.id, {
          slotStart: nextAvailableSlot,
          slotEnd: nextAvailableSlot + slotsNeeded
        })
        nextAvailableSlot += slotsNeeded
      }

      return occupiedSlots
    }

    // Pour chaque booking, créer ses segments
    // IMPORTANT : Ne créer des segments que pour les sessions ACTIVE (pas LASER)
    for (const booking of bookings) {
      if (booking.type !== 'GAME' && booking.type !== 'EVENT') continue

      // Si le booking a des game_sessions, utiliser celles-ci (filtrer ACTIVE uniquement)
      if (booking.game_sessions && booking.game_sessions.length > 0) {
        // Filtrer uniquement les sessions ACTIVE
        const activeSessions = booking.game_sessions.filter(s => s.game_area === 'ACTIVE')
        
        for (const session of activeSessions) {
          const gameStartTime = new Date(session.start_datetime)
          const gameEndTime = new Date(session.end_datetime)

          // Trouver les tranches de 15 minutes couvertes
          // Découper par tranche de 15 min : un segment par tranche
          for (let i = 0; i < timeSlotDates.length; i++) {
            const timeSlotStart = timeSlotDates[i]
            const timeSlotEnd = new Date(timeSlotStart)
            timeSlotEnd.setMinutes(timeSlotEnd.getMinutes() + SLOT_DURATION)

            // Vérifier si cette tranche est dans la plage du jeu
            if (timeSlotStart < gameEndTime && timeSlotEnd > gameStartTime) {
              // Calculer quels slots sont occupés pour cette tranche
              const occupiedSlots = getOccupiedSlotsForTimeSlot(timeSlotStart)
              const bookingSlotInfo = occupiedSlots.get(booking.id)

              if (bookingSlotInfo) {
                let { slotStart, slotEnd } = bookingSlotInfo
                
                // HARD BOUNDARY : Clamp slotEnd à 14 maximum (jamais de débordement)
                if (slotEnd > TOTAL_SLOTS) {
                  slotEnd = TOTAL_SLOTS
                }
                
                // Découper par tranche de 15 min : un segment par tranche
                const slotsKey = `${slotStart}-${slotEnd}`
                
                // Lookup OB pour cette tranche (O(1))
                const timeKey = Math.floor(timeSlotStart.getTime() / (SLOT_DURATION * 60 * 1000)) * (SLOT_DURATION * 60 * 1000)
                const obData = obByTimeKey.get(timeKey)
                const isOverbooked = obData?.isOverbooked || false

                // Créer un segment pour cette tranche de 15 min
                segments.push({
                  segmentId: `${booking.id}-${session.id}-${timeSlotStart.getTime()}-${timeSlotEnd.getTime()}-${slotsKey}`,
                  bookingId: booking.id,
                  booking,
                  start: timeSlotStart,
                  end: timeSlotEnd,
                  slotStart,
                  slotEnd,
                  slotsKey,
                  isOverbooked
                })
              }
            }
          }
        }
      } else {
        // Fallback pour anciens bookings sans game_sessions : utiliser game_start_datetime/end_datetime
        const gameStartTime = booking.game_start_datetime ? new Date(booking.game_start_datetime) : new Date(booking.start_datetime)
        const gameEndTime = booking.game_end_datetime ? new Date(booking.game_end_datetime) : new Date(booking.end_datetime)

        // Trouver les tranches de 15 minutes couvertes
        for (let i = 0; i < timeSlotDates.length; i++) {
          const timeSlotStart = timeSlotDates[i]
          const timeSlotEnd = new Date(timeSlotStart)
          timeSlotEnd.setMinutes(timeSlotEnd.getMinutes() + SLOT_DURATION)

          // Vérifier si cette tranche est dans la plage du jeu
          if (timeSlotStart < gameEndTime && timeSlotEnd > gameStartTime) {
            // Calculer quels slots sont occupés pour cette tranche
            const occupiedSlots = getOccupiedSlotsForTimeSlot(timeSlotStart)
            const bookingSlotInfo = occupiedSlots.get(booking.id)

            if (bookingSlotInfo) {
              let { slotStart, slotEnd } = bookingSlotInfo
              
              // HARD BOUNDARY : Clamp slotEnd à 14 maximum (jamais de débordement)
              if (slotEnd > TOTAL_SLOTS) {
                slotEnd = TOTAL_SLOTS
              }
              
              // Découper par tranche de 15 min : un segment par tranche
              const slotsKey = `${slotStart}-${slotEnd}`
              
              // Lookup OB pour cette tranche (O(1))
              const timeKey = Math.floor(timeSlotStart.getTime() / (SLOT_DURATION * 60 * 1000)) * (SLOT_DURATION * 60 * 1000)
              const obData = obByTimeKey.get(timeKey)
              const isOverbooked = obData?.isOverbooked || false

              // Créer un segment pour cette tranche de 15 min
              segments.push({
                segmentId: `${booking.id}-${timeSlotStart.getTime()}-${timeSlotEnd.getTime()}-${slotsKey}`,
                bookingId: booking.id,
                booking,
                start: timeSlotStart,
                end: timeSlotEnd,
                slotStart,
                slotEnd,
                slotsKey,
                isOverbooked
              })
            }
          }
        }
      }
    }

    // Merger les segments contigus (même bookingId + même slotsKey + end == next.start)
    const mergedSegments: UISegment[] = []
    for (let i = 0; i < segments.length; i++) {
      const current = segments[i]
      if (mergedSegments.length === 0) {
        mergedSegments.push({ ...current })
        continue
      }
      
      const last = mergedSegments[mergedSegments.length - 1]
      // Vérifier si on peut merger : même booking, même slots, et contigu
      if (
        last.bookingId === current.bookingId &&
        last.slotsKey === current.slotsKey &&
        last.end.getTime() === current.start.getTime()
      ) {
        // Merger : étendre le dernier segment
        last.end = current.end
        last.segmentId = `${last.bookingId}-${last.start.getTime()}-${last.end.getTime()}-${last.slotsKey}`
      } else {
        // Nouveau segment
        mergedSegments.push({ ...current })
      }
    }

    return mergedSegments
  }

  // Calculer CAPACITY (après les hooks, mais TOTAL_SLOTS est déjà défini plus haut)
  const CAPACITY = TOTAL_SLOTS * MAX_PLAYERS_PER_SLOT // 14 * 6 = 84

  // Pré-calculer la map OB une fois (après définition de CAPACITY, avant buildUISegments)
  const obByTimeKey = calculateOBMapForDate(CAPACITY)

  // Construire les segments UI
  const uiSegments = buildUISegments()

  // Ouvrir le modal de réservation
  const openBookingModal = async (hour?: number, minute?: number, booking?: BookingWithSlots, defaultType: 'GAME' | 'EVENT' = 'GAME', defaultGameArea?: 'ACTIVE' | 'LASER') => {
    // Vérifier les permissions:
    // - Pour une réservation existante: view suffit pour ouvrir (en lecture seule)
    // - Pour une nouvelle réservation: create est requis
    if (booking && !canViewAgenda) return
    if (!booking && !canCreateAgenda) return

    if (booking) {
      setEditingBooking(booking)
      // Chercher l'order_id et status correspondant au booking
      setEditingBookingOrderId(null) // Reset pendant la recherche
      setEditingBookingOrderStatus(null)
      const supabase = createClient()
      const { data: orderData } = await supabase
        .from('orders')
        .select('id, status')
        .eq('booking_id', booking.id)
        .single()
      const order = orderData as { id: string; status: string } | null
      if (order) {
        setEditingBookingOrderId(order.id)
        setEditingBookingOrderStatus(order.status)
      }
      // Extraire l'heure de début de la réservation
      const startTime = new Date(booking.game_start_datetime || booking.start_datetime)
      setModalInitialHour(startTime.getHours())
      setModalInitialMinute(startTime.getMinutes())
      // Le type sera celui de la réservation existante
      setModalDefaultBookingType(booking.type as 'GAME' | 'EVENT')
      // Pour GAME, déterminer la zone depuis les sessions
      if (booking.type === 'GAME' && booking.game_sessions && booking.game_sessions.length > 0) {
        setModalDefaultGameArea(booking.game_sessions[0].game_area as 'ACTIVE' | 'LASER')
      } else {
        setModalDefaultGameArea(undefined) // Forcer le commercial à choisir
      }
    } else {
      setEditingBooking(null)
      setEditingBookingOrderId(null)
      setEditingBookingOrderStatus(null)
      setModalInitialHour(hour ?? 10)
      setModalInitialMinute(minute ?? 0)
      setModalDefaultBookingType(defaultType) // Définir le type selon où on clique
      setModalDefaultGameArea(defaultGameArea) // Définir la zone selon où on clique
    }
    setShowBookingModal(true)
  }

  // Créer ou mettre à jour une réservation
  const handleSubmitBooking = async (data: CreateBookingData): Promise<boolean> => {
    if (editingBooking) {
      // Mode édition
      const result = await updateBooking(editingBooking.id, data)
      return result !== null
    } else {
      // Mode création
      const result = await createBooking(data)
      return result !== null
    }
  }

  // Supprimer une réservation
  const handleDeleteBooking = async (id: string): Promise<boolean> => {
    const success = await deleteBooking(id)
    if (success) {
      setEditingBooking(null)
      setEditingBookingOrderId(null)
      setEditingBookingOrderStatus(null)
      setShowBookingModal(false)
    }
    return success
  }

  // Supprimer toutes les réservations (remettre le système à zéro)
  const handleDeleteAllBookings = () => {
    setConfirmationModal({
      isOpen: true,
      title: `⚠️ ${t('admin.agenda.delete_all_title')}`,
      message: t('admin.agenda.delete_all_message'),
      type: 'warning',
      onConfirm: async () => {
        const success = await deleteAllBookings()
        if (success) {
          setConfirmationModal({
            isOpen: true,
            title: t('admin.common.success'),
            message: t('admin.agenda.delete_all_success'),
            type: 'success',
            onConfirm: () => {},
          })
        } else {
          setConfirmationModal({
            isOpen: true,
            title: t('admin.common.error'),
            message: t('admin.agenda.delete_all_error'),
            type: 'warning',
            onConfirm: () => {},
          })
        }
      },
    })
  }

  // Clôturer une commande (créer facture + annuler devis)
  const handleCloseOrder = (orderId: string) => {
    console.log('[CLOSE ORDER] Called with orderId:', orderId)
    setConfirmationModal({
      isOpen: true,
      title: t('admin.orders.close_order'),
      message: t('admin.orders.close_order_confirm'),
      type: 'warning',
      onConfirm: async () => {
        console.log('[CLOSE ORDER] Confirmed, calling API for orderId:', orderId)
        try {
          const response = await fetch(`/api/orders/${orderId}/close`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          })

          const result = await response.json()

          if (result.success) {
            setEditingBookingOrderStatus('closed')
            setConfirmationModal({
              isOpen: true,
              title: t('admin.common.success'),
              message: t('admin.orders.close_order_success'),
              type: 'success',
              onConfirm: () => {},
            })
          } else {
            setConfirmationModal({
              isOpen: true,
              title: t('admin.common.error'),
              message: result.error || 'Failed to close order',
              type: 'warning',
              onConfirm: () => {},
            })
          }
        } catch (error) {
          console.error('Error closing order:', error)
          setConfirmationModal({
            isOpen: true,
            title: t('admin.common.error'),
            message: 'Failed to close order',
            type: 'warning',
            onConfirm: () => {},
          })
        }
      },
    })
  }

  // Charger les données utilisateur
  // Note: L'auth est gérée par le layout parent, pas besoin de rediriger ici
  useEffect(() => {
    const loadUserData = async () => {
      const supabase = createClient()

      try {
        const { data: { user } } = await supabase.auth.getUser()

        if (!user) {
          // Ne pas rediriger - le layout gère l'auth
          setLoading(false)
          return
        }

        // Récupérer le profil
        const { data: profile } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', user.id)
          .single<Profile>()

        // Récupérer les branches
        let branches: Array<{ id: string; name: string; slug: string }> = []

        if (profile?.role === 'super_admin') {
          const { data } = await supabase
            .from('branches')
            .select('id, name, slug')
            .eq('is_active', true)
            .order('name')
          branches = data || []
        } else {
          const { data: userBranches } = await supabase
            .from('user_branches')
            .select('branch_id')
            .eq('user_id', user.id)
            .returns<UserBranch[]>()

          if (userBranches && userBranches.length > 0) {
            const branchIds = userBranches.map(ub => ub.branch_id)
            const { data } = await supabase
              .from('branches')
              .select('id, name, slug')
              .in('id', branchIds)
              .eq('is_active', true)
              .order('name')
            branches = data || []
          }
        }

        setUserData({
          id: user.id,
          email: user.email || '',
          profile,
          branches,
          role: profile?.role || 'agent'
        })

        // NE PAS forcer la sélection de branche ici
        // useBranches gère déjà la sélection initiale (Rishon LeZion par défaut au premier chargement)
        // et la persistance via localStorage pour conserver la branche entre les pages
      } catch (error) {
        console.error('Error loading user data:', error)
      } finally {
        setLoading(false)
      }
    }

    loadUserData()
  }, [])

  // Charger le thème
  useEffect(() => {
    const savedTheme = localStorage.getItem('admin_theme') as Theme
    if (savedTheme) setTheme(savedTheme)
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('admin_theme', newTheme)
  }

  const handleSignOut = async () => {
    const supabase = createClient()
    await supabase.auth.signOut()
    router.push('/admin/login')
  }

  const formatDate = (date: Date) => {
    return date.toLocaleDateString(getDateLocale(), {
      weekday: 'long',
      day: 'numeric',
      month: 'long',
      year: 'numeric'
    })
  }

  const formatDateFull = (date: Date) => {
    return date.toLocaleDateString(getDateLocale(), {
      weekday: 'long',
      day: 'numeric',
      month: 'long',
      year: 'numeric'
    })
  }

  // Gestion du calendrier modal
  const handleCalendarDateClick = (date: Date) => {
    setSelectedDate(date)
    setCalendarMonth(date.getMonth())
    setCalendarYear(date.getFullYear())
    setShowCalendarModal(false)
    // Mettre à jour la semaine
    const day = date.getDay()
    const diff = date.getDate() - day + (day === 0 ? -6 : 1)
    const monday = new Date(date)
    monday.setDate(diff)
    monday.setHours(0, 0, 0, 0)
    setCurrentWeekStart(monday)
  }

  const handlePreviousMonth = () => {
    if (calendarMonth === 0) {
      setCalendarMonth(11)
      setCalendarYear(calendarYear - 1)
    } else {
      setCalendarMonth(calendarMonth - 1)
    }
  }

  const handleNextMonth = () => {
    if (calendarMonth === 11) {
      setCalendarMonth(0)
      setCalendarYear(calendarYear + 1)
    } else {
      setCalendarMonth(calendarMonth + 1)
    }
  }

  const handlePreviousYear = () => {
    setCalendarYear(calendarYear - 1)
  }

  const handleNextYear = () => {
    setCalendarYear(calendarYear + 1)
  }

  // Générer le calendrier pour le modal
  const getCalendarDays = () => {
    const firstDay = new Date(calendarYear, calendarMonth, 1)
    const lastDay = new Date(calendarYear, calendarMonth + 1, 0)
    const daysInMonth = lastDay.getDate()
    const startDay = firstDay.getDay()
    const days = []
    
    // Jours vides avant le premier jour
    for (let i = 0; i < (startDay === 0 ? 6 : startDay - 1); i++) {
      days.push(null)
    }
    
    // Jours du mois
    for (let i = 1; i <= daysInMonth; i++) {
      days.push(new Date(calendarYear, calendarMonth, i))
    }
    
    return days
  }

  // Les noms de mois sont maintenant gérés via les clés de traduction
  const getMonthName = (monthIndex: number) => {
    const monthKeys = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
    return t(`admin.agenda.months.${monthKeys[monthIndex]}`)
  }

  const goToPrevDay = () => {
    const newDate = new Date(selectedDate)
    newDate.setDate(newDate.getDate() - 1)
    setSelectedDate(newDate)
    // Mettre à jour la semaine si nécessaire
    const day = newDate.getDay()
    const diff = newDate.getDate() - day + (day === 0 ? -6 : 1)
    const monday = new Date(newDate)
    monday.setDate(diff)
    monday.setHours(0, 0, 0, 0)
    setCurrentWeekStart(monday)
  }

  const goToNextDay = () => {
    const newDate = new Date(selectedDate)
    newDate.setDate(newDate.getDate() + 1)
    setSelectedDate(newDate)
    // Mettre à jour la semaine si nécessaire
    const day = newDate.getDay()
    const diff = newDate.getDate() - day + (day === 0 ? -6 : 1)
    const monday = new Date(newDate)
    monday.setDate(diff)
    monday.setHours(0, 0, 0, 0)
    setCurrentWeekStart(monday)
  }

  const goToToday = () => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    setSelectedDate(today)
    // Mettre à jour la semaine
    const day = today.getDay()
    const diff = today.getDate() - day + (day === 0 ? -6 : 1)
    const monday = new Date(today)
    monday.setDate(diff)
    monday.setHours(0, 0, 0, 0)
    setCurrentWeekStart(monday)
  }

  // Générer les jours de la semaine
  const getWeekDays = () => {
    const days = []
    for (let i = 0; i < 7; i++) {
      const date = new Date(currentWeekStart)
      date.setDate(date.getDate() + i)
      days.push(date)
    }
    return days
  }

  const handleWeekDayClick = (date: Date) => {
    setSelectedDate(date)
  }

  const handlePreviousWeek = () => {
    const newWeekStart = new Date(currentWeekStart)
    newWeekStart.setDate(newWeekStart.getDate() - 7)
    setCurrentWeekStart(newWeekStart)
    // Mettre à jour la date sélectionnée pour rester sur le même jour de la semaine
    const dayOfWeek = selectedDate.getDay()
    const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek
    const newSelectedDate = new Date(newWeekStart)
    newSelectedDate.setDate(newWeekStart.getDate() + diffToMonday + (selectedDate.getDay() === 0 ? 6 : selectedDate.getDay() - 1))
    setSelectedDate(newSelectedDate)
  }

  const handleNextWeek = () => {
    const newWeekStart = new Date(currentWeekStart)
    newWeekStart.setDate(newWeekStart.getDate() + 7)
    setCurrentWeekStart(newWeekStart)
    // Mettre à jour la date sélectionnée pour rester sur le même jour de la semaine
    const dayOfWeek = selectedDate.getDay()
    const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek
    const newSelectedDate = new Date(newWeekStart)
    newSelectedDate.setDate(newWeekStart.getDate() + diffToMonday + (selectedDate.getDay() === 0 ? 6 : selectedDate.getDay() - 1))
    setSelectedDate(newSelectedDate)
  }

  // Calculer les stats
  const gameBookings = bookings.filter(b => b.type === 'GAME')
  const eventBookings = bookings.filter(b => b.type === 'EVENT')
  const totalParticipants = bookings.reduce((sum, b) => sum + b.participants_count, 0)

  // Calculer les statistiques détaillées (Jour, Semaine, Mois)
  const calculateStats = () => {
    const dateStr = formatDateToString(selectedDate)
    
    // Utiliser allBookings directement (même source que l'agenda)
    const bookingsForStats = allBookings || []
    
    // Stats du jour
    const dayBookings = bookingsForStats.filter(b => {
      const bookingDate = extractLocalDateFromISO(b.start_datetime)
      return bookingDate === dateStr
    })
    const dayWithRoom = dayBookings.filter(b => b.event_room_id !== null)
    const dayWithoutRoom = dayBookings.filter(b => b.event_room_id === null)
    const dayTotalParticipants = dayBookings.reduce((sum, b) => sum + b.participants_count, 0)
    
    // Stats de la semaine (lundi à dimanche)
    const dayOfWeek = selectedDate.getDay()
    const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek
    const weekStart = new Date(selectedDate)
    weekStart.setDate(selectedDate.getDate() + diffToMonday)
    weekStart.setHours(0, 0, 0, 0)
    const weekEnd = new Date(weekStart)
    weekEnd.setDate(weekStart.getDate() + 6)
    weekEnd.setHours(23, 59, 59, 999)
    
    // Filtrer les réservations de la semaine en utilisant les dates locales
    const weekBookings = bookingsForStats.filter(b => {
      const bookingDateStr = extractLocalDateFromISO(b.start_datetime)
      const bookingDate = new Date(bookingDateStr + 'T00:00:00')
      bookingDate.setHours(0, 0, 0, 0)
      return bookingDate >= weekStart && bookingDate <= weekEnd
    })
    
    const weekWithRoom = weekBookings.filter(b => b.event_room_id !== null)
    const weekWithoutRoom = weekBookings.filter(b => b.event_room_id === null)
    const weekTotalParticipants = weekBookings.reduce((sum, b) => sum + b.participants_count, 0)
    
    // Stats du mois
    const year = selectedDate.getFullYear()
    const monthStart = new Date(year, selectedDate.getMonth(), 1)
    monthStart.setHours(0, 0, 0, 0)
    const monthEnd = new Date(year, selectedDate.getMonth() + 1, 0)
    monthEnd.setHours(23, 59, 59, 999)
    
    // Filtrer les réservations du mois en utilisant les dates locales
    const monthBookings = bookingsForStats.filter(b => {
      const bookingDateStr = extractLocalDateFromISO(b.start_datetime)
      const bookingDate = new Date(bookingDateStr + 'T00:00:00')
      bookingDate.setHours(0, 0, 0, 0)
      return bookingDate >= monthStart && bookingDate <= monthEnd
    })
    
    const monthWithRoom = monthBookings.filter(b => b.event_room_id !== null)
    const monthWithoutRoom = monthBookings.filter(b => b.event_room_id === null)
    const monthTotalParticipants = monthBookings.reduce((sum, b) => sum + b.participants_count, 0)
    
    // Formater la période de la semaine
    const weekStartStr = weekStart.toLocaleDateString(getDateLocale(), { day: '2-digit', month: 'short' })
    const weekEndStr = weekEnd.toLocaleDateString(getDateLocale(), { day: '2-digit', month: 'short', year: 'numeric' })
    
    return {
      day: {
        withRoom: dayWithRoom.length,
        withoutRoom: dayWithoutRoom.length,
        totalParticipants: dayTotalParticipants,
        dateStr: selectedDate.toLocaleDateString(getDateLocale(), { day: '2-digit', month: 'short' })
      },
      week: {
        withRoom: weekWithRoom.length,
        withoutRoom: weekWithoutRoom.length,
        totalParticipants: weekTotalParticipants,
        period: `${weekStartStr} - ${weekEndStr}`
      },
      month: {
        withRoom: monthWithRoom.length,
        withoutRoom: monthWithoutRoom.length,
        totalParticipants: monthTotalParticipants,
        period: selectedDate.toLocaleDateString(getDateLocale(), { month: 'long', year: 'numeric' })
      }
    }
  }

  const stats = calculateStats()

  // Rechercher dans TOUTES les réservations (pas seulement le jour sélectionné)
  const searchResults = agendaSearchQuery
    ? allBookings.filter((b) => {
        const searchLower = agendaSearchQuery.toLowerCase()
        const contactData = getContactDisplayData(b)
        const customerName = `${contactData.firstName || ''} ${contactData.lastName || ''}`.toLowerCase().trim()
        const bookingDate = extractLocalDateFromISO(b.start_datetime)
        const startTime = new Date(b.start_datetime)
        const timeStr = `${String(startTime.getHours()).padStart(2, '0')}:${String(startTime.getMinutes()).padStart(2, '0')}`
        const notes = (b.notes || '').toLowerCase()
        const customerPhone = contactData.phone.toLowerCase()
        const customerEmail = contactData.email.toLowerCase()
        const referenceCode = (b.reference_code || '').toLowerCase()
        
        return (
          customerName.includes(searchLower) ||
          bookingDate.includes(searchLower) ||
          timeStr.includes(searchLower) ||
          notes.includes(searchLower) ||
          customerPhone.includes(searchLower) ||
          customerEmail.includes(searchLower) ||
          referenceCode.includes(searchLower) ||
          b.id.toLowerCase().includes(searchLower)
        )
      })
    : []

  const calendarDays = getCalendarDays()

  // Cache pour les réservations des autres branches (pour éviter de recharger à chaque fois)
  const [bookingsCache, setBookingsCache] = useState<Map<string, BookingWithSlots[]>>(new Map())

  // Fonction pour charger les réservations d'une branche spécifique (synchrone avec cache)
  const getBookingsForBranch = (branchId: string | null, date: Date): BookingWithSlots[] => {
    if (!branchId) return []
    
    // Si c'est la branche actuelle, utiliser allBookings
    if (branchId === selectedBranchId) {
      const dateStr = formatDateToString(date)
      return allBookings.filter(b => {
        const bookingDate = extractLocalDateFromISO(b.start_datetime)
        return bookingDate === dateStr
      })
    }

    // Vérifier le cache
    const cacheKey = `${branchId}-${formatDateToString(date)}`
    if (bookingsCache.has(cacheKey)) {
      return bookingsCache.get(cacheKey)!
    }

    // Si pas dans le cache, charger de manière asynchrone (mais retourner vide pour l'instant)
    // Le chargement se fera dans un useEffect séparé
    loadBookingsForBranchAsync(branchId, date)
    return []
  }

  // Fonction asynchrone pour charger les réservations d'une branche spécifique
  const loadBookingsForBranchAsync = async (branchId: string, date: Date) => {
    const cacheKey = `${branchId}-${formatDateToString(date)}`
    
    // Ne pas recharger si déjà en cache
    if (bookingsCache.has(cacheKey)) return

    const supabase = createClient()
    const dateStr = formatDateToString(date)
    const startOfDay = `${dateStr}T00:00:00.000Z`
    const endOfDay = `${dateStr}T23:59:59.999Z`

    try {
      const { data: bookingsData, error } = await supabase
        .from('bookings')
        .select('*')
        .eq('branch_id', branchId)
        .neq('status', 'CANCELLED')
        .gte('start_datetime', startOfDay)
        .lte('start_datetime', endOfDay)
        .order('start_datetime', { ascending: true })

      if (error) throw error

      // Charger les slots et contacts comme dans useBookings
      type BookingRow = { id: string; [key: string]: unknown }
      type SlotRow = { booking_id: string; [key: string]: unknown }
      type BookingContactRow = { booking_id: string; is_primary: boolean; contact: Contact | null }
      
      const typedBookings = (bookingsData || []) as BookingRow[]
      const bookingIds = typedBookings.map((b) => b.id)
      if (bookingIds.length > 0) {
        const { data: slotsData } = await supabase
          .from('booking_slots')
          .select('*')
          .in('booking_id', bookingIds)
          .order('slot_start')

        const { data: bookingContactsData } = await supabase
          .from('booking_contacts')
          .select('*, contact:contacts(*)')
          .in('booking_id', bookingIds)

        // Construire les bookings avec slots et contacts (simplifié)
        const typedSlots = (slotsData || []) as SlotRow[]
        const typedContacts = (bookingContactsData || []) as BookingContactRow[]
        const bookingsWithDetails: BookingWithSlots[] = typedBookings.map((b) => {
          const primaryContactData = typedContacts.find((bc) => bc.booking_id === b.id && bc.is_primary)
          return {
            ...b,
            slots: typedSlots.filter((s) => s.booking_id === b.id),
            primaryContact: primaryContactData?.contact || null,
          }
        }) as BookingWithSlots[]

        setBookingsCache(new Map(bookingsCache.set(cacheKey, bookingsWithDetails)))
      } else {
        setBookingsCache(new Map(bookingsCache.set(cacheKey, [])))
      }
    } catch (err) {
      console.error('Error loading bookings for branch:', err)
      setBookingsCache(new Map(bookingsCache.set(cacheKey, [])))
    }
  }

  // Fonction pour trouver la meilleure salle disponible pour un événement
  const findBestAvailableRoom = (
    participants: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string,
    targetBranchId?: string | null
  ): string | null => {
    // Utiliser la branche cible si fournie, sinon la branche actuelle
    const branchIdToUse = targetBranchId || selectedBranchId
    const targetBranch = branches.find(b => b.id === branchIdToUse)
    const targetRooms = targetBranch?.rooms || []
    
    if (!targetRooms || targetRooms.length === 0) return null

    // Obtenir les bookings de la branche cible (utilise le cache)
    const bookingsForBranch = getBookingsForBranch(branchIdToUse, startDateTime)
    // Déclencher le chargement asynchrone si nécessaire
    if (targetBranchId && targetBranchId !== selectedBranchId) {
      loadBookingsForBranchAsync(targetBranchId, startDateTime)
    }

    // Trier les salles par capacité croissante (plus petite salle en premier)
    const sortedRooms = [...targetRooms]
      .filter(room => room.is_active)
      .sort((a, b) => {
        // D'abord par capacité (croissant)
        if (a.capacity !== b.capacity) {
          return a.capacity - b.capacity
        }
        // Ensuite par sort_order (croissant)
        return a.sort_order - b.sort_order
      })

    // Filtrer les salles qui peuvent accueillir le nombre de participants
    const suitableRooms = sortedRooms.filter(room => room.capacity >= participants)

    if (suitableRooms.length === 0) return null

    // Vérifier la disponibilité de chaque salle dans l'ordre
    for (const room of suitableRooms) {
      // Vérifier si la salle est disponible pendant cette période
      let isAvailable = true

      for (const booking of bookingsForBranch) {
        // Exclure le booking en cours de modification
        if (excludeBookingId && booking.id === excludeBookingId) continue
        
        // Ne vérifier que les événements qui utilisent cette salle
        if (booking.type === 'EVENT' && booking.event_room_id === room.id) {
          const bookingStart = new Date(booking.start_datetime)
          const bookingEnd = new Date(booking.end_datetime)

          // Vérifier s'il y a un chevauchement
          if (
            (startDateTime >= bookingStart && startDateTime < bookingEnd) ||
            (endDateTime > bookingStart && endDateTime <= bookingEnd) ||
            (startDateTime <= bookingStart && endDateTime >= bookingEnd)
          ) {
            isAvailable = false
            break
          }
        }
      }

      if (isAvailable) {
        return room.id
      }
    }

    // Aucune salle disponible
    return null
  }

  // Fonction pour obtenir des informations détaillées sur la disponibilité des salles
  const findRoomAvailability = (
    participants: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string,
    targetBranchId?: string | null
  ): { bestRoomId: string | null; availableRoomWithLowerCapacity: { id: string; capacity: number } | null; hasAnyAvailableRoom: boolean } => {
    // Utiliser la branche cible si fournie, sinon la branche actuelle
    const branchIdToUse = targetBranchId || selectedBranchId
    const targetBranch = branches.find(b => b.id === branchIdToUse)
    const targetRooms = targetBranch?.rooms || []
    
    if (!targetRooms || targetRooms.length === 0) {
      return { bestRoomId: null, availableRoomWithLowerCapacity: null, hasAnyAvailableRoom: false }
    }

    // Obtenir les bookings de la branche cible (utilise le cache)
    const bookingsForBranch = getBookingsForBranch(branchIdToUse, startDateTime)
    // Déclencher le chargement asynchrone si nécessaire
    if (targetBranchId && targetBranchId !== selectedBranchId) {
      loadBookingsForBranchAsync(targetBranchId, startDateTime)
    }

    // Trier les salles par capacité croissante
    const sortedRooms = [...targetRooms]
      .filter(room => room.is_active)
      .sort((a, b) => {
        if (a.capacity !== b.capacity) {
          return a.capacity - b.capacity
        }
        return a.sort_order - b.sort_order
      })

    // Fonction pour vérifier si une salle est disponible
    const isRoomAvailable = (roomId: string): boolean => {
      for (const booking of bookingsForBranch) {
        // Exclure le booking en cours de modification
        if (excludeBookingId && booking.id === excludeBookingId) continue
        
        if (booking.type === 'EVENT' && booking.event_room_id === roomId) {
          const bookingStart = new Date(booking.start_datetime)
          const bookingEnd = new Date(booking.end_datetime)

          if (
            (startDateTime >= bookingStart && startDateTime < bookingEnd) ||
            (endDateTime > bookingStart && endDateTime <= bookingEnd) ||
            (startDateTime <= bookingStart && endDateTime >= bookingEnd)
          ) {
            return false
          }
        }
      }
      return true
    }

    // Chercher une salle avec capacité suffisante
    const suitableRooms = sortedRooms.filter(room => room.capacity >= participants)
    for (const room of suitableRooms) {
      if (isRoomAvailable(room.id)) {
        return { bestRoomId: room.id, availableRoomWithLowerCapacity: null, hasAnyAvailableRoom: true }
      }
    }

    // Si aucune salle avec capacité suffisante, chercher la plus grande salle disponible
    // (même si sa capacité est inférieure au nombre de participants demandé)
    let bestAvailableRoom: { id: string; capacity: number } | null = null
    let hasAnyAvailable = false

    // Trier par capacité décroissante pour trouver la plus grande salle disponible
    const sortedRoomsDesc = [...sortedRooms].sort((a, b) => {
      if (a.capacity !== b.capacity) {
        return b.capacity - a.capacity // Décroissant
      }
      return a.sort_order - b.sort_order
    })

    for (const room of sortedRoomsDesc) {
      if (isRoomAvailable(room.id)) {
        hasAnyAvailable = true
        // Prendre la première salle disponible (la plus grande)
        if (!bestAvailableRoom) {
          bestAvailableRoom = { id: room.id, capacity: room.capacity }
          break
        }
      }
    }

    return {
      bestRoomId: null,
      availableRoomWithLowerCapacity: bestAvailableRoom,
      hasAnyAvailableRoom: hasAnyAvailable
    }
  }

  // Fonction pour calculer l'overbooking potentiel d'une réservation
  const calculateOverbooking = (
    participants: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string,
    targetBranchId?: string | null
  ): { willCauseOverbooking: boolean; maxOverbookedCount: number; maxOverbookedSlots: number; affectedTimeSlots: Array<{ time: string; overbookedCount: number; overbookedSlots: number; totalParticipants: number; capacity: number }> } => {
    const CAPACITY = TOTAL_SLOTS * MAX_PLAYERS_PER_SLOT
    const affectedTimeSlots: Array<{ time: string; overbookedCount: number; overbookedSlots: number; totalParticipants: number; capacity: number }> = []
    let maxOverbookedCount = 0
    let maxOverbookedSlots = 0

    // Obtenir les bookings de la branche cible (utilise le cache)
    const branchIdToUse = targetBranchId || selectedBranchId
    const bookingsForBranch = getBookingsForBranch(branchIdToUse, startDateTime)
    // Déclencher le chargement asynchrone si nécessaire
    if (targetBranchId && targetBranchId !== selectedBranchId) {
      loadBookingsForBranchAsync(targetBranchId, startDateTime)
    }

    // Générer toutes les tranches de 15 minutes couvertes par cette réservation
    const bookingTimeSlots: Date[] = []
    let currentTime = new Date(startDateTime)
    while (currentTime < endDateTime) {
      const slotStart = new Date(currentTime)
      slotStart.setMinutes(Math.floor(slotStart.getMinutes() / SLOT_DURATION) * SLOT_DURATION, 0, 0)
      
      if (!bookingTimeSlots.some(ts => ts.getTime() === slotStart.getTime())) {
        bookingTimeSlots.push(new Date(slotStart))
      }
      
      currentTime = new Date(currentTime)
      currentTime.setMinutes(currentTime.getMinutes() + SLOT_DURATION)
    }

    // Pour chaque tranche de 15 minutes
    for (const timeSlotStart of bookingTimeSlots) {
      const timeSlotEnd = new Date(timeSlotStart)
      timeSlotEnd.setMinutes(timeSlotEnd.getMinutes() + SLOT_DURATION)

      // Calculer totalParticipants = somme des participants ACTIVE sur cette tranche (sans exclure le booking en cours de modification)
      // IMPORTANT: Ne compter que les sessions ACTIVE, pas LASER (LASER a sa propre logique de salles)
      let totalParticipants = participants // Inclure la nouvelle réservation
      for (const booking of bookingsForBranch) {
        if (booking.id === excludeBookingId) continue // Exclure le booking en cours de modification
        if (booking.type !== 'GAME' && booking.type !== 'EVENT') continue

        // Si le booking a des game_sessions, utiliser celles-ci (filtrer ACTIVE uniquement)
        if (booking.game_sessions && booking.game_sessions.length > 0) {
          for (const session of booking.game_sessions) {
            // Ne prendre en compte que les sessions ACTIVE pour l'overbooking
            if (session.game_area !== 'ACTIVE') continue

            const sessionStart = new Date(session.start_datetime)
            const sessionEnd = new Date(session.end_datetime)

            // Vérifier si cette session est active sur cette tranche
            if (sessionStart < timeSlotEnd && sessionEnd > timeSlotStart) {
              totalParticipants += booking.participants_count
              break // Une seule fois par booking (même si plusieurs sessions ACTIVE)
            }
          }
        } else {
          // Fallback pour anciens bookings sans game_sessions
          // Ne compter que si game_area est ACTIVE (ou non défini pour rétrocompatibilité)
          const bookingGameArea = (booking as any).game_area
          if (bookingGameArea === 'LASER') continue // Exclure les bookings LASER

          const bookingStart = booking.game_start_datetime ? new Date(booking.game_start_datetime) : new Date(booking.start_datetime)
          const bookingEnd = booking.game_end_datetime ? new Date(booking.game_end_datetime) : new Date(booking.end_datetime)

          if (bookingStart < timeSlotEnd && bookingEnd > timeSlotStart) {
            totalParticipants += booking.participants_count
          }
        }
      }

      const isOverbooked = totalParticipants > CAPACITY
      if (isOverbooked) {
        const overbookedCount = totalParticipants - CAPACITY
        const overbookedSlots = Math.ceil(overbookedCount / MAX_PLAYERS_PER_SLOT)
        
        maxOverbookedCount = Math.max(maxOverbookedCount, overbookedCount)
        maxOverbookedSlots = Math.max(maxOverbookedSlots, overbookedSlots)
        
        const timeLabel = timeSlotStart.toLocaleTimeString(getDateLocale(), { hour: '2-digit', minute: '2-digit' })
        affectedTimeSlots.push({
          time: timeLabel,
          overbookedCount,
          overbookedSlots,
          totalParticipants,
          capacity: CAPACITY
        })
      }
    }

    return {
      willCauseOverbooking: affectedTimeSlots.length > 0,
      maxOverbookedCount,
      maxOverbookedSlots,
      affectedTimeSlots
    }
  }

  // =====================================================
  // FONCTIONS LASER
  // =====================================================

  // Hook pour les laser rooms
  const { laserRooms, calculateVestsUsage, checkLaserRoomAvailability } = useLaserRooms(selectedBranchId)
  
  // Calculer le nombre de salles laser actives pour la branche sélectionnée
  const TOTAL_LASER_ROOMS = laserRooms.filter(r => r.is_active).length

  // Trouver la meilleure salle laser pour un booking
  const findBestLaserRoom = async (
    participants: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string,
    targetBranchId?: string | null,
    allocationMode: 'auto' | 'petit' | 'grand' | 'maxi' = 'auto'
  ): Promise<{ roomIds: string[]; requiresTwoRooms: boolean } | null> => {
    const branchIdToUse = targetBranchId || selectedBranchId
    const targetBranch = branches.find(b => b.id === branchIdToUse)
    const targetLaserRooms = targetBranch?.laserRooms?.filter(r => r.is_active) || []
    
    // Récupérer le seuil exclusif depuis les settings
    const exclusiveThreshold = targetBranch?.settings?.laser_exclusive_threshold || 10

    if (targetLaserRooms.length === 0) return null

    // Trier les salles par capacité croissante pour optimiser l'espace (plus petite salle suffisante en premier)
    const sortedRoomsByCapacity = [...targetLaserRooms].sort((a, b) => {
      if (a.capacity !== b.capacity) {
        return a.capacity - b.capacity // Croissant (L1=15 en premier, puis L2=20)
      }
      return a.sort_order - b.sort_order
    })

    // Fonction helper pour calculer la capacité restante d'une salle
    const getRoomRemainingCapacity = (roomId: string): number => {
      const room = targetLaserRooms.find(r => r.id === roomId)
      if (!room) return 0
      
      // CRITIQUE : Filtrer UNIQUEMENT les bookings de la branche cible
      // Chaque branche doit avoir ses salles laser totalement indépendantes
      const overlappingLaserBookings = allBookings.filter(b => {
        // FILTRE PAR BRANCHE : Exclure les bookings des autres branches
        if (b.branch_id !== branchIdToUse) return false
        if (excludeBookingId && b.id === excludeBookingId) return false
        if (!b.game_sessions || b.game_sessions.length === 0) return false
        
        return b.game_sessions.some(s => {
          if (s.game_area !== 'LASER') return false
          const sessionStart = new Date(s.start_datetime)
          const sessionEnd = new Date(s.end_datetime)
          return sessionStart < endDateTime && sessionEnd > startDateTime
        })
      })
      
      // RÈGLE 1 : Vérifier si une résa utilise mode MAXI (2 salles ou plus)
      // Si oui, TOUT le laser est bloqué pour ce créneau
      const hasMaxiMode = overlappingLaserBookings.some(b => {
        const laserRoomIds = b.game_sessions
          ?.filter(s => s.game_area === 'LASER')
          .map(s => s.laser_room_id)
          .filter((id): id is string => id !== null) || []
        const uniqueRoomIds = [...new Set(laserRoomIds)]
        return uniqueRoomIds.length > 1 // Mode Maxi = utilise plusieurs salles
      })
      
      if (hasMaxiMode) {
        return 0 // Créneau entier bloqué
      }
      
      // RÈGLE 2 : Vérifier si cette salle spécifique contient une résa au-delà du seuil exclusif
      // Si oui, la salle est EXCLUSIVE (fermée, personne d'autre ne peut s'ajouter)
      const hasExclusiveBooking = overlappingLaserBookings.some(b => {
        const isInThisRoom = b.game_sessions?.some(s => 
          s.game_area === 'LASER' && s.laser_room_id === roomId
        )
        return isInThisRoom && b.participants_count >= exclusiveThreshold
      })
      
      if (hasExclusiveBooking) {
        return 0 // Salle exclusive, groupe joue seul
      }
      
      // RÈGLE 3 : Calcul normal de capacité restante (seulement pour résas < 10 qui peuvent partager)
      const bookingsInThisRoom = overlappingLaserBookings.filter(b => 
        b.game_sessions?.some(s => s.game_area === 'LASER' && s.laser_room_id === roomId)
      )
      const currentParticipants = bookingsInThisRoom.reduce((sum, b) => sum + b.participants_count, 0)
      return room.capacity - currentParticipants
    }
    
    // ALLOCATION MANUELLE : Forcer une salle spécifique si mode != 'auto'
    if (allocationMode !== 'auto') {
      const smallRoom = sortedRoomsByCapacity[0] // Plus petite capacité
      const largeRoom = sortedRoomsByCapacity[sortedRoomsByCapacity.length - 1] // Plus grande capacité
      
      let forcedRoomIds: string[] = []
      
      if (allocationMode === 'petit') {
        forcedRoomIds = [smallRoom.id]
      } else if (allocationMode === 'grand') {
        forcedRoomIds = [largeRoom.id]
      } else if (allocationMode === 'maxi') {
        forcedRoomIds = targetLaserRooms.map(r => r.id)
      }
      
      // Vérifier capacité restante
      const totalRemaining = forcedRoomIds.reduce((sum, id) => sum + getRoomRemainingCapacity(id), 0)
      
      if (totalRemaining >= participants) {
        return { 
          roomIds: forcedRoomIds, 
          requiresTwoRooms: forcedRoomIds.length > 1 
        }
      } else {
        // Capacité insuffisante
        return null
      }
    }
    
    // Logique d'allocation AUTOMATIQUE basée sur la capacité restante
    // TOUJOURS vérifier la capacité restante, pas juste si vide
    
    // Si le groupe nécessite toutes les salles combinées
    if (participants > Math.max(...targetLaserRooms.map(r => r.capacity))) {
      // Vérifier si la capacité restante totale suffit
      const totalRemainingCapacity = targetLaserRooms.reduce((sum, r) => sum + getRoomRemainingCapacity(r.id), 0)
      if (totalRemainingCapacity >= participants) {
        return { 
          roomIds: targetLaserRooms.map(r => r.id), 
          requiresTwoRooms: targetLaserRooms.length > 1 
        }
      }
      return null // Vraiment plein
    }
    
    // Groupe >= exclusiveThreshold : PRÉFÈRE une salle vide seule, mais peut partager si nécessaire
    // Si >= exclusiveThreshold, la salle deviendra exclusive (bloquée aux autres) après allocation
    if (participants >= exclusiveThreshold) {
      // D'abord chercher une salle vide avec capacité suffisante
      for (const room of sortedRoomsByCapacity) {
        const remaining = getRoomRemainingCapacity(room.id)
        if (remaining === room.capacity && room.capacity >= participants) {
          // Salle vide et suffisante
          return { roomIds: [room.id], requiresTwoRooms: false }
        }
      }
      
      // Sinon, chercher une salle avec capacité restante suffisante (partage)
      for (const room of sortedRoomsByCapacity) {
        const remaining = getRoomRemainingCapacity(room.id)
        if (remaining >= participants) {
          // Capacité restante suffisante pour partager
          return { roomIds: [room.id], requiresTwoRooms: false }
        }
      }
      
      return null // Aucune salle ne peut accueillir le groupe
    }
    
    // Groupe < threshold : PEUT partager, chercher la plus petite salle avec capacité restante
    for (const room of sortedRoomsByCapacity) {
      const remaining = getRoomRemainingCapacity(room.id)
      if (remaining >= participants) {
        return { roomIds: [room.id], requiresTwoRooms: false }
      }
    }
    
    // Aucune salle ne peut accueillir le groupe
    return null
  }

  // Vérifier contrainte hard vests avec gestion des spare vests
  const checkLaserVestsConstraint = async (
    participants: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeBookingId?: string,
    targetBranchId?: string | null
  ): Promise<{ 
    isViolated: boolean; 
    needsSpareVests: boolean;
    currentUsage: number; 
    maxVests: number; 
    spareVests: number;
    totalVests: number;
    message: string 
  }> => {
    const branchIdToUse = targetBranchId || selectedBranchId
    const targetBranch = branches.find(b => b.id === branchIdToUse)
    const maxVests = targetBranch?.settings?.laser_total_vests || 0
    const spareVests = targetBranch?.settings?.laser_spare_vests || 0
    const totalVests = maxVests + spareVests

    if (maxVests === 0) {
      // Si pas de contrainte configurée, autoriser
      return { 
        isViolated: false, 
        needsSpareVests: false,
        currentUsage: 0, 
        maxVests: 0, 
        spareVests: 0,
        totalVests: 0,
        message: '' 
      }
    }

    // Calculer l'utilisation actuelle sur ce créneau (filtrer par branche)
    const currentUsage = await calculateVestsUsage(startDateTime, endDateTime, excludeBookingId, branchIdToUse)
    const totalWithNew = currentUsage + participants

    // Vérifier si on dépasse la limite principale
    const exceedsMain = totalWithNew > maxVests
    // Vérifier si on dépasse la limite totale (principale + spare)
    const exceedsTotal = totalWithNew > totalVests

    return {
      isViolated: exceedsTotal, // Bloque seulement si on dépasse la limite totale
      needsSpareVests: exceedsMain && !exceedsTotal, // Demande spare si on dépasse principale mais pas totale
      currentUsage,
      maxVests,
      spareVests,
      totalVests,
      message: exceedsTotal
        ? `Dépassement de la contrainte vestes (incluant spare) : ${totalWithNew} > ${totalVests} (REFUS)`
        : exceedsMain
          ? `Limite principale atteinte (${maxVests} vestes). ${spareVests} vestes spare disponibles.`
          : ''
    }
  }

  // Vérifier capacité soft d'une salle laser
  const checkLaserRoomCapacity = (
    roomId: string,
    participants: number,
    targetBranchId?: string | null
  ): { isExceeded: boolean; roomCapacity: number; overcapBy: number } => {
    const branchIdToUse = targetBranchId || selectedBranchId
    const targetBranch = branches.find(b => b.id === branchIdToUse)
    const room = targetBranch?.laserRooms?.find(r => r.id === roomId)

    if (!room) {
      return { isExceeded: false, roomCapacity: 0, overcapBy: 0 }
    }

    const isExceeded = participants > room.capacity
    const overcapBy = isExceeded ? participants - room.capacity : 0

    return {
      isExceeded,
      roomCapacity: room.capacity,
      overcapBy
    }
  }

  // Vérifier si un créneau contient un segment pour GRID GAME (slots uniquement)
  const getSegmentForCellSlots = (hour: number, minute: number, slotIndex: number): UISegment | null => {
    const cellDate = new Date(selectedDate)
    cellDate.setHours(hour, minute, 0, 0)
    const cellDateEnd = new Date(cellDate)
    cellDateEnd.setMinutes(cellDateEnd.getMinutes() + 15)

    // Parcourir les segments dans l'ordre inverse pour prioriser les plus récents
    for (let i = uiSegments.length - 1; i >= 0; i--) {
      const segment = uiSegments[i]
      
      // Vérifier si ce segment chevauche la cellule
      if (segment.start < cellDateEnd && segment.end > cellDate) {
        // Vérifier si le slotIndex demandé est dans la plage du segment
        if (slotIndex >= segment.slotStart && slotIndex < segment.slotEnd) {
          return segment
        }
      }
    }

    return null
  }

  // Obtenir tous les segments qui chevauchent une cellule LASER (pour affichage côte à côte)
  const getSegmentsForCellLaser = (hour: number, minute: number, roomIndex: number): UISegment[] => {
    const cellDate = new Date(selectedDate)
    cellDate.setHours(hour, minute, 0, 0)
    const cellDateEnd = new Date(cellDate)
    cellDateEnd.setMinutes(cellDateEnd.getMinutes() + 15)
    
    const selectedBranch = branches.find(b => b.id === selectedBranchId)
    const branchLaserRooms = selectedBranch?.laserRooms || []
    
    // Trier les laser rooms par sort_order
    const sortedLaserRooms = [...branchLaserRooms]
      .filter(r => r.is_active)
      .sort((a, b) => a.sort_order - b.sort_order)
    
    if (roomIndex >= sortedLaserRooms.length) return []
    
    const targetRoom = sortedLaserRooms[roomIndex]
    const segments: UISegment[] = []
    
    // IMPORTANT : Utiliser allBookings (toutes les réservations) au lieu de bookings (filtré par date)
    // car une réservation peut avoir start_datetime sur une autre date mais des sessions LASER sur cette date
    // Exemple : EVENT avec salle le 1er janvier mais sessions LASER le 2 janvier
    const dateStr = formatDateToString(selectedDate)
    
    // Chercher TOUS les bookings avec sessions LASER qui chevauchent ce créneau ET sont sur cette date
    const relevantBookings = allBookings.filter(b => {
      // Vérifier qu'il y a des game_sessions LASER
      if (!b.game_sessions || b.game_sessions.length === 0) return false
      
      // Trouver toutes les sessions LASER qui chevauchent ce créneau ET sont sur cette date
      const overlappingLaserSessions = b.game_sessions.filter(s => {
        if (s.game_area !== 'LASER') return false
        const sessionDate = extractLocalDateFromISO(s.start_datetime)
        // Vérifier que la session est sur la date sélectionnée
        if (sessionDate !== dateStr) return false
        // Vérifier que la session chevauche le créneau de la cellule
        const sessionStart = new Date(s.start_datetime)
        const sessionEnd = new Date(s.end_datetime)
        return sessionStart < cellDateEnd && sessionEnd > cellDate
      })
      
      return overlappingLaserSessions.length > 0
    })
    
    for (const booking of relevantBookings) {
      // Vérifier si le booking a des game_sessions LASER
      if (booking.game_sessions && booking.game_sessions.length > 0) {
        // Trouver toutes les sessions LASER de ce booking qui chevauchent ce créneau
        const overlappingSessions = booking.game_sessions.filter(session => {
          if (session.game_area !== 'LASER') return false
          const sessionStart = new Date(session.start_datetime)
          const sessionEnd = new Date(session.end_datetime)
          return sessionStart < cellDateEnd && sessionEnd > cellDate
        })
        
        if (overlappingSessions.length === 0) continue
        
        // Vérifier si une de ces sessions utilise la salle cible
        const sessionForThisRoom = overlappingSessions.find(s => s.laser_room_id === targetRoom.id)
        if (!sessionForThisRoom) continue
        
        // Trouver toutes les salles utilisées par ce booking pour CE CRÉNEAU SPÉCIFIQUE
        // Important: ne prendre que les sessions qui chevauchent exactement ce créneau
        const usedRoomIds = new Set(overlappingSessions.map(s => s.laser_room_id).filter(Boolean))
        const usedRooms = sortedLaserRooms.filter(r => usedRoomIds.has(r.id))
        
        if (usedRooms.length === 0) continue
        
        // Trier les salles utilisées par sort_order pour déterminer slotStart et slotEnd
        usedRooms.sort((a, b) => a.sort_order - b.sort_order)
        const firstRoomIndex = sortedLaserRooms.findIndex(r => r.id === usedRooms[0].id)
        const lastRoomIndex = sortedLaserRooms.findIndex(r => r.id === usedRooms[usedRooms.length - 1].id)
        
        // IMPORTANT: Utiliser les dates de la session spécifique, pas une fusion
        // Cela permet d'afficher chaque jeu (session_order) séparément
        const sessionStart = new Date(sessionForThisRoom.start_datetime)
        const sessionEnd = new Date(sessionForThisRoom.end_datetime)
        
        // Créer le segment avec un ID unique incluant session_order pour différencier les jeux
        const segment: UISegment = {
          segmentId: `${booking.id}-laser-${sessionForThisRoom.session_order}-${firstRoomIndex}-${lastRoomIndex}-${sessionStart.getTime()}`,
          bookingId: booking.id,
          booking,
          start: sessionStart,
          end: sessionEnd,
          slotStart: firstRoomIndex,
          slotEnd: lastRoomIndex + 1, // +1 car slotEnd est exclusif
          slotsKey: `laser-${firstRoomIndex}-${lastRoomIndex}`,
          isOverbooked: false // Laser n'a pas d'overbooking
        }
        
        segments.push(segment)
      }
    }
    
    // Trier les segments par bookingId pour un affichage stable
    segments.sort((a, b) => a.bookingId.localeCompare(b.bookingId))
    
    return segments
  }

  // Fonction de compatibilité : retourne le premier segment (pour le code existant)
  const getSegmentForCellLaser = (hour: number, minute: number, roomIndex: number): UISegment | null => {
    const segments = getSegmentsForCellLaser(hour, minute, roomIndex)
    return segments.length > 0 ? segments[0] : null
  }

  // Vérifier si un créneau contient un segment pour GRID ROOMS (rooms uniquement)
  const getSegmentForCellRooms = (hour: number, minute: number, roomIndex: number): UISegment | null => {
    const cellTime = hour * 60 + minute
    const cellDate = new Date(selectedDate)
    cellDate.setHours(hour, minute, 0, 0)
    const cellDateEnd = new Date(cellDate)
    cellDateEnd.setMinutes(cellDateEnd.getMinutes() + 15)
    
    const selectedBranch = branches.find(b => b.id === selectedBranchId)
    const branchRooms = selectedBranch?.rooms || []
    
    for (let i = bookings.length - 1; i >= 0; i--) {
      const booking = bookings[i]
      // RÈGLE BÉTON : Rooms = uniquement EVENT
      if (booking.type !== 'EVENT') continue
      if (!booking.event_room_id) continue

      const bookingRoom = branchRooms.find(r => r.id === booking.event_room_id)
      if (!bookingRoom) continue

      const sortedRooms = [...branchRooms]
        .filter(r => r.is_active)
        .sort((a, b) => a.sort_order - b.sort_order)
      
      const bookingRoomIndex = sortedRooms.findIndex(r => r.id === booking.event_room_id)
      if (bookingRoomIndex !== roomIndex) continue

      // Pour les événements, afficher la salle d'événement pendant toute sa durée
      // IMPORTANT : La grille ROOMS affiche la réservation de la salle
      // Les sessions ACTIVE apparaissent dans la grille ACTIVE, les sessions LASER dans la grille LASER
      // On affiche la salle pendant toute sa durée (start_datetime à end_datetime) pour montrer qu'elle est réservée
      const startTime = new Date(booking.start_datetime)
      const endTime = new Date(booking.end_datetime)
      const bookingStartMinutes = startTime.getHours() * 60 + startTime.getMinutes()
      const bookingEndMinutes = endTime.getHours() * 60 + endTime.getMinutes()
      
      if (cellTime >= bookingStartMinutes && cellTime < bookingEndMinutes) {
        // Retourner un segment pour la salle d'événement
        return {
          segmentId: `${booking.id}-room-${roomIndex}`,
          bookingId: booking.id,
          booking,
          start: startTime,
          end: endTime,
          slotStart: roomIndex,
          slotEnd: roomIndex + 1,
          slotsKey: `room-${roomIndex}`,
          isOverbooked: false // Rooms n'ont pas d'overbooking
        }
      }
    }
    return null
  }

  // Calculer les dimensions d'une réservation (nombre de créneaux horaires et de slots)
  const getBookingDimensions = (booking: BookingWithSlots, isRoom: boolean): {
    timeSlots: number // Nombre de créneaux horaires (30 min chacun)
    slotCount: number // Nombre de slots verticaux
    startTimeSlotIndex: number // Index du premier créneau horaire
    startSlotIndex: number // Index du premier slot vertical
  } => {
    // Pour LASER, compter le nombre de JEUX (session_order uniques), pas la durée totale
    if (booking.type === 'GAME' && booking.game_sessions && booking.game_sessions.length > 0) {
      const laserSessions = booking.game_sessions.filter(s => s.game_area === 'LASER')
      if (laserSessions.length > 0) {
        // Compter les session_order uniques
        const uniqueGameNumbers = new Set(laserSessions.map(s => s.session_order))
        const numberOfGames = uniqueGameNumbers.size
        
        let slotCount = 1
        let startSlotIndex = 0
        
        if (!isRoom && booking.type === 'GAME') {
          slotCount = Math.ceil(booking.participants_count / 6)
          startSlotIndex = 0
        }
        
        return {
          timeSlots: numberOfGames, // Nombre de jeux, pas de créneaux de temps
          slotCount,
          startTimeSlotIndex: 0,
          startSlotIndex
        }
      }
    }
    
    // Pour ACTIVE et autres : utiliser la durée totale
    const startTime = new Date(booking.game_start_datetime || booking.start_datetime)
    const endTime = new Date(booking.game_end_datetime || booking.end_datetime)
    const bookingStartMinutes = startTime.getHours() * 60 + startTime.getMinutes()
    const bookingEndMinutes = endTime.getHours() * 60 + endTime.getMinutes()
    
    // Calculer le nombre de créneaux horaires (chaque créneau = 30 min)
    const durationMinutes = bookingEndMinutes - bookingStartMinutes
    const numberOfTimeSlots = Math.ceil(durationMinutes / 30)
    
    let slotCount = 1
    let startSlotIndex = 0
    
    if (!isRoom && booking.type === 'GAME') {
      slotCount = Math.ceil(booking.participants_count / 6)
      startSlotIndex = 0 // Les slots commencent toujours à 0 pour les jeux
    } else if (isRoom && booking.type === 'EVENT') {
      slotCount = 1
      // Pour les salles, trouver l'index de la salle
      // On doit trouver quelle salle est utilisée (pour l'instant, on suppose que c'est la première disponible)
      startSlotIndex = 0
    }
    
    return {
      timeSlots: numberOfTimeSlots,
      slotCount,
      startTimeSlotIndex: 0, // Non utilisé pour l'instant
      startSlotIndex
    }
  }


  // Loading state
  if (loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <Loader2 className="w-12 h-12 text-blue-500 animate-spin mx-auto mb-4" />
          <p className="text-gray-400">{t('admin.common.loading')}</p>
        </div>
      </div>
    )
  }

  // Not authenticated
  if (!userData) {
    return null
  }

  const selectedBranchFromUserData = userData.branches.find(b => b.id === selectedBranchId)
  // Récupérer le Branch complet depuis useBranches
  const selectedBranch = branches.find(b => b.id === selectedBranchId) || (branches.length > 0 ? branches[0] : null)
  const isDark = theme === 'dark'

  // Conversion userData vers format AuthUser pour AdminHeader
  // Utiliser les branches complètes de useBranches pour avoir toutes les propriétés
  const authUserBranches = branches.filter(b => 
    userData?.branches.some(ub => ub.id === b.id)
  )

  const authUser = userData ? {
    id: userData.id,
    email: userData.email,
    role: userData.role as UserRole,
    profile: userData.profile as Profile | null,
    branches: authUserBranches,
    isSuperAdmin: userData.role === 'super_admin',
    isBranchAdmin: userData.role === 'branch_admin',
    isAgent: userData.role === 'agent',
  } : null

  // Récupérer les salles et settings de la branche sélectionnée
  const branchWithDetails = branches.find(b => b.id === selectedBranchId)
  const branchRooms = branchWithDetails?.rooms || []
  const branchSettings = branchWithDetails?.settings || null

  // Fonction helper pour formater l'heure (HH:mm)
  const formatTime = (date: Date): string => {
    const hours = date.getHours().toString().padStart(2, '0')
    const minutes = date.getMinutes().toString().padStart(2, '0')
    return `${hours}:${minutes}`
  }

  // Classes CSS pour l'affichage selon les paramètres
  const getTextSizeClass = (size: string) => {
    switch (size) {
      case 'xs': return 'text-xs'
      case 'sm': return 'text-sm'
      case 'base': return 'text-base'
      case 'lg': return 'text-lg'
      default: return 'text-sm'
    }
  }

  const getTextWeightClass = (weight: string) => {
    switch (weight) {
      case 'normal': return 'font-normal'
      case 'semibold': return 'font-semibold'
      case 'bold': return 'font-bold'
      default: return 'font-bold'
    }
  }

  const getTextAlignClass = (align: string) => {
    switch (align) {
      case 'left': return 'text-left'
      case 'center': return 'text-center'
      case 'right': return 'text-right'
      default: return 'text-left'
    }
  }

  return (
    <div className={`min-h-screen ${isDark ? 'bg-gray-900' : 'bg-gray-100'}`}>
      {/* Header avec navigation */}
      {!loading && authUser && branches.length > 0 && (
        <AdminHeader
          user={authUser}
          branches={branches}
          selectedBranch={selectedBranch || branches[0]}
          onBranchSelect={(branchId) => {
            branchesHook.selectBranch(branchId) // Utiliser selectBranch du hook pour synchroniser avec le CRM
            setShowBranchMenu(false)
          }}
          onSignOut={handleSignOut}
          theme={theme}
          onToggleTheme={toggleTheme}
        />
      )}

      {/* Contenu principal */}
      <main className="p-6">
        {/* Barre de recherche */}
        <AgendaSearch
          searchQuery={agendaSearchQuery}
          onSearchChange={setAgendaSearchQuery}
          searchResults={searchResults}
          onSelectBooking={(booking, bookingDate) => {
            setSelectedDate(bookingDate)
            setCalendarMonth(bookingDate.getMonth())
            setCalendarYear(bookingDate.getFullYear())
            setAgendaSearchQuery('')
            openBookingModal(undefined, undefined, booking)
          }}
          isDark={isDark}
        />

        {/* Statistiques Agenda (Jour, Semaine, Mois) */}
        <AgendaStats stats={stats} isDark={isDark} />

        {/* Navigation de date */}
        <div className="flex items-center justify-between mb-6 gap-4">
          {/* GAUCHE : Boutons Paramètres + Boutons de rétractation */}
          <div className="flex gap-2">
            {/* Bouton Paramètres de la branche */}
            <button
              onClick={() => setShowBranchSettingsModal(true)}
              className={`p-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              }`}
              title={t('admin.agenda.settings.branch_title')}
            >
              <Settings className="w-5 h-5" />
            </button>
            
            {/* Bouton Paramètres de la grille */}
            <button
              onClick={() => setShowGridSettingsModal(true)}
              className={`p-2 rounded-lg transition-colors ${
                isDark
                  ? 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              }`}
              title={t('admin.agenda.settings.grid_title')}
            >
              <Sliders className="w-5 h-5" />
            </button>
            
            <button
              onClick={() => setVisibleGrids(prev => ({ ...prev, active: !prev.active }))}
              className={`px-3 py-2 rounded-lg font-medium text-sm transition-colors ${
                visibleGrids.active
                  ? isDark
                    ? 'bg-blue-600 text-white'
                    : 'bg-blue-500 text-white'
                  : isDark
                    ? 'bg-gray-700 text-gray-400 hover:bg-gray-600'
                    : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
              }`}
            >
              ACTIVE
            </button>
            <button
              onClick={() => setVisibleGrids(prev => ({ ...prev, laser: !prev.laser }))}
              className={`px-3 py-2 rounded-lg font-medium text-sm transition-colors ${
                visibleGrids.laser
                  ? isDark
                    ? 'bg-purple-600 text-white'
                    : 'bg-purple-500 text-white'
                  : isDark
                    ? 'bg-gray-700 text-gray-400 hover:bg-gray-600'
                    : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
              }`}
            >
              LASER
            </button>
            <button
              onClick={() => setVisibleGrids(prev => ({ ...prev, rooms: !prev.rooms }))}
              className={`px-3 py-2 rounded-lg font-medium text-sm transition-colors ${
                visibleGrids.rooms
                  ? isDark
                    ? 'bg-green-600 text-white'
                    : 'bg-green-500 text-white'
                  : isDark
                    ? 'bg-gray-700 text-gray-400 hover:bg-gray-600'
                    : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
              }`}
            >
              ROOMS
            </button>
          </div>

          {/* CENTRE : Date sélectionnée avec flèches jour précédent/suivant + bouton Aujourd'hui + Icône calendrier */}
          <div className="flex items-center gap-2 flex-1 justify-center">
            {/* Icône calendrier */}
            <div className="relative">
              <button
                onClick={() => setShowCalendarModal(!showCalendarModal)}
                className={`p-2 ${isDark ? 'bg-gray-800 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'} border ${isDark ? 'border-gray-700' : 'border-gray-300'} rounded-lg transition-all`}
                title={t('admin.agenda.settings.open_calendar')}
              >
                <Calendar className={`w-5 h-5 ${isDark ? 'text-white' : 'text-gray-900'}`} />
              </button>

              {/* Modal Calendrier */}
              {showCalendarModal && (
                <>
                  <div
                    className="fixed inset-0 z-40"
                    onClick={() => setShowCalendarModal(false)}
                  />
                  <div className={`absolute left-0 top-12 z-50 ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'} rounded-lg shadow-xl p-4 min-w-[280px]`}>
                    {/* Navigation Mois/Année */}
                    <div className="flex items-center justify-between mb-4">
                      <button
                        onClick={handlePreviousYear}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.agenda.settings.previous_year')}
                      >
                        <div className="relative w-4 h-4">
                          <ChevronLeft className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute`} />
                          <ChevronLeft className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute left-1`} />
                        </div>
                      </button>
                      <button
                        onClick={handlePreviousMonth}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.agenda.settings.previous_month')}
                      >
                        <ChevronLeft className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'}`} />
                      </button>
                      <div className={`text-base font-bold ${isDark ? 'text-white' : 'text-gray-900'} px-4`}>
                        {getMonthName(calendarMonth)} {calendarYear}
                      </div>
                      <button
                        onClick={handleNextMonth}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.agenda.settings.next_month')}
                      >
                        <ChevronRight className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'}`} />
                      </button>
                      <button
                        onClick={handleNextYear}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.agenda.settings.next_year')}
                      >
                        <div className="relative w-4 h-4">
                          <ChevronRight className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute`} />
                          <ChevronRight className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute left-1`} />
                        </div>
                      </button>
                    </div>

                    {/* Grille calendrier */}
                    <div className="grid grid-cols-7 gap-1">
                      {/* En-têtes jours */}
                      {(tArray('admin.agenda.days_short').length > 0 ? tArray('admin.agenda.days_short') : ['L', 'M', 'M', 'J', 'V', 'S', 'D']).map((day, i) => (
                        <div key={i} className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-600'} text-center p-1 font-bold`}>
                          {day}
                        </div>
                      ))}
                      {/* Jours */}
                      {calendarDays.map((date, i) => {
                        if (!date) {
                          return <div key={`empty-${i}`} className="p-2"></div>
                        }
                        const isToday = date.toDateString() === new Date().toDateString()
                        const isSelected = date.toDateString() === selectedDate.toDateString()
                        
                        return (
                          <button
                            key={i}
                            onClick={() => handleCalendarDateClick(date)}
                            className={`p-2 rounded text-sm transition-all ${
                              isSelected
                                ? `${isDark ? 'bg-blue-600/30' : 'bg-blue-100'} ${isDark ? 'text-blue-400' : 'text-blue-600'} font-bold`
                                : isToday
                                ? `${isDark ? 'bg-blue-500/20' : 'bg-blue-50'} ${isDark ? 'text-blue-400' : 'text-blue-600'}`
                                : `${isDark ? 'text-white hover:bg-gray-700' : 'text-gray-900 hover:bg-gray-100'}`
                            }`}
                          >
                            {date.getDate()}
                          </button>
                        )
                      })}
                    </div>
                  </div>
                </>
              )}
            </div>

            {/* Flèche jour précédent */}
            <button
              onClick={goToPrevDay}
              className={`p-2 ${isDark ? 'bg-gray-800 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'} border ${isDark ? 'border-gray-700' : 'border-gray-300'} rounded-lg transition-all`}
            >
              <ChevronLeft className={`w-5 h-5 ${isDark ? 'text-white' : 'text-gray-900'}`} />
            </button>
            
            {/* Date sélectionnée */}
            <div className={`text-lg font-bold ${isDark ? 'text-white' : 'text-gray-900'} min-w-[200px] text-center`}>
              {formatDateFull(selectedDate)}
            </div>
            
            {/* Flèche jour suivant */}
            <button
              onClick={goToNextDay}
              className={`p-2 ${isDark ? 'bg-gray-800 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'} border ${isDark ? 'border-gray-700' : 'border-gray-300'} rounded-lg transition-all`}
            >
              <ChevronRight className={`w-5 h-5 ${isDark ? 'text-white' : 'text-gray-900'}`} />
            </button>
            
            {/* Bouton Aujourd'hui */}
            <button
              onClick={goToToday}
              className={`px-3 py-2 ${isDark ? 'bg-blue-600/20 border-blue-500/50 hover:bg-blue-600/30' : 'bg-blue-100 border-blue-300 hover:bg-blue-200'} border rounded-lg transition-all text-sm ${isDark ? 'text-blue-400' : 'text-blue-600'}`}
            >
              {t('admin.agenda.today_button')}
            </button>
          </div>

          {/* DROITE : Jours de la semaine avec navigation semaine */}
          <div className="flex items-center gap-2">
            {/* Flèche gauche : semaine précédente */}
            <button
              onClick={handlePreviousWeek}
              className={`p-2 ${isDark ? 'bg-gray-800 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'} border ${isDark ? 'border-gray-700' : 'border-gray-300'} rounded-lg transition-all`}
              title={t('admin.agenda.settings.previous_week')}
            >
              <ChevronLeft className={`w-5 h-5 ${isDark ? 'text-white' : 'text-gray-900'}`} />
            </button>
            
            {/* Jours de la semaine */}
            <div className="flex gap-2">
              {getWeekDays().map((day, index) => {
                const isToday = day.toDateString() === new Date().toDateString()
                const isSelected = day.toDateString() === selectedDate.toDateString()
                return (
                  <button
                    key={index}
                    onClick={() => handleWeekDayClick(day)}
                    className={`px-3 py-2 rounded-lg border text-sm font-medium transition-all ${
                      isSelected
                        ? `${isDark ? 'bg-blue-600/20 border-blue-500' : 'bg-blue-100 border-blue-500'} ${isDark ? 'text-blue-400' : 'text-blue-600'} font-bold`
                        : isToday
                        ? `${isDark ? 'bg-blue-500/10 border-blue-500/30' : 'bg-blue-50 border-blue-300'} ${isDark ? 'text-blue-400' : 'text-blue-600'}`
                        : `${isDark ? 'bg-gray-800 border-gray-700 text-white hover:bg-gray-700' : 'bg-gray-200 border-gray-300 text-gray-900 hover:bg-gray-300'}`
                    }`}
                  >
                    <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-600'} leading-tight`}>
                      {day.toLocaleDateString(getDateLocale(), { weekday: 'short' })}
                    </div>
                    <div className={`text-sm font-bold leading-tight ${isDark ? 'text-white' : 'text-gray-900'}`}>
                      {day.getDate()}
                    </div>
                  </button>
                )
              })}
            </div>
            
            {/* Flèche droite : semaine suivante */}
            <button
              onClick={handleNextWeek}
              className={`p-2 ${isDark ? 'bg-gray-800 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'} border ${isDark ? 'border-gray-700' : 'border-gray-300'} rounded-lg transition-all`}
              title={t('admin.agenda.settings.next_week')}
            >
              <ChevronRight className={`w-5 h-5 ${isDark ? 'text-white' : 'text-gray-900'}`} />
            </button>
          </div>
        </div>

        {/* Erreur */}
        {bookingsError && (
          <div className="mb-4 p-4 bg-red-500/10 border border-red-500/50 rounded-lg text-red-400">
            {bookingsError}
          </div>
        )}

        {/* Grille de l'agenda */}
        <div className={`rounded-xl overflow-hidden relative ${isDark ? 'bg-gray-800' : 'bg-white'}`} style={{ 
          position: 'relative',
          border: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`, // Même épaisseur que les cellules (2px)
          width: '100%',
          maxWidth: '100%'
        }}>
          {/* Loader sur la grille */}
          {bookingsLoading && (
            <div className="absolute inset-0 bg-gray-900/50 flex items-center justify-center z-10">
              <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
            </div>
          )}

          {/* 3 Grilles séparées côte à côte */}
          <div className="flex gap-0" style={{ width: '100%', minWidth: 0, overflowX: 'auto' }}>
            {/* GRID GAME - Heure + S1-S14 */}
            {visibleGrids.active && (
            <div style={{ flexGrow: gridWidths.active / 100, flexShrink: 1, flexBasis: `${gridWidths.active}%`, minWidth: `${Math.max(100, 80 + TOTAL_SLOTS * 30 * gridWidths.active / 100)}px`, borderRight: `2px solid ${isDark ? '#374151' : '#e5e7eb'}` }}>
              {/* En-tête GRID GAME */}
              <div className={`grid ${isDark ? '' : ''}`} style={{
                gridTemplateColumns: `80px repeat(${TOTAL_SLOTS}, minmax(30px, 1fr))`,
                borderBottom: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`
              }}>
                <div className={`p-3 text-center font-medium ${isDark ? 'text-gray-400 bg-gray-900' : 'text-gray-600 bg-gray-50'}`}>
                  {t('admin.agenda.grid_headers.hour')}
                </div>
                {Array.from({ length: TOTAL_SLOTS }, (_, i) => (
                  <div key={`slot-${i}`} className={`p-3 text-center font-medium border-l ${isDark ? 'text-blue-400 bg-gray-900 border-gray-700' : 'text-blue-600 bg-gray-50 border-gray-200'}`}>
                    S{i + 1}
                  </div>
                ))}
              </div>

              {/* Corps GRID GAME */}
              <div className="grid" style={{
                gridTemplateColumns: `80px repeat(${TOTAL_SLOTS}, minmax(30px, 1fr))`,
                gridTemplateRows: `repeat(${timeSlots.length}, ${rowHeight}px)`,
                minWidth: 0
              }}>
            {/* Colonne Heure */}
            {timeSlots.map((slot, timeIndex) => {
              // Pour avoir des lignes visibles à 10:00, 10:30, 11:00, etc. (créneaux de 30 minutes)
              // La bordure borderBottom d'une case crée une ligne en bas de cette case
              // Donc pour avoir une ligne à 10:30, il faut une bordure sur la case 10:15 (qui précède)
              // Mais on veut aussi une ligne à 10:00, donc bordure sur la case 10:00
              // En fait, on veut des bordures sur les cases de 30 minutes (0 et 30) ET sur les cases de 15 minutes qui précèdent (pour créer la ligne)
              // Non, en fait : si on veut une ligne à 10:30, il faut une bordure sur la case 10:15 (qui est juste avant)
              // Mais on ne veut pas de ligne à 10:15, donc pas de bordure sur 10:00
              // Attendez, réfléchissons différemment :
              // - Case 10:00 → bordure en bas → ligne entre 10:00 et 10:15 (on veut cette ligne ? Non, on veut ligne à 10:30)
              // - Case 10:15 → bordure en bas → ligne entre 10:15 et 10:30 (on veut cette ligne ? Oui, c'est la ligne de 10:30)
              // - Case 10:30 → bordure en bas → ligne entre 10:30 et 10:45 (on veut cette ligne ? Non)
              // - Case 10:45 → bordure en bas → ligne entre 10:45 et 11:00 (on veut cette ligne ? Oui, c'est la ligne de 11:00)
              
              // Pour aligner avec les cellules : borderTop visible sur 0 et 30 dans les cellules
              // Donc on utilise borderTop sur les cases de 30 minutes (0 et 30) dans la colonne des heures
              const showBorder = (slot.minute === 0 || slot.minute === 30)
              
              return (
                <div
                  key={`time-${timeIndex}`}
                  onClick={() => openBookingModal(slot.hour, slot.minute, undefined, 'GAME', 'ACTIVE')}
                  className={`p-2 text-center text-sm cursor-pointer ${isDark ? 'text-gray-500 hover:text-gray-300 hover:bg-gray-800/50' : 'text-gray-400 hover:text-gray-600 hover:bg-gray-100'}`}
                  style={{ 
                    gridColumn: '1', 
                    gridRow: timeIndex + 1,
                    // Afficher borderTop sur les cases de 30 minutes pour aligner avec les cellules
                    // Appliquer la même épaisseur que les cellules (2px solid)
                    borderTop: showBorder ? `2px solid ${isDark ? '#374151' : '#e5e7eb'}` : 'none',
                    borderBottom: 'none',
                    borderLeft: 'none',
                    borderRight: `2px solid ${isDark ? '#374151' : '#e5e7eb'}` // Bordure droite pour séparer de la grille
                  }}
                >
                  {(slot.minute === 0 || slot.minute === 30) ? slot.label : ''}
                </div>
              )
            })}
            
            {/* Cellules pour les slots et salles */}
            {timeSlots.map((slot, timeIndex) => {
              return (
                <Fragment key={`row-${timeIndex}`}>
                  {/* Slots de jeu */}
                  {Array.from({ length: TOTAL_SLOTS }, (_, slotIndex) => {
                    const segment = getSegmentForCellSlots(slot.hour, slot.minute, slotIndex)
                    const booking = segment?.booking
                    
                    // Déterminer si cette cellule est le début d'un segment (top-left corner)
                    // Utiliser segmentId au lieu de booking.id
                    const isSegmentTop = segment && (
                      timeIndex === 0 ||
                      getSegmentForCellSlots(timeSlots[timeIndex - 1].hour, timeSlots[timeIndex - 1].minute, slotIndex)?.segmentId !== segment.segmentId
                    )
                    const isSegmentStart = segment && (
                      slotIndex === segment.slotStart || 
                      getSegmentForCellSlots(slot.hour, slot.minute, slotIndex - 1)?.segmentId !== segment.segmentId
                    )
                    const isSegmentEnd = segment && (
                      slotIndex === segment.slotEnd - 1 || 
                      getSegmentForCellSlots(slot.hour, slot.minute, slotIndex + 1)?.segmentId !== segment.segmentId
                    )
                    const isSegmentBottom = segment && (
                      timeIndex === timeSlots.length - 1 ||
                      getSegmentForCellSlots(timeSlots[timeIndex + 1].hour, timeSlots[timeIndex + 1].minute, slotIndex)?.segmentId !== segment.segmentId
                    )
                    
                    // Si cette cellule fait partie d'un segment mais n'est pas le début, ne pas la rendre
                    const isPartOfSegment = segment && !(isSegmentStart && isSegmentTop)
                    if (isPartOfSegment) return null

                    // Afficher les détails uniquement sur le premier segment du booking (premier segment continu)
                    // Vérifier si c'est le premier segment de ce booking (pas juste le premier segment de 15 min)
                    const isFirstSegmentOfBooking = segment && (
                      timeIndex === 0 || 
                      getSegmentForCellSlots(timeSlots[timeIndex - 1].hour, timeSlots[timeIndex - 1].minute, slotIndex)?.bookingId !== segment.bookingId
                    )
                    const showDetails = segment && isSegmentStart && isSegmentTop && isFirstSegmentOfBooking
                    
                    const gridColumn = slotIndex + 2 // +2 car colonne 1 = Heure
                    const gridRow = timeIndex + 1
                    
                    // Calculer les spans pour les segments
                    let colSpan = 1
                    let rowSpan = 1
                    if (segment) {
                      // colSpan basé sur le nombre de slots du segment
                      colSpan = segment.slotEnd - segment.slotStart
                      
                      // rowSpan basé sur la durée du segment (pas du booking global)
                      const segmentStartMinutes = segment.start.getHours() * 60 + segment.start.getMinutes()
                      const segmentEndMinutes = segment.end.getHours() * 60 + segment.end.getMinutes()
                      const durationMinutes = segmentEndMinutes - segmentStartMinutes
                      rowSpan = Math.ceil(durationMinutes / 15) // Cases de 15 minutes
                    }
                    
                    // Vérifier les segments adjacents pour les bordures de quadrillage
                    const leftSegment = slotIndex > 0 ? getSegmentForCellSlots(slot.hour, slot.minute, slotIndex - 1) : null
                    const rightSegment = slotIndex < TOTAL_SLOTS - 1 ? getSegmentForCellSlots(slot.hour, slot.minute, slotIndex + 1) : null
                    const topSegment = timeIndex > 0 ? getSegmentForCellSlots(timeSlots[timeIndex - 1].hour, timeSlots[timeIndex - 1].minute, slotIndex) : null
                    
                    const isDifferentBookingLeft = segment && leftSegment && segment.bookingId !== leftSegment.bookingId
                    const isDifferentBookingRight = segment && rightSegment && segment.bookingId !== rightSegment.bookingId
                    const isDifferentBookingTop = segment && topSegment && segment.bookingId !== topSegment.bookingId
                    const isEmptyLeft = !segment && leftSegment
                    const isEmptyRight = !segment && rightSegment
                    
                    // Bordures verticales : TOUJOURS afficher le quadrillage entre slots
                    // Si c'est une réservation, utiliser gris pour le contour, sinon gris du quadrillage
                    const borderLeftColor = booking 
                      ? (isDark ? '#6b7280' : '#9ca3af') // Gris pour contour réservation
                      : (slotIndex === 0 ? 'none' : (isDark ? '#374151' : '#e5e7eb')) // Quadrillage (pas de bordure à gauche du premier slot)
                    const borderRightColor = booking
                      ? (isDark ? '#6b7280' : '#9ca3af') // Gris pour contour réservation
                      : (slotIndex === TOTAL_SLOTS - 1 ? 'none' : (isDark ? '#374151' : '#e5e7eb')) // Quadrillage (pas de bordure à droite du dernier slot)
                    
                    // Pour les réservations fusionnées, ne pas afficher les bordures internes
                    const showLeftBorder = !booking || slotIndex === segment.slotStart || isDifferentBookingLeft
                    const showRightBorder = !booking || slotIndex === segment.slotEnd - 1 || isDifferentBookingRight
                    
                    // Bordures horizontales : quadrillage toutes les 15 min
                    const shouldShowTopBorder = true
                    const borderTopColor = isDifferentBookingTop 
                      ? (isDark ? '#374151' : '#e5e7eb')
                      : (booking ? (isDark ? '#6b7280' : '#9ca3af') : (isDark ? '#374151' : '#e5e7eb')) // Gris pour contour réservation
                    
                    // Formater l'heure pour l'affichage
                    const bookingStartTime = booking ? (booking.game_start_datetime ? new Date(booking.game_start_datetime) : new Date(booking.start_datetime)) : null
                    const displayTime = bookingStartTime ? formatTime(bookingStartTime) : ''

                    // Vérifier que colSpan ne dépasse jamais TOTAL_SLOTS (hard boundary)
                    if (segment && gridColumn + colSpan > TOTAL_SLOTS + 2) {
                      colSpan = TOTAL_SLOTS + 2 - gridColumn
                    }

                    // Vérifier si c'est la dernière cellule verticale de la réservation
                    const bottomSegment = timeIndex < timeSlots.length - 1 ? getSegmentForCellSlots(timeSlots[timeIndex + 1].hour, timeSlots[timeIndex + 1].minute, slotIndex) : null
                    const isDifferentBookingBottom = segment && bottomSegment && segment.bookingId !== bottomSegment.bookingId
                    const isBookingBottom = booking && (timeIndex === timeSlots.length - 1 || isDifferentBookingBottom)
                    const borderBottomColor = isBookingBottom ? (isDark ? '#6b7280' : '#9ca3af') : 'none' // Gris pour contour réservation

                    return (
                      <div
                        key={`cell-slot-${timeIndex}-${slotIndex}`}
                        onClick={() => booking ? openBookingModal(slot.hour, slot.minute, booking) : openBookingModal(slot.hour, slot.minute, undefined, 'GAME')}
                        className={`cursor-pointer relative ${
                          booking
                            ? `flex items-center justify-center p-2 text-center`
                            : `p-2 ${isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'} transition-colors bg-transparent`
                        }`}
                        style={{
                          gridColumn: booking ? `${gridColumn} / ${gridColumn + colSpan}` : gridColumn,
                          gridRow: booking ? `${gridRow} / ${gridRow + rowSpan}` : gridRow,
                          ...(booking && { backgroundColor: booking.color || (booking.type === 'EVENT' ? '#22c55e' : '#3b82f6') }),
                          // Quadrillage complet + contour gris pour les réservations
                          borderTop: shouldShowTopBorder ? `2px solid ${borderTopColor}` : 'none',
                          borderBottom: borderBottomColor !== 'none' ? `2px solid ${borderBottomColor}` : 'none',
                          borderLeft: showLeftBorder && borderLeftColor !== 'none' ? `2px solid ${borderLeftColor}` : 'none',
                          borderRight: showRightBorder && borderRightColor !== 'none' ? `2px solid ${borderRightColor}` : 'none',
                        }}
                        title={booking ? (() => {
                          const contactData = getContactDisplayData(booking)
                          return `${contactData.firstName} ${contactData.lastName || ''}`.trim() || t('admin.agenda.booking.no_name')
                        })() + ` - ${booking.participants_count} ${t('admin.agenda.booking.people')}` : ''}
                      >
                        {/* Badge OB supprimé - la colonne OB est la source de vérité */}
                        {booking && showDetails && (
                          <div className={`${getTextSizeClass(displayTextSize)} ${getTextWeightClass(displayTextWeight)} leading-tight ${isDark ? 'text-white' : 'text-white'}`} style={{ textShadow: '0 1px 3px rgba(0,0,0,0.5)' }}>
                            {(() => {
                              const contactData = getContactDisplayData(booking)
                              const name = contactData.firstName || t('admin.agenda.booking.no_name')
                              return `${name}-${booking.participants_count}`
                            })()}
                          </div>
                        )}
                      </div>
                    )
                  })}
                </Fragment>
              )
            })}
              </div>
            </div>
            )}

            {/* GRID OB - 1 colonne métrique (affiché avec ACTIVE) */}
            {visibleGrids.active && (
            <div style={{ flex: '0 0 80px', borderRight: `2px solid ${isDark ? '#374151' : '#e5e7eb'}` }}>
              {/* En-tête GRID OB */}
              <div className={`grid ${isDark ? '' : ''}`} style={{
                gridTemplateColumns: `1fr`,
                borderBottom: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`
              }}>
                <div className={`p-3 text-center font-medium ${isDark ? 'text-yellow-400 bg-gray-900' : 'text-yellow-600 bg-gray-50'}`}>
                  OB
                </div>
              </div>

              {/* Corps GRID OB - Métrique pure, jamais de getSegmentForCell */}
              <div className="grid" style={{
                gridTemplateColumns: `1fr`,
                gridTemplateRows: `repeat(${timeSlots.length}, ${rowHeight}px)`,
              }}>
                {timeSlots.map((slot, timeIndex) => {
                  // Convertir slot en Date pour calculer timeKey
                  const slotDate = new Date(selectedDate)
                  slotDate.setHours(slot.hour, slot.minute, 0, 0)
                  
                  // Lookup OB pour cette tranche (O(1))
                  const timeKey = Math.floor(slotDate.getTime() / (SLOT_DURATION * 60 * 1000)) * (SLOT_DURATION * 60 * 1000)
                  const obData = obByTimeKey.get(timeKey)
                  
                  // OB : afficher les lignes toutes les 15 min (comme les slots)
                  // IMPORTANT : Utiliser exactement la même structure que les cellules des slots pour un alignement parfait
                  const showBorder = true // Toujours afficher les lignes pour OB (quadrillage en 15 min)
                  
                  return (
                    <div
                      key={`ob-${timeIndex}`}
                      className={`p-2 flex items-center justify-center text-center text-sm font-bold ${
                        obData && obData.totalParticipants > 0
                          ? obData.isOverbooked
                            ? 'text-red-500'
                            : 'text-blue-500'
                          : isDark ? 'text-gray-600' : 'text-gray-300'
                      }`}
                      style={{
                        gridRow: timeIndex + 1,
                        // Afficher toutes les lignes de 15 min comme les slots
                        borderTop: showBorder ? `2px solid ${isDark ? '#374151' : '#e5e7eb'}` : 'none',
                        borderBottom: 'none',
                        borderLeft: 'none',
                        borderRight: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                      }}
                    >
                      {obData && obData.totalParticipants > 0 && (
                        <span className="text-xs font-bold">
                          {obData.isOverbooked ? (
                            `${obData.slotsOver}/${obData.totalParticipants}P`
                          ) : (
                            `${obData.totalSlotsUsed}/${obData.totalParticipants}P`
                          )}
                        </span>
                      )}
                    </div>
                  )
                })}
              </div>
            </div>
            )}

            {/* GRID LASER - Avec colonne Heure à droite */}
            {visibleGrids.laser && laserRooms.length > 0 && (
              <div style={{ flexGrow: gridWidths.laser / 100, flexShrink: 1, flexBasis: `${gridWidths.laser}%`, minWidth: `${Math.max(100, 80 + TOTAL_LASER_ROOMS * 30 * gridWidths.laser / 100)}px`, borderRight: `2px solid ${isDark ? '#374151' : '#e5e7eb'}` }}>
                {/* En-tête GRID LASER */}
                <div className={`grid ${isDark ? '' : ''}`} style={{
                  gridTemplateColumns: `repeat(${TOTAL_LASER_ROOMS}, minmax(30px, 1fr))`,
                  borderBottom: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                  minWidth: 0
                }}>
                  {laserRooms
                    .filter(r => r.is_active)
                    .sort((a, b) => a.sort_order - b.sort_order)
                    .map((room, i) => {
                      const roomName = room.name || `L${i + 1}`
                      return (
                        <div key={`laser-room-${room.id}`} className={`p-3 text-center font-medium ${isDark ? 'text-purple-400 bg-gray-900 border-gray-700' : 'text-purple-600 bg-gray-50 border-gray-200'} ${i > 0 ? 'border-l' : ''}`}>
                          {roomName}
                        </div>
                      )
                    })}
                </div>

                {/* Corps GRID LASER */}
                <div className="grid" style={{
                  gridTemplateColumns: `repeat(${TOTAL_LASER_ROOMS}, minmax(30px, 1fr))`,
                  gridTemplateRows: `repeat(${timeSlots.length}, ${rowHeight}px)`,
                  minWidth: 0
                }}>
                  {/* Laser rooms - Afficher toutes les cases de 15 min comme les salles */}
                  {timeSlots.map((slot, timeIndex) => {
                    return (
                      <Fragment key={`laser-row-${timeIndex}`}>
                        {laserRooms
                          .filter(r => r.is_active)
                          .sort((a, b) => a.sort_order - b.sort_order)
                          .map((room, roomIndex) => {
                            // Obtenir TOUS les segments qui chevauchent ce créneau
                            const allSegments = getSegmentsForCellLaser(slot.hour, slot.minute, roomIndex)
                            
                            // Filtrer pour ne garder que les segments qui commencent à ce créneau (isSegmentTop)
                            // ET qui commencent à cette salle (isSegmentStart)
                            const segmentsToDisplay = allSegments.filter(segment => {
                              // Vérifier début vertical (isSegmentTop)
                              const isSegmentTop = timeIndex === 0 || 
                                !getSegmentsForCellLaser(
                                  timeSlots[timeIndex - 1].hour, 
                                  timeSlots[timeIndex - 1].minute, 
                                  roomIndex
                                ).find(ps => ps.segmentId === segment.segmentId)
                              
                              // Vérifier début horizontal (isSegmentStart)
                              const isSegmentStart = segment.slotStart === roomIndex
                              
                              // Afficher seulement si c'est le coin top-left du segment
                              return isSegmentTop && isSegmentStart
                            })
                            
                            const gridColumn = roomIndex + 1
                            const gridRow = timeIndex + 1
                            const shouldShowTopBorder = (slot.minute === 0 || slot.minute === 30)
                            const grayBorderColor = isDark ? '#6b7280' : '#9ca3af'
                            
                            // Vérifier si cette cellule est à l'intérieur d'une réservation (pas le début)
                            const isInsideReservation = allSegments.length > 0 && segmentsToDisplay.length === 0
                            
                            // Cellule vide (aucun segment à afficher)
                            if (segmentsToDisplay.length === 0) {
                              // Vérifier si cette cellule est couverte par un segment fusionné horizontalement
                              // (le segment commence à gauche et s'étend jusqu'ici)
                              const isCoveredByFusedSegment = allSegments.some(seg => 
                                seg.slotStart < roomIndex && seg.slotEnd > roomIndex
                              )
                              
                              // Ne pas afficher les cellules couvertes par un segment fusionné
                              if (isCoveredByFusedSegment || isInsideReservation) {
                                return null
                              }
                              
                              return (
                                <div
                                  key={`laser-cell-${timeIndex}-${roomIndex}`}
                                  onClick={() => openBookingModal(slot.hour, slot.minute, undefined, 'GAME', 'LASER')}
                                  className={`cursor-pointer relative p-2 ${isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'} transition-colors bg-transparent`}
                                  style={{
                                    gridColumn,
                                    gridRow,
                                    // Ne pas afficher borderTop si on est à l'intérieur d'une réservation
                                    borderTop: shouldShowTopBorder ? `2px solid ${isDark ? '#374151' : '#e5e7eb'}` : 'none',
                                    borderBottom: 'none',
                                    borderLeft: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                                    borderRight: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                                  }}
                                />
                              )
                            }

                            
                            // Si des segments doivent être affichés
                            if (segmentsToDisplay.length > 0) {
                              // Calculer le rowSpan et colSpan max (tous les segments partagent les mêmes)
                              const firstSegment = segmentsToDisplay[0]
                              const segmentStartMinutes = firstSegment.start.getHours() * 60 + firstSegment.start.getMinutes()
                              const segmentEndMinutes = firstSegment.end.getHours() * 60 + firstSegment.end.getMinutes()
                              const durationMinutes = segmentEndMinutes - segmentStartMinutes
                              const rowSpan = Math.ceil(durationMinutes / 15)
                              const colSpan = firstSegment.slotEnd - firstSegment.slotStart
                              
                              // Conteneur qui occupe les cellules fusionnées
                              return (
                                <div
                                  key={`laser-cell-${timeIndex}-${roomIndex}`}
                                  className="relative flex"
                                  style={{
                                    gridColumn: colSpan > 1 ? `${gridColumn} / span ${colSpan}` : gridColumn,
                                    gridRow: rowSpan > 1 ? `${gridRow} / span ${rowSpan}` : gridRow,
                                    backgroundColor: 'transparent',
                                  }}
                                >
                                  {/* Afficher chaque segment côte à côte */}
                                  {segmentsToDisplay.map((segment, segmentIndex) => {
                                    const booking = segment.booking
                                    const bookingColor = booking.color || '#a855f7'
                                    const segmentWidth = `calc(100% / ${segmentsToDisplay.length})`
                                    
                                    return (
                                      <div
                                        key={`laser-segment-${segment.segmentId}`}
                                        onClick={(e) => {
                                          e.stopPropagation()
                                          openBookingModal(slot.hour, slot.minute, booking)
                                        }}
                                        className="cursor-pointer flex flex-col items-center justify-center text-center p-1"
                                        style={{
                                          width: segmentWidth,
                                          height: '100%',
                                          backgroundColor: bookingColor,
                                          border: `2px solid ${grayBorderColor}`,
                                          borderRight: segmentIndex < segmentsToDisplay.length - 1 ? `1px solid ${isDark ? '#1f2937' : '#f3f4f6'}` : `2px solid ${grayBorderColor}`,
                                        }}
                                        title={(() => {
                                          const contactData = getContactDisplayData(booking)
                                          return `${contactData.firstName} ${contactData.lastName || ''}`.trim() || t('admin.agenda.booking.no_name')
                                        })() + ` - ${booking.participants_count} ${t('admin.agenda.booking.people')}`}
                                      >
                                        <div 
                                          className={`${getTextSizeClass(displayTextSize)} ${getTextWeightClass(displayTextWeight)} leading-tight text-white whitespace-nowrap overflow-hidden text-ellipsis px-1`}
                                          style={{ textShadow: '0 1px 3px rgba(0,0,0,0.5)' }}
                                        >
                                          {(() => {
                                            const contactData = getContactDisplayData(booking)
                                            const name = contactData.firstName || t('admin.agenda.booking.no_name')
                                            return `${name}-${booking.participants_count}`
                                          })()}
                                        </div>
                                      </div>
                                    )
                                  })}
                                </div>
                              )
                            }
                          })}
                      </Fragment>
                    )
                  })}
                </div>
              </div>
            )}

            {/* GRID ROOMS - Heure + Room A-D */}
            {visibleGrids.rooms && (
            <div style={{ flexGrow: gridWidths.rooms / 100, flexShrink: 1, flexBasis: `${gridWidths.rooms}%`, minWidth: `${Math.max(100, 80 + TOTAL_ROOMS * 100 * gridWidths.rooms / 100)}px` }}>
              {/* En-tête GRID ROOMS */}
              <div className={`grid ${isDark ? '' : ''}`} style={{
                gridTemplateColumns: `80px repeat(${TOTAL_ROOMS}, minmax(100px, 1fr))`,
                borderBottom: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`
              }}>
                <div className={`p-3 text-center font-medium ${isDark ? 'text-gray-400 bg-gray-900' : 'text-gray-600 bg-gray-50'}`}>
                  {t('admin.agenda.grid_headers.hour')}
                </div>
                {branchRooms
                  .filter(r => r.is_active)
                  .sort((a, b) => a.sort_order - b.sort_order)
                  .map((room, i) => {
                    const roomName = room.name || `${t('admin.agenda.grid_headers.room')} ${i + 1}`
                    return (
                      <div key={`room-${room.id}`} className={`p-3 text-center font-medium border-l ${isDark ? 'text-green-400 bg-gray-900 border-gray-700' : 'text-green-600 bg-gray-50 border-gray-200'}`}>
                        {roomName}
                      </div>
                    )
                  })}
              </div>

              {/* Corps GRID ROOMS */}
              <div className="grid" style={{
                gridTemplateColumns: `80px repeat(${TOTAL_ROOMS}, minmax(100px, 1fr))`,
                gridTemplateRows: `repeat(${timeSlots.length}, ${rowHeight}px)`,
              }}>
                {/* Colonne Heure pour ROOMS */}
                {timeSlots.map((slot, timeIndex) => {
                  // SALLES : lignes seulement à 0 et 30 (comme OB avant)
                  const showBorder = (slot.minute === 0 || slot.minute === 30)
                  return (
                    <div
                      key={`time-room-${timeIndex}`}
                      onClick={() => openBookingModal(slot.hour, slot.minute, undefined, 'GAME', 'LASER')}
                      className={`p-2 text-center text-sm cursor-pointer ${isDark ? 'text-gray-500 hover:text-gray-300 hover:bg-gray-800/50' : 'text-gray-400 hover:text-gray-600 hover:bg-gray-100'}`}
                      style={{
                        gridColumn: '1',
                        gridRow: timeIndex + 1,
                        borderTop: showBorder ? `2px solid ${isDark ? '#374151' : '#e5e7eb'}` : 'none',
                        borderRight: `2px solid ${isDark ? '#374151' : '#e5e7eb'}`,
                      }}
                    >
                      {(slot.minute === 0 || slot.minute === 30) ? slot.label : ''}
                    </div>
                  )
                })}
                
                {/* Salles d'événements */}
                {timeSlots.map((slot, timeIndex) => {
                  return (
                    <Fragment key={`row-room-${timeIndex}`}>
                      {branchRooms
                        .filter(r => r.is_active)
                        .sort((a, b) => a.sort_order - b.sort_order)
                        .map((room, roomIndex) => {
                        const segment = getSegmentForCellRooms(slot.hour, slot.minute, roomIndex)
                    const booking = segment?.booking
                    
                    // RÈGLE BÉTON : Rooms = uniquement EVENT
                    if (booking && booking.type !== 'EVENT') return null
                    
                    // Déterminer si cette cellule est le début d'un segment (top-left corner)
                    // Utiliser segmentId au lieu de booking.id
                        const isSegmentTop = segment && (
                          timeIndex === 0 ||
                          getSegmentForCellRooms(timeSlots[timeIndex - 1].hour, timeSlots[timeIndex - 1].minute, roomIndex)?.segmentId !== segment.segmentId
                        )
                        const isSegmentStart = segment && (
                          roomIndex === 0 || 
                          getSegmentForCellRooms(slot.hour, slot.minute, roomIndex - 1)?.segmentId !== segment.segmentId
                        )
                        const isSegmentEnd = segment && (
                          roomIndex === TOTAL_ROOMS - 1 || 
                          getSegmentForCellRooms(slot.hour, slot.minute, roomIndex + 1)?.segmentId !== segment.segmentId
                        )
                        const isSegmentBottom = segment && (
                          timeIndex === timeSlots.length - 1 ||
                          getSegmentForCellRooms(timeSlots[timeIndex + 1].hour, timeSlots[timeIndex + 1].minute, roomIndex)?.segmentId !== segment.segmentId
                        )
                    
                        // Si cette cellule fait partie d'un segment mais n'est pas le début, ne pas la rendre
                        const isPartOfSegment = segment && !(isSegmentStart && isSegmentTop)
                        if (isPartOfSegment) return null
                        
                        const gridColumn = roomIndex + 2 // +2 car colonne 1 = Heure
                        const gridRow = timeIndex + 1
                    
                    // Calculer les spans pour les segments
                    let colSpan = 1
                    let rowSpan = 1
                    if (segment) {
                      colSpan = segment.slotEnd - segment.slotStart // Pour les rooms, c'est toujours 1
                      
                      // rowSpan basé sur la durée du segment (pas du booking global)
                      const segmentStartMinutes = segment.start.getHours() * 60 + segment.start.getMinutes()
                      const segmentEndMinutes = segment.end.getHours() * 60 + segment.end.getMinutes()
                      const durationMinutes = segmentEndMinutes - segmentStartMinutes
                      rowSpan = Math.ceil(durationMinutes / 15) // Cases de 15 minutes
                    }
                    
                    // Vérifier les segments adjacents pour les bordures de quadrillage
                    const leftSegment = roomIndex > 0 ? getSegmentForCellRooms(slot.hour, slot.minute, roomIndex - 1) : null
                    const rightSegment = roomIndex < TOTAL_ROOMS - 1 ? getSegmentForCellRooms(slot.hour, slot.minute, roomIndex + 1) : null
                    const topSegment = timeIndex > 0 ? getSegmentForCellRooms(timeSlots[timeIndex - 1].hour, timeSlots[timeIndex - 1].minute, roomIndex) : null
                    const bottomSegment = timeIndex < timeSlots.length - 1 ? getSegmentForCellRooms(timeSlots[timeIndex + 1].hour, timeSlots[timeIndex + 1].minute, roomIndex) : null
                    
                    const isDifferentBookingLeft = segment && leftSegment && segment.bookingId !== leftSegment.bookingId
                    const isDifferentBookingRight = segment && rightSegment && segment.bookingId !== rightSegment.bookingId
                    const isDifferentBookingTop = segment && topSegment && segment.bookingId !== topSegment.bookingId
                    const isDifferentBookingBottom = segment && bottomSegment && segment.bookingId !== bottomSegment.bookingId
                    
                    // Bordures verticales : TOUJOURS afficher le quadrillage entre salles
                    // Si c'est une réservation, utiliser gris pour le contour, sinon gris du quadrillage
                    const borderLeftColor = booking
                      ? (isDark ? '#6b7280' : '#9ca3af') // Gris pour contour réservation
                      : (roomIndex === 0 ? 'none' : (isDark ? '#374151' : '#e5e7eb')) // Quadrillage (pas de bordure à gauche de la première salle)
                    const borderRightColor = booking
                      ? (isDark ? '#6b7280' : '#9ca3af') // Gris pour contour réservation
                      : (roomIndex === TOTAL_ROOMS - 1 ? 'none' : (isDark ? '#374151' : '#e5e7eb')) // Quadrillage (pas de bordure à droite de la dernière salle)
                    
                    // Pour les réservations, afficher les bordures sur les bords extérieurs
                    const showLeftBorder = !booking || roomIndex === 0 || isDifferentBookingLeft
                    const showRightBorder = !booking || roomIndex === TOTAL_ROOMS - 1 || isDifferentBookingRight
                    
                    // Bordures horizontales : SALLES - lignes SEULEMENT à 0 et 30 (comme OB avant)
                    const shouldShowTopBorder = (slot.minute === 0 || slot.minute === 30)
                    const borderTopColor = shouldShowTopBorder 
                      ? (isDifferentBookingTop ? (isDark ? '#374151' : '#e5e7eb') : (booking ? (isDark ? '#6b7280' : '#9ca3af') : (isDark ? '#374151' : '#e5e7eb'))) // Gris pour contour réservation
                      : 'none'
                    
                    // Bordure du bas : uniquement pour la dernière cellule de la réservation
                    const isBookingBottom = booking && (timeIndex === timeSlots.length - 1 || isDifferentBookingBottom)
                    const borderBottomColor = isBookingBottom ? (isDark ? '#6b7280' : '#9ca3af') : 'none' // Gris pour contour réservation
                    
                    // Formater l'heure pour l'affichage
                    const roomBookingStartTime = booking ? new Date(booking.start_datetime) : null
                    const roomDisplayTime = roomBookingStartTime ? formatTime(roomBookingStartTime) : ''

                    return (
                      <div
                        key={`cell-room-${timeIndex}-${roomIndex}`}
                        onClick={() => booking ? openBookingModal(slot.hour, slot.minute, booking) : openBookingModal(slot.hour, slot.minute, undefined, 'EVENT')}
                        className={`cursor-pointer ${
                          booking
                            ? `flex flex-col items-center justify-center p-1 text-center`
                            : `p-1 ${isDark ? 'hover:bg-gray-700' : 'hover:bg-gray-100'} transition-colors bg-transparent`
                        }`}
                        style={{
                          gridColumn: segment ? `${gridColumn} / ${gridColumn + colSpan}` : gridColumn,
                          gridRow: segment ? `${gridRow} / ${gridRow + rowSpan}` : gridRow,
                          ...(segment && booking && { backgroundColor: booking.color || '#22c55e' }),
                          // Quadrillage complet + contour gris pour les réservations
                          borderTop: borderTopColor !== 'none' ? `2px solid ${borderTopColor}` : 'none',
                          borderBottom: borderBottomColor !== 'none' ? `2px solid ${borderBottomColor}` : 'none',
                          borderLeft: showLeftBorder && borderLeftColor !== 'none' ? `2px solid ${borderLeftColor}` : 'none',
                          borderRight: showRightBorder && borderRightColor !== 'none' ? `2px solid ${borderRightColor}` : 'none',
                        }}
                        title={booking ? (() => {
                          const contactData = getContactDisplayData(booking)
                          return `${contactData.firstName} ${contactData.lastName || ''}`.trim() || t('admin.agenda.booking.no_name')
                        })() + ` - ${booking.participants_count} ${t('admin.agenda.booking.people')}` : ''}
                      >
                        {booking && (
                          <>
                            <div className={`${getTextSizeClass(displayTextSize)} ${getTextWeightClass(displayTextWeight)} leading-tight ${isDark ? 'text-white' : 'text-white'}`} style={{ textShadow: '0 1px 3px rgba(0,0,0,0.5)' }}>
                              {(() => {
                                const contactData = getContactDisplayData(booking)
                                return contactData.firstName || t('admin.agenda.booking.no_name')
                              })()}
                            </div>
                            <div className={`${getTextSizeClass(displayTextSize)} ${getTextWeightClass(displayTextWeight)} leading-tight ${isDark ? 'text-white/95' : 'text-white/95'}`} style={{ textShadow: '0 1px 3px rgba(0,0,0,0.5)' }}>
                              {booking.participants_count} {t('admin.agenda.booking.people')}
                            </div>
                            <div className={`${getTextSizeClass(displayTextSize)} ${getTextWeightClass(displayTextWeight)} leading-tight ${isDark ? 'text-white/90' : 'text-white/90'}`} style={{ textShadow: '0 1px 3px rgba(0,0,0,0.5)' }}>
                              {roomDisplayTime}
                            </div>
                          </>
                        )}
                      </div>
                    )
                  })}
                </Fragment>
              )
            })}
              </div>
            </div>
            )}
          </div>
        </div>
      </main>

      {/* Popup Paramètres de grille - petit popup non-bloquant */}
      <GridSettingsPopup
        isOpen={showGridSettingsModal}
        onClose={() => setShowGridSettingsModal(false)}
        gridWidths={gridWidths}
        setGridWidths={setGridWidths}
        rowHeight={rowHeight}
        setRowHeight={setRowHeight}
        visibleHoursStart={visibleHoursStart}
        setVisibleHoursStart={setVisibleHoursStart}
        visibleHoursEnd={visibleHoursEnd}
        setVisibleHoursEnd={setVisibleHoursEnd}
        selectedBranchId={selectedBranchId}
        isDark={isDark}
      />

      {/* Modal Paramètres de la branche */}
      {showBranchSettingsModal && selectedBranchId && (
        <SettingsModal
          isOpen={showBranchSettingsModal}
          onClose={() => setShowBranchSettingsModal(false)}
          branchId={selectedBranchId}
          rooms={branchRooms}
          settings={branchSettings}
          onUpdate={async () => {
            // Rafraîchir les données de la branche après mise à jour des paramètres
            await refreshBranches()
            await refreshAllBookings()
            setShowBranchSettingsModal(false)
          }}
          isDark={isDark}
        />
      )}

      {/* Modal de réservation */}
      {selectedBranchId && (
        <BookingModal
          isOpen={showBookingModal}
          onClose={() => {
            setShowBookingModal(false)
            setEditingBooking(null)
            setEditingBookingOrderId(null)
            setEditingBookingOrderStatus(null)
          }}
          onSubmit={handleSubmitBooking}
          onDelete={handleDeleteBooking}
          branchId={selectedBranchId || ''}
          selectedDate={selectedDate}
          initialHour={modalInitialHour}
          initialMinute={modalInitialMinute}
          editingBooking={editingBooking}
          isDark={isDark}
          defaultBookingType={modalDefaultBookingType}
          defaultGameArea={modalDefaultGameArea}
          findBestAvailableRoom={findBestAvailableRoom}
          findRoomAvailability={findRoomAvailability}
          calculateOverbooking={calculateOverbooking}
          branches={branches.filter((branch, index, self) =>
            index === self.findIndex(b => b.id === branch.id)
          )}
          selectedBranchId={selectedBranchId}
          findBestLaserRoom={findBestLaserRoom}
          checkLaserVestsConstraint={checkLaserVestsConstraint}
          checkLaserRoomCapacity={checkLaserRoomCapacity}
          laserRooms={laserRooms}
          maxPlayersPerSlot={MAX_PLAYERS_PER_SLOT}
          totalSlots={TOTAL_SLOTS}
          canCreate={canCreateAgenda}
          canEdit={canEditAgenda}
          canDelete={canDeleteAgenda}
          onViewOrder={(orderId) => setOrderDetailId(orderId)}
          orderId={editingBookingOrderId}
          orderStatus={editingBookingOrderStatus}
          onOpenAccounting={(orderId) => setAccountingOrderId(orderId)}
          onCloseOrder={handleCloseOrder}
        />
      )}

      {/* Modal Fiche Commande */}
      {orderDetailId && selectedBranchId && (
        <OrderDetailModalWrapper
          orderId={orderDetailId}
          onClose={() => setOrderDetailId(null)}
          isDark={isDark}
          onOpenAccounting={(orderId) => setAccountingOrderId(orderId)}
        />
      )}

      {/* Modal Fiche Comptable */}
      {accountingOrderId && selectedBranchId && (
        <AccountingModal
          orderId={accountingOrderId}
          branchId={selectedBranchId}
          onClose={() => setAccountingOrderId(null)}
          onCloseOrder={handleCloseOrder}
          isDark={isDark}
        />
      )}

      {/* Modal de confirmation */}
      <ConfirmationModal
        isOpen={confirmationModal.isOpen}
        onClose={() => setConfirmationModal({ ...confirmationModal, isOpen: false })}
        onConfirm={confirmationModal.onConfirm}
        title={confirmationModal.title}
        message={confirmationModal.message}
        type={confirmationModal.type}
        isDark={theme === 'dark'}
      />
    </div>
  )
}
</file>

<file path="src/lib/email-sender.ts">
/**
 * Email Sender Utility
 * Utilise Brevo pour envoyer des emails
 */

import * as Brevo from '@getbrevo/brevo'
import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import type { EmailLog, EmailTemplate, Booking, Branch, EmailLogInsert } from '@/lib/supabase/types'
import { logEmailSent } from '@/lib/activity-logger'

// Client Supabase admin pour les opérations d'email (pas besoin d'auth utilisateur)
const getAdminSupabase = () => {
  return createSupabaseClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

// Configuration Brevo
const getBrevoClient = () => {
  const apiKey = process.env.BREVO_API_KEY

  if (!apiKey) {
    throw new Error('BREVO_API_KEY not configured in environment variables')
  }

  const apiInstance = new Brevo.TransactionalEmailsApi()
  apiInstance.setApiKey(Brevo.TransactionalEmailsApiApiKeys.apiKey, apiKey)
  return apiInstance
}

// Types pour les variables du template
export interface BookingEmailVariables {
  booking_reference: string
  booking_date: string
  booking_time: string
  participants: number
  booking_type: string
  game_type: string // "Laser City", "Active Games", ou "Mix"
  branch_name: string
  branch_address: string
  branch_phone: string
  branch_email: string
  client_name: string
  client_first_name: string
  client_last_name: string
  client_email: string
  logo_activegames_url: string
  logo_lasercity_url: string
  current_year: string
  terms_conditions: string // HTML content of terms & conditions
  offer_url: string // iCount offer document URL (for EVENT bookings)
  offer_section: string // HTML section for offer link (empty if no offer URL)
  cgv_url: string // URL for CGV validation (admin-created orders only)
  cgv_section: string // HTML section for CGV validation link
}

// Remplace les variables {{variable}} dans le template
export function replaceTemplateVariables(template: string, variables: Record<string, string | number>): string {
  let result = template
  for (const [key, value] of Object.entries(variables)) {
    const regex = new RegExp(`{{${key}}}`, 'g')
    result = result.replace(regex, String(value))
  }
  return result
}

// Génère un aperçu du body (premiers 200 caractères sans HTML)
function generateBodyPreview(html: string): string {
  // Supprime les tags HTML
  const text = html.replace(/<[^>]*>/g, ' ')
  // Supprime les espaces multiples
  const cleaned = text.replace(/\s+/g, ' ').trim()
  // Retourne les premiers 200 caractères
  return cleaned.substring(0, 200)
}

// Récupère les conditions générales depuis la base de données
async function getTermsConditions(
  bookingType: 'GAME' | 'EVENT',
  locale: string
): Promise<string> {
  const supabase = getAdminSupabase()

  // Déterminer le code du template (terms_game_xx ou terms_event_xx)
  const templateType = bookingType === 'EVENT' ? 'event' : 'game'
  const langCode = ['en', 'fr', 'he'].includes(locale) ? locale : 'en'
  const templateCode = `terms_${templateType}_${langCode}`

  // Récupérer le template des conditions
  const { data: template } = await supabase
    .from('email_templates')
    .select('body_template')
    .eq('code', templateCode)
    .eq('is_active', true)
    .single()

  if (template?.body_template) {
    return template.body_template
  }

  // Fallback vers anglais si pas trouvé
  if (langCode !== 'en') {
    const { data: fallbackTemplate } = await supabase
      .from('email_templates')
      .select('body_template')
      .eq('code', `terms_${templateType}_en`)
      .eq('is_active', true)
      .single()

    if (fallbackTemplate?.body_template) {
      return fallbackTemplate.body_template
    }
  }

  return '' // Retourne vide si aucun template trouvé
}

// Envoie un email et log le résultat
export async function sendEmail(params: {
  to: string
  toName?: string
  subject: string
  html: string
  templateId?: string
  templateCode?: string
  entityType?: 'booking' | 'order' | 'contact'
  entityId?: string
  branchId?: string
  triggeredBy?: string
  metadata?: Record<string, unknown>
}): Promise<{ success: boolean; emailLogId?: string; error?: string }> {
  console.log('[EMAIL sendEmail] === START ===')
  console.log('[EMAIL sendEmail] to:', params.to)
  console.log('[EMAIL sendEmail] subject:', params.subject)
  console.log('[EMAIL sendEmail] entityType:', params.entityType)
  console.log('[EMAIL sendEmail] entityId:', params.entityId)
  console.log('[EMAIL sendEmail] branchId:', params.branchId)

  const supabase = getAdminSupabase()

  // Créer le log initial avec status 'pending'
  const emailLogData: EmailLogInsert = {
    recipient_email: params.to,
    recipient_name: params.toName || null,
    template_id: params.templateId || null,
    template_code: params.templateCode || null,
    subject: params.subject,
    body_preview: generateBodyPreview(params.html),
    body_html: params.html,
    entity_type: params.entityType || null,
    entity_id: params.entityId || null,
    branch_id: params.branchId || null,
    attachments: [],
    status: 'pending',
    error_message: null,
    metadata: (params.metadata || {}) as unknown as import('@/lib/supabase/types').Json,
    sent_at: null,
    triggered_by: params.triggeredBy || null,
  }

  console.log('[EMAIL sendEmail] Creating email log in database...')
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: emailLog, error: logError } = await (supabase as any)
    .from('email_logs')
    .insert(emailLogData)
    .select()
    .single()

  if (logError) {
    console.error('[EMAIL sendEmail] Failed to create email log:', logError)
    return { success: false, error: 'Failed to create email log' }
  }
  console.log('[EMAIL sendEmail] Email log created with id:', emailLog?.id)

  try {
    console.log('[EMAIL sendEmail] Getting Brevo client...')
    const brevoClient = getBrevoClient()

    // Configuration de l'email avec Brevo
    const fromEmail = process.env.BREVO_FROM_EMAIL || 'noreply@activegames.co.il'
    const fromName = process.env.BREVO_FROM_NAME || 'ActiveGames'
    console.log('[EMAIL sendEmail] Sending via Brevo - from:', fromEmail, 'to:', params.to)

    const sendSmtpEmail = new Brevo.SendSmtpEmail()
    sendSmtpEmail.sender = { email: fromEmail, name: fromName }
    sendSmtpEmail.replyTo = { email: fromEmail, name: fromName }
    sendSmtpEmail.to = [{ email: params.to, name: params.toName || params.to }]
    sendSmtpEmail.subject = params.subject
    sendSmtpEmail.htmlContent = params.html

    const response = await brevoClient.sendTransacEmail(sendSmtpEmail)

    console.log('[EMAIL sendEmail] Brevo response:', response)

    // Vérifier le succès (Brevo retourne un messageId si succès)
    if (!response?.body?.messageId) {
      throw new Error('Brevo did not return a messageId')
    }

    const brevoMessageId = response.body.messageId
    console.log('[EMAIL sendEmail] Brevo messageId:', brevoMessageId)

    // Mettre à jour le log avec succès et stocker le messageId pour les webhooks
    console.log('[EMAIL sendEmail] Updating email log to sent... emailLog.id:', emailLog.id)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { error: updateError } = await (supabase as any)
      .from('email_logs')
      .update({
        status: 'sent',
        sent_at: new Date().toISOString(),
        metadata: {
          ...(params.metadata || {}),
          brevo_message_id: brevoMessageId,
        },
      })
      .eq('id', emailLog.id)

    if (updateError) {
      console.error('[EMAIL sendEmail] Failed to update email log to sent:', updateError)
    } else {
      console.log('[EMAIL sendEmail] Email log updated to sent successfully')
    }

    // Log l'envoi d'email dans les activity logs
    await logEmailSent({
      recipientEmail: params.to,
      recipientName: params.toName,
      subject: params.subject,
      templateCode: params.templateCode,
      entityType: params.entityType,
      entityId: params.entityId,
      branchId: params.branchId,
    })

    console.log('[EMAIL sendEmail] === SUCCESS ===')
    return { success: true, emailLogId: emailLog.id }

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    console.error('[EMAIL sendEmail] Error caught:', errorMessage)

    // Mettre à jour le log avec l'erreur
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    await (supabase as any)
      .from('email_logs')
      .update({
        status: 'failed',
        error_message: errorMessage,
      })
      .eq('id', emailLog.id)

    console.error('[EMAIL sendEmail] === FAILED ===')
    return { success: false, emailLogId: emailLog.id, error: errorMessage }
  }
}

// Envoie un email de confirmation de réservation
export async function sendBookingConfirmationEmail(params: {
  booking: Booking
  branch: Branch
  triggeredBy?: string
  locale?: string // 'fr' | 'en' | 'he'
  cgvToken?: string | null // Token pour validation CGV (orders admin seulement)
}): Promise<{ success: boolean; emailLogId?: string; error?: string }> {
  const { booking, branch, triggeredBy, locale = 'en', cgvToken } = params

  console.log('[EMAIL CONFIRMATION] === START ===')
  console.log('[EMAIL CONFIRMATION] booking.id:', booking.id)
  console.log('[EMAIL CONFIRMATION] booking.reference_code:', booking.reference_code)
  console.log('[EMAIL CONFIRMATION] booking.customer_email:', booking.customer_email)
  console.log('[EMAIL CONFIRMATION] branch.id:', branch.id)
  console.log('[EMAIL CONFIRMATION] locale:', locale)
  console.log('[EMAIL CONFIRMATION] triggeredBy:', triggeredBy)

  // Vérifier que le client a un email
  if (!booking.customer_email) {
    console.log('[EMAIL CONFIRMATION] No customer email, skipping')
    return { success: false, error: 'Customer has no email address' }
  }

  const supabase = getAdminSupabase()

  // Déterminer le code du template selon la langue
  const templateCode = `booking_confirmation_${locale}`
  console.log('[EMAIL CONFIRMATION] Looking for template:', templateCode)

  // Récupérer le template de confirmation dans la bonne langue
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let { data: template, error: templateError } = await (supabase as any)
    .from('email_templates')
    .select('*')
    .eq('code', templateCode)
    .eq('is_active', true)
    .single() as { data: EmailTemplate | null; error: unknown }

  console.log('[EMAIL CONFIRMATION] Template fetch result - found:', !!template, 'error:', templateError)

  // Fallback vers anglais si le template n'existe pas dans cette langue
  if (templateError || !template) {
    console.log('[EMAIL CONFIRMATION] Trying fallback to booking_confirmation_en...')
    const { data: fallbackTemplate, error: fallbackError } = await supabase
      .from('email_templates')
      .select('*')
      .eq('code', 'booking_confirmation_en')
      .eq('is_active', true)
      .single()

    console.log('[EMAIL CONFIRMATION] Fallback result - found:', !!fallbackTemplate, 'error:', fallbackError)
    template = fallbackTemplate as EmailTemplate | null
  }

  if (!template) {
    console.error('[EMAIL CONFIRMATION] Template not found for locale:', locale)
    return { success: false, error: 'Email template not found' }
  }
  console.log('[EMAIL CONFIRMATION] Using template:', template.code, 'id:', template.id)

  // Déterminer la locale pour le formatage des dates
  const dateLocale = locale === 'he' ? 'he-IL' : locale === 'fr' ? 'fr-FR' : 'en-US'

  // Formater la date et l'heure selon la locale
  const bookingDate = new Date(booking.start_datetime)
  const formattedDate = bookingDate.toLocaleDateString(dateLocale, {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  })
  const formattedTime = bookingDate.toLocaleTimeString(dateLocale, {
    hour: '2-digit',
    minute: '2-digit',
  })

  // Déterminer l'URL de base pour les logos
  // En production, utiliser le domaine réel
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://activegames.co.il'

  // Traduire le type de booking selon la langue
  const getBookingTypeLabel = (type: string, lang: string) => {
    if (type === 'GAME') {
      return lang === 'fr' ? 'Partie de jeux' : lang === 'he' ? 'משחק' : 'Game'
    }
    return lang === 'fr' ? 'Événement' : lang === 'he' ? 'אירוע' : 'Event'
  }

  // Récupérer les game_sessions pour déterminer le type de jeu (Laser/Active/Mix)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: gameSessions } = await (supabase as any)
    .from('game_sessions')
    .select('game_area')
    .eq('booking_id', booking.id)

  // Déterminer le type de jeu basé sur les sessions
  const getGameTypeLabel = (sessions: Array<{ game_area: string }> | null, lang: string) => {
    if (!sessions || sessions.length === 0) {
      return '' // Pas de sessions, ne pas afficher
    }

    const hasLaser = sessions.some(s => s.game_area === 'LASER')
    const hasActive = sessions.some(s => s.game_area === 'ACTIVE')

    if (hasLaser && hasActive) {
      return 'Mix Active + Laser'
    } else if (hasLaser) {
      return 'Laser City'
    } else if (hasActive) {
      return 'Active Games'
    }
    return ''
  }

  // Récupérer les conditions générales
  const termsConditions = await getTermsConditions(
    booking.type as 'GAME' | 'EVENT',
    locale
  )

  // iCount offers removed - no more offer section in emails
  const offerUrl = ''
  const offerSectionHtml = ''

  // Generate CGV validation section HTML (only for admin-created orders with cgvToken)
  const cgvUrl = cgvToken ? `${baseUrl}/cgv/${cgvToken}` : ''
  let cgvSectionHtml = ''

  if (cgvToken) {
    // CGV section - prominent card that explains customer will see their order details AND validate T&C
    if (locale === 'he') {
      cgvSectionHtml = `
        <tr>
          <td style="padding: 20px 40px;">
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: #fffbeb; border-radius: 12px; border: 2px solid #f59e0b;">
              <tr>
                <td style="padding: 20px;">
                  <div style="text-align: center;">
                    <p style="color: #92400e; font-size: 18px; font-weight: bold; margin: 0 0 8px 0;">⚠️ פעולה נדרשת</p>
                    <p style="color: #78350f; font-size: 14px; margin: 0 0 16px 0;">צפה בפרטי ההזמנה שלך ואשר את תנאי השירות</p>
                    <a href="${cgvUrl}" target="_blank" style="display: inline-block; background-color: #f59e0b; color: #ffffff; padding: 12px 32px; border-radius: 8px; text-decoration: none; font-weight: bold; font-size: 15px;">
                      צפה בהזמנה ואשר תנאים
                    </a>
                  </div>
                </td>
              </tr>
            </table>
          </td>
        </tr>`
    } else if (locale === 'fr') {
      cgvSectionHtml = `
        <tr>
          <td style="padding: 20px 40px;">
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: #fffbeb; border-radius: 12px; border: 2px solid #f59e0b;">
              <tr>
                <td style="padding: 20px; text-align: center;">
                  <p style="color: #92400e; font-size: 18px; font-weight: bold; margin: 0 0 8px 0;">⚠️ Action requise</p>
                  <p style="color: #78350f; font-size: 14px; margin: 0 0 16px 0;">Consultez le détail de votre commande et acceptez les CGV</p>
                  <a href="${cgvUrl}" target="_blank" style="display: inline-block; background-color: #f59e0b; color: #ffffff; padding: 12px 32px; border-radius: 8px; text-decoration: none; font-weight: bold; font-size: 15px;">
                    Voir ma commande et valider
                  </a>
                </td>
              </tr>
            </table>
          </td>
        </tr>`
    } else {
      cgvSectionHtml = `
        <tr>
          <td style="padding: 20px 40px;">
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: #fffbeb; border-radius: 12px; border: 2px solid #f59e0b;">
              <tr>
                <td style="padding: 20px; text-align: center;">
                  <p style="color: #92400e; font-size: 18px; font-weight: bold; margin: 0 0 8px 0;">⚠️ Action Required</p>
                  <p style="color: #78350f; font-size: 14px; margin: 0 0 16px 0;">View your order details and accept the Terms & Conditions</p>
                  <a href="${cgvUrl}" target="_blank" style="display: inline-block; background-color: #f59e0b; color: #ffffff; padding: 12px 32px; border-radius: 8px; text-decoration: none; font-weight: bold; font-size: 15px;">
                    View Order & Accept T&C
                  </a>
                </td>
              </tr>
            </table>
          </td>
        </tr>`
    }
  }

  // Préparer les variables
  const variables: BookingEmailVariables = {
    booking_reference: booking.reference_code,
    booking_date: formattedDate,
    booking_time: formattedTime,
    participants: booking.participants_count,
    booking_type: getBookingTypeLabel(booking.type, locale),
    game_type: getGameTypeLabel(gameSessions, locale),
    branch_name: branch.name,
    branch_address: branch.address,
    branch_phone: branch.phone || '',
    branch_email: '', // À ajouter si disponible dans la table branches
    client_name: `${booking.customer_first_name} ${booking.customer_last_name}`.trim(),
    client_first_name: booking.customer_first_name || '',
    client_last_name: booking.customer_last_name || '',
    client_email: booking.customer_email,
    logo_activegames_url: `${baseUrl}/images/logo-activegames.png`,
    logo_lasercity_url: `${baseUrl}/images/logo_laser_city.png`,
    current_year: new Date().getFullYear().toString(),
    terms_conditions: termsConditions,
    offer_url: offerUrl,
    offer_section: offerSectionHtml, // Complete HTML section (empty if no URL)
    cgv_url: cgvUrl,
    cgv_section: cgvSectionHtml, // Complete HTML section for CGV validation
  }

  // Générer le sujet et le body
  const subject = replaceTemplateVariables(template.subject_template, variables as unknown as Record<string, string | number>)
  const html = replaceTemplateVariables(template.body_template, variables as unknown as Record<string, string | number>)

  // Envoyer l'email
  return sendEmail({
    to: booking.customer_email,
    toName: `${booking.customer_first_name} ${booking.customer_last_name}`.trim(),
    subject,
    html,
    templateId: template.id,
    templateCode: template.code,
    entityType: 'booking',
    entityId: booking.id,
    branchId: branch.id,
    triggeredBy,
    metadata: {
      booking_reference: booking.reference_code,
      booking_type: booking.type,
      participants: booking.participants_count,
    },
  })
}

// Renvoyer un email depuis un log existant
export async function resendEmail(emailLogId: string, triggeredBy?: string): Promise<{ success: boolean; newEmailLogId?: string; error?: string }> {
  const supabase = getAdminSupabase()

  // Récupérer le log original
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: originalLog, error } = await (supabase as any)
    .from('email_logs')
    .select('*')
    .eq('id', emailLogId)
    .single() as { data: EmailLog | null; error: unknown }

  if (error || !originalLog) {
    return { success: false, error: 'Original email log not found' }
  }

  // Si on a un template, le récupérer pour avoir le body complet
  let html = ''

  if (originalLog.template_id) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data: template } = await (supabase as any)
      .from('email_templates')
      .select('*')
      .eq('id', originalLog.template_id)
      .single() as { data: EmailTemplate | null }

    if (template) {
      // On devrait stocker les variables originales dans metadata pour pouvoir régénérer
      // Pour l'instant, on utilise le body_preview (pas idéal)
      html = template.body_template

      // Si on a des metadata avec les variables, les utiliser
      if (originalLog.metadata && typeof originalLog.metadata === 'object') {
        const metadata = originalLog.metadata as Record<string, unknown>
        for (const [key, value] of Object.entries(metadata)) {
          const regex = new RegExp(`{{${key}}}`, 'g')
          html = html.replace(regex, String(value))
        }
      }
    }
  }

  if (!html) {
    return { success: false, error: 'Cannot regenerate email content' }
  }

  // Créer un nouveau log et envoyer
  return sendEmail({
    to: originalLog.recipient_email,
    toName: originalLog.recipient_name || undefined,
    subject: originalLog.subject,
    html,
    templateId: originalLog.template_id || undefined,
    templateCode: originalLog.template_code || undefined,
    entityType: originalLog.entity_type as 'booking' | 'order' | 'contact' | undefined,
    entityId: originalLog.entity_id || undefined,
    branchId: originalLog.branch_id || undefined,
    triggeredBy,
    metadata: {
      ...((originalLog.metadata as Record<string, unknown>) || {}),
      resent_from: emailLogId,
    },
  })
}
</file>

<file path="src/app/admin/components/BookingModal.tsx">
'use client'

import { useState, useEffect, useRef, useCallback, useMemo } from 'react'
import { X, Loader2, Users, Clock, User, Phone, Mail, MessageSquare, Gamepad2, PartyPopper, Palette, Home, Calendar, ChevronLeft, ChevronRight, Trash2, Edit2, RefreshCw, AlertTriangle, ChevronDown, Building2, Zap, Target, FileText, Receipt, CheckCheck } from 'lucide-react'
import type { CreateBookingData, BookingWithSlots } from '@/hooks/useBookings'
import { ContactFieldAutocomplete } from './ContactFieldAutocomplete'
import { useContacts } from '@/hooks/useContacts'
import type { Contact, GameArea, LaserRoom } from '@/lib/supabase/types'
import { useTranslation } from '@/contexts/LanguageContext'
import { validateIsraeliPhone, validateEmail, VALIDATION_MESSAGES } from '@/lib/validation'
import { usePricingData } from '@/hooks/usePricingData'
import { calculateBookingPrice, type PriceCalculationResult } from '@/lib/price-calculator'

interface OverbookingInfo {
  willCauseOverbooking: boolean
  maxOverbookedCount: number
  maxOverbookedSlots: number
  affectedTimeSlots: Array<{ time: string; overbookedCount: number; overbookedSlots: number; totalParticipants: number; capacity: number }>
}

interface BookingModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (data: CreateBookingData) => Promise<boolean>
  onDelete?: (id: string) => Promise<boolean>
  branchId: string
  selectedDate: Date
  initialHour?: number
  initialMinute?: number
  editingBooking?: BookingWithSlots | null
  isDark: boolean
  defaultBookingType?: BookingType // Type par défaut selon où on clique
  defaultGameArea?: 'ACTIVE' | 'LASER' // Zone de jeu par défaut (pour GAME)
  findBestAvailableRoom?: (participants: number, startDateTime: Date, endDateTime: Date, excludeBookingId?: string, targetBranchId?: string | null) => string | null
  findRoomAvailability?: (participants: number, startDateTime: Date, endDateTime: Date, excludeBookingId?: string, targetBranchId?: string | null) => { bestRoomId: string | null; availableRoomWithLowerCapacity: { id: string; capacity: number } | null; hasAnyAvailableRoom: boolean }
  calculateOverbooking?: (participants: number, startDateTime: Date, endDateTime: Date, excludeBookingId?: string, targetBranchId?: string | null) => OverbookingInfo
  branches?: Array<{ id: string; name: string; slug: string }> // Liste des branches pour permettre le changement
  selectedBranchId?: string | null // ID de la branche sélectionnée
  // Fonctions Laser
  findBestLaserRoom?: (participants: number, startDateTime: Date, endDateTime: Date, excludeBookingId?: string, targetBranchId?: string | null, allocationMode?: 'auto' | 'petit' | 'grand' | 'maxi') => Promise<{ roomIds: string[]; requiresTwoRooms: boolean } | null>
  checkLaserVestsConstraint?: (participants: number, startDateTime: Date, endDateTime: Date, excludeBookingId?: string, targetBranchId?: string | null) => Promise<{ isViolated: boolean; needsSpareVests: boolean; currentUsage: number; maxVests: number; spareVests: number; totalVests: number; message: string }>
  checkLaserRoomCapacity?: (roomId: string, participants: number, targetBranchId?: string | null) => { isExceeded: boolean; roomCapacity: number; overcapBy: number }
  laserRooms?: LaserRoom[] // Liste des laser rooms de la branche
  maxPlayersPerSlot?: number // Max players per slot (dynamique)
  totalSlots?: number // Total slots (dynamique)
  // Permissions
  canCreate?: boolean // Permission de créer une réservation
  canEdit?: boolean // Permission de modifier une réservation
  canDelete?: boolean // Permission de supprimer une réservation
  // Navigation vers la commande
  onViewOrder?: (orderId: string) => void // Callback pour voir la commande dans la zone Orders
  orderId?: string | null // ID de la commande liée au booking
  orderStatus?: string | null // Statut de la commande (pour conditionner les boutons)
  onOpenAccounting?: (orderId: string) => void // Callback pour ouvrir la fiche comptable
  onCloseOrder?: (orderId: string) => void // Callback pour clôturer la commande
}

type BookingType = 'GAME' | 'EVENT'

// Configuration des slots
const SLOT_DURATION = 15 // minutes
const MAX_PLAYERS_PER_SLOT = 6
const TOTAL_SLOTS = 14
const TOTAL_CAPACITY = TOTAL_SLOTS * MAX_PLAYERS_PER_SLOT // 84 joueurs max

// Horaires disponibles dans le formulaire (24h)
const OPENING_HOUR = 0
const CLOSING_HOUR = 24

// Couleurs disponibles (10 couleurs)
const COLORS = [
  { name: 'Bleu', value: '#3B82F6' },        // Défaut pour GAME
  { name: 'Vert', value: '#22C55E' },        // Défaut pour EVENT
  { name: 'Rouge', value: '#EF4444' },
  { name: 'Orange', value: '#F97316' },
  { name: 'Violet', value: '#A855F7' },
  { name: 'Rose', value: '#EC4899' },
  { name: 'Cyan', value: '#06B6D4' },
  { name: 'Jaune', value: '#EAB308' },
  { name: 'Indigo', value: '#6366F1' },
  { name: 'Emeraude', value: '#10B981' },
]

export function BookingModal({
  isOpen,
  onClose,
  onSubmit,
  onDelete,
  branchId,
  selectedDate,
  initialHour = 10,
  initialMinute = 0,
  editingBooking = null,
  isDark,
  defaultBookingType = 'GAME',
  defaultGameArea, // Pas de valeur par défaut - forcer le commercial à choisir
  findBestAvailableRoom,
  findRoomAvailability,
  calculateOverbooking,
  branches = [],
  selectedBranchId = null,
  findBestLaserRoom,
  checkLaserVestsConstraint,
  checkLaserRoomCapacity,
  laserRooms = [],
  maxPlayersPerSlot = 6,
  totalSlots = 14,
  canCreate = true,
  canEdit = true,
  canDelete = true,
  onViewOrder,
  orderId,
  orderStatus,
  onOpenAccounting,
  onCloseOrder
}: BookingModalProps) {
  const { t, tArray, locale } = useTranslation()

  // Helper pour obtenir la locale de date en fonction de la langue
  const getDateLocale = () => {
    switch (locale) {
      case 'he': return 'he-IL'
      case 'en': return 'en-US'
      default: return 'fr-FR'
    }
  }

  // Helper pour obtenir le nom du mois traduit
  const getMonthName = (monthIndex: number) => {
    const monthKeys = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
    return t(`admin.agenda.months.${monthKeys[monthIndex]}`)
  }

  // Helper pour obtenir les jours de la semaine traduits
  const getDaysShort = (): string[] => {
    const days = tArray('admin.agenda.days_short')
    if (days.length > 0) {
      return days
    }
    // Fallback si la traduction n'est pas un tableau
    return ['L', 'M', 'M', 'J', 'V', 'S', 'D']
  }

  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const [showOverCapacityConfirm, setShowOverCapacityConfirm] = useState(false)
  const [showNoRoomAvailable, setShowNoRoomAvailable] = useState(false)
  const [showLowerCapacityRoom, setShowLowerCapacityRoom] = useState(false)
  const [showOverbookingWarning, setShowOverbookingWarning] = useState(false)
  const [overbookingInfo, setOverbookingInfo] = useState<OverbookingInfo | null>(null)
  const [pendingRoomId, setPendingRoomId] = useState<string | null | undefined>(null)
  const [lowerCapacityRoomInfo, setLowerCapacityRoomInfo] = useState<{ id: string; capacity: number } | null>(null)
  
  // Référence pour suivre si le modal vient de s'ouvrir (pour éviter de réinitialiser le type quand l'utilisateur le change)
  const prevIsOpenRef = useRef(false)
  const skipSyncRef = useRef(false) // Pour éviter la synchronisation pendant l'initialisation
  // Référence pour suivre la branche précédente et détecter les changements
  const prevBookingBranchIdRef = useRef<string | null>(null)

  // Date locale (modifiable)
  const [localDate, setLocalDate] = useState(selectedDate)
  const [showCalendarModal, setShowCalendarModal] = useState(false)
  const [calendarMonth, setCalendarMonth] = useState(selectedDate.getMonth())
  const [calendarYear, setCalendarYear] = useState(selectedDate.getFullYear())

  // Formulaire
  const [bookingType, setBookingType] = useState<BookingType>('GAME')
  const [hour, setHour] = useState(initialHour)
  const [minute, setMinute] = useState(initialMinute)
  const [durationMinutes, setDurationMinutes] = useState('60') // Durée en minutes (champ libre)
  const [participants, setParticipants] = useState('')
  const [firstName, setFirstName] = useState('')
  const [lastName, setLastName] = useState('')
  const [phone, setPhone] = useState('')
  const [phoneError, setPhoneError] = useState<string | null>(null)
  const [email, setEmail] = useState('')
  const [emailError, setEmailError] = useState<string | null>(null)
  const [notes, setNotes] = useState('')
  const [preferredLocale, setPreferredLocale] = useState<'he' | 'fr' | 'en'>('he') // Langue préférée du contact pour les emails
  const [contactId, setContactId] = useState('') // ID unique du contact (auto-généré)
  const [color, setColor] = useState(COLORS[0].value) // Couleur par défaut bleu

  // Discount (remise)
  const [discountType, setDiscountType] = useState<'percent' | 'fixed' | null>(null)
  const [discountValue, setDiscountValue] = useState<string>('')

  // Branche de la réservation (peut être différente de branchId si on modifie)
  const [bookingBranchId, setBookingBranchId] = useState<string>(branchId)
  const [isEditingBranch, setIsEditingBranch] = useState(false)
  const [showBranchDropdown, setShowBranchDropdown] = useState(false)
  const branchDropdownRef = useRef<HTMLDivElement>(null)
  const [showCustomGamesDropdown, setShowCustomGamesDropdown] = useState(false)
  const customGamesDropdownRef = useRef<HTMLDivElement>(null)
  
  // CRM: Contact sélectionné
  const [selectedContact, setSelectedContact] = useState<Contact | null>(null)
  const [isEditingContact, setIsEditingContact] = useState(false) // Mode modification activé par "modifier client"
  const [isEditingEvent, setIsEditingEvent] = useState(false) // Mode modification activé par "modifier événement"
  const [showDuplicateWarning, setShowDuplicateWarning] = useState(false)
  const [pendingContactData, setPendingContactData] = useState<{ phone: string; email: string | null } | null>(null)
  const [pendingEventRoomId, setPendingEventRoomId] = useState<string | null | undefined>(null)
  // Utiliser bookingBranchId pour les opérations sur les contacts (peut changer si on modifie la branche)
  const { createContact, checkDuplicates, updateContact, getContact } = useContacts(bookingBranchId)

  // Prix pour le calcul
  const { products, eventFormulas, rooms: pricingRooms } = usePricingData(bookingBranchId)
  
  // Les champs sont gelés si un contact est sélectionné ET qu'on n'est pas en mode édition
  const areFieldsFrozen = selectedContact !== null && !isEditingContact

  // Pour les événements avec salle (automatique pour EVENT)
  const [roomStartHour, setRoomStartHour] = useState(initialHour)
  const [roomStartMinute, setRoomStartMinute] = useState(initialMinute)
  const [roomDurationMinutes, setRoomDurationMinutes] = useState('120') // Durée salle par défaut 2 heures, modifiable
  const [eventAlias, setEventAlias] = useState('') // Alias : nom de la personne qui fête l'événement
  const [eventNotes, setEventNotes] = useState('') // Notes spécifiques à l'événement/salle

  // Gestion Laser et game_sessions
  // Pour GAME : game_area (ACTIVE/LASER/CUSTOM), nombre de jeux (1/2/3), durées, pauses
  const [gameArea, setGameArea] = useState<GameArea | 'CUSTOM' | null>(null) // ACTIVE, LASER ou CUSTOM (sur mesure) pour GAME, null par défaut pour nouvelle réservation
  const [numberOfGames, setNumberOfGames] = useState(1) // Par défaut 1 jeu (sera ajusté selon gameArea)
  const [laserAllocationMode, setLaserAllocationMode] = useState<'auto' | 'petit' | 'grand' | 'maxi'>('auto') // Mode d'allocation manuelle pour LASER
  const [showSpareVestsPopup, setShowSpareVestsPopup] = useState(false) // Popup pour demander si spare vests disponibles
  const [pendingSpareVestsData, setPendingSpareVestsData] = useState<{ currentUsage: number; maxVests: number; spareVests: number; totalVests: number } | null>(null) // Données pour le popup spare vests
  const [spareVestsAuthorized, setSpareVestsAuthorized] = useState(false) // Flag pour bypasser la vérification des vests après autorisation
  const [gameDurations, setGameDurations] = useState<string[]>(['30', '30']) // Durée de chaque jeu (en minutes)
  const [gamePauses, setGamePauses] = useState<number[]>([]) // Pause après chaque jeu (en minutes)
  const [laserRoomIds, setLaserRoomIds] = useState<string[]>([]) // IDs des salles laser pour chaque jeu (si LASER)
  // Pour GAME en mode sur mesure : même système que EVENT
  const [gameCustomGameArea, setGameCustomGameArea] = useState<GameArea[]>([]) // Zone de chaque jeu pour plan sur mesure
  const [gameCustomNumberOfGames, setGameCustomNumberOfGames] = useState(2) // Nombre de jeux pour plan sur mesure
  const [gameCustomGameDurations, setGameCustomGameDurations] = useState<string[]>(['30', '30']) // Durées pour plan sur mesure
  const [gameCustomGamePauses, setGameCustomGamePauses] = useState<number[]>([]) // Pauses pour plan sur mesure
  const [gameCustomLaserRoomIds, setGameCustomLaserRoomIds] = useState<string[]>([]) // IDs salles laser pour plan sur mesure
  const [showGameCustomGamesDropdown, setShowGameCustomGamesDropdown] = useState(false)
  const gameCustomGamesDropdownRef = useRef<HTMLDivElement>(null)

  // Pour EVENT : Nouveau système de plans de jeu
  type EventGamePlanType = '2' | 'CUSTOM' // 2 jeux prédéfinis ou sur mesure
  type EventQuickPlan = 'AA' | 'LL' | 'AL' | 'LA' | 'AAA' | 'LLL' | 'AAL' | 'ALL' | 'LAA' | 'LLA' | 'ALA' | 'LAL' | 'AAAA' | 'LLLL' | 'AALL' | 'LLAA' | 'ALAL' | 'LALA' | 'AALA' | 'LLAL' | 'ALAA' | 'LALL' | 'AAAL' | 'LLLA' // Plans prédéfinis
  const [eventGamePlanType, setEventGamePlanType] = useState<EventGamePlanType>('2') // Type de plan : 1, 2, 3, 4 jeux ou CUSTOM
  const [eventQuickPlan, setEventQuickPlan] = useState<EventQuickPlan>('AA') // Plan prédéfini sélectionné (AA, LL, AL, LA, etc.)
  const [eventFirstGameStartHour, setEventFirstGameStartHour] = useState(initialHour) // Heure de début du premier jeu
  const [eventFirstGameStartMinute, setEventFirstGameStartMinute] = useState(initialMinute) // Minute de début du premier jeu
  // Pour plans prédéfinis : durées et pauses par jeu
  const [eventGameDurations, setEventGameDurations] = useState<string[]>(['30', '30']) // Durée de chaque jeu EVENT
  const [eventGamePauses, setEventGamePauses] = useState<number[]>([]) // Pause après chaque jeu EVENT
  // Pour plan sur mesure : même système que GAME
  const [eventCustomGameArea, setEventCustomGameArea] = useState<GameArea[]>([]) // Zone de chaque jeu pour plan sur mesure
  const [eventCustomNumberOfGames, setEventCustomNumberOfGames] = useState(2) // Nombre de jeux pour plan sur mesure
  const [eventCustomGameDurations, setEventCustomGameDurations] = useState<string[]>(['30', '30']) // Durées pour plan sur mesure
  const [eventCustomGamePauses, setEventCustomGamePauses] = useState<number[]>([]) // Pauses pour plan sur mesure
  const [eventCustomLaserRoomIds, setEventCustomLaserRoomIds] = useState<string[]>([]) // IDs salles laser pour plan sur mesure
  // Anciennes variables pour compatibilité (à supprimer progressivement)
  // Anciennes variables pour compatibilité (à supprimer progressivement)
  const [eventGamePlan, setEventGamePlan] = useState<'AA' | 'LL' | 'AL' | 'LA'>('AA') // DEPRECATED: utiliser eventQuickPlan
  const [eventNumberOfGames, setEventNumberOfGames] = useState(2) // DEPRECATED
  const [eventSession1Duration, setEventSession1Duration] = useState('30') // DEPRECATED
  const [eventSession2Duration, setEventSession2Duration] = useState('30') // DEPRECATED
  const [eventPause, setEventPause] = useState(30) // DEPRECATED

  // Fonction pour générer un ID unique de contact (numéro séquentiel simple)
  // NOTE: Ceci est conservé pour rétrocompatibilité mais ne sera plus utilisé avec le CRM
  const generateContactId = (): string => {
    // Utiliser localStorage pour stocker le dernier ID utilisé
    const storageKey = `lastContactId_${branchId}`
    const lastId = localStorage.getItem(storageKey)
    const nextId = lastId ? parseInt(lastId, 10) + 1 : 1
    localStorage.setItem(storageKey, nextId.toString())
    return nextId.toString()
  }

  // CRM: Quand un contact est sélectionné depuis n'importe quel champ, remplir tous les autres champs
  const handleContactSelectedFromField = (contact: Contact) => {
    setSelectedContact(contact)
    setFirstName(contact.first_name || '')
    setLastName(contact.last_name || '')
    setPhone(contact.phone || '')
    setEmail(contact.email || '')
    setNotes(contact.notes_client || '')
    setPreferredLocale(contact.preferred_locale || 'he') // Charger la langue préférée du contact
    setIsEditingContact(false) // Désactiver le mode édition quand on sélectionne un nouveau contact
  }

  // CRM: Mettre à jour un champ (seulement si en mode édition)
  const handleFieldChange = (field: 'firstName' | 'lastName' | 'phone' | 'email', value: string) => {
    // Si les champs sont gelés, ne rien faire
    if (areFieldsFrozen) {
      return
    }

    // Mettre à jour le champ
    if (field === 'firstName') setFirstName(value)
    else if (field === 'lastName') setLastName(value)
    else if (field === 'phone') {
      setPhone(value)
      // Valider le format téléphone israélien
      if (value.trim() && !validateIsraeliPhone(value)) {
        setPhoneError(VALIDATION_MESSAGES.phone.israeliFormat)
      } else {
        setPhoneError(null)
      }
    }
    else if (field === 'email') {
      setEmail(value)
      // Valider le format email si c'est un EVENT et que le champ n'est pas vide
      if (value.trim() && !validateEmail(value)) {
        setEmailError(VALIDATION_MESSAGES.email.invalid)
      } else {
        setEmailError(null)
      }
    }
  }

  // CRM: Activer le mode modification de contact
  const handleModifyClient = () => {
    if (!selectedContact) return
    // Activer le mode édition pour permettre la modification des champs directement dans le formulaire
    // Pas besoin de pop-up, les champs sont débloqués et la sauvegarde de la réservation mettra à jour le contact
    setIsEditingContact(true)
  }

  // Activer le mode modification de l'événement
  const handleModifyEvent = () => {
    if (bookingType !== 'EVENT' || !editingBooking) return
    setIsEditingEvent(true)
  }

  // CRM: Changer de contact (réinitialiser et permettre nouveau contact)
  const handleChangeContact = () => {
    setSelectedContact(null)
    setIsEditingContact(false)
    setFirstName('')
    setLastName('')
    setPhone('')
    setPhoneError(null)
    setEmail('')
    setNotes('')
    setPreferredLocale('he') // Réinitialiser la langue par défaut à hébreu
  }

  // Fonction utilitaire pour formater une date en YYYY-MM-DD (sans conversion UTC)
  const formatDateToString = (date: Date): string => {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  // Fonctions utilitaires pour les plans de jeu EVENT
  // Obtenir les zones de jeu d'un plan prédéfini
  const getQuickPlanAreas = (plan: EventQuickPlan): GameArea[] => {
    return plan.split('').map(char => char === 'A' ? 'ACTIVE' : 'LASER') as GameArea[]
  }

  // Obtenir le nombre de jeux d'un plan prédéfini
  const getQuickPlanGameCount = (plan: EventQuickPlan): number => {
    return plan.length
  }

  // Générer les plans prédéfinis disponibles selon le nombre de jeux
  const getAvailableQuickPlans = (gameCount: '2'): EventQuickPlan[] => {
    if (gameCount === '2') return ['AA', 'LL', 'AL', 'LA'] as EventQuickPlan[]
    return []
  }

  // Helper pour calculer les sessions ACTIVE d'un événement (pour vérification overbooking)
  const calculateActiveSessionsForEvent = (): Array<{ start: Date; end: Date }> => {
    const activeSessions: Array<{ start: Date; end: Date }> = []
    
    if (eventGamePlanType !== 'CUSTOM') {
      const areas = getQuickPlanAreas(eventQuickPlan)
      let currentStart = new Date(localDate)
      currentStart.setHours(eventFirstGameStartHour, eventFirstGameStartMinute, 0, 0)
      
      for (let i = 0; i < areas.length; i++) {
        if (areas[i] === 'ACTIVE') {
          const duration = parseInt(eventGameDurations[i] || '30', 10)
          const sessionStart = new Date(currentStart)
          const sessionEnd = new Date(sessionStart)
          sessionEnd.setMinutes(sessionEnd.getMinutes() + duration)
          activeSessions.push({ start: sessionStart, end: sessionEnd })
        }
        
        // Préparer le début du prochain jeu
        if (i < areas.length - 1) {
          const duration = parseInt(eventGameDurations[i] || '30', 10)
          currentStart = new Date(currentStart)
          currentStart.setMinutes(currentStart.getMinutes() + duration + (eventGamePauses[i] ?? 0))
        }
      }
    } else {
      // Plan sur mesure
      let currentStart = new Date(localDate)
      currentStart.setHours(eventFirstGameStartHour, eventFirstGameStartMinute, 0, 0)
      
      for (let i = 0; i < eventCustomNumberOfGames; i++) {
        if (eventCustomGameArea[i] === 'ACTIVE') {
          const duration = parseInt(eventCustomGameDurations[i] || '30', 10)
          const sessionStart = new Date(currentStart)
          const sessionEnd = new Date(sessionStart)
          sessionEnd.setMinutes(sessionEnd.getMinutes() + duration)
          activeSessions.push({ start: sessionStart, end: sessionEnd })
        }
        
        // Préparer le début du prochain jeu
        if (i < eventCustomNumberOfGames - 1) {
          const duration = parseInt(eventCustomGameDurations[i] || '30', 10)
          currentStart = new Date(currentStart)
          currentStart.setMinutes(currentStart.getMinutes() + duration + (eventCustomGamePauses[i] ?? 0))
        }
      }
    }
    
    return activeSessions
  }

  // Obtenir le label d'un plan prédéfini
  const getQuickPlanLabel = (plan: EventQuickPlan): string => {
    const areas = getQuickPlanAreas(plan)
    return areas.map(a => a === 'ACTIVE' ? 'Active' : 'Laser').join(' + ')
  }

  // Fonction utilitaire pour extraire la date locale d'une date ISO
  const extractLocalDateFromISO = (isoString: string): Date => {
    const date = new Date(isoString)
    return new Date(date.getFullYear(), date.getMonth(), date.getDate())
  }

  // Fermer le dropdown de branche quand on clique ailleurs
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (branchDropdownRef.current && !branchDropdownRef.current.contains(event.target as Node)) {
        setShowBranchDropdown(false)
      }
    }

    if (showBranchDropdown) {
      document.addEventListener('mousedown', handleClickOutside)
    }
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [showBranchDropdown])

  // Fermer le dropdown "sur mesure" quand on clique ailleurs
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (customGamesDropdownRef.current && !customGamesDropdownRef.current.contains(event.target as Node)) {
        setShowCustomGamesDropdown(false)
      }
    }

    if (showCustomGamesDropdown) {
      document.addEventListener('mousedown', handleClickOutside)
    }
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [showCustomGamesDropdown])

  // Fermer le dropdown "sur mesure" GAME quand on clique ailleurs
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (gameCustomGamesDropdownRef.current && !gameCustomGamesDropdownRef.current.contains(event.target as Node)) {
        setShowGameCustomGamesDropdown(false)
      }
    }

    if (showGameCustomGamesDropdown) {
      document.addEventListener('mousedown', handleClickOutside)
    }
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [showGameCustomGamesDropdown])

  // Reset le formulaire quand on ouvre/ferme ou charge une réservation à éditer
  useEffect(() => {
    // Ne réinitialiser que si le modal vient de s'ouvrir (passage de false à true)
    const justOpened = isOpen && !prevIsOpenRef.current
    prevIsOpenRef.current = isOpen
    
    if (justOpened) {
      // Reset spare vests authorization flag
      setSpareVestsAuthorized(false)
      // Initialiser la branche de la réservation
      const initialBranchId = editingBooking ? (editingBooking.branch_id || branchId) : branchId
      setBookingBranchId(initialBranchId)
      // Initialiser la référence pour éviter de déclencher la validation au premier chargement
      prevBookingBranchIdRef.current = initialBranchId
      // Pour les réservations existantes, geler la branche par défaut
      setIsEditingBranch(false)
      setShowBranchDropdown(false)
      
      if (editingBooking) {
        // Mode édition : pré-remplir avec les données de la réservation
        const bookingStartDate = extractLocalDateFromISO(editingBooking.game_start_datetime || editingBooking.start_datetime)
        const bookingStartTime = new Date(editingBooking.game_start_datetime || editingBooking.start_datetime)
        
        setLocalDate(bookingStartDate)
        setCalendarMonth(bookingStartDate.getMonth())
        setCalendarYear(bookingStartDate.getFullYear())
        setHour(bookingStartTime.getHours())
        setMinute(bookingStartTime.getMinutes())
        setParticipants(String(editingBooking.participants_count))
        setBookingType(editingBooking.type)
        
        // Extraire les notes et l'alias depuis les notes
        const notes = editingBooking.notes || ''
        const contactIdMatch = notes.match(/Contact ID: (\d+)/)
        if (contactIdMatch) {
          setContactId(contactIdMatch[1])
        } else {
          setContactId(generateContactId())
        }
        
          // Extraire l'alias (pour les événements)
          if (editingBooking.type === 'EVENT') {
            const aliasMatch = notes.match(/Alias: ([^\n]+)/)
            if (aliasMatch) {
              setEventAlias(aliasMatch[1].trim())
            }
            // Extraire les notes de l'événement (après Alias)
            const eventNotesMatch = notes.match(/Alias: [^\n]+\n(.*?)(?:\n(?:Contact ID):|$)/s)
            if (eventNotesMatch) {
              setEventNotes(eventNotesMatch[1].trim())
            }
          
          // Calculer la durée de la salle
          if (editingBooking.start_datetime && editingBooking.end_datetime) {
            const roomStart = new Date(editingBooking.start_datetime)
            const roomEnd = new Date(editingBooking.end_datetime)
            const roomDurationMs = roomEnd.getTime() - roomStart.getTime()
            const roomDurationMinutes = Math.round(roomDurationMs / (1000 * 60))
            setRoomDurationMinutes(String(roomDurationMinutes))
            
            // Pour les EVENT, utiliser directement l'heure de start_datetime (comme pour GAME)
            // C'est l'heure de début de la salle, pas besoin de la calculer depuis game_start_datetime
            if (editingBooking.type === 'EVENT') {
              // Utiliser directement l'heure de start_datetime pour la salle
              setRoomStartHour(roomStart.getHours())
              setRoomStartMinute(roomStart.getMinutes())
              
              // Pour l'heure du premier jeu, utiliser game_start_datetime si disponible
              if (editingBooking.game_start_datetime) {
                const gameStart = new Date(editingBooking.game_start_datetime)
                setEventFirstGameStartHour(gameStart.getHours())
                setEventFirstGameStartMinute(gameStart.getMinutes())
              }
            } else {
              // Pour les autres cas, utiliser l'heure de start_datetime
              setRoomStartHour(roomStart.getHours())
              setRoomStartMinute(roomStart.getMinutes())
            }
          }
          
          // Calculer la durée du jeu
          if (editingBooking.game_start_datetime && editingBooking.game_end_datetime) {
            const gameStart = new Date(editingBooking.game_start_datetime)
            const gameEnd = new Date(editingBooking.game_end_datetime)
            const gameDurationMs = gameEnd.getTime() - gameStart.getTime()
            const gameDurationMinutes = Math.round(gameDurationMs / (1000 * 60))
            setDurationMinutes(String(gameDurationMinutes))
          }
        } else {
          // Pour les jeux, calculer la durée
          if (editingBooking.game_start_datetime && editingBooking.game_end_datetime) {
            const gameStart = new Date(editingBooking.game_start_datetime)
            const gameEnd = new Date(editingBooking.game_end_datetime)
            const gameDurationMs = gameEnd.getTime() - gameStart.getTime()
            const gameDurationMinutes = Math.round(gameDurationMs / (1000 * 60))
            setDurationMinutes(String(gameDurationMinutes))
          }
          
          // Extraire les notes de contact (pour les jeux)
          const contactNotesMatch = notes.match(/Contact ID: \d+\n(.*?)$/s)
          if (contactNotesMatch) {
            setNotes(contactNotesMatch[1].trim())
          }
        }
        
        // Initialiser les game_sessions si disponibles
        if (editingBooking.game_sessions && editingBooking.game_sessions.length > 0) {
          // Déterminer game_area pour GAME
          if (editingBooking.type === 'GAME') {
            const firstSession = editingBooking.game_sessions[0]
            setGameArea(firstSession.game_area)
            
            // IMPORTANT: Compter les session_order UNIQUES, pas le nombre total de sessions
            // Car un jeu peut avoir plusieurs sessions (ex: 2 salles LASER pour un même jeu)
            const sessions = editingBooking.game_sessions || []
            const uniqueSessionOrders = [...new Set(sessions.map(s => s.session_order))].sort((a, b) => a - b)
            setNumberOfGames(uniqueSessionOrders.length)
            
            // Initialiser les durées et pauses par JEU (groupé par session_order)
            const durations: string[] = []
            const pauses: number[] = []
            const roomIds: string[] = []
            
            uniqueSessionOrders.forEach((sessionOrder, index) => {
              // Trouver toutes les sessions de ce jeu
              const sessionsForThisGame = sessions.filter(s => s.session_order === sessionOrder)
              if (sessionsForThisGame.length === 0) return
              
              // Prendre la première session pour les temps (toutes ont les mêmes heures)
              const firstSessionOfGame = sessionsForThisGame[0]
              const sessionStart = new Date(firstSessionOfGame.start_datetime)
              const sessionEnd = new Date(firstSessionOfGame.end_datetime)
              const durationMs = sessionEnd.getTime() - sessionStart.getTime()
              const durationMinutes = Math.round(durationMs / (1000 * 60))
              durations.push(String(durationMinutes))
              
              // Calculer la pause "après" ce jeu en regardant l'écart avec le jeu suivant
              if (index < uniqueSessionOrders.length - 1) {
                const nextSessionOrder = uniqueSessionOrders[index + 1]
                const nextSessions = sessions.filter(s => s.session_order === nextSessionOrder)
                if (nextSessions.length > 0) {
                  const nextSessionStart = new Date(nextSessions[0].start_datetime)
                  const pauseMs = nextSessionStart.getTime() - sessionEnd.getTime()
                  const pauseMinutes = Math.round(pauseMs / (1000 * 60))
                  pauses.push(pauseMinutes)
                }
              }
              // Pas de pause après le dernier jeu
              
              // Collecter les room IDs pour ce jeu
              sessionsForThisGame.forEach(s => {
                if (s.laser_room_id) {
                  roomIds.push(s.laser_room_id)
                }
              })
            })
            
            setGameDurations(durations)
            setGamePauses(pauses)
            setLaserRoomIds(roomIds)
            
            // Mode allocation LASER reste toujours sur 'auto' par défaut
            // L'utilisateur peut le changer manuellement si besoin
            
            // Les pauses sont maintenant "après" chaque jeu, pas besoin de gapBetweenGames
          } else if (editingBooking.type === 'EVENT') {
            // EVENT : déterminer le plan de jeu depuis les sessions
            const sessions = editingBooking.game_sessions || []
            
            if (sessions.length >= 2) {
              // Déterminer si c'est un plan prédéfini (2 jeux) ou sur mesure
              if (sessions.length === 2) {
                // Plan prédéfini à 2 jeux
                setEventGamePlanType('2')
                
                const session1 = sessions[0]
                const session2 = sessions[1]
                const plan1 = session1.game_area === 'ACTIVE' ? 'A' : 'L'
                const plan2 = session2.game_area === 'ACTIVE' ? 'A' : 'L'
                const quickPlan = `${plan1}${plan2}` as EventQuickPlan
                setEventQuickPlan(quickPlan)
                setEventGamePlan(quickPlan as 'AA' | 'LL' | 'AL' | 'LA') // Pour compatibilité
                
                // Durées des sessions
                const session1Start = new Date(session1.start_datetime)
                const session1End = new Date(session1.end_datetime)
                const session1DurationMs = session1End.getTime() - session1Start.getTime()
                const session1DurationMinutes = Math.round(session1DurationMs / (1000 * 60))
                
                const session2Start = new Date(session2.start_datetime)
                const session2End = new Date(session2.end_datetime)
                const session2DurationMs = session2End.getTime() - session2Start.getTime()
                const session2DurationMinutes = Math.round(session2DurationMs / (1000 * 60))
                
                setEventGameDurations([String(session1DurationMinutes), String(session2DurationMinutes)])
                
                // Pause entre sessions
                const pauseMs = session2Start.getTime() - session1End.getTime()
                const pauseMinutes = Math.round(pauseMs / (1000 * 60))
                setEventGamePauses([pauseMinutes])
                
                // Durées pour compatibilité (ancien système)
                setEventSession1Duration(String(session1DurationMinutes))
                setEventSession2Duration(String(session2DurationMinutes))
                setEventPause(pauseMinutes)
              } else {
                // Plan sur mesure (plus de 2 jeux)
                setEventGamePlanType('CUSTOM')
                setEventCustomNumberOfGames(sessions.length)
                
                const areas: GameArea[] = []
                const durations: string[] = []
                const pauses: number[] = []
                const roomIds: string[] = []
                
                sessions.forEach((session, index) => {
                  areas.push(session.game_area || 'ACTIVE')
                  
                  const sessionStart = new Date(session.start_datetime)
                  const sessionEnd = new Date(session.end_datetime)
                  const durationMs = sessionEnd.getTime() - sessionStart.getTime()
                  const durationMinutes = Math.round(durationMs / (1000 * 60))
                  durations.push(String(durationMinutes))
                  
                  // Calculer la pause après ce jeu
                  if (index < sessions.length - 1) {
                    const nextSession = sessions[index + 1]
                    const nextSessionStart = new Date(nextSession.start_datetime)
                    const pauseMs = nextSessionStart.getTime() - sessionEnd.getTime()
                    const pauseMinutes = Math.round(pauseMs / (1000 * 60))
                    pauses.push(pauseMinutes)
                  }
                  
                  if (session.laser_room_id) {
                    roomIds.push(session.laser_room_id)
                  } else {
                    roomIds.push('')
                  }
                })
                
                setEventCustomGameArea(areas)
                setEventCustomGameDurations(durations)
                setEventCustomGamePauses(pauses)
                setEventCustomLaserRoomIds(roomIds)
              }
              
              // Initialiser l'heure de début du premier jeu
              if (sessions.length > 0) {
                const firstGameStart = new Date(sessions[0].start_datetime)
                setEventFirstGameStartHour(firstGameStart.getHours())
                setEventFirstGameStartMinute(firstGameStart.getMinutes())
              }
              
              // Verrouiller les données de l'événement par défaut
              setIsEditingEvent(false)
            }
          }
        } else {
          // Pas de game_sessions : comportement par défaut UNIQUEMENT pour nouvelle réservation
          // Si editingBooking existe, ne pas réinitialiser (c'est une réservation existante sans game_sessions)
          if (!editingBooking) {
            setGameArea(null) // Pas de zone sélectionnée par défaut pour nouvelle réservation
            setNumberOfGames(1) // Par défaut 1 jeu (ajusté selon gameArea)
            setGameDurations(['30'])
            setGamePauses([]) // Pas de pause par défaut
            setLaserRoomIds([])
            setEventGamePlan('AA')
            setEventSession1Duration('30')
            setEventSession2Duration('30')
            setEventPause(30)
          }
        }
        
        // Informations client
        setFirstName(editingBooking.customer_first_name || '')
        setLastName(editingBooking.customer_last_name || '')
        setPhone(editingBooking.customer_phone || '')
        setEmail(editingBooking.customer_email || '')
        
        // CRM: Charger le contact si primary_contact_id existe
        if (editingBooking.primary_contact_id) {
          getContact(editingBooking.primary_contact_id).then((contact) => {
            if (contact) {
              setSelectedContact(contact)
              setIsEditingContact(false) // Les champs doivent être gelés pour une réservation existante
              setIsEditingEvent(false) // Les données de l'événement doivent être gelées pour une réservation existante
              // Charger les notes du contact (notes_client fait partie du contact)
              setNotes(contact.notes_client || '')
              // Charger la langue préférée du contact
              setPreferredLocale(contact.preferred_locale || 'he')
              // Ne pas écraser les champs si le contact existe (on garde les snapshot)
              // Mais on peut les pré-remplir avec les infos du contact si les snapshot sont vides
              if (!editingBooking.customer_first_name && contact.first_name) {
                setFirstName(contact.first_name)
              }
              if (!editingBooking.customer_last_name && contact.last_name) {
                setLastName(contact.last_name)
              }
              if (!editingBooking.customer_phone && contact.phone) {
                setPhone(contact.phone)
              }
              if (!editingBooking.customer_email && contact.email) {
                setEmail(contact.email)
              }
            }
          }).catch(() => {
            // Contact introuvable ou archivé, on garde les snapshot
          })
        }
        
        // Couleur : utiliser celle de la base de données si disponible, sinon couleur par défaut selon le type
        setColor(editingBooking.color || (editingBooking.type === 'GAME' ? COLORS[0].value : COLORS[1].value))

        // Discount : charger les valeurs existantes
        setDiscountType((editingBooking as unknown as { discount_type?: string }).discount_type as 'percent' | 'fixed' | null || null)
        setDiscountValue((editingBooking as unknown as { discount_value?: number }).discount_value?.toString() || '')
      } else {
        // Mode création : réinitialiser le formulaire
        setLocalDate(selectedDate)
        setCalendarMonth(selectedDate.getMonth())
        setCalendarYear(selectedDate.getFullYear())
        
        // Pour EVENT : l'heure cliquée est l'heure de la salle, calculer l'heure du jeu à partir de celle-ci
        if (defaultBookingType === 'EVENT') {
          // Désactiver temporairement la synchronisation pendant l'initialisation
          skipSyncRef.current = true
          setRoomStartHour(initialHour)
          setRoomStartMinute(initialMinute)
          // Calculer l'heure du jeu = heure de la salle + 15 minutes
          const roomStartMinutes = initialHour * 60 + initialMinute
          const gameStartMinutes = roomStartMinutes + 15
          const gameHour = Math.floor(gameStartMinutes / 60)
          const gameMinute = gameStartMinutes % 60
          setHour(gameHour)
          setMinute(gameMinute)
          // Initialiser l'heure de début du premier jeu (pour les plans prédéfinis et sur mesure)
          setEventFirstGameStartHour(gameHour)
          setEventFirstGameStartMinute(gameMinute)
        } else {
          // Pour GAME : l'heure cliquée est l'heure du jeu
          setHour(initialHour)
          setMinute(initialMinute)
          setRoomStartHour(initialHour)
          setRoomStartMinute(initialMinute)
        }
        
        setParticipants('')
        setBookingType(defaultBookingType) // Utiliser le type par défaut selon où on clique
        // Réinitialiser gameArea selon defaultGameArea (ne pas mémoriser le dernier)
        if (defaultBookingType === 'GAME') {
          setGameArea(defaultGameArea || null)
        } else {
          setGameArea(null)
        }
        setEventAlias('')
        setEventNotes('')
        setNotes('')
        setContactId(generateContactId())
        // Initialiser la durée selon le type de jeu
        if (defaultBookingType === 'GAME' && defaultGameArea === 'LASER') {
          setDurationMinutes('30') // 30 min par défaut pour LASER
        } else {
          setDurationMinutes('60') // 60 min par défaut pour ACTIVE ou autres
        }
        setRoomDurationMinutes('120')
        // Initialiser les pauses pour les événements
        if (defaultBookingType === 'EVENT') {
          setEventGamePauses([30]) // Par défaut : 30 min de pause après le premier jeu
          setEventCustomGamePauses([0]) // Par défaut : 0 min de pause pour le plan sur mesure
        }
        setError(null)
        // CRM: Réinitialiser le contact et le mode édition pour une nouvelle réservation
        setSelectedContact(null)
        setIsEditingContact(false)
        setIsEditingEvent(false) // Réinitialiser le mode édition événement
        // Couleur par défaut selon le type
        setColor(defaultBookingType === 'GAME' ? COLORS[0].value : COLORS[1].value)
        // Réinitialiser le discount
        setDiscountType(null)
        setDiscountValue('')

        // Vérifier s'il y a des données de réactivation
        const reactivateDataStr = localStorage.getItem('booking-reactivate-data')
        if (reactivateDataStr) {
          try {
            const data = JSON.parse(reactivateDataStr)
            setParticipants(data.participants || '')
            setNumberOfGames(Number(data.numberOfGames) || 1)
            
            // Si un contactId est fourni, charger le contact existant
            if (data.contactId) {
              getContact(data.contactId).then((contact) => {
                if (contact) {
                  setSelectedContact(contact)
                  setFirstName(contact.first_name || '')
                  setLastName(contact.last_name || '')
                  setPhone(contact.phone || '')
                  setEmail(contact.email || '')
                  setNotes(contact.notes_client || '')
                  setPreferredLocale(contact.preferred_locale || 'he')
                  setIsEditingContact(false) // Champs gelés car contact importé
                } else {
                  // Fallback si le contact n'existe plus
                  setFirstName(data.firstName || '')
                  setLastName(data.lastName || '')
                  setPhone(data.phone || '')
                  setEmail(data.email || '')
                }
              })
            } else {
              // Pas de contactId, juste remplir les champs
              setFirstName(data.firstName || '')
              setLastName(data.lastName || '')
              setPhone(data.phone || '')
              setEmail(data.email || '')
            }
            // Ne pas supprimer les données tout de suite - on en aura besoin pour le submit
          } catch (e) {
            console.error('Error parsing reactivate data:', e)
            setFirstName('')
            setLastName('')
            setPhone('')
            setPhoneError(null)
            setEmail('')
          }
        } else {
          setFirstName('')
          setLastName('')
          setPhone('')
          setPhoneError(null)
          setEmail('')
        }
      }
    }
  }, [isOpen, selectedDate, initialHour, initialMinute, defaultBookingType, defaultGameArea, editingBooking])


  // Générer le calendrier pour le modal
  const getCalendarDays = () => {
    const firstDay = new Date(calendarYear, calendarMonth, 1)
    const lastDay = new Date(calendarYear, calendarMonth + 1, 0)
    const daysInMonth = lastDay.getDate()
    const startDay = firstDay.getDay()
    const days = []
    
    // Jours vides avant le premier jour
    for (let i = 0; i < (startDay === 0 ? 6 : startDay - 1); i++) {
      days.push(null)
    }
    
    // Jours du mois
    for (let i = 1; i <= daysInMonth; i++) {
      days.push(new Date(calendarYear, calendarMonth, i))
    }
    
    return days
  }

  // monthNames est maintenant dynamique via getMonthName()

  const handleCalendarDateClick = (date: Date) => {
    setLocalDate(date)
    setCalendarMonth(date.getMonth())
    setCalendarYear(date.getFullYear())
    setShowCalendarModal(false)
  }

  const handlePreviousMonth = () => {
    if (calendarMonth === 0) {
      setCalendarMonth(11)
      setCalendarYear(calendarYear - 1)
    } else {
      setCalendarMonth(calendarMonth - 1)
    }
  }

  const handleNextMonth = () => {
    if (calendarMonth === 11) {
      setCalendarMonth(0)
      setCalendarYear(calendarYear + 1)
    } else {
      setCalendarMonth(calendarMonth + 1)
    }
  }

  const handlePreviousYear = () => {
    setCalendarYear(calendarYear - 1)
  }

  const handleNextYear = () => {
    setCalendarYear(calendarYear + 1)
  }

  // Changer la couleur automatiquement selon le type (uniquement lors de la création)
  // Changer la couleur automatiquement selon le type (création ET édition)
  useEffect(() => {
    const currentDefaultColor = bookingType === 'GAME' ? COLORS[0].value : COLORS[1].value
    const oppositeDefaultColor = bookingType === 'GAME' ? COLORS[1].value : COLORS[0].value
    
    // Changer automatiquement la couleur si :
    // 1. La couleur actuelle est une des couleurs par défaut (bleu ou vert)
    // 2. Elle correspond à la couleur opposée du type actuel
    // Cela fonctionne en mode création ET édition
    if (color === oppositeDefaultColor || color === currentDefaultColor) {
      // Si c'est la couleur opposée, changer vers la couleur par défaut du type actuel
      // Si c'est déjà la bonne couleur par défaut, ne rien faire
      if (color === oppositeDefaultColor) {
        setColor(currentDefaultColor)
      }
    }
    // Si la couleur est personnalisée (rouge, orange, etc.), ne pas la changer automatiquement
  }, [bookingType, color])

  // Pour les EVENT : synchroniser automatiquement l'heure du jeu avec l'heure de la salle + 15 minutes
  // (l'heure de la salle est la source de vérité quand on clique sur une case de salle)
  // Ne pas synchroniser pendant l'initialisation pour éviter les conflits
  useEffect(() => {
    // Ne pas synchroniser si le flag est activé (pendant l'initialisation)
    if (skipSyncRef.current) {
      // Réinitialiser le flag après un court délai pour permettre la synchronisation future
      setTimeout(() => {
        skipSyncRef.current = false
      }, 100)
      return
    }
    
    if (bookingType === 'EVENT' && isOpen && !editingBooking) {
      // Calculer l'heure du jeu = heure de la salle + 15 minutes
      const roomStartMinutes = roomStartHour * 60 + roomStartMinute
      const gameStartMinutes = roomStartMinutes + 15
      const newGameHour = Math.floor(gameStartMinutes / 60)
      const newGameMinute = gameStartMinutes % 60
      
      // Mettre à jour seulement si différent (éviter les boucles infinies)
      if (hour !== newGameHour || minute !== newGameMinute) {
        setHour(newGameHour)
        setMinute(newGameMinute)
      }
    }
  }, [bookingType, roomStartHour, roomStartMinute, hour, minute, isOpen, editingBooking])

  // Calculer l'heure de début du premier jeu = heure de la salle + 15 minutes (pour EVENT)
  useEffect(() => {
    if (bookingType === 'EVENT') {
      const roomStartMinutes = roomStartHour * 60 + roomStartMinute
      const firstGameStartMinutes = roomStartMinutes + 15
      const newFirstGameHour = Math.floor(firstGameStartMinutes / 60)
      const newFirstGameMinute = firstGameStartMinutes % 60
      
      // Mettre à jour seulement si différent (éviter les boucles infinies)
      // Ne pas inclure eventFirstGameStartHour/Minute dans les dépendances pour éviter la boucle
      if (eventFirstGameStartHour !== newFirstGameHour || eventFirstGameStartMinute !== newFirstGameMinute) {
        setEventFirstGameStartHour(newFirstGameHour)
        setEventFirstGameStartMinute(newFirstGameMinute)
      }
    }
  }, [bookingType, roomStartHour, roomStartMinute])

  // Valider les disponibilités dans la nouvelle branche quand bookingBranchId change
  useEffect(() => {
    // Ne valider que si le modal est ouvert
    if (!isOpen || !bookingBranchId) {
      // Réinitialiser la référence quand le modal se ferme
      if (!isOpen) {
        prevBookingBranchIdRef.current = null
      }
      return
    }
    
    // Ne valider que si la branche a vraiment changé (pas au premier chargement)
    if (prevBookingBranchIdRef.current === bookingBranchId) return
    
    // Mettre à jour la référence AVANT la validation pour éviter les boucles
    const previousBranchId = prevBookingBranchIdRef.current
    prevBookingBranchIdRef.current = bookingBranchId
    
    // Ne pas valider au premier chargement (quand previousBranchId est null)
    if (previousBranchId === null) return
    
    // Attendre un peu pour laisser le temps au cache de se charger si nécessaire
    const timeoutId = setTimeout(() => {
      // Calculer parsedParticipants directement ici
      const currentParsedParticipants = parseInt(participants) || 0
      const currentParsedDuration = parseInt(durationMinutes) || 60
      const currentParsedRoomDuration = parseInt(roomDurationMinutes) || 120
      
      // Ne valider que si on a des données de réservation valides
      if (!currentParsedParticipants || currentParsedParticipants <= 0) return
      
      // Calculer les dates de la réservation
      const gameStartDate = new Date(localDate)
      gameStartDate.setHours(hour, minute, 0, 0)
      
      // Calculer l'heure de fin du jeu
      const startMinutes = hour * 60 + minute
      const endMinutes = startMinutes + currentParsedDuration
      const gameEndHour = Math.floor(endMinutes / 60)
      const gameEndMinute = endMinutes % 60
      const gameEndDate = new Date(localDate)
      gameEndDate.setHours(gameEndHour, gameEndMinute, 0, 0)
      
      // Pour les événements, utiliser les dates de la salle
      let startDateTime = gameStartDate
      let endDateTime = gameEndDate
      
      if (bookingType === 'EVENT') {
        const roomStartDate = new Date(localDate)
        roomStartDate.setHours(roomStartHour, roomStartMinute, 0, 0)
        
        // Calculer l'heure de fin de la salle
        const roomStartMinutes = roomStartHour * 60 + roomStartMinute
        const roomEndMinutes = roomStartMinutes + currentParsedRoomDuration
        const roomEndHour = Math.floor(roomEndMinutes / 60)
        const roomEndMinute = roomEndMinutes % 60
        const roomEndDate = new Date(localDate)
        roomEndDate.setHours(roomEndHour, roomEndMinute, 0, 0)
        
        // Prendre les dates les plus larges
        if (roomStartDate < gameStartDate) startDateTime = roomStartDate
        if (roomEndDate > gameEndDate) endDateTime = roomEndDate
      }
      
      // Vérifier l'overbooking dans la nouvelle branche
      // IMPORTANT: L'overbooking ne s'applique qu'aux sessions ACTIVE (pas LASER qui a sa propre logique de salles)
      const hasActiveContentForOB = bookingType === 'EVENT'
        ? eventQuickPlan.includes('A')
        : (gameArea === 'ACTIVE' || gameArea === 'CUSTOM' || gameArea === 'MIX')

      if (calculateOverbooking && hasActiveContentForOB) {
        let overbookingInfo = null
        let hasOverbooking = false

        if (bookingType === 'EVENT') {
          // Pour les événements, calculer les sessions ACTIVE et vérifier chacune individuellement
          const activeSessions = calculateActiveSessionsForEvent()

          // Vérifier chaque session ACTIVE individuellement (pas la durée totale)
          for (const session of activeSessions) {
            const sessionObInfo = calculateOverbooking(
              currentParsedParticipants,
              session.start,
              session.end,
              editingBooking?.id,
              bookingBranchId
            )

            if (sessionObInfo.willCauseOverbooking) {
              hasOverbooking = true
              // Garder l'info avec le plus grand overbooking
              if (!overbookingInfo || sessionObInfo.maxOverbookedCount > overbookingInfo.maxOverbookedCount) {
                overbookingInfo = sessionObInfo
              }
            }
          }
        } else {
          // Pour GAME ACTIVE/CUSTOM/MIX, vérifier l'overbooking
          overbookingInfo = calculateOverbooking(
            currentParsedParticipants,
            startDateTime,
            endDateTime,
            editingBooking?.id,
            bookingBranchId
          )
          hasOverbooking = overbookingInfo.willCauseOverbooking
        }

        if (hasOverbooking && overbookingInfo) {
          setOverbookingInfo(overbookingInfo)
          setShowOverbookingWarning(true)
        } else {
          // Réinitialiser si pas d'overbooking
          setOverbookingInfo(null)
          setShowOverbookingWarning(false)
        }
      } else if (!hasActiveContentForOB) {
        // Pas de contenu ACTIVE = pas d'overbooking à vérifier
        setOverbookingInfo(null)
        setShowOverbookingWarning(false)
      }
      
      // Pour les événements, vérifier la disponibilité des salles dans la nouvelle branche
      if (bookingType === 'EVENT' && findRoomAvailability) {
        // Pour les événements, utiliser les dates de la salle pour vérifier la disponibilité
        const roomStartDate = new Date(localDate)
        roomStartDate.setHours(roomStartHour, roomStartMinute, 0, 0)
        const { endHour: roomEndHour, endMinute: roomEndMinute } = calculateRoomEndTime()
        const roomEndDate = new Date(localDate)
        roomEndDate.setHours(roomEndHour, roomEndMinute, 0, 0)
        
        const roomAvailability = findRoomAvailability(
          currentParsedParticipants,
          roomStartDate,
          roomEndDate,
          editingBooking?.id,
          bookingBranchId // Passer la branche cible
        )
        
        if (!roomAvailability.bestRoomId && !roomAvailability.hasAnyAvailableRoom) {
          // Aucune salle disponible dans la nouvelle branche
          setShowNoRoomAvailable(true)
        } else if (!roomAvailability.bestRoomId && roomAvailability.availableRoomWithLowerCapacity) {
          // Salle disponible mais capacité insuffisante
          setLowerCapacityRoomInfo(roomAvailability.availableRoomWithLowerCapacity)
          setShowLowerCapacityRoom(true)
        } else {
          // Réinitialiser si tout est OK
          setShowNoRoomAvailable(false)
          setLowerCapacityRoomInfo(null)
          setShowLowerCapacityRoom(false)
        }
      }
    }, 300) // Délai pour laisser le cache se charger

    return () => clearTimeout(timeoutId)
  }, [bookingBranchId, bookingType, participants, hour, minute, localDate, roomStartHour, roomStartMinute, durationMinutes, roomDurationMinutes, isOpen, branchId, editingBooking?.id, calculateOverbooking, findRoomAvailability])

  // Générer les options d'heures
  const hourOptions = []
  for (let h = OPENING_HOUR; h < CLOSING_HOUR; h++) {
    hourOptions.push(h)
  }

  // Parser les valeurs
  const parsedParticipants = parseInt(participants) || 0
  const parsedDuration = parseInt(durationMinutes) || 60
  const parsedRoomDuration = parseInt(roomDurationMinutes) || 120 // Durée salle modifiable, par défaut 2 heures

  // Calcul du prix en temps réel
  const priceCalculation = useMemo(() => {
    if (parsedParticipants < 1) return null

    // Pour EVENT, le prix de la salle vient de la formule (formula.room_id -> icount_rooms)
    // On ne passe pas eventRoomId car booking.event_room_id pointe vers event_rooms (salles physiques)
    // alors que le calcul de prix utilise icount_rooms (configuration de prix)
    // La formule contient déjà le room_id vers la bonne table icount_rooms

    const result = calculateBookingPrice({
      bookingType,
      participants: parsedParticipants,
      // GAME params
      gameArea: gameArea as 'ACTIVE' | 'LASER' | 'CUSTOM' | null,
      numberOfGames,
      gameDurations,
      // GAME CUSTOM params
      customGameAreas: gameCustomGameArea as ('ACTIVE' | 'LASER')[],
      customGameDurations: gameCustomGameDurations,
      // EVENT params
      eventQuickPlan,
      eventRoomId: null, // Laisser le calcul utiliser formula.room_id
      // Discount
      discountType,
      discountValue,
      // Pricing data
      products,
      eventFormulas,
      rooms: pricingRooms,
    })
    console.log('[PRICE CALC]', { bookingType, parsedParticipants, gameArea, numberOfGames, products: products.length, result })
    return result
  }, [
    bookingType,
    parsedParticipants,
    gameArea,
    numberOfGames,
    gameDurations,
    gameCustomGameArea,
    gameCustomGameDurations,
    eventQuickPlan,
    discountType,
    discountValue,
    products,
    eventFormulas,
    pricingRooms,
  ])

  // Validation des participants EVENT - calculer les limites min/max
  const eventParticipantsValidation = useMemo(() => {
    if (bookingType !== 'EVENT' || eventFormulas.length === 0) {
      return { valid: true, minParticipants: 0, maxParticipants: Infinity }
    }

    const minParticipants = Math.min(...eventFormulas.map(f => f.min_participants))
    const maxParticipants = Math.max(...eventFormulas.map(f => f.max_participants))

    const valid = parsedParticipants >= minParticipants && parsedParticipants <= maxParticipants

    return {
      valid,
      minParticipants,
      maxParticipants,
      message: valid
        ? null
        : `Nombre de participants invalide. Minimum: ${minParticipants}, Maximum: ${maxParticipants}`
    }
  }, [bookingType, eventFormulas, parsedParticipants])

  // Calculer les slots nécessaires (logique Tetris)
  const calculateSlots = () => {
    const slotsNeeded = Math.ceil(parsedParticipants / MAX_PLAYERS_PER_SLOT)
    return Math.min(slotsNeeded, TOTAL_SLOTS)
  }


  // Calculer l'heure de fin du jeu
  const calculateGameEndTime = () => {
    const startMinutes = hour * 60 + minute
    const endMinutes = startMinutes + parsedDuration
    return {
      endHour: Math.floor(endMinutes / 60),
      endMinute: endMinutes % 60
    }
  }

  // Calculer l'heure de fin de la salle
  const calculateRoomEndTime = () => {
    const startMinutes = roomStartHour * 60 + roomStartMinute
    const endMinutes = startMinutes + parsedRoomDuration
    // Gérer correctement les heures qui dépassent minuit (modulo 24)
    const endHour = Math.floor(endMinutes / 60) % 24
    const endMinute = endMinutes % 60
    return {
      endHour,
      endMinute
    }
  }

  // Vérifier si la capacité est dépassée
  const isOverCapacity = parsedParticipants > TOTAL_CAPACITY

  // Fonction interne pour soumettre avec une salle spécifique
  const submitWithRoom = async (eventRoomId: string | null | undefined, skipDuplicateCheck = false) => {
    setLoading(true)

    try {
      // CRM: Gérer le contact (création ou liaison)
      let contactIdToLink: string | null = null
      
      if (selectedContact) {
        // Contact déjà sélectionné, utiliser son ID
        contactIdToLink = selectedContact.id

        // Normaliser les valeurs pour comparaison (null et "" sont équivalents)
        const normalize = (val: string | null | undefined) => (val || '').trim()

        // Si les infos ont été VRAIMENT modifiées, mettre à jour le contact
        const hasChanges =
          normalize(selectedContact.first_name) !== normalize(firstName) ||
          normalize(selectedContact.last_name) !== normalize(lastName) ||
          normalize(selectedContact.phone) !== normalize(phone) ||
          normalize(selectedContact.email) !== normalize(email) ||
          normalize(selectedContact.notes_client) !== normalize(notes) ||
          (selectedContact.preferred_locale || 'he') !== preferredLocale

        if (hasChanges) {
          const updated = await updateContact(selectedContact.id, {
            first_name: firstName.trim(),
            last_name: lastName.trim() || null,
            phone: phone.trim(),
            email: email.trim() || null,
            notes_client: notes.trim() || null,
            preferred_locale: preferredLocale,
          })
          if (updated) {
            contactIdToLink = updated.id
            // Mettre à jour le contact dans l'état pour refléter les changements
            setSelectedContact(updated)
          }
        }
      } else if (!skipDuplicateCheck) {
        // Nouveau contact à créer - vérifier les doublons
        if (phone.trim()) {
          const duplicates = await checkDuplicates(phone.trim(), email.trim() || null)
          
          if (duplicates.phoneMatches.length > 0 || duplicates.emailMatches.length > 0) {
            // Il y a des doublons, demander confirmation
            setPendingContactData({ phone: phone.trim(), email: email.trim() || null })
            setPendingEventRoomId(eventRoomId)
            setShowDuplicateWarning(true)
            setLoading(false)
            return
          }
          
          // Pas de doublon, créer le contact
          const newContact = await createContact({
            branch_id_main: bookingBranchId, // Utiliser la branche de la réservation
            first_name: firstName.trim(),
            last_name: lastName.trim() || null,
            phone: phone.trim(),
            email: email.trim() || null,
            notes_client: notes.trim() || null,
            source: 'admin_agenda',
            preferred_locale: preferredLocale,
          })
          
          if (newContact) {
            contactIdToLink = newContact.id
            setSelectedContact(newContact)
          }
        }
      } else {
        // skipDuplicateCheck = true : créer le contact malgré le doublon potentiel
        if (phone.trim()) {
          const newContact = await createContact({
            branch_id_main: bookingBranchId,
            first_name: firstName.trim(),
            last_name: lastName.trim() || null,
            phone: phone.trim(),
            email: email.trim() || null,
            notes_client: notes.trim() || null,
            source: 'admin_agenda',
            preferred_locale: preferredLocale,
          })

          if (newContact) {
            contactIdToLink = newContact.id
            setSelectedContact(newContact)
          }
        }
      }

      // Construire les dates du jeu (format simple)
      const gameStartDate = new Date(localDate)
      gameStartDate.setHours(hour, minute, 0, 0)

      const { endHour: gameEndHour, endMinute: gameEndMinute } = calculateGameEndTime()
      const gameEndDate = new Date(localDate)
      gameEndDate.setHours(gameEndHour, gameEndMinute, 0, 0)

      // Dates globales
      let startDate: Date
      let endDate: Date

      // Si événement, utiliser directement les dates de la salle (comme pour GAME qui utilise les dates du jeu)
      if (bookingType === 'EVENT') {
        const roomStartDate = new Date(localDate)
        roomStartDate.setHours(roomStartHour, roomStartMinute, 0, 0)

        // IMPORTANT : Calculer l'heure de fin en utilisant la durée fixe (parsedRoomDuration)
        // Exactement comme pour GAME : début + durée = fin
        const roomStartMinutes = roomStartHour * 60 + roomStartMinute
        const roomEndMinutes = roomStartMinutes + parsedRoomDuration
        const roomEndHour = Math.floor(roomEndMinutes / 60)
        const roomEndMinute = roomEndMinutes % 60
        
        const roomEndDate = new Date(localDate)
        roomEndDate.setHours(roomEndHour, roomEndMinute, 0, 0)

        // Pour EVENT, utiliser directement les dates de la salle (comme GAME utilise les dates du jeu)
        startDate = roomStartDate
        endDate = roomEndDate
      } else {
        // Pour GAME, utiliser les dates du jeu
        startDate = gameStartDate
        endDate = gameEndDate
      }

      // Notes : séparer notes client (globales) et notes réservation (spécifiques)
      const bookingNotes = bookingType === 'EVENT' 
        ? (eventAlias.trim() || eventNotes.trim()
            ? `Alias: ${eventAlias.trim() || 'N/A'}\n${eventNotes.trim()}`.trim() 
            : '')
        : notes.trim()

      // Générer les game_sessions selon le type de booking
      const game_sessions: CreateBookingData['game_sessions'] = []
      
      if (bookingType === 'GAME') {
        // GAME : créer des sessions selon game_area et nombre de jeux
        if (gameArea === 'ACTIVE') {
          // ACTIVE : créer des sessions pour chaque jeu
          // Utiliser la durée saisie par l'utilisateur
          let currentStart = new Date(gameStartDate)
          for (let i = 0; i < numberOfGames; i++) {
            // Si un seul jeu, utiliser durationMinutes, sinon utiliser gameDurations[i]
            const gameDuration = numberOfGames === 1 
              ? (parseInt(durationMinutes) || 60) 
              : (parseInt(gameDurations[i] || '30', 10))
            const sessionStart = new Date(currentStart)
            const sessionEnd = new Date(sessionStart)
            sessionEnd.setMinutes(sessionEnd.getMinutes() + gameDuration)
            
            // Pause après ce jeu (sauf pour le dernier)
            const pauseAfter = i < numberOfGames - 1 ? (gamePauses[i] || 0) : 0
            
            game_sessions.push({
              game_area: 'ACTIVE',
              start_datetime: sessionStart.toISOString(),
              end_datetime: sessionEnd.toISOString(),
              laser_room_id: null,
              session_order: i + 1,
              pause_before_minutes: 0 // Plus utilisé, mais gardé pour compatibilité
            })
            
            // Prochain jeu commence après la pause
            currentStart = new Date(sessionEnd)
            if (pauseAfter > 0) {
              currentStart.setMinutes(currentStart.getMinutes() + pauseAfter)
            }
          }
        } else if (gameArea === 'LASER') {
          // LASER : créer des sessions pour chaque jeu
          // Utiliser la durée saisie par l'utilisateur (par défaut 30 min)
          // Ne pas forcer l'alignement - garder l'heure exacte (x:15 ou x:45 peuvent rester)
          let currentStart = new Date(gameStartDate)
          
          for (let i = 0; i < numberOfGames; i++) {
            // Si un seul jeu, utiliser durationMinutes, sinon utiliser gameDurations[i]
            const gameDuration = numberOfGames === 1 
              ? (parseInt(durationMinutes) || 30) 
              : (parseInt(gameDurations[i] || '30', 10))
            const sessionStart = new Date(currentStart)
            // Ne pas forcer l'alignement - garder l'heure exacte
            
            const sessionEnd = new Date(sessionStart)
            sessionEnd.setMinutes(sessionEnd.getMinutes() + gameDuration)
            
            // Pause après ce jeu (sauf pour le dernier)
            const pauseAfter = i < numberOfGames - 1 ? (gamePauses[i] || 30) : 0
            
            // Trouver la meilleure salle laser pour cette session
            let allocatedRoomIds: string[] = []
            if (findBestLaserRoom) {
              const allocation = await findBestLaserRoom(parsedParticipants, sessionStart, sessionEnd, editingBooking?.id, bookingBranchId, laserAllocationMode)
              if (allocation) {
                allocatedRoomIds = allocation.roomIds
              } else {
                // AUCUNE SALLE DISPONIBLE : BLOQUER LA CRÉATION
                const timeStr = `${String(sessionStart.getHours()).padStart(2, '0')}:${String(sessionStart.getMinutes()).padStart(2, '0')}`
                const modeText = laserAllocationMode === 'petit' ? ' (Petit laby forcé)' :
                                laserAllocationMode === 'grand' ? ' (Grand laby forcé)' :
                                laserAllocationMode === 'maxi' ? ' (Maxi forcé)' : ''
                setError(`Aucune salle laser disponible pour ${parsedParticipants} participants à ${timeStr}${modeText}. Capacité insuffisante. Veuillez choisir un autre créneau, réduire le nombre de participants${laserAllocationMode !== 'auto' ? ', ou changer le mode d\'allocation' : ''}.`)
                return
              }
            }
            
            // Créer une session par salle (si L1+L2, créer 2 sessions)
            allocatedRoomIds.forEach((roomId, roomIndex) => {
              game_sessions.push({
                game_area: 'LASER',
                start_datetime: sessionStart.toISOString(),
                end_datetime: sessionEnd.toISOString(),
                laser_room_id: roomId,
                session_order: i + 1, // Ordre du jeu (1, 2, 3, etc.)
                pause_before_minutes: 0
              })
            })
            
            // Prochain jeu commence après la pause
            currentStart = new Date(sessionEnd)
            if (pauseAfter > 0) {
              currentStart.setMinutes(currentStart.getMinutes() + pauseAfter)
            }
          }
        } else if (gameArea === 'CUSTOM') {
          // CUSTOM (sur mesure) : créer des sessions selon gameCustomGameArea, gameCustomGameDurations, gameCustomGamePauses
          let currentStart = new Date(gameStartDate)
          for (let i = 0; i < gameCustomNumberOfGames; i++) {
            const customGameArea = gameCustomGameArea[i] || 'ACTIVE'
            const gameDuration = parseInt(gameCustomGameDurations[i] || '30', 10)
            const sessionStart = new Date(currentStart)
            const sessionEnd = new Date(sessionStart)
            sessionEnd.setMinutes(sessionEnd.getMinutes() + gameDuration)
            
            // Pause après ce jeu (sauf pour le dernier)
            const pauseAfter = i < gameCustomNumberOfGames - 1 ? (gameCustomGamePauses[i] || 0) : 0
            
            if (customGameArea === 'ACTIVE') {
              game_sessions.push({
                game_area: 'ACTIVE',
                start_datetime: sessionStart.toISOString(),
                end_datetime: sessionEnd.toISOString(),
                laser_room_id: null,
                session_order: i + 1,
                pause_before_minutes: 0
              })
            } else if (customGameArea === 'LASER') {
              // Pour LASER, ne pas forcer l'alignement - garder l'heure exacte (x:15 ou x:45 peuvent rester)
              sessionEnd.setTime(sessionStart.getTime() + gameDuration * 60000)
              
              // Trouver la meilleure salle laser pour cette session
              let allocatedRoomIds: string[] = []
              if (findBestLaserRoom) {
                const allocation = await findBestLaserRoom(parsedParticipants, sessionStart, sessionEnd, editingBooking?.id, bookingBranchId, laserAllocationMode)
                if (allocation) {
                  allocatedRoomIds = allocation.roomIds
                } else {
                  // AUCUNE SALLE DISPONIBLE : BLOQUER LA CRÉATION
                  const timeStr = `${String(sessionStart.getHours()).padStart(2, '0')}:${String(sessionStart.getMinutes()).padStart(2, '0')}`
                  const modeText = laserAllocationMode === 'petit' ? ' (Petit laby forcé)' :
                                  laserAllocationMode === 'grand' ? ' (Grand laby forcé)' :
                                  laserAllocationMode === 'maxi' ? ' (Maxi forcé)' : ''
                  setError(`Aucune salle laser disponible pour ${parsedParticipants} participants à ${timeStr}${modeText}. Capacité insuffisante. Veuillez choisir un autre créneau, réduire le nombre de participants${laserAllocationMode !== 'auto' ? ', ou changer le mode d\'allocation' : ''}.`)
                  return
                }
              }
              
              // Créer une session par salle (si L1+L2, créer 2 sessions)
              allocatedRoomIds.forEach((roomId) => {
                game_sessions.push({
                  game_area: 'LASER',
                  start_datetime: sessionStart.toISOString(),
                  end_datetime: sessionEnd.toISOString(),
                  laser_room_id: roomId,
                  session_order: i + 1,
                  pause_before_minutes: 0
                })
              })
            }
            
            // Prochain jeu commence après la pause
            currentStart = new Date(sessionEnd)
            if (pauseAfter > 0) {
              currentStart.setMinutes(currentStart.getMinutes() + pauseAfter)
              // Ne pas forcer l'alignement - garder l'heure exacte
            }
          }
        }
      } else if (bookingType === 'EVENT') {
        // EVENT : générer les sessions selon le plan de jeu (prédéfini ou sur mesure)
        const roomStartDate = new Date(localDate)
        roomStartDate.setHours(roomStartHour, roomStartMinute, 0, 0)
        
        // Premier jeu : commencer à eventFirstGameStartHour:eventFirstGameStartMinute
        // Cette heure est utilisée pour les plans prédéfinis ET sur mesure
        let currentStart = new Date(localDate)
        currentStart.setHours(eventFirstGameStartHour, eventFirstGameStartMinute, 0, 0)
        
        if (eventGamePlanType !== 'CUSTOM') {
          // Plan prédéfini : utiliser eventQuickPlan, eventGameDurations, eventGamePauses
          const areas = getQuickPlanAreas(eventQuickPlan)
          const gameCount = areas.length
          
          for (let i = 0; i < gameCount; i++) {
            const area = areas[i]
            const duration = parseInt(eventGameDurations[i] || '30', 10)
            
            // Si LASER, ne pas forcer l'alignement - garder l'heure exacte (x:15 ou x:45 peuvent rester)
            
            const sessionStart = new Date(currentStart)
            const sessionEnd = new Date(sessionStart)
            sessionEnd.setMinutes(sessionEnd.getMinutes() + duration)
            
            // Allocation Laser si nécessaire
            let laserRoomId: string | null = null
            if (area === 'LASER') {
              if (findBestLaserRoom) {
                const allocation = await findBestLaserRoom(parsedParticipants, sessionStart, sessionEnd, editingBooking?.id, bookingBranchId, laserAllocationMode)
                if (allocation && allocation.roomIds.length > 0) {
                  laserRoomId = allocation.roomIds[0]
                } else {
                  // AUCUNE SALLE DISPONIBLE : BLOQUER LA CRÉATION
                  const timeStr = `${String(sessionStart.getHours()).padStart(2, '0')}:${String(sessionStart.getMinutes()).padStart(2, '0')}`
                  const modeText = laserAllocationMode === 'petit' ? ' (Petit laby forcé)' :
                                  laserAllocationMode === 'grand' ? ' (Grand laby forcé)' :
                                  laserAllocationMode === 'maxi' ? ' (Maxi forcé)' : ''
                  setError(`Aucune salle laser disponible pour ${parsedParticipants} participants à ${timeStr}${modeText}. Capacité insuffisante. Veuillez choisir un autre créneau, réduire le nombre de participants${laserAllocationMode !== 'auto' ? ', ou changer le mode d\'allocation' : ''}.`)
                  return
                }
              }
            }
            
            game_sessions.push({
              game_area: area,
              start_datetime: sessionStart.toISOString(),
              end_datetime: sessionEnd.toISOString(),
              laser_room_id: laserRoomId,
              session_order: i + 1,
              pause_before_minutes: i === 0 ? 15 : (eventGamePauses[i - 1] ?? 0) // Pause avant le premier jeu = 15 min (salle + 15), puis pause après chaque jeu précédent
            })
            
            // Préparer le début du prochain jeu (après la pause)
            if (i < gameCount - 1) {
              currentStart = new Date(sessionEnd)
              currentStart.setMinutes(currentStart.getMinutes() + (eventGamePauses[i] ?? 0))
            }
          }
        } else {
          // Plan sur mesure : utiliser eventCustomGameArea, eventCustomGameDurations, eventCustomGamePauses
          const gameCount = eventCustomNumberOfGames
          
          for (let i = 0; i < gameCount; i++) {
            const area = eventCustomGameArea[i] || 'ACTIVE'
            const duration = parseInt(eventCustomGameDurations[i] || '30', 10)
            
            // Si LASER, ne pas forcer l'alignement - garder l'heure exacte (x:15 ou x:45 peuvent rester)
            
            const sessionStart = new Date(currentStart)
            const sessionEnd = new Date(sessionStart)
            sessionEnd.setMinutes(sessionEnd.getMinutes() + duration)
            
              // Allocation Laser si nécessaire
              let laserRoomId: string | null = null
              if (area === 'LASER') {
                if (findBestLaserRoom) {
                  const allocation = await findBestLaserRoom(parsedParticipants, sessionStart, sessionEnd, editingBooking?.id, bookingBranchId, laserAllocationMode)
                  if (allocation && allocation.roomIds.length > 0) {
                    laserRoomId = allocation.roomIds[0]
                  } else {
                    // AUCUNE SALLE DISPONIBLE : BLOQUER LA CRÉATION
                    const timeStr = `${String(sessionStart.getHours()).padStart(2, '0')}:${String(sessionStart.getMinutes()).padStart(2, '0')}`
                  setError(`Aucune salle laser disponible pour ${parsedParticipants} participants à ${timeStr}. Les salles sont pleines ou ont une capacité insuffisante. Veuillez choisir un autre créneau ou réduire le nombre de participants.`)
                    return
                  }
                }
              }
              
              game_sessions.push({
                game_area: area,
                start_datetime: sessionStart.toISOString(),
                end_datetime: sessionEnd.toISOString(),
                laser_room_id: laserRoomId,
                session_order: i + 1,
                pause_before_minutes: i === 0 ? 15 : (eventCustomGamePauses[i - 1] ?? 0) // Pause avant le premier jeu = 15 min (salle + 15), puis pause après chaque jeu précédent
              })
            
            // Préparer le début du prochain jeu (après la pause)
            if (i < gameCount - 1) {
              currentStart = new Date(sessionEnd)
              currentStart.setMinutes(currentStart.getMinutes() + (eventCustomGamePauses[i] ?? 0))
            }
          }
        }
      }

      // Construire les slots selon le type de booking
      const slots: CreateBookingData['slots'] = []
      
      if (bookingType === 'GAME') {
        // Pour GAME : un seul slot continu
        const slotStart = new Date(localDate)
        slotStart.setHours(hour, minute, 0, 0)
        
        const slotEnd = new Date(localDate)
        slotEnd.setHours(hour, minute, parsedDuration, 0)
        
        slots.push({
          slot_start: slotStart.toISOString(),
          slot_end: slotEnd.toISOString(),
          participants_count: parsedParticipants
        })
      } else if (bookingType === 'EVENT') {
        // Pour EVENT : créer un slot uniquement pour chaque session ACTIVE (pas pendant les pauses)
        // Les pauses entre les jeux ne doivent pas bloquer les slots
        for (const session of game_sessions) {
          if (session.game_area === 'ACTIVE') {
            slots.push({
              slot_start: session.start_datetime,
              slot_end: session.end_datetime,
              participants_count: parsedParticipants
            })
          }
        }
      }

      // Vérifier s'il y a des données de réactivation
      let reactivateOrderId: string | undefined
      let reactivateReference: string | undefined
      const reactivateDataStr = localStorage.getItem('booking-reactivate-data')
      if (reactivateDataStr) {
        try {
          const reactivateData = JSON.parse(reactivateDataStr)
          if (reactivateData.isReactivate) {
            reactivateOrderId = reactivateData.orderId
            reactivateReference = reactivateData.reference
          }
        } catch (e) {
          console.error('Error parsing reactivate data:', e)
        }
      }

      const bookingData: CreateBookingData = {
        branch_id: bookingBranchId, // Utiliser la branche de la réservation (peut être modifiée)
        type: bookingType,
        start_datetime: startDate.toISOString(),
        end_datetime: endDate.toISOString(),
        game_start_datetime: gameStartDate.toISOString(),
        game_end_datetime: gameEndDate.toISOString(),
        participants_count: parsedParticipants,
        event_room_id: bookingType === 'EVENT' ? (eventRoomId ?? undefined) : undefined,
        customer_first_name: firstName.trim(),
        customer_last_name: lastName.trim() || '',
        customer_phone: phone.trim(),
        customer_email: email.trim() || undefined,
        customer_notes_at_booking: selectedContact?.notes_client || notes.trim() || undefined, // Snapshot
        primary_contact_id: contactIdToLink || undefined,
        notes: bookingNotes || undefined,
        color: color,
        // Discount (remise)
        discount_type: discountType || undefined,
        discount_value: discountValue ? parseFloat(discountValue) : undefined,
        slots: slots.length > 0 ? slots : [],
        game_sessions: game_sessions.length > 0 ? game_sessions : [],
        // Données de réactivation si présentes
        reactivateOrderId,
        reactivateReference,
        // Langue préférée du contact pour les emails
        locale: preferredLocale
      }

      const success = await onSubmit(bookingData)

      // Nettoyer les données de réactivation après soumission
      if (reactivateDataStr) {
        localStorage.removeItem('booking-reactivate-data')
      }

      if (success) {
        // Si c'était une nouvelle réservation (pas d'édition), reset et fermer
        if (!editingBooking) {
          setFirstName('')
          setLastName('')
          setPhone('')
          setPhoneError(null)
          setEmail('')
          setNotes('')
          setEventNotes('')
          setParticipants('')
          setDurationMinutes('60')
          setSelectedContact(null)
          setIsEditingContact(false)
          onClose()
        } else {
          // Pour une édition, fermer automatiquement le modal après sauvegarde
          setIsEditingContact(false)
          setIsEditingEvent(false)
          onClose()
        }
      } else {
        setError(t('admin.booking_modal.errors.create_error'))
      }
    } catch (err) {
      console.error('Error creating booking:', err)
      setError(t('admin.booking_modal.errors.generic_error'))
    } finally {
      setLoading(false)
    }
  }

  // Soumettre le formulaire
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    // Bloquer la soumission si un avertissement d'overbooking est actif
    if (showOverbookingWarning && overbookingInfo) {
      // Le pop-up d'overbooking doit être confirmé avant de pouvoir soumettre
      return
    }

    // Validations
    if (!firstName.trim()) {
      setError(t('admin.booking_modal.validation.required_fields'))
      return
    }
    
    if (!phone.trim()) {
      setError(t('admin.booking_modal.validation.required_fields'))
      return
    }
    if (!validateIsraeliPhone(phone)) {
      setError(VALIDATION_MESSAGES.phone.israeliFormat)
      setPhoneError(VALIDATION_MESSAGES.phone.israeliFormat)
      return
    }
    if (parsedParticipants < 1) {
      setError(t('admin.booking_modal.validation.min_participants'))
      return
    }
    // Plus de limitation de capacité : le système d'overbooking gère les dépassements
    if (parsedDuration < 15) {
      setError(t('admin.booking_modal.validation.min_duration'))
      return
    }

    // Validation Laser : contrainte hard vests (skip si spare vests déjà autorisées)
    if (bookingType === 'GAME' && gameArea === 'LASER' && checkLaserVestsConstraint && !spareVestsAuthorized) {
      const gameStartDate = new Date(localDate)
      gameStartDate.setHours(hour, minute, 0, 0)
      const { endHour: gameEndHour, endMinute: gameEndMinute } = calculateGameEndTime()
      const gameEndDate = new Date(localDate)
      gameEndDate.setHours(gameEndHour, gameEndMinute, 0, 0)

      const vestsCheck = await checkLaserVestsConstraint(
        parsedParticipants,
        gameStartDate,
        gameEndDate,
        editingBooking?.id,
        bookingBranchId
      )

      if (vestsCheck.needsSpareVests) {
        // Afficher popup pour demander si spare vests disponibles
        setPendingSpareVestsData({
          currentUsage: vestsCheck.currentUsage,
          maxVests: vestsCheck.maxVests,
          spareVests: vestsCheck.spareVests,
          totalVests: vestsCheck.totalVests
        })
        setShowSpareVestsPopup(true)
        return // Interrompre la soumission jusqu'à confirmation
      }

      if (vestsCheck.isViolated) {
        setError(`Contrainte vestes violée (incluant spare) : ${vestsCheck.currentUsage + parsedParticipants} > ${vestsCheck.totalVests} (REFUS). ${vestsCheck.message}`)
        return
      }
    }

    // Validation Laser : contrainte hard vests pour GAME en mode sur mesure avec sessions Laser
    if (bookingType === 'GAME' && gameArea === 'CUSTOM' && checkLaserVestsConstraint) {
      const hasLaserSession = gameCustomGameArea.some(area => area === 'LASER')
      if (hasLaserSession) {
        const gameStartDate = new Date(localDate)
        gameStartDate.setHours(hour, minute, 0, 0)
        // Calculer la date de fin en additionnant toutes les durées et pauses
        let totalMinutes = 0
        for (let i = 0; i < gameCustomNumberOfGames; i++) {
          totalMinutes += parseInt(gameCustomGameDurations[i] || '30', 10)
          if (i < gameCustomNumberOfGames - 1) {
            totalMinutes += gameCustomGamePauses[i] || 0
          }
        }
        const gameEndDate = new Date(gameStartDate)
        gameEndDate.setMinutes(gameEndDate.getMinutes() + totalMinutes)

        const vestsCheck = await checkLaserVestsConstraint(
          parsedParticipants,
          gameStartDate,
          gameEndDate,
          editingBooking?.id,
          bookingBranchId
        )

        if (vestsCheck.isViolated) {
          setError(`Contrainte hard vests violée : ${vestsCheck.currentUsage + parsedParticipants} > ${vestsCheck.maxVests} (REFUS). ${vestsCheck.message}`)
          return
        }
      }
    }

    // Validation Laser : contrainte hard vests pour EVENT avec sessions Laser
    // Vérifier chaque session LASER individuellement (pas la durée totale de la salle)
    // IMPORTANT : Toujours exclure editingBooking?.id pour éviter de compter la réservation en cours de modification
    if (bookingType === 'EVENT' && checkLaserVestsConstraint) {
      // Calculer les sessions LASER qui seront créées
      const laserSessions: Array<{ start: Date; end: Date }> = []
      
      if (eventGamePlanType !== 'CUSTOM') {
        // Plan prédéfini : calculer les sessions selon le plan
        const areas = getQuickPlanAreas(eventQuickPlan)
        let currentStart = new Date(localDate)
        currentStart.setHours(eventFirstGameStartHour, eventFirstGameStartMinute, 0, 0)
        
        for (let i = 0; i < areas.length; i++) {
          if (areas[i] === 'LASER') {
            const duration = parseInt(eventGameDurations[i] || '30', 10)
            const sessionStart = new Date(currentStart)
            const sessionEnd = new Date(sessionStart)
            sessionEnd.setMinutes(sessionEnd.getMinutes() + duration)
            laserSessions.push({ start: sessionStart, end: sessionEnd })
          }
          
          // Préparer le début du prochain jeu
          if (i < areas.length - 1) {
            const duration = parseInt(eventGameDurations[i] || '30', 10)
            currentStart = new Date(currentStart)
            currentStart.setMinutes(currentStart.getMinutes() + duration + (eventGamePauses[i] ?? 0))
          }
        }
      } else {
        // Plan sur mesure : calculer les sessions selon la configuration
        let currentStart = new Date(localDate)
        currentStart.setHours(eventFirstGameStartHour, eventFirstGameStartMinute, 0, 0)
        
        for (let i = 0; i < eventCustomNumberOfGames; i++) {
          if (eventCustomGameArea[i] === 'LASER') {
            const duration = parseInt(eventCustomGameDurations[i] || '30', 10)
            const sessionStart = new Date(currentStart)
            const sessionEnd = new Date(sessionStart)
            sessionEnd.setMinutes(sessionEnd.getMinutes() + duration)
            laserSessions.push({ start: sessionStart, end: sessionEnd })
          }
          
          // Préparer le début du prochain jeu
          if (i < eventCustomNumberOfGames - 1) {
            const duration = parseInt(eventCustomGameDurations[i] || '30', 10)
            currentStart = new Date(currentStart)
            currentStart.setMinutes(currentStart.getMinutes() + duration + (eventCustomGamePauses[i] ?? 0))
          }
        }
      }
      
      // Vérifier chaque session LASER individuellement
      // IMPORTANT : Pour chaque session, vérifier la contrainte en excluant la réservation en cours de modification
      // Si on modifie un événement, editingBooking?.id doit être défini pour exclure toutes ses sessions
      const excludeBookingId = editingBooking?.id || undefined
      
      for (const session of laserSessions) {
        const vestsCheck = await checkLaserVestsConstraint(
          parsedParticipants,
          session.start,
          session.end,
          excludeBookingId, // Exclure la réservation en cours de modification (toutes ses sessions)
          bookingBranchId
        )

        if (vestsCheck.isViolated) {
          setError(`Contrainte hard vests violée : ${vestsCheck.currentUsage + parsedParticipants} > ${vestsCheck.maxVests} (REFUS). ${vestsCheck.message}`)
          return
        }
      }
    }

    // Si événement, vérifier la salle
    let eventRoomId: string | null | undefined = editingBooking?.event_room_id || null
    
    if (bookingType === 'EVENT' && findRoomAvailability) {
      const roomStartDate = new Date(localDate)
      roomStartDate.setHours(roomStartHour, roomStartMinute, 0, 0)

      const { endHour: roomEndHour, endMinute: roomEndMinute } = calculateRoomEndTime()
      const roomEndDate = new Date(localDate)
      roomEndDate.setHours(roomEndHour, roomEndMinute, 0, 0)

      // Exclure le booking en cours de modification pour qu'il ne se bloque pas lui-même
      const roomAvailability = findRoomAvailability(parsedParticipants, roomStartDate, roomEndDate, editingBooking?.id, bookingBranchId)
      
      if (roomAvailability.bestRoomId) {
        // Une salle avec capacité suffisante est disponible
        eventRoomId = roomAvailability.bestRoomId
      } else if (roomAvailability.availableRoomWithLowerCapacity) {
        // Une salle disponible mais avec capacité inférieure
        setLowerCapacityRoomInfo(roomAvailability.availableRoomWithLowerCapacity)
        setShowLowerCapacityRoom(true)
        return
      } else if (!roomAvailability.hasAnyAvailableRoom) {
        // Aucune salle disponible du tout - NE PAS AUTORISER
        setShowNoRoomAvailable(true)
        return
      } else {
        // Cas de secours (ne devrait pas arriver)
        setError(t('admin.booking_modal.errors.no_room_for_quantity'))
        return
      }
    } else if (bookingType === 'EVENT' && findBestAvailableRoom) {
      // Fallback vers l'ancienne fonction si findRoomAvailability n'est pas fournie
      const roomStartDate = new Date(localDate)
      roomStartDate.setHours(roomStartHour, roomStartMinute, 0, 0)

      const { endHour: roomEndHour, endMinute: roomEndMinute } = calculateRoomEndTime()
      const roomEndDate = new Date(localDate)
      roomEndDate.setHours(roomEndHour, roomEndMinute, 0, 0)

      // Exclure le booking en cours de modification pour qu'il ne se bloque pas lui-même
      const bestRoomId = findBestAvailableRoom(parsedParticipants, roomStartDate, roomEndDate, editingBooking?.id, bookingBranchId)
      
      if (!bestRoomId) {
        // Aucune salle disponible - over capacity
        setPendingRoomId(editingBooking?.event_room_id || null)
        setShowOverCapacityConfirm(true)
        return
      } else {
        // Une salle convient - l'utiliser (même si différente de la salle actuelle)
        eventRoomId = bestRoomId
      }
    }

    // Vérifier l'overbooking avant de soumettre
    // IMPORTANT: L'overbooking ne s'applique qu'aux sessions ACTIVE (pas LASER qui a sa propre logique de salles)
    const hasActiveContent = bookingType === 'EVENT'
      ? eventQuickPlan.includes('A') // EVENT avec sessions ACTIVE
      : (gameArea === 'ACTIVE' || gameArea === 'CUSTOM' || gameArea === 'MIX') // GAME avec zone ACTIVE

    if (calculateOverbooking && hasActiveContent) {
      let obInfo = null

      if (bookingType === 'EVENT') {
        // Pour les événements, vérifier chaque session ACTIVE individuellement
        const activeSessions = calculateActiveSessionsForEvent()
        let maxOverbooking = null

        for (const session of activeSessions) {
          const sessionObInfo = calculateOverbooking(
            parsedParticipants,
            session.start,
            session.end,
            editingBooking?.id,
            bookingBranchId
          )

          if (sessionObInfo.willCauseOverbooking) {
            // Garder l'info avec le plus grand overbooking
            if (!maxOverbooking || sessionObInfo.maxOverbookedCount > maxOverbooking.maxOverbookedCount) {
              maxOverbooking = sessionObInfo
            }
          }
        }

        obInfo = maxOverbooking || {
          willCauseOverbooking: false,
          maxOverbookedCount: 0,
          maxOverbookedSlots: 0,
          affectedTimeSlots: []
        }
      } else {
        // Pour GAME ACTIVE/CUSTOM/MIX, vérifier l'overbooking
        const gameStartDate = new Date(localDate)
        gameStartDate.setHours(hour || 10, minute || 0, 0, 0)

        const { endHour: gameEndHour, endMinute: gameEndMinute } = calculateGameEndTime()
        const gameEndDate = new Date(localDate)
        gameEndDate.setHours(gameEndHour, gameEndMinute, 0, 0)

        obInfo = calculateOverbooking(
          parsedParticipants,
          gameStartDate,
          gameEndDate,
          editingBooking?.id,
          bookingBranchId
        )
      }

      if (obInfo.willCauseOverbooking) {
        // Stocker la salle avant d'afficher le popup
        setPendingRoomId(eventRoomId)
        setOverbookingInfo(obInfo)
        setShowOverbookingWarning(true)
        return
      }
    }

    // Soumettre avec la salle trouvée
    await submitWithRoom(eventRoomId)
  }

  const handleOverCapacityConfirm = async () => {
    const confirmedRoomId = pendingRoomId
    setShowOverCapacityConfirm(false)
    setPendingRoomId(null)

    // Vérifier l'overbooking seulement si contenu ACTIVE
    const hasActiveContent = bookingType === 'EVENT'
      ? eventQuickPlan.includes('A')
      : (gameArea === 'ACTIVE' || gameArea === 'CUSTOM' || gameArea === 'MIX')

    // Après avoir confirmé la salle, vérifier l'overbooking avant de soumettre
    if (calculateOverbooking && hasActiveContent) {
      const gameStartDate = new Date(localDate)
      gameStartDate.setHours(hour || 10, minute || 0, 0, 0)

      const { endHour: gameEndHour, endMinute: gameEndMinute } = calculateGameEndTime()
      const gameEndDate = new Date(localDate)
      gameEndDate.setHours(gameEndHour, gameEndMinute, 0, 0)

      const obInfo = calculateOverbooking(
        parsedParticipants,
        gameStartDate,
        gameEndDate,
        editingBooking?.id,
        bookingBranchId
      )

      if (obInfo.willCauseOverbooking) {
        // Stocker la salle confirmée et afficher le popup d'overbooking
        setPendingRoomId(confirmedRoomId)
        setOverbookingInfo(obInfo)
        setShowOverbookingWarning(true)
        return
      }
    }

    // Pas d'overbooking, soumettre directement
    await submitWithRoom(confirmedRoomId)
  }

  const handleOverCapacityCancel = () => {
    setShowOverCapacityConfirm(false)
    setError(t('admin.booking_modal.errors.booking_cancelled'))
    setPendingRoomId(null)
  }

  const handleLowerCapacityRoomConfirm = async () => {
    if (lowerCapacityRoomInfo) {
      const confirmedRoomId = lowerCapacityRoomInfo.id
      setShowLowerCapacityRoom(false)
      setLowerCapacityRoomInfo(null)

      // Vérifier l'overbooking seulement si contenu ACTIVE
      const hasActiveContent = bookingType === 'EVENT'
        ? eventQuickPlan.includes('A')
        : (gameArea === 'ACTIVE' || gameArea === 'CUSTOM' || gameArea === 'MIX')

      // Après avoir confirmé la salle, vérifier l'overbooking avant de soumettre
      if (calculateOverbooking && hasActiveContent) {
        const gameStartDate = new Date(localDate)
        gameStartDate.setHours(hour || 10, minute || 0, 0, 0)

        const { endHour: gameEndHour, endMinute: gameEndMinute } = calculateGameEndTime()
        const gameEndDate = new Date(localDate)
        gameEndDate.setHours(gameEndHour, gameEndMinute, 0, 0)

        const obInfo = calculateOverbooking(
          parsedParticipants,
          gameStartDate,
          gameEndDate,
          editingBooking?.id,
          bookingBranchId
        )

        if (obInfo.willCauseOverbooking) {
          // Stocker la salle confirmée et afficher le popup d'overbooking
          setPendingRoomId(confirmedRoomId)
          setOverbookingInfo(obInfo)
          setShowOverbookingWarning(true)
          return
        }
      }

      // Pas d'overbooking, soumettre directement
      await submitWithRoom(confirmedRoomId)
    }
  }

  const handleLowerCapacityRoomCancel = () => {
    setShowLowerCapacityRoom(false)
    setError(`Aucune salle disponible pour ${parsedParticipants} participants. Veuillez réduire le nombre de participants ou choisir une autre période.`)
    setLowerCapacityRoomInfo(null)
  }

  const handleNoRoomAvailableClose = () => {
    setShowNoRoomAvailable(false)
    setError(`Aucune salle disponible pour ${parsedParticipants} participants. Veuillez réduire le nombre de participants ou choisir une autre période.`)
  }

  const handleOverbookingConfirm = async () => {
    setShowOverbookingWarning(false)
    // Continuer avec la soumission
    const eventRoomId = pendingRoomId || editingBooking?.event_room_id || null
    await submitWithRoom(eventRoomId)
    setOverbookingInfo(null)
    setPendingRoomId(null)
  }

  const handleOverbookingCancel = () => {
    setShowOverbookingWarning(false)
    setError(t('admin.booking_modal.errors.booking_cancelled'))
    setOverbookingInfo(null)
  }

  const handleDeleteClick = () => {
    setShowDeleteConfirm(true)
  }

  const handleDeleteConfirm = async () => {
    if (!editingBooking || !onDelete) return

    setLoading(true)
    try {
      const success = await onDelete(editingBooking.id)
      if (success) {
        setShowDeleteConfirm(false)
        onClose()
      } else {
        setError(t('admin.booking_modal.delete_error'))
        setShowDeleteConfirm(false)
      }
    } catch (err) {
      console.error('Error deleting booking:', err)
      setError(t('admin.booking_modal.delete_error'))
      setShowDeleteConfirm(false)
    } finally {
      setLoading(false)
    }
  }

  // Ref pour le formulaire
  const formRef = useRef<HTMLFormElement>(null)

  // Handler simple pour la touche Entrée - soumet directement
  const handleEnterKey = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !loading) {
      // Si on est dans un textarea, laisser le comportement par défaut (sauf Ctrl+Enter)
      if (e.target instanceof HTMLTextAreaElement) {
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault()
          const fakeEvent = { preventDefault: () => {} } as React.FormEvent
          handleSubmit(fakeEvent)
        }
        return
      }
      
      // Pour tous les autres inputs, soumettre directement
      e.preventDefault()
      e.stopPropagation()
      const fakeEvent = { preventDefault: () => {} } as React.FormEvent
      handleSubmit(fakeEvent)
    }
  }

  // Wrapper pour ContactFieldAutocomplete qui attend () => void
  const handleEnterKeyWrapper = () => {
    if (!loading) {
      const fakeEvent = { preventDefault: () => {}, stopPropagation: () => {} } as React.FormEvent
      handleSubmit(fakeEvent)
    }
  }

  if (!isOpen) return null

  const slotsNeeded = calculateSlots()
  const { endHour: gameEndHour, endMinute: gameEndMinute } = calculateGameEndTime()
  const { endHour: roomEndHour, endMinute: roomEndMinute } = calculateRoomEndTime()

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/50 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* Modal */}
      <div className={`relative w-full max-w-3xl mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
        {/* Header */}
        <div className={`flex items-center justify-between p-6 border-b ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <div>
            <h2 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
              {editingBooking ? t('admin.booking_modal.title_edit') : t('admin.booking_modal.title_new')}
            </h2>
            <div className="flex items-center gap-6 mt-1">
              {/* Date - complètement à gauche */}
              <div className="relative">
                <button
                  type="button"
                  onClick={() => setShowCalendarModal(!showCalendarModal)}
                  className={`text-sm font-medium ${isDark ? 'text-blue-400 hover:text-blue-300' : 'text-blue-600 hover:text-blue-700'} flex items-center gap-1 cursor-pointer transition-colors`}
                >
                  <Calendar className="w-4 h-4" />
                  {localDate.toLocaleDateString(getDateLocale(), {
                    weekday: 'long',
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric'
                  })}
                </button>

              {/* Modal Calendrier */}
              {showCalendarModal && (
                <>
                  <div
                    className="fixed inset-0 z-40"
                    onClick={() => setShowCalendarModal(false)}
                  />
                  <div className={`absolute left-0 top-12 z-50 ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'} rounded-lg shadow-xl p-4 min-w-[280px]`}>
                    {/* Navigation Mois/Année */}
                    <div className="flex items-center justify-between mb-4">
                      <button
                        type="button"
                        onClick={handlePreviousYear}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.booking_modal.calendar.previous_year')}
                      >
                        <div className="relative w-4 h-4">
                          <ChevronLeft className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute`} />
                          <ChevronLeft className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute left-1`} />
                        </div>
                      </button>
                      <button
                        type="button"
                        onClick={handlePreviousMonth}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.booking_modal.calendar.previous_month')}
                      >
                        <ChevronLeft className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'}`} />
                      </button>
                      <div className={`text-base font-bold ${isDark ? 'text-white' : 'text-gray-900'} px-4`}>
                        {getMonthName(calendarMonth)} {calendarYear}
                      </div>
                      <button
                        type="button"
                        onClick={handleNextMonth}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.booking_modal.calendar.next_month')}
                      >
                        <ChevronRight className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'}`} />
                      </button>
                      <button
                        type="button"
                        onClick={handleNextYear}
                        className={`p-1 ${isDark ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'} rounded hover:opacity-80 transition-all`}
                        title={t('admin.booking_modal.calendar.next_year')}
                      >
                        <div className="relative w-4 h-4">
                          <ChevronRight className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute`} />
                          <ChevronRight className={`w-4 h-4 ${isDark ? 'text-white' : 'text-gray-900'} absolute left-1`} />
                        </div>
                      </button>
                    </div>

                    {/* Grille calendrier */}
                    <div className="grid grid-cols-7 gap-1">
                      {/* En-têtes jours */}
                      {getDaysShort().map((day, i) => (
                        <div key={i} className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-600'} text-center p-1 font-bold`}>
                          {day}
                        </div>
                      ))}
                      {/* Jours */}
                      {getCalendarDays().map((date, i) => {
                        if (!date) {
                          return <div key={`empty-${i}`} className="p-2"></div>
                        }
                        const isToday = date.toDateString() === new Date().toDateString()
                        const isSelected = date.toDateString() === localDate.toDateString()
                        
                        return (
                          <button
                            key={i}
                            type="button"
                            onClick={() => handleCalendarDateClick(date)}
                            className={`p-2 rounded text-sm transition-all ${
                              isSelected
                                ? `${isDark ? 'bg-blue-600/30' : 'bg-blue-100'} ${isDark ? 'text-blue-400' : 'text-blue-600'} font-bold`
                                : isToday
                                ? `${isDark ? 'bg-blue-500/20' : 'bg-blue-50'} ${isDark ? 'text-blue-400' : 'text-blue-600'}`
                                : `${isDark ? 'text-white hover:bg-gray-700' : 'text-gray-900 hover:bg-gray-100'}`
                            }`}
                          >
                            {date.getDate()}
                          </button>
                        )
                      })}
                    </div>
                  </div>
                </>
              )}
              </div>
              
              {/* Branche - au milieu avec espacement */}
              <div ref={branchDropdownRef} className="relative">
                {editingBooking && !isEditingBranch ? (
                  // Mode gelé pour réservation existante : afficher la branche avec bouton modification
                  <div className="flex items-center gap-2">
                    <span className={`text-xs px-2 py-1 rounded ${isDark ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'}`}>
                      {branches.find(b => b.id === bookingBranchId)?.name || t('admin.booking_modal.branch')}
                    </span>
                    <button
                      type="button"
                      onClick={() => setIsEditingBranch(true)}
                      className={`p-1 rounded ${isDark ? 'hover:bg-gray-700 text-gray-400' : 'hover:bg-gray-100 text-gray-500'}`}
                      title={t('admin.booking_modal.edit_branch')}
                    >
                      <Edit2 className="w-3 h-3" />
                    </button>
                  </div>
                ) : (
                  // Mode édition ou nouvelle réservation : dropdown actif
                  <>
                    <button
                      type="button"
                      onClick={() => setShowBranchDropdown(!showBranchDropdown)}
                      className={`flex items-center gap-2 px-3 py-1.5 rounded-lg transition-colors text-sm ${
                        isDark
                          ? 'bg-gray-800 hover:bg-gray-700 text-white'
                          : 'bg-gray-100 hover:bg-gray-200 text-gray-900'
                      }`}
                      title={t('admin.booking_modal.edit_branch')}
                    >
                      <Building2 className={`w-4 h-4 ${
                        isDark ? 'text-blue-400' : 'text-blue-600'
                      }`} />
                      <span>{branches.find(b => b.id === bookingBranchId)?.name || 'Branche'}</span>
                      <ChevronDown className={`w-3 h-3 transition-transform ${
                        isDark ? 'text-gray-400' : 'text-gray-600'
                      } ${showBranchDropdown ? 'rotate-180' : ''}`} />
                    </button>

                    {showBranchDropdown && branches.length > 0 && (
                  <div className={`absolute top-full left-0 mt-2 w-56 rounded-lg shadow-xl z-50 overflow-hidden ${
                    isDark
                      ? 'bg-gray-800 border border-gray-700'
                      : 'bg-white border border-gray-200'
                  }`}>
                    {branches.filter((branch, index, self) => 
                      index === self.findIndex(b => b.id === branch.id)
                    ).map((branch) => (
                      <button
                        key={branch.id}
                        type="button"
                        onClick={() => {
                          // Changer la branche - cela déclenchera la validation dans le useEffect
                          setBookingBranchId(branch.id)
                          setShowBranchDropdown(false)
                          // Réinitialiser les états d'avertissement pour forcer la re-vérification
                          setShowOverbookingWarning(false)
                          setOverbookingInfo(null)
                          setShowNoRoomAvailable(false)
                          setShowLowerCapacityRoom(false)
                        }}
                        className={`w-full px-4 py-2.5 text-left transition-colors text-sm ${
                          bookingBranchId === branch.id
                            ? isDark
                              ? 'bg-blue-600/20 text-blue-400'
                              : 'bg-blue-100 text-blue-700'
                            : isDark
                            ? 'text-white hover:bg-gray-700'
                            : 'text-gray-900 hover:bg-gray-100'
                        }`}
                      >
                        <div className="font-medium">{branch.name}</div>
                      </button>
                    ))}
                  </div>
                    )}
                  </>
                )}
              </div>
            </div>
          </div>
          <div className="flex items-center gap-1">
            {/* Icônes d'accès rapide - visibles uniquement en mode édition avec orderId */}
            {editingBooking && orderId && (
              <div className="flex items-center gap-1 mr-2">
                {/* Fiche Commande */}
                {onViewOrder && (
                  <button
                    type="button"
                    onClick={() => onViewOrder(orderId)}
                    className={`p-2.5 rounded-lg transition-colors ${
                      isDark
                        ? 'hover:bg-blue-600/30 text-blue-400'
                        : 'hover:bg-blue-100 text-blue-600'
                    }`}
                    title={t('admin.booking_modal.actions.view_order')}
                  >
                    <FileText className="w-6 h-6" />
                  </button>
                )}
                {/* Fiche Comptable */}
                {onOpenAccounting && (
                  <button
                    type="button"
                    onClick={() => onOpenAccounting(orderId)}
                    className={`p-2.5 rounded-lg transition-colors ${
                      isDark
                        ? 'hover:bg-cyan-600/30 text-cyan-400'
                        : 'hover:bg-cyan-100 text-cyan-600'
                    }`}
                    title={t('admin.accounting.title')}
                  >
                    <Receipt className="w-6 h-6" />
                  </button>
                )}
                {/* Clôturer la commande */}
                {onCloseOrder && orderId && orderStatus !== 'closed' && orderStatus !== 'cancelled' && (
                  <button
                    type="button"
                    onClick={() => onCloseOrder(orderId)}
                    className={`p-2.5 rounded-lg transition-colors ${
                      isDark
                        ? 'hover:bg-green-600/30 text-green-400'
                        : 'hover:bg-green-100 text-green-600'
                    }`}
                    title={t('admin.orders.close_order')}
                  >
                    <CheckCheck className="w-6 h-6" />
                  </button>
                )}
              </div>
            )}
            <button
              onClick={onClose}
              className={`p-2 rounded-lg ${isDark ? 'hover:bg-gray-700 text-gray-400' : 'hover:bg-gray-100 text-gray-500'}`}
            >
              <X className="w-5 h-5" />
            </button>
          </div>
        </div>

        {/* Body */}
        <form ref={formRef} onSubmit={handleSubmit} className="p-6 space-y-5 max-h-[75vh] overflow-y-auto">
          {/* Avertissement commande fermée */}
          {orderStatus === 'closed' && (
            <div className="flex items-center gap-3 p-3 rounded-lg bg-amber-500/20 border border-amber-500/30">
              <AlertTriangle className="w-5 h-5 text-amber-500 flex-shrink-0" />
              <p className="text-sm text-amber-600 dark:text-amber-400">
                {t('errors.orderClosed')}
              </p>
            </div>
          )}

          {/* Reference Code / Numéro de commande */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.booking_modal.order_number')}
            </label>
            <div className={`px-3 py-2 rounded-lg border text-sm font-mono ${
              isDark
                ? 'bg-gray-700/50 border-gray-600 text-gray-300'
                : 'bg-gray-100 border-gray-300 text-gray-700'
            }`}>
              {editingBooking?.reference_code || t('admin.booking_modal.creating')}
            </div>
            <p className={`text-xs mt-1 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
              {editingBooking ? t('admin.booking_modal.order_number_help_edit') : t('admin.booking_modal.order_number_help_new')}
            </p>
          </div>

          {/* Type de réservation + Couleur */}
          <div>
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              {t('admin.booking_modal.type_label')}
            </label>
            <div className="grid grid-cols-2 gap-3 mb-3">
              <button
                type="button"
                onClick={() => setBookingType('GAME')}
                className={`p-3 rounded-xl border-2 transition-all flex items-center gap-3 ${
                  bookingType === 'GAME'
                    ? 'border-blue-500 bg-blue-500/10'
                    : isDark ? 'border-gray-700 hover:border-gray-600' : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                <Gamepad2 className={`w-6 h-6 ${bookingType === 'GAME' ? 'text-blue-500' : isDark ? 'text-gray-400' : 'text-gray-500'}`} />
                <span className={`font-medium ${bookingType === 'GAME' ? 'text-blue-500' : isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  Game
                </span>
              </button>
              <button
                type="button"
                onClick={() => setBookingType('EVENT')}
                className={`p-3 rounded-xl border-2 transition-all flex items-center gap-3 ${
                  bookingType === 'EVENT'
                    ? 'border-green-500 bg-green-500/10'
                    : isDark ? 'border-gray-700 hover:border-gray-600' : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                <PartyPopper className={`w-6 h-6 ${bookingType === 'EVENT' ? 'text-green-500' : isDark ? 'text-gray-400' : 'text-gray-500'}`} />
                <span className={`font-medium ${bookingType === 'EVENT' ? 'text-green-500' : isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  Event
                </span>
              </button>
            </div>

            {/* Sélecteur de couleur - en dessous, sur une ligne */}
            <div className="flex items-center gap-3">
              <Palette className={`w-4 h-4 flex-shrink-0 ${isDark ? 'text-gray-400' : 'text-gray-500'}`} />
              <div className="flex items-center gap-2 flex-1">
                {COLORS.map((c) => (
                  <button
                    key={c.value}
                    type="button"
                    onClick={() => setColor(c.value)}
                    className={`w-7 h-7 rounded-full transition-all border-2 flex-shrink-0 ${
                      color === c.value
                        ? `${isDark ? 'ring-2 ring-offset-2 ring-white ring-offset-gray-800' : 'ring-2 ring-offset-2 ring-gray-800 ring-offset-white'} scale-125 border-white shadow-lg`
                        : `${isDark ? 'border-gray-600 hover:border-gray-500' : 'border-gray-300 hover:border-gray-400'} hover:scale-110`
                    }`}
                    style={{ backgroundColor: c.value }}
                    title={c.name}
                  />
                ))}
              </div>
            </div>

            {/* Remise (Discount) */}
            <div className="flex items-center gap-3 mt-3">
              <span className={`text-sm ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>Remise:</span>
              <div className="flex items-center gap-2">
                <button
                  type="button"
                  onClick={() => setDiscountType(discountType === 'percent' ? null : 'percent')}
                  className={`px-3 py-1 rounded-lg text-sm transition-all ${
                    discountType === 'percent'
                      ? 'bg-purple-500 text-white'
                      : isDark ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`}
                >
                  %
                </button>
                <button
                  type="button"
                  onClick={() => setDiscountType(discountType === 'fixed' ? null : 'fixed')}
                  className={`px-3 py-1 rounded-lg text-sm transition-all ${
                    discountType === 'fixed'
                      ? 'bg-purple-500 text-white'
                      : isDark ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`}
                >
                  ₪
                </button>
                {discountType && (
                  <input
                    type="number"
                    value={discountValue}
                    onChange={(e) => setDiscountValue(e.target.value)}
                    placeholder={discountType === 'percent' ? 'Ex: 10' : 'Ex: 50'}
                    className={`w-20 px-2 py-1 rounded-lg border text-sm ${
                      isDark
                        ? 'bg-gray-800 border-gray-600 text-white'
                        : 'bg-white border-gray-300 text-gray-900'
                    }`}
                    min="0"
                    max={discountType === 'percent' ? '100' : undefined}
                  />
                )}
                {discountType && discountValue && (
                  <span className={`text-xs ${isDark ? 'text-purple-400' : 'text-purple-600'}`}>
                    {discountType === 'percent' ? `${discountValue}%` : `${discountValue}₪`}
                  </span>
                )}
              </div>
            </div>
          </div>

          {/* EVENT : Salle d'événement - EN PREMIER (définit l'heure de début) */}
          {bookingType === 'EVENT' && (
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
              <div className="flex items-center gap-2 mb-3">
                <Home className="w-5 h-5 text-green-400" />
                <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>{t('admin.booking_modal.event.room_title')}</span>
              </div>
              <div className="grid grid-cols-4 gap-3">
                <div>
                  <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.booking_modal.event.room_start')}
                  </label>
                  <div className="flex gap-1">
                    <select
                      value={roomStartHour}
                      onChange={(e) => setRoomStartHour(parseInt(e.target.value))}
                      className={`admin-time-select flex-1 px-2 py-2 rounded-lg border text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 hover:border-blue-400 ${
                        isDark
                          ? 'bg-gray-800 border-gray-600 text-white focus:bg-gray-800 hover:bg-gray-800'
                          : 'bg-white border-gray-300 text-gray-900 focus:bg-white hover:bg-white'
                      }`}
                    >
                      {hourOptions.map(h => (
                        <option key={h} value={h}>{String(h).padStart(2, '0')}h</option>
                      ))}
                    </select>
                    <select
                      value={roomStartMinute}
                      onChange={(e) => setRoomStartMinute(parseInt(e.target.value))}
                      className={`admin-time-select flex-1 px-2 py-2 rounded-lg border text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 hover:border-blue-400 ${
                        isDark
                          ? 'bg-gray-800 border-gray-600 text-white focus:bg-gray-800 hover:bg-gray-800'
                          : 'bg-white border-gray-300 text-gray-900 focus:bg-white hover:bg-white'
                      }`}
                    >
                      {[0, 15, 30, 45].map(m => (
                        <option key={m} value={m}>{String(m).padStart(2, '0')}</option>
                      ))}
                    </select>
                  </div>
                </div>
                <div>
                  <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.booking_modal.fields.duration_min')}
                  </label>
                  <input
                    type="number"
                    min="15"
                    step="15"
                    value={roomDurationMinutes}
                    onChange={(e) => setRoomDurationMinutes(e.target.value)}
                    className={`w-full px-2 py-2 rounded-lg border text-sm ${
                      isDark
                        ? 'bg-gray-700 border-gray-600 text-white'
                        : 'bg-white border-gray-300 text-gray-900'
                    }`}
                    placeholder="120"
                  />
                </div>
                <div>
                  <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.booking_modal.event.room_end')}
                  </label>
                  <div className={`px-2 py-2 rounded-lg border text-sm ${
                    isDark ? 'bg-gray-700/50 border-gray-600 text-gray-400' : 'bg-gray-100 border-gray-300 text-gray-600'
                  }`}>
                    {String(roomEndHour).padStart(2, '0')}:{String(roomEndMinute).padStart(2, '0')}
                  </div>
                </div>
                <div>
                  <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.booking_modal.fields.participants')}
                  </label>
                  <input
                    type="number"
                    min="1"
                    value={participants}
                    onChange={(e) => setParticipants(e.target.value)}
                    onKeyDown={handleEnterKey}
                    className={`w-full px-2 py-2 rounded-lg border text-sm ${
                      isOverCapacity
                        ? 'border-red-500 bg-red-500/10'
                        : isDark
                          ? 'bg-gray-700 border-gray-600 text-white'
                          : 'bg-white border-gray-300 text-gray-900'
                    }`}
                    placeholder="1"
                  />
                </div>
              </div>
              
              {/* Alias et Notes de l'événement */}
              <div className="mt-3 grid grid-cols-4 gap-3">
                <div className="col-span-1">
                  <label className={`block text-xs font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    <User className="w-3 h-3 inline mr-1" />
                    {t('admin.booking_modal.fields.alias')}
                  </label>
                  <input
                    type="text"
                    value={eventAlias}
                    onChange={(e) => setEventAlias(e.target.value)}
                    className={`w-full px-2 py-2 rounded-lg border text-sm ${
                      isDark
                        ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                        : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                    }`}
                    placeholder={t('admin.booking_modal.fields.alias_placeholder')}
                  />
                </div>
                <div className="col-span-3">
                  <label className={`block text-xs font-medium mb-1 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    <MessageSquare className="w-3 h-3 inline mr-1" />
                    {t('admin.booking_modal.event.event_notes')}
                  </label>
                  <textarea
                    value={eventNotes}
                    onChange={(e) => {
                      setEventNotes(e.target.value)
                      const textarea = e.target as HTMLTextAreaElement
                      textarea.style.height = 'auto'
                      const maxHeight = 5 * 24
                      const newHeight = Math.min(textarea.scrollHeight, maxHeight)
                      textarea.style.height = `${newHeight}px`
                    }}
                    rows={2}
                    className={`w-full px-3 py-2 rounded-lg border resize-none text-sm overflow-y-auto ${
                      isDark
                        ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                        : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
                    }`}
                    placeholder={t('admin.booking_modal.event.event_notes_placeholder')}
                    style={{ minHeight: '48px', maxHeight: '120px' }}
                  />
                </div>
              </div>
            </div>
          )}

          {/* EVENT : Plan de jeu - ENSUITE */}
          {bookingType === 'EVENT' && laserRooms.length > 0 && (
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <PartyPopper className="w-5 h-5 text-green-400" />
                  <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>{t('admin.booking_modal.event.game_plan')}</span>
                </div>
                {/* Bouton Modifier événement (uniquement en mode édition) */}
                {editingBooking && !isEditingEvent && (
                  <button
                    type="button"
                    onClick={handleModifyEvent}
                    className={`px-3 py-1.5 text-xs rounded-lg transition-colors flex items-center gap-2 ${
                      isDark
                        ? 'bg-blue-600/20 hover:bg-blue-600/30 text-blue-400 border border-blue-500/50'
                        : 'bg-blue-100 hover:bg-blue-200 text-blue-700 border border-blue-300'
                    }`}
                  >
                    <Edit2 className="w-3 h-3" />
                    {t('admin.booking_modal.event.modify_event')}
                  </button>
                )}
              </div>
              
              {/* Variable pour désactiver les champs si l'événement est verrouillé */}
              {(() => {
                const isEventLocked = editingBooking && !isEditingEvent
                return (
                  <div className={isEventLocked ? 'opacity-60 pointer-events-none' : ''}>
              
              {/* Sélection du nombre de jeux (2 jeux ou sur mesure) */}
              <div className="mb-4">
                <label className={`block text-xs mb-2 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.booking_modal.event.game_plan')}
                </label>
                <div className="grid grid-cols-2 gap-2">
                  {(['2', 'CUSTOM'] as EventGamePlanType[]).map(planType => (
                    <button
                      key={planType}
                      type="button"
                      onClick={() => {
                        setEventGamePlanType(planType)
                        if (planType !== 'CUSTOM') {
                          const count = parseInt(planType)
                          // Initialiser les durées et pauses selon le nombre de jeux
                          const defaultDurations = Array(count).fill('30')
                          const defaultPauses = Array(count - 1).fill(30) // Pauses après chaque jeu (sauf le dernier)
                          setEventGameDurations(defaultDurations)
                          setEventGamePauses(defaultPauses)
                          // Sélectionner le premier plan prédéfini disponible
                          const availablePlans = getAvailableQuickPlans(planType)
                          if (availablePlans.length > 0) {
                            setEventQuickPlan(availablePlans[0])
                            // Réinitialiser les pauses selon le nouveau plan
                            const areas = getQuickPlanAreas(availablePlans[0])
                            const newPauses = Array(areas.length - 1).fill(30)
                            setEventGamePauses(newPauses)
                          }
                        }
                      }}
                      className={`p-2 rounded-lg border-2 transition-all text-sm ${
                        eventGamePlanType === planType
                          ? 'border-green-500 bg-green-500/10 text-green-500'
                          : isDark ? 'border-gray-700 hover:border-gray-600 text-gray-300' : 'border-gray-200 hover:border-gray-300 text-gray-700'
                      }`}
                    >
                      {planType === 'CUSTOM' ? t('admin.booking_modal.event.custom_plan') : `${planType} ${t('admin.booking_modal.fields.games')}`}
                    </button>
                  ))}
                </div>
              </div>

              {/* Plans prédéfinis (si pas sur mesure) */}
              {eventGamePlanType !== 'CUSTOM' && (
                <div className="mb-4">
                  <label className={`block text-xs mb-2 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {t('admin.booking_modal.event.predefined_plan')}
                  </label>
                  <div className="grid grid-cols-2 gap-2">
                    {getAvailableQuickPlans(eventGamePlanType).map(plan => (
                      <button
                        key={plan}
                        type="button"
                        onClick={() => {
                          setEventQuickPlan(plan)
                          // Réinitialiser les pauses selon le nouveau plan
                          const areas = getQuickPlanAreas(plan)
                          const newPauses = Array(areas.length - 1).fill(30)
                          setEventGamePauses(newPauses)
                        }}
                        className={`p-2 rounded-lg border-2 transition-all text-xs ${
                          eventQuickPlan === plan
                            ? 'border-green-500 bg-green-500/10 text-green-500'
                            : isDark ? 'border-gray-700 hover:border-gray-600 text-gray-300' : 'border-gray-200 hover:border-gray-300 text-gray-700'
                        }`}
                      >
                        {getQuickPlanLabel(plan)}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* Configuration des sessions selon le plan */}
              {eventGamePlanType !== 'CUSTOM' ? (
                // Plan prédéfini : afficher configuration pour chaque jeu
                <div className="space-y-3">
                  <div className="mb-3">
                    <label className={`block text-xs mb-2 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      {t('admin.booking_modal.event.first_game_start')}
                    </label>
                    <div className="flex gap-1 w-fit">
                      <select
                        value={eventFirstGameStartHour}
                        onChange={(e) => setEventFirstGameStartHour(parseInt(e.target.value))}
                        className={`admin-time-select w-20 px-2 py-1.5 rounded-lg border text-sm ${
                          isDark
                            ? 'bg-gray-800 border-gray-600 text-white'
                            : 'bg-white border-gray-300 text-gray-900'
                        }`}
                      >
                        {hourOptions.map(h => (
                          <option key={h} value={h}>{String(h).padStart(2, '0')}h</option>
                        ))}
                      </select>
                      <select
                        value={eventFirstGameStartMinute}
                        onChange={(e) => setEventFirstGameStartMinute(parseInt(e.target.value))}
                        className={`admin-time-select w-20 px-2 py-1.5 rounded-lg border text-sm ${
                          isDark
                            ? 'bg-gray-800 border-gray-600 text-white'
                            : 'bg-white border-gray-300 text-gray-900'
                        }`}
                      >
                        {[0, 15, 30, 45].map(m => (
                          <option key={m} value={m}>{String(m).padStart(2, '0')}</option>
                        ))}
                      </select>
                    </div>
                  </div>
                  
                  {getQuickPlanAreas(eventQuickPlan).map((area, index) => {
                    const gameNumber = index + 1
                    return (
                      <div key={index} className={`p-3 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
                        <div className="flex items-center justify-between mb-2">
                          <span className={`text-sm font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                            {t('admin.booking_modal.fields.game_number')} {gameNumber} ({area === 'ACTIVE' ? 'Active' : 'Laser'})
                          </span>
                        </div>
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                              Durée (min)
                            </label>
                            <input
                              type="number"
                              min="15"
                              step="15"
                              value={eventGameDurations[index] || '30'}
                              onChange={(e) => {
                                const newDurations = [...eventGameDurations]
                                newDurations[index] = e.target.value
                                setEventGameDurations(newDurations)
                              }}
                              className={`w-full px-2 py-1 rounded border text-sm ${
                                isDark
                                  ? 'bg-gray-700 border-gray-600 text-white'
                                  : 'bg-white border-gray-300 text-gray-900'
                              }`}
                              placeholder={area === 'LASER' ? '30' : '30'}
                            />
                          </div>
                          {index < getQuickPlanAreas(eventQuickPlan).length - 1 && (
                            <div>
                              <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                                Pause après (min)
                              </label>
                              <input
                                type="number"
                                min="0"
                                step="15"
                                value={eventGamePauses[index] ?? 30}
                                onChange={(e) => {
                                  const newPauses = [...eventGamePauses]
                                  const value = e.target.value === '' ? 0 : parseInt(e.target.value, 10)
                                  newPauses[index] = isNaN(value) ? 0 : value
                                  setEventGamePauses(newPauses)
                                }}
                                className={`w-full px-2 py-1 rounded border text-sm ${
                                  isDark
                                    ? 'bg-gray-700 border-gray-600 text-white'
                                    : 'bg-white border-gray-300 text-gray-900'
                                }`}
                              />
                            </div>
                          )}
                        </div>
                      </div>
                    )
                  })}
                </div>
              ) : (
                // Plan sur mesure : même interface que GAME
                <div className="space-y-3">
                  <div className="mb-3">
                    <label className={`block text-xs mb-2 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      {t('admin.booking_modal.event.first_game_start')}
                    </label>
                    <div className="flex gap-1 w-fit">
                      <select
                        value={eventFirstGameStartHour}
                        onChange={(e) => setEventFirstGameStartHour(parseInt(e.target.value))}
                        className={`admin-time-select w-20 px-2 py-1.5 rounded-lg border text-sm ${
                          isDark
                            ? 'bg-gray-800 border-gray-600 text-white'
                            : 'bg-white border-gray-300 text-gray-900'
                        }`}
                      >
                        {hourOptions.map(h => (
                          <option key={h} value={h}>{String(h).padStart(2, '0')}h</option>
                        ))}
                      </select>
                      <select
                        value={eventFirstGameStartMinute}
                        onChange={(e) => setEventFirstGameStartMinute(parseInt(e.target.value))}
                        className={`admin-time-select w-20 px-2 py-1.5 rounded-lg border text-sm ${
                          isDark
                            ? 'bg-gray-800 border-gray-600 text-white'
                            : 'bg-white border-gray-300 text-gray-900'
                        }`}
                      >
                        {[0, 15, 30, 45].map(m => (
                          <option key={m} value={m}>{String(m).padStart(2, '0')}</option>
                        ))}
                      </select>
                    </div>
                  </div>
                  <div className="mb-3">
                    <label className={`block text-xs mb-2 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                      Nombre de jeux
                    </label>
                    <div ref={customGamesDropdownRef} className="relative">
                      <button
                        type="button"
                        onClick={() => setShowCustomGamesDropdown(!showCustomGamesDropdown)}
                        className={`flex items-center justify-between w-full px-3 py-2 rounded-lg transition-colors text-sm ${
                          isDark
                            ? 'bg-gray-800 hover:bg-gray-700 text-white'
                            : 'bg-gray-100 hover:bg-gray-200 text-gray-900'
                        }`}
                      >
                        <span>{eventCustomNumberOfGames} {t('admin.booking_modal.fields.games')}</span>
                        <ChevronDown className={`w-3 h-3 transition-transform ${
                          isDark ? 'text-gray-400' : 'text-gray-600'
                        } ${showCustomGamesDropdown ? 'rotate-180' : ''}`} />
                      </button>

                      {showCustomGamesDropdown && (
                        <div className={`absolute top-full left-0 mt-2 w-full rounded-lg shadow-xl z-50 overflow-hidden ${
                          isDark
                            ? 'bg-gray-800 border border-gray-700'
                            : 'bg-white border border-gray-200'
                        }`}>
                          {[1, 2, 3, 4].map(n => (
                            <button
                              key={n}
                              type="button"
                              onClick={() => {
                                setEventCustomNumberOfGames(n)
                                const defaultDurations = Array(n).fill('30')
                                const defaultPauses = Array(n - 1).fill(0)
                                setEventCustomGameDurations(defaultDurations)
                                setEventCustomGamePauses(defaultPauses)
                                setEventCustomGameArea(Array(n).fill('ACTIVE' as GameArea))
                                setEventCustomLaserRoomIds(Array(n).fill(''))
                                setShowCustomGamesDropdown(false)
                              }}
                              className={`w-full px-4 py-2.5 text-left transition-colors text-sm ${
                                eventCustomNumberOfGames === n
                                  ? isDark
                                    ? 'bg-blue-600/20 text-blue-400'
                                    : 'bg-blue-100 text-blue-700'
                                  : isDark
                                  ? 'text-white hover:bg-gray-700'
                                  : 'text-gray-900 hover:bg-gray-100'
                              }`}
                            >
                              {n} {t('admin.booking_modal.fields.games')}
                            </button>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {Array.from({ length: eventCustomNumberOfGames }).map((_, index) => (
                    <div key={index} className={`p-3 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
                      <div className="mb-2">
                        <label className={`block text-xs mb-1 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                          {t('admin.booking_modal.fields.game_number')} {index + 1} - {t('admin.booking_modal.event.game_type')}
                        </label>
                        <div className="grid grid-cols-2 gap-2">
                          <button
                            type="button"
                            onClick={() => {
                              const newAreas = [...eventCustomGameArea]
                              newAreas[index] = 'ACTIVE'
                              setEventCustomGameArea(newAreas)
                            }}
                            className={`p-2 rounded-lg border-2 text-xs ${
                              eventCustomGameArea[index] === 'ACTIVE'
                                ? 'border-blue-500 bg-blue-500/10 text-blue-500'
                                : isDark ? 'border-gray-700 text-gray-300' : 'border-gray-200 text-gray-700'
                            }`}
                          >
                            Active
                          </button>
                          <button
                            type="button"
                            onClick={() => {
                              const newAreas = [...eventCustomGameArea]
                              newAreas[index] = 'LASER'
                              setEventCustomGameArea(newAreas)
                            }}
                            className={`p-2 rounded-lg border-2 text-xs ${
                              eventCustomGameArea[index] === 'LASER'
                                ? 'border-purple-500 bg-purple-500/10 text-purple-500'
                                : isDark ? 'border-gray-700 text-gray-300' : 'border-gray-200 text-gray-700'
                            }`}
                          >
                            Laser
                          </button>
                        </div>
                      </div>
                      <div className="grid grid-cols-2 gap-2 mt-2">
                        <div>
                          <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                            Durée (min)
                          </label>
                          <input
                            type="number"
                            min="15"
                            step="15"
                            value={eventCustomGameDurations[index] || '30'}
                            onChange={(e) => {
                              const newDurations = [...eventCustomGameDurations]
                              newDurations[index] = e.target.value
                              setEventCustomGameDurations(newDurations)
                            }}
                            className={`w-full px-2 py-1 rounded border text-sm ${
                              isDark
                                ? 'bg-gray-700 border-gray-600 text-white'
                                : 'bg-white border-gray-300 text-gray-900'
                            }`}
                          />
                        </div>
                        {index < eventCustomNumberOfGames - 1 && (
                          <div>
                            <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                              {t('admin.booking_modal.event.pause_after')}
                            </label>
                            <input
                              type="number"
                              min="0"
                              step="15"
                              value={eventCustomGamePauses[index] ?? 0}
                              onChange={(e) => {
                                const newPauses = [...eventCustomGamePauses]
                                const value = e.target.value === '' ? 0 : parseInt(e.target.value, 10)
                                newPauses[index] = isNaN(value) ? 0 : value
                                setEventCustomGamePauses(newPauses)
                              }}
                              className={`w-full px-2 py-1 rounded border text-sm ${
                                isDark
                                  ? 'bg-gray-700 border-gray-600 text-white'
                                  : 'bg-white border-gray-300 text-gray-900'
                              }`}
                            />
                          </div>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}
                  </div>
                )
              })()}
            </div>
          )}

          {/* Sélection Zone de jeu (ACTIVE/LASER/Sur mesure) - Uniquement pour GAME */}
          {bookingType === 'GAME' && laserRooms.length > 0 && (
            <div>
              <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.game_area_label')}
              </label>
              <div className="grid grid-cols-3 gap-3">
                <button
                  type="button"
                      onClick={() => {
                        setGameArea('ACTIVE')
                        // Par défaut ACTIVE : 2 jeux de 30 min avec 0 pause après le premier
                        setNumberOfGames(2)
                        setGameDurations(['30', '30'])
                        setGamePauses([0]) // Pause après le premier jeu (0 par défaut)
                        setDurationMinutes('60') // Durée par défaut pour un jeu ACTIVE simple (60 min)
                      }}
                  className={`p-3 rounded-xl border-2 transition-all flex items-center gap-3 ${
                    gameArea === 'ACTIVE'
                      ? 'border-blue-500 bg-blue-500/10'
                      : isDark ? 'border-gray-700 hover:border-gray-600' : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <Zap className={`w-6 h-6 ${gameArea === 'ACTIVE' ? 'text-blue-500' : isDark ? 'text-gray-400' : 'text-gray-500'}`} />
                  <span className={`font-medium ${gameArea === 'ACTIVE' ? 'text-blue-500' : isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    Active
                  </span>
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setGameArea('LASER')
                    // Par défaut LASER : 1 jeu de 30 min
                    setNumberOfGames(1)
                    setGameDurations(['30'])
                    setGamePauses([]) // Pas de pause pour un seul jeu
                    setDurationMinutes('30') // Durée par défaut pour un jeu LASER simple (30 min)
                  }}
                  className={`p-3 rounded-xl border-2 transition-all flex items-center gap-3 ${
                    gameArea === 'LASER'
                      ? 'border-purple-500 bg-purple-500/10'
                      : isDark ? 'border-gray-700 hover:border-gray-600' : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <Target className={`w-6 h-6 ${gameArea === 'LASER' ? 'text-purple-500' : isDark ? 'text-gray-400' : 'text-gray-500'}`} />
                  <span className={`font-medium ${gameArea === 'LASER' ? 'text-purple-500' : isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    Laser
                  </span>
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setGameArea('CUSTOM')
                    // Initialiser les valeurs par défaut pour sur mesure
                    setGameCustomNumberOfGames(2)
                    setGameCustomGameDurations(['30', '30'])
                    setGameCustomGamePauses([0])
                    setGameCustomGameArea(['ACTIVE', 'ACTIVE'] as GameArea[])
                    setGameCustomLaserRoomIds(['', ''])
                  }}
                  className={`p-3 rounded-xl border-2 transition-all flex items-center gap-3 ${
                    gameArea === 'CUSTOM'
                      ? 'border-green-500 bg-green-500/10'
                      : isDark ? 'border-gray-700 hover:border-gray-600' : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <Gamepad2 className={`w-6 h-6 ${gameArea === 'CUSTOM' ? 'text-green-500' : isDark ? 'text-gray-400' : 'text-gray-500'}`} />
                  <span className={`font-medium ${gameArea === 'CUSTOM' ? 'text-green-500' : isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {t('admin.booking_modal.game_area.custom')}
                  </span>
                </button>
              </div>
            </div>
          )}

          {/* Temps de jeu et Participants - Uniquement affiché si zone de jeu sélectionnée (GAME) */}
          {bookingType === 'GAME' && gameArea !== null && (
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
              <div className="flex items-center gap-2 mb-3">
                <Gamepad2 className="w-5 h-5 text-blue-400" />
                <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>{t('admin.booking_modal.game_time')}</span>
              </div>
              <div className={`grid gap-3 ${(gameArea as string) === 'CUSTOM' ? 'grid-cols-2' : (numberOfGames === 1 && (gameArea as string) !== 'CUSTOM' ? 'grid-cols-3' : 'grid-cols-2')}`}>
                <div>
                  <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.booking_modal.start')}
                  </label>
                  <div className="flex gap-1">
                    <select
                      value={hour}
                      onChange={(e) => setHour(parseInt(e.target.value))}
                      onKeyDown={handleEnterKey}
                      className={`admin-time-select flex-1 px-2 py-2 rounded-lg border text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 hover:border-blue-400 ${
                        isDark
                          ? 'bg-gray-800 border-gray-600 text-white focus:bg-gray-800 hover:bg-gray-800'
                          : 'bg-white border-gray-300 text-gray-900 focus:bg-white hover:bg-white'
                      }`}
                    >
                      {hourOptions.map(h => (
                        <option key={h} value={h}>{String(h).padStart(2, '0')}h</option>
                      ))}
                    </select>
                    <select
                      value={minute}
                      onChange={(e) => setMinute(parseInt(e.target.value))}
                      onKeyDown={handleEnterKey}
                      className={`admin-time-select flex-1 px-2 py-2 rounded-lg border text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 hover:border-blue-400 ${
                        isDark
                          ? 'bg-gray-800 border-gray-600 text-white focus:bg-gray-800 hover:bg-gray-800'
                          : 'bg-white border-gray-300 text-gray-900 focus:bg-white hover:bg-white'
                      }`}
                    >
                      {[0, 15, 30, 45].map(m => (
                        <option key={m} value={m}>{String(m).padStart(2, '0')}</option>
                      ))}
                    </select>
                  </div>
                </div>
                {/* Durée - uniquement affichée pour 1 jeu (pas pour 2, 3, 4 jeux où on utilise les durées individuelles) */}
                {gameArea !== 'CUSTOM' && numberOfGames === 1 && (
                  <div>
                    <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                      Durée (min)
                    </label>
                    <input
                      type="number"
                      min="15"
                      step="15"
                      value={durationMinutes}
                      onChange={(e) => setDurationMinutes(e.target.value)}
                      onKeyDown={handleEnterKey}
                      className={`w-full px-2 py-2 rounded-lg border text-sm ${
                        isDark
                          ? 'bg-gray-700 border-gray-600 text-white'
                          : 'bg-white border-gray-300 text-gray-900'
                      }`}
                      placeholder={gameArea === 'LASER' ? '30' : '60'}
                    />
                  </div>
                )}
                <div>
                  <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.booking_modal.fields.participants')}
                  </label>
                  <input
                    type="number"
                    min="1"
                    value={participants}
                    onChange={(e) => setParticipants(e.target.value)}
                    className={`w-full px-2 py-2 rounded-lg border text-sm ${
                      isOverCapacity
                        ? 'border-red-500 bg-red-500/10'
                        : isDark
                          ? 'bg-gray-700 border-gray-600 text-white'
                          : 'bg-white border-gray-300 text-gray-900'
                    }`}
                    placeholder="1"
                  />
                </div>
              </div>
              {/* Info slots Tetris */}
              {parsedParticipants > 0 && bookingType === 'GAME' && gameArea === 'ACTIVE' && (
                <div className={`mt-2 text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.booking_modal.game.slots_info', { slots: slotsNeeded, places: slotsNeeded * MAX_PLAYERS_PER_SLOT })}
                  {isOverCapacity && <span className="text-red-400 ml-2">{t('admin.booking_modal.game.max_capacity')}: {TOTAL_CAPACITY}</span>}
                </div>
              )}
            </div>
          )}

          {/* Allocation manuelle LASER */}
          {bookingType === 'GAME' && gameArea === 'LASER' && (
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
              <div className="flex items-center gap-2 mb-3">
                <Target className="w-5 h-5 text-purple-400" />
                <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>{t('admin.booking_modal.laser.allocation_title')}</span>
              </div>
              {(() => {
                const activeLaserRooms = laserRooms?.filter(r => r.is_active) || []
                const hasMultipleRooms = activeLaserRooms.length > 1
                return (
                  <>
                    <div className="grid grid-cols-2 gap-2">
                      <button
                        type="button"
                        onClick={() => setLaserAllocationMode('auto')}
                        className={`px-4 py-3 rounded-lg border-2 transition-all ${
                          laserAllocationMode === 'auto'
                            ? 'border-purple-500 bg-purple-500/10 text-purple-500'
                            : isDark ? 'border-gray-700 hover:border-gray-600 text-gray-300' : 'border-gray-200 hover:border-gray-300 text-gray-700'
                        }`}
                      >
                        <div className="font-medium">{t('admin.booking_modal.laser.auto')}</div>
                        <div className={`text-xs mt-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.booking_modal.laser.auto_desc')}</div>
                      </button>
                      <button
                        type="button"
                        onClick={() => hasMultipleRooms && setLaserAllocationMode('petit')}
                        disabled={!hasMultipleRooms}
                        className={`px-4 py-3 rounded-lg border-2 transition-all ${
                          !hasMultipleRooms
                            ? 'opacity-40 cursor-not-allowed border-gray-600 text-gray-500'
                            : laserAllocationMode === 'petit'
                              ? 'border-purple-500 bg-purple-500/10 text-purple-500'
                              : isDark ? 'border-gray-700 hover:border-gray-600 text-gray-300' : 'border-gray-200 hover:border-gray-300 text-gray-700'
                        }`}
                      >
                        <div className="font-medium">{t('admin.booking_modal.laser.petit')}</div>
                        <div className={`text-xs mt-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.booking_modal.laser.petit_desc')}</div>
                      </button>
                      <button
                        type="button"
                        onClick={() => hasMultipleRooms && setLaserAllocationMode('grand')}
                        disabled={!hasMultipleRooms}
                        className={`px-4 py-3 rounded-lg border-2 transition-all ${
                          !hasMultipleRooms
                            ? 'opacity-40 cursor-not-allowed border-gray-600 text-gray-500'
                            : laserAllocationMode === 'grand'
                              ? 'border-purple-500 bg-purple-500/10 text-purple-500'
                              : isDark ? 'border-gray-700 hover:border-gray-600 text-gray-300' : 'border-gray-200 hover:border-gray-300 text-gray-700'
                        }`}
                      >
                        <div className="font-medium">{t('admin.booking_modal.laser.grand')}</div>
                        <div className={`text-xs mt-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.booking_modal.laser.grand_desc')}</div>
                      </button>
                      <button
                        type="button"
                        onClick={() => hasMultipleRooms && setLaserAllocationMode('maxi')}
                        disabled={!hasMultipleRooms}
                        className={`px-4 py-3 rounded-lg border-2 transition-all ${
                          !hasMultipleRooms
                            ? 'opacity-40 cursor-not-allowed border-gray-600 text-gray-500'
                            : laserAllocationMode === 'maxi'
                              ? 'border-purple-500 bg-purple-500/10 text-purple-500'
                              : isDark ? 'border-gray-700 hover:border-gray-600 text-gray-300' : 'border-gray-200 hover:border-gray-300 text-gray-700'
                        }`}
                      >
                        <div className="font-medium">{t('admin.booking_modal.laser.maxi')}</div>
                        <div className={`text-xs mt-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>{t('admin.booking_modal.laser.maxi_desc')}</div>
                      </button>
                    </div>
                    {!hasMultipleRooms && (
                      <p className={`text-xs mt-2 ${isDark ? 'text-gray-500' : 'text-gray-400'}`}>
                        {t('admin.booking_modal.laser.single_room_notice')}
                      </p>
                    )}
                  </>
                )
              })()}
            </div>
          )}

          {/* Configuration des jeux (ACTIVE, LASER ou Sur mesure) - Uniquement pour GAME */}
          {bookingType === 'GAME' && laserRooms.length > 0 && gameArea && gameArea !== 'CUSTOM' && (
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
              <div className="flex items-center gap-2 mb-3">
                {gameArea === 'ACTIVE' ? (
                  <Zap className="w-5 h-5 text-blue-400" />
                ) : (
                  <Target className="w-5 h-5 text-purple-400" />
                )}
                <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  {t('admin.booking_modal.game.config_title')} ({gameArea === 'ACTIVE' ? 'Active' : 'Laser'})
                </span>
              </div>
              
              {/* Nombre de jeux (1/2/3/4) */}
              <div className="mb-3">
                <label className={`block text-xs mb-2 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('admin.booking_modal.fields.games_count')}
                </label>
                <div className="flex gap-2">
                  {[1, 2, 3, 4].map(num => (
                    <button
                      key={num}
                      type="button"
                      onClick={() => {
                        setNumberOfGames(num)
                        // Initialiser les durées et pauses
                        setGameDurations(Array(num).fill('30'))
                        // Pauses après chaque jeu (sauf le dernier) : 0 pour ACTIVE, 30 pour LASER
                        const defaultPause = gameArea === 'ACTIVE' ? 0 : 30
                        setGamePauses(Array(num - 1).fill(defaultPause)) // num-1 car pas de pause après le dernier jeu
                        setLaserRoomIds(Array(num).fill(''))
                      }}
                      className={`px-4 py-2 rounded-lg border-2 transition-all ${
                        numberOfGames === num
                          ? gameArea === 'ACTIVE'
                            ? 'border-blue-500 bg-blue-500/10 text-blue-500'
                            : 'border-purple-500 bg-purple-500/10 text-purple-500'
                          : isDark ? 'border-gray-700 hover:border-gray-600 text-gray-300' : 'border-gray-200 hover:border-gray-300 text-gray-700'
                      }`}
                    >
                      {num}
                    </button>
                  ))}
                </div>
              </div>

              {/* Configuration des jeux individuels (ACTIVE et LASER) */}
              {numberOfGames > 1 && (
                <div className="space-y-3">
                  <label className={`block text-xs font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {t('admin.booking_modal.game.config_title')}
                  </label>
                  {Array.from({ length: numberOfGames }, (_, i) => (
                    <div key={i} className={`p-3 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
                      <div className="flex items-center gap-2 mb-2">
                        <span className={`text-sm font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>
                          {t('admin.booking_modal.fields.game_number')} {i + 1}
                        </span>
                      </div>
                      <div className={`grid gap-2 ${i < numberOfGames - 1 ? 'grid-cols-2' : 'grid-cols-1'}`}>
                        <div>
                          <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                            Durée (min)
                          </label>
                          <input
                            type="number"
                            min="15"
                            step="15"
                            value={gameDurations[i] || '30'}
                            onChange={(e) => {
                              const newDurations = [...gameDurations]
                              newDurations[i] = e.target.value
                              setGameDurations(newDurations)
                            }}
                            className={`w-full px-2 py-1 rounded border text-sm ${
                              isDark
                                ? 'bg-gray-700 border-gray-600 text-white'
                                : 'bg-white border-gray-300 text-gray-900'
                            }`}
                          />
                        </div>
                        {/* Pause après ce jeu (sauf pour le dernier) */}
                        {i < numberOfGames - 1 && (
                          <div>
                            <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                              {t('admin.booking_modal.event.pause_after')}
                            </label>
                            <input
                              type="number"
                              min="0"
                              step="15"
                              value={gamePauses[i] || (gameArea === 'LASER' ? 30 : 0)}
                              onChange={(e) => {
                                const newPauses = [...gamePauses]
                                newPauses[i] = parseInt(e.target.value, 10) || 0
                                setGamePauses(newPauses)
                              }}
                              className={`w-full px-2 py-1 rounded border text-sm ${
                                isDark
                                  ? 'bg-gray-700 border-gray-600 text-white'
                                  : 'bg-white border-gray-300 text-gray-900'
                              }`}
                            />
                          </div>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Configuration Laser : allocation de salle */}
              {gameArea === 'LASER' && laserRooms.length > 0 && (
                <div className="mt-3">
                  <label className={`block text-xs mb-2 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                    {t('admin.booking_modal.laser.room_allocation')}
                  </label>
                  <div className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                    {parsedParticipants <= 15 && t('admin.booking_modal.laser.default_l1')}
                    {parsedParticipants > 15 && parsedParticipants <= 20 && t('admin.booking_modal.laser.default_l2')}
                    {parsedParticipants > 20 && t('admin.booking_modal.laser.needs_both')}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Configuration sur mesure pour GAME */}
          {bookingType === 'GAME' && laserRooms.length > 0 && gameArea === 'CUSTOM' && (
            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-700/50' : 'bg-gray-50'}`}>
              <div className="flex items-center gap-2 mb-3">
                <Gamepad2 className="w-5 h-5 text-green-400" />
                <span className={`font-medium ${isDark ? 'text-white' : 'text-gray-900'}`}>{t('admin.booking_modal.custom.config_title')}</span>
              </div>
              
              <div className="space-y-3">
                <div className="mb-3">
                  <label className={`block text-xs mb-2 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                    {t('admin.booking_modal.fields.games_count')}
                  </label>
                  <div ref={gameCustomGamesDropdownRef} className="relative">
                    <button
                      type="button"
                      onClick={() => setShowGameCustomGamesDropdown(!showGameCustomGamesDropdown)}
                      className={`flex items-center justify-between w-full px-3 py-2 rounded-lg transition-colors text-sm ${
                        isDark
                          ? 'bg-gray-800 hover:bg-gray-700 text-white'
                          : 'bg-gray-100 hover:bg-gray-200 text-gray-900'
                      }`}
                    >
                      <span>{gameCustomNumberOfGames} {t('admin.booking_modal.fields.games')}</span>
                      <ChevronDown className={`w-3 h-3 transition-transform ${
                        isDark ? 'text-gray-400' : 'text-gray-600'
                      } ${showGameCustomGamesDropdown ? 'rotate-180' : ''}`} />
                    </button>

                    {showGameCustomGamesDropdown && (
                      <div className={`absolute top-full left-0 mt-2 w-full rounded-lg shadow-xl z-50 overflow-hidden ${
                        isDark
                          ? 'bg-gray-800 border border-gray-700'
                          : 'bg-white border border-gray-200'
                      }`}>
                        {[1, 2, 3, 4].map(n => (
                          <button
                            key={n}
                            type="button"
                            onClick={() => {
                              setGameCustomNumberOfGames(n)
                              const defaultDurations = Array(n).fill('30')
                              const defaultPauses = Array(n - 1).fill(0)
                              setGameCustomGameDurations(defaultDurations)
                              setGameCustomGamePauses(defaultPauses)
                              setGameCustomGameArea(Array(n).fill('ACTIVE' as GameArea))
                              setGameCustomLaserRoomIds(Array(n).fill(''))
                              setShowGameCustomGamesDropdown(false)
                            }}
                            className={`w-full px-4 py-2.5 text-left transition-colors text-sm ${
                              gameCustomNumberOfGames === n
                                ? isDark
                                  ? 'bg-blue-600/20 text-blue-400'
                                  : 'bg-blue-100 text-blue-700'
                                : isDark
                                ? 'text-white hover:bg-gray-700'
                                : 'text-gray-900 hover:bg-gray-100'
                            }`}
                          >
                            {n} {t('admin.booking_modal.fields.games')}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
                
                {Array.from({ length: gameCustomNumberOfGames }).map((_, index) => (
                  <div key={index} className={`p-3 rounded-lg ${isDark ? 'bg-gray-800' : 'bg-white'} border ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
                    <div className="mb-2">
                      <label className={`block text-xs mb-1 font-medium ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                        {t('admin.booking_modal.fields.game_number')} {index + 1} - {t('admin.booking_modal.event.game_type')}
                      </label>
                      <div className="grid grid-cols-2 gap-2">
                        <button
                          type="button"
                          onClick={() => {
                            const newAreas = [...gameCustomGameArea]
                            newAreas[index] = 'ACTIVE'
                            setGameCustomGameArea(newAreas)
                          }}
                          className={`p-2 rounded-lg border-2 text-xs ${
                            gameCustomGameArea[index] === 'ACTIVE'
                              ? 'border-blue-500 bg-blue-500/10 text-blue-500'
                              : isDark ? 'border-gray-700 text-gray-300' : 'border-gray-200 text-gray-700'
                          }`}
                        >
                          Active
                        </button>
                        <button
                          type="button"
                          onClick={() => {
                            const newAreas = [...gameCustomGameArea]
                            newAreas[index] = 'LASER'
                            setGameCustomGameArea(newAreas)
                          }}
                          className={`p-2 rounded-lg border-2 text-xs ${
                            gameCustomGameArea[index] === 'LASER'
                              ? 'border-purple-500 bg-purple-500/10 text-purple-500'
                              : isDark ? 'border-gray-700 text-gray-300' : 'border-gray-200 text-gray-700'
                          }`}
                        >
                          Laser
                        </button>
                      </div>
                    </div>
                    <div className="grid grid-cols-2 gap-2 mt-2">
                      <div>
                        <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                          Durée (min)
                        </label>
                        <input
                          type="number"
                          min="15"
                          step="15"
                          value={gameCustomGameDurations[index] || '30'}
                          onChange={(e) => {
                            const newDurations = [...gameCustomGameDurations]
                            newDurations[index] = e.target.value
                            setGameCustomGameDurations(newDurations)
                          }}
                          className={`w-full px-2 py-1 rounded border text-sm ${
                            isDark
                              ? 'bg-gray-700 border-gray-600 text-white'
                              : 'bg-white border-gray-300 text-gray-900'
                          }`}
                        />
                      </div>
                      {index < gameCustomNumberOfGames - 1 && (
                        <div>
                          <label className={`block text-xs mb-1 ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                            {t('admin.booking_modal.event.pause_after')}
                          </label>
                          <input
                            type="number"
                            min="0"
                            step="15"
                            value={gameCustomGamePauses[index] || 0}
                            onChange={(e) => {
                              const newPauses = [...gameCustomGamePauses]
                              newPauses[index] = parseInt(e.target.value, 10) || 0
                              setGameCustomGamePauses(newPauses)
                            }}
                            className={`w-full px-2 py-1 rounded border text-sm ${
                              isDark
                                ? 'bg-gray-700 border-gray-600 text-white'
                                : 'bg-white border-gray-300 text-gray-900'
                            }`}
                          />
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Informations du contact avec autocomplete sur chaque champ */}
          <div className="space-y-4">
            {selectedContact && (
              <div className="flex items-center gap-2 mb-2">
                <button
                  type="button"
                  onClick={handleModifyClient}
                  className={`px-3 py-1.5 text-xs rounded-lg flex items-center gap-1.5 transition-colors ${
                    isDark
                      ? 'bg-blue-600/20 text-blue-400 hover:bg-blue-600/30'
                      : 'bg-blue-50 text-blue-600 hover:bg-blue-100'
                  }`}
                >
                  <Edit2 className="w-3 h-3" />
                  {t('admin.booking_modal.contact.modify_client')}
                </button>
                <button
                  type="button"
                  onClick={handleChangeContact}
                  className={`px-3 py-1.5 text-xs rounded-lg flex items-center gap-1.5 transition-colors ${
                    isDark
                      ? 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                      : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                  }`}
                >
                  <RefreshCw className="w-3 h-3" />
                  {t('admin.booking_modal.contact.change_contact')}
                </button>
              </div>
            )}

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  <User className="w-4 h-4 inline mr-1" />
                  {t('admin.booking_modal.contact.first_name_required')}
                </label>
                <ContactFieldAutocomplete
                  branchId={bookingBranchId}
                  value={firstName}
                  onChange={(value) => handleFieldChange('firstName', value)}
                  onSelectContact={handleContactSelectedFromField}
                  fieldType="firstName"
                  placeholder={t('admin.booking_modal.contact.first_name_placeholder')}
                  required
                  isDark={isDark}
                  inputType="text"
                  disabled={areFieldsFrozen}
                  onEnterKey={handleEnterKeyWrapper}
                />
              </div>
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  {t('admin.booking_modal.fields.last_name')}
                </label>
                <ContactFieldAutocomplete
                  branchId={bookingBranchId}
                  value={lastName}
                  onChange={(value) => handleFieldChange('lastName', value)}
                  onSelectContact={handleContactSelectedFromField}
                  fieldType="lastName"
                  placeholder={t('admin.booking_modal.contact.last_name_optional')}
                  isDark={isDark}
                  inputType="text"
                  disabled={areFieldsFrozen}
                  onEnterKey={handleEnterKeyWrapper}
                />
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  <Phone className="w-4 h-4 inline mr-1" />
                  {t('admin.booking_modal.contact.phone_required')}
                </label>
                <ContactFieldAutocomplete
                  branchId={bookingBranchId}
                  value={phone}
                  onChange={(value) => handleFieldChange('phone', value)}
                  onSelectContact={handleContactSelectedFromField}
                  fieldType="phone"
                  placeholder="05XXXXXXXX"
                  required
                  isDark={isDark}
                  inputType="tel"
                  disabled={areFieldsFrozen}
                  onEnterKey={handleEnterKeyWrapper}
                />
                {phoneError && (
                  <p className="mt-1 text-sm text-red-500">{phoneError}</p>
                )}
              </div>
              <div>
                <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                  <Mail className="w-4 h-4 inline mr-1" />
                  {t('admin.booking_modal.fields.email')}
                  {bookingType === 'EVENT' && <span className="text-red-500 ml-1">*</span>}
                </label>
                <ContactFieldAutocomplete
                  branchId={bookingBranchId}
                  value={email}
                  onChange={(value) => handleFieldChange('email', value)}
                  onSelectContact={handleContactSelectedFromField}
                  fieldType="email"
                  placeholder={t('admin.booking_modal.contact.email_placeholder')}
                  isDark={isDark}
                  inputType="email"
                  disabled={areFieldsFrozen}
                  onEnterKey={handleEnterKeyWrapper}
                />
                {emailError && (
                  <p className="mt-1 text-sm text-red-500">{emailError}</p>
                )}
              </div>
            </div>

            {/* Sélecteur de langue préférée */}
            <div className="flex items-center gap-2 mt-3">
              <span className={`text-xs ${isDark ? 'text-gray-400' : 'text-gray-500'}`}>
                {t('admin.booking_modal.contact.preferred_language')}:
              </span>
              <div className="flex gap-1">
                {([
                  { code: 'he', flag: '🇮🇱', label: 'עברית' },
                  { code: 'fr', flag: '🇫🇷', label: 'Français' },
                  { code: 'en', flag: '🇬🇧', label: 'English' }
                ] as const).map(({ code, flag, label }) => (
                  <button
                    key={code}
                    type="button"
                    onClick={() => setPreferredLocale(code)}
                    title={label}
                    className={`text-lg px-1.5 py-0.5 rounded transition-all ${
                      preferredLocale === code
                        ? isDark
                          ? 'bg-blue-600/30 ring-2 ring-blue-500'
                          : 'bg-blue-100 ring-2 ring-blue-500'
                        : isDark
                          ? 'hover:bg-gray-700 opacity-50 hover:opacity-100'
                          : 'hover:bg-gray-100 opacity-50 hover:opacity-100'
                    }`}
                  >
                    {flag}
                  </button>
                ))}
              </div>
            </div>
          </div>

          {/* Notes */}
          <div className="mt-4">
            <label className={`block text-sm font-medium mb-2 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
              <MessageSquare className="w-4 h-4 inline mr-1" />
              {t('admin.booking_modal.fields.notes')}
            </label>
            <textarea
              value={notes}
              onChange={(e) => {
                if (!areFieldsFrozen) {
                  setNotes(e.target.value)
                  // Auto-resize jusqu'à 5 lignes max
                  const textarea = e.target as HTMLTextAreaElement
                  textarea.style.height = 'auto'
                  const maxHeight = 5 * 24 // 5 lignes environ (24px par ligne)
                  const newHeight = Math.min(textarea.scrollHeight, maxHeight)
                  textarea.style.height = `${newHeight}px`
                }
              }}
              rows={2}
              disabled={areFieldsFrozen}
              readOnly={areFieldsFrozen}
              className={`w-full px-3 py-2 rounded-lg border resize-none text-sm overflow-y-auto ${
                areFieldsFrozen
                  ? isDark
                    ? 'bg-gray-800 border-gray-700 text-gray-500 cursor-not-allowed'
                    : 'bg-gray-100 border-gray-300 text-gray-500 cursor-not-allowed'
                  : isDark
                    ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-500'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400'
              }`}
              placeholder={t('admin.booking_modal.fields.notes_additional')}
              style={{ minHeight: '48px', maxHeight: '120px' }}
            />
          </div>

          {/* Erreur */}
          {error && (
            <div className="p-3 bg-red-500/10 border border-red-500/50 rounded-lg text-red-400 text-sm">
              {error}
            </div>
          )}

          {/* Avertissement participants EVENT invalides */}
          {bookingType === 'EVENT' && parsedParticipants > 0 && !eventParticipantsValidation.valid && (
            <div className={`p-3 rounded-xl ${isDark ? 'bg-orange-900/20 border border-orange-500/30' : 'bg-orange-50 border border-orange-200'}`}>
              <div className={`text-center text-sm ${isDark ? 'text-orange-300' : 'text-orange-700'}`}>
                ⚠️ {eventParticipantsValidation.message}
              </div>
            </div>
          )}

          {/* Calcul du prix */}
          {priceCalculation && priceCalculation.valid && (
            <div className={`p-3 rounded-xl ${isDark ? 'bg-green-900/20 border border-green-500/30' : 'bg-green-50 border border-green-200'}`}>
              <div className={`text-center font-mono text-sm ${isDark ? 'text-green-300' : 'text-green-700'}`}>
                {priceCalculation.breakdown} = <span className="font-bold text-base">{priceCalculation.total.toLocaleString()}₪</span>
              </div>
            </div>
          )}
        </form>

        {/* Footer */}
        <div className={`flex items-center justify-between gap-3 p-6 border-t ${isDark ? 'border-gray-700' : 'border-gray-200'}`}>
          <div className="flex items-center gap-2">
            {editingBooking && onDelete && (
              <button
                type="button"
                onClick={handleDeleteClick}
                disabled={loading || !canDelete || orderStatus === 'closed'}
                title={orderStatus === 'closed' ? t('errors.orderClosed') : !canDelete ? t('admin.common.no_permission') : undefined}
                className={`px-4 py-2 rounded-lg flex items-center gap-2 transition-colors ${
                  !canDelete || orderStatus === 'closed'
                    ? 'opacity-50 cursor-not-allowed text-gray-400'
                    : isDark
                      ? 'text-red-400 hover:bg-red-900/20 hover:text-red-300'
                      : 'text-red-600 hover:bg-red-50 hover:text-red-700'
                } disabled:opacity-50 disabled:cursor-not-allowed`}
              >
                <Trash2 className="w-4 h-4" />
                {t('admin.booking_modal.actions.delete')}
              </button>
            )}
          </div>
          <div className="flex items-center gap-3">
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className={`px-4 py-2 rounded-lg ${
                isDark
                  ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                  : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              }`}
            >
              {t('admin.booking_modal.actions.cancel')}
            </button>
            <button
              type="submit"
              onClick={handleSubmit}
              disabled={loading || parsedParticipants < 1 || (bookingType === 'EVENT' && !eventParticipantsValidation.valid) || (bookingType === 'EVENT' && (!email.trim() || !!emailError)) || (editingBooking ? !canEdit : !canCreate) || orderStatus === 'closed'}
              title={orderStatus === 'closed' ? t('errors.orderClosed') : (editingBooking ? !canEdit : !canCreate) ? t('admin.common.no_permission') : undefined}
              className={`px-6 py-2 rounded-lg text-white flex items-center gap-2 disabled:opacity-50 ${
                (editingBooking ? !canEdit : !canCreate) || orderStatus === 'closed' ? 'cursor-not-allowed' : ''
              }`}
              style={{ backgroundColor: (editingBooking ? !canEdit : !canCreate) || orderStatus === 'closed' ? '#6B7280' : color }}
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  {editingBooking ? t('admin.booking_modal.actions.modifying') : t('admin.booking_modal.actions.creating')}
                </>
              ) : (
                editingBooking ? t('admin.booking_modal.actions.modify') : t('admin.booking_modal.actions.create')
              )}
            </button>
          </div>
        </div>
      </div>

      {/* Modal de confirmation d'over capacity */}
      {showOverCapacityConfirm && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center">
          {/* Backdrop */}
          <div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={handleOverCapacityCancel}
          />

          {/* Modal de confirmation */}
          <div className={`relative w-full max-w-md mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className="p-6">
              <h3 className={`text-xl font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                ⚠️ {t('admin.booking_modal.modals.insufficient_capacity')}
              </h3>
              <p className={`mb-6 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.modals.no_room_for_participants', { count: parsedParticipants })}<br /><br />
                {t('admin.booking_modal.modals.capacity_insufficient')}<br /><br />
                {t('admin.booking_modal.modals.continue_anyway')}
              </p>
              <div className="flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={handleOverCapacityCancel}
                  disabled={loading}
                  className={`px-4 py-2 rounded-lg ${
                    isDark
                      ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                      : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  } disabled:opacity-50`}
                >
                  {t('admin.booking_modal.actions.cancel')}
                </button>
                <button
                  type="button"
                  onClick={handleOverCapacityConfirm}
                  disabled={loading}
                  className="px-4 py-2 rounded-lg bg-orange-600 hover:bg-orange-700 text-white flex items-center gap-2 disabled:opacity-50"
                >
                  {loading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      {t('admin.booking_modal.actions.processing')}
                    </>
                  ) : (
                    t('admin.booking_modal.modals.continue_button')
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Modal : Aucune salle disponible (NON AUTORISABLE) */}
      {showNoRoomAvailable && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center">
          {/* Backdrop */}
          <div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={handleNoRoomAvailableClose}
          />

          {/* Modal */}
          <div className={`relative w-full max-w-md mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className="p-6">
              <h3 className={`text-xl font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                ❌ {t('admin.booking_modal.modals.no_room_available')}
              </h3>
              <p className={`mb-6 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.modals.no_room_at_period', { count: parsedParticipants })}<br /><br />
                {t('admin.booking_modal.modals.reduce_participants')}
              </p>
              <div className="flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={handleNoRoomAvailableClose}
                  disabled={loading}
                  className={`px-4 py-2 rounded-lg ${
                    isDark
                      ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                      : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  } disabled:opacity-50`}
                >
                  {t('admin.booking_modal.actions.close')}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Modal : Salle disponible avec capacité inférieure (AUTORISABLE) */}
      {showLowerCapacityRoom && lowerCapacityRoomInfo && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center">
          {/* Backdrop */}
          <div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={handleLowerCapacityRoomCancel}
          />

          {/* Modal */}
          <div className={`relative w-full max-w-md mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className="p-6">
              <h3 className={`text-xl font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                ⚠️ {t('admin.booking_modal.modals.lower_capacity')}
              </h3>
              <p className={`mb-6 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.modals.requested_vs_available', { requested: parsedParticipants, available: lowerCapacityRoomInfo.capacity })}<br /><br />
                {parsedParticipants > lowerCapacityRoomInfo.capacity ? (
                  <>
                    {t('admin.booking_modal.modals.exceeds_by', { count: parsedParticipants - lowerCapacityRoomInfo.capacity })}<br /><br />
                  </>
                ) : null}
                {t('admin.booking_modal.modals.use_this_room')}
              </p>
              <div className="flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={handleLowerCapacityRoomCancel}
                  disabled={loading}
                  className={`px-4 py-2 rounded-lg ${
                    isDark
                      ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                      : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  } disabled:opacity-50`}
                >
                  {t('admin.booking_modal.actions.cancel')}
                </button>
                <button
                  type="button"
                  onClick={handleLowerCapacityRoomConfirm}
                  disabled={loading}
                  className="px-4 py-2 rounded-lg bg-orange-600 hover:bg-orange-700 text-white flex items-center gap-2 disabled:opacity-50"
                >
                  {loading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      {t('admin.booking_modal.actions.processing')}
                    </>
                  ) : (
                    t('admin.booking_modal.modals.use_room_button')
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Modal : Avertissement de doublon de contact */}
      {showDuplicateWarning && pendingContactData && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center">
          {/* Backdrop */}
          <div
            className="absolute inset-0 z-0 bg-black/50 backdrop-blur-sm"
            onClick={() => setShowDuplicateWarning(false)}
          />

          {/* Modal */}
          <div className={`relative z-10 w-full max-w-md mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className="p-6">
              <div className="flex items-center gap-3 mb-4">
                <AlertTriangle className={`w-6 h-6 ${isDark ? 'text-yellow-400' : 'text-yellow-600'}`} />
                <h3 className={`text-xl font-bold ${isDark ? 'text-white' : 'text-gray-900'}`}>
                  {t('admin.booking_modal.modals.duplicate_detected')}
                </h3>
              </div>
              <p className={`mb-4 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.modals.duplicate_exists')}
              </p>
              <div className={`p-4 rounded-lg mb-4 ${isDark ? 'bg-gray-700' : 'bg-gray-50'}`}>
                {pendingContactData.phone && (
                  <div className="mb-2">
                    <strong className={isDark ? 'text-gray-300' : 'text-gray-700'}>{t('admin.booking_modal.fields.phone')} :</strong>{' '}
                    <span className={isDark ? 'text-gray-400' : 'text-gray-600'}>{pendingContactData.phone}</span>
                  </div>
                )}
                {pendingContactData.email && (
                  <div>
                    <strong className={isDark ? 'text-gray-300' : 'text-gray-700'}>{t('admin.booking_modal.fields.email')} :</strong>{' '}
                    <span className={isDark ? 'text-gray-400' : 'text-gray-600'}>{pendingContactData.email}</span>
                  </div>
                )}
              </div>
              <p className={`mb-6 text-sm ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                {t('admin.booking_modal.modals.create_anyway_question')}
              </p>
              <div className="flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={() => {
                    setShowDuplicateWarning(false)
                    setPendingContactData(null)
                  }}
                  disabled={loading}
                  className={`px-4 py-2 rounded-lg ${
                    isDark
                      ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                      : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  } disabled:opacity-50`}
                >
                  {t('admin.booking_modal.actions.cancel')}
                </button>
                <button
                  type="button"
                  onClick={async () => {
                    if (!pendingContactData) return

                    setShowDuplicateWarning(false)
                    setPendingContactData(null)
                    // Relancer la soumission avec skipDuplicateCheck = true (créer nouveau contact)
                    const roomId = pendingEventRoomId
                    setPendingEventRoomId(null)
                    await submitWithRoom(roomId, true)
                  }}
                  disabled={loading}
                  className="px-4 py-2 rounded-lg bg-yellow-600 hover:bg-yellow-700 text-white flex items-center gap-2 disabled:opacity-50"
                >
                  {loading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      {t('admin.booking_modal.actions.processing')}
                    </>
                  ) : (
                    t('admin.booking_modal.modals.create_anyway_button')
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Modal : Avertissement d'overbooking */}
      {showOverbookingWarning && overbookingInfo && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center">
          {/* Backdrop */}
          <div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={handleOverbookingCancel}
          />

          {/* Modal */}
          <div className={`relative w-full max-w-lg mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className="p-6">
              <h3 className={`text-xl font-bold mb-4 ${isDark ? 'text-red-400' : 'text-red-600'}`}>
                ⚠️ {t('admin.booking_modal.modals.overbooking_warning')}
              </h3>
              <div className={`mb-6 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                <p className="mb-4">
                  {bookingBranchId && bookingBranchId !== branchId && (
                    <span className="block mb-2">
                      <strong>{t('admin.booking_modal.modals.destination_branch')} :</strong> {branches.find(b => b.id === bookingBranchId)?.name || t('admin.booking_modal.modals.unknown_branch')}
                    </span>
                  )}
                  {t('admin.booking_modal.modals.will_create_overbooking')}
                </p>
                <div className={`p-4 rounded-lg ${isDark ? 'bg-red-900/30 border border-red-700' : 'bg-red-50 border border-red-200'}`}>
                  <div className="space-y-2">
                    <div>
                      <strong className={isDark ? 'text-red-300' : 'text-red-700'}>{t('admin.booking_modal.modals.maximum')} :</strong>
                      <span className="ml-2">
                        <strong>{overbookingInfo.maxOverbookedCount} {t('admin.booking_modal.modals.persons_surplus')}</strong>
                        {' '}(<strong>{overbookingInfo.maxOverbookedSlots} {t('admin.booking_modal.modals.slots')}</strong>)
                      </span>
                    </div>
                    {overbookingInfo.affectedTimeSlots.length > 0 && (
                      <div className="mt-3">
                        <strong className={isDark ? 'text-red-300' : 'text-red-700'}>{t('admin.booking_modal.modals.affected_slots')} :</strong>
                        <ul className="mt-2 space-y-1 text-sm">
                          {overbookingInfo.affectedTimeSlots.slice(0, 5).map((slot, idx) => (
                            <li key={idx}>
                              • <strong>{slot.time}</strong> : +{slot.overbookedCount} pers. ({slot.totalParticipants}/{slot.capacity})
                            </li>
                          ))}
                          {overbookingInfo.affectedTimeSlots.length > 5 && (
                            <li className="italic">{t('admin.booking_modal.modals.and_more', { count: overbookingInfo.affectedTimeSlots.length - 5 })}</li>
                          )}
                        </ul>
                      </div>
                    )}
                  </div>
                </div>
                <p className="mt-4">
                  <strong>{t('admin.booking_modal.modals.manual_auth_required')}</strong>
                </p>
              </div>
              <div className="flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={handleOverbookingCancel}
                  disabled={loading}
                  className={`px-4 py-2 rounded-lg ${
                    isDark
                      ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                      : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  } disabled:opacity-50`}
                >
                  {t('admin.booking_modal.actions.cancel')}
                </button>
                <button
                  type="button"
                  onClick={handleOverbookingConfirm}
                  disabled={loading}
                  className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white flex items-center gap-2 disabled:opacity-50"
                >
                  {loading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      {t('admin.booking_modal.actions.processing')}
                    </>
                  ) : (
                    t('admin.booking_modal.modals.authorize_continue')
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Modal de confirmation de suppression */}
      {showDeleteConfirm && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center">
          {/* Backdrop */}
          <div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={() => setShowDeleteConfirm(false)}
          />

          {/* Modal de confirmation */}
          <div className={`relative w-full max-w-md mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className="p-6">
              <h3 className={`text-xl font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.booking_modal.modals.confirm_delete')}
              </h3>
              <p className={`mb-6 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.modals.delete_irreversible')}
              </p>
              <div className="flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={() => setShowDeleteConfirm(false)}
                  disabled={loading}
                  className={`px-4 py-2 rounded-lg ${
                    isDark
                      ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                      : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  } disabled:opacity-50`}
                >
                  {t('admin.booking_modal.actions.cancel')}
                </button>
                <button
                  type="button"
                  onClick={handleDeleteConfirm}
                  disabled={loading}
                  className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white flex items-center gap-2 disabled:opacity-50"
                >
                  {loading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      {t('admin.booking_modal.actions.deleting')}
                    </>
                  ) : (
                    <>
                      <Trash2 className="w-4 h-4" />
                      {t('admin.booking_modal.actions.delete')}
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Modal spare vests */}
      {showSpareVestsPopup && pendingSpareVestsData && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center">
          {/* Backdrop */}
          <div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={() => {
              setShowSpareVestsPopup(false)
              setPendingSpareVestsData(null)
            }}
          />

          {/* Modal spare vests */}
          <div className={`relative w-full max-w-md mx-4 rounded-2xl shadow-2xl ${isDark ? 'bg-gray-800' : 'bg-white'}`}>
            <div className="p-6">
              <h3 className={`text-xl font-bold mb-4 ${isDark ? 'text-white' : 'text-gray-900'}`}>
                {t('admin.booking_modal.modals.vests_limit')}
              </h3>
              <p className={`mb-4 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.modals.vests_limit_reached', { max: pendingSpareVestsData.maxVests })}
              </p>
              <p className={`mb-6 ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>
                {t('admin.booking_modal.modals.spare_vests_available', { spare: pendingSpareVestsData.spareVests })}
              </p>
              <div className="flex items-center justify-end gap-3">
                <button
                  type="button"
                  onClick={() => {
                    setShowSpareVestsPopup(false)
                    setPendingSpareVestsData(null)
                  }}
                  className={`px-4 py-2 rounded-lg ${
                    isDark
                      ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                      : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                  }`}
                >
                  {t('admin.booking_modal.modals.no_cancel')}
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setShowSpareVestsPopup(false)
                    setPendingSpareVestsData(null)
                    // Activer le flag pour bypasser la vérification des vests
                    setSpareVestsAuthorized(true)
                    // Soumettre automatiquement le formulaire
                    setTimeout(() => {
                      formRef.current?.requestSubmit()
                    }, 0)
                  }}
                  className="px-4 py-2 rounded-lg bg-green-600 hover:bg-green-700 text-white"
                >
                  {t('admin.booking_modal.modals.yes_authorize')}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

    </div>
  )
}
</file>

<file path="src/i18n/locales/en.json">
{
  "nav": {
    "concept": "ABOUT THE GAME",
    "games": "GAMES",
    "pricing": "PRICING",
    "branches": "LOCATIONS",
    "contact": "CONTACT"
  },
  "hero": {
    "subtitle": "New generation leisure activities",
    "title": "Active Games",
    "description": "Fully immersive interactive arenas, where neon lighting, sound, and physical challenges combine to create unique experiences.",
    "cta_games": "Discover our games",
    "cta_concept": "Discover the concept"
  },
  "concept": {
    "title": "ABOUT THE GAME",
    "intro": "Active Games is an innovative interactive gaming complex based on teamwork, movement, and strategic thinking.",
    "features": {
      "players": "Up to 6 players",
      "duration": "60 minutes of action",
      "bracelet": "Smart bracelet",
      "rooms": "8 different rooms",
      "modes": "Competitive or Team",
      "strategy": "Your strategy wins"
    },
    "description": [
      "The experience is designed for groups of up to 6 players and lasts 60 minutes of non-stop action.",
      "Upon arrival, each player receives a smart bracelet and registers with their name.",
      "The complex includes 8 different rooms, each with its own world, concept, and unique challenges."
    ]
  },
  "games": {
    "title": "OUR GAMES",
    "subtitle": "Each game offers a unique experience combining fun, challenge, and physical engagement. Whether you prefer testing your reflexes, improving your coordination, or working together in cooperation: choose your style and dive into the action.",
    "more_info": "More info",
    "items": {
      "grid": {
        "name": "Grid",
        "description": "A revolutionary interactive flooring system with built-in RGB LED lights and sensors.",
        "popup_description": "The Active Games Grid immerses players in a captivating challenge of logic and reasoning.",
        "features": ["5 game modes", "50 levels to explore"]
      },
      "arena": {
        "name": "Arena",
        "description": "The ultimate dodgeball LED target wall game. Test speed, accuracy & memory.",
        "popup_description": "An interactive LED hexagon target wall where players use dodgeballs to hit glowing targets.",
        "features": ["4 game modes", "40 levels to explore"]
      },
      "push": {
        "name": "Push",
        "description": "In this room, the walls are filled with buttons that can change colors.",
        "popup_description": "Push is an observation and strategy challenge game.",
        "features": ["5 game modes", "50 levels to explore"]
      },
      "basketball": {
        "name": "Hoops Basketball",
        "description": "An interactive basketball fitness game that combines fun, exercise, and technology.",
        "popup_description": "A fully interactive fitness experience.",
        "features": ["LED-lit targets", "Smart sensor tracking"]
      },
      "climbing": {
        "name": "Climbing",
        "description": "An interactive LED wall designed to test your agility, strategy, and team fun.",
        "popup_description": "An interactive LED climbing wall game that simulates the thrill of cliff climbing.",
        "features": ["Grab green safe lights", "Avoid dangerous red zones"]
      },
      "hide": {
        "name": "Digital Hide Room",
        "description": "In this room, sensor eyes track your every movement.",
        "popup_description": "A thrilling blend of stealth, strategy, and teamwork.",
        "features": ["4 game modes", "40 levels to explore"]
      },
      "flash": {
        "name": "Flash",
        "description": "Two or more players must cooperate. Press the circular light before the current reaches the target.",
        "popup_description": "Flash is a game of quick reaction challenges.",
        "features": ["4 game modes", "40 levels to explore"]
      },
      "laser": {
        "name": "Laser",
        "description": "A thrilling escape room experience where players dodge laser beams.",
        "popup_description": "Creates a real-life action challenge where players must dodge, crawl, and weave through laser beams.",
        "features": ["Dynamic difficulty modes", "For kids, teens, and adults"]
      },
      "control": {
        "name": "Control",
        "description": "In Control, players control the movement of light blocks via an interactive console.",
        "popup_description": "Control the movement of light blocks via an interactive console.",
        "features": ["Interactive console", "LED tile integration"]
      }
    }
  },
  "pricing": {
    "title": "PRICING",
    "subtitle": "Choose the option that suits you best",
    "single": {
      "title": "Unlimited Games",
      "price": "100",
      "currency": "NIS",
      "duration": "One hour per participant",
      "features": [
        "Access to all 8 rooms",
        "Unlimited games",
        "Smart bracelet: 10 NIS first-time fee (reusable)"
      ]
    },
    "packages": {
      "title": "Event Packages",
      "items": [
        {
          "name": "Package 15+",
          "minParticipants": "From 15 participants",
          "price": "130",
          "currency": "NIS / person",
          "features": [
            "Unlimited games for one hour",
            "Private event room for 2 hours",
            "Sound and lighting system",
            "Smart bracelet included"
          ]
        },
        {
          "name": "Package 30+",
          "minParticipants": "From 30 participants",
          "price": "120",
          "currency": "NIS / person",
          "features": [
            "Unlimited games for one hour",
            "Private event room for 2 hours",
            "Sound and lighting system",
            "Smart bracelet included"
          ]
        }
      ]
    }
  },
  "branches": {
    "title": "LOCATIONS",
    "subtitle": "Find the location nearest to you",
    "items": [
      {
        "name": "Rishon LeZion",
        "slug": "rishon-lezion",
        "address": "Aliyat HaNoar 1, Bar-On Center - Floor 5",
        "city": "Rishon LeZion",
        "phone": "03-5512277 (Ext. 1)",
        "venue": "At Laser City complex"
      },
      {
        "name": "Petah Tikva",
        "slug": "petah-tikva",
        "address": "Amal 37",
        "city": "Petah Tikva",
        "phone": "03-5512277 (Ext. 3)",
        "venue": "At Laser City complex"
      }
    ]
  },
  "contact": {
    "title": "Contact Us",
    "subtitle": "Contact us for any further information or specific inquiries.",
    "form": {
      "name": "Name",
      "email": "Email",
      "message": "Message",
      "send": "Send"
    },
    "info": {
      "phone": "03 551-2277",
      "email": "contact@activegames.co.il"
    }
  },
  "footer": {
    "games_title": "OUR GAMES",
    "concept_title": "CONCEPT",
    "pricing_title": "PRICING"
  },
  "booking": {
    "order_now": "Order now",
    "title": "Book your session",
    "step1": {
      "title": "Select branch",
      "subtitle": "Choose the location where you want to play"
    },
    "step2": {
      "title": "Reservation Type",
      "subtitle": "Choose the type of activity"
    },
    "step3": {
      "title": "Select date",
      "subtitle": "Choose the day for your session"
    },
    "step4": {
      "title": "Select time",
      "subtitle": "Choose the time slot"
    },
    "step5": {
      "title": "Contact Information",
      "subtitle": "Please fill in your details",
      "title_event": "Event Information & Contact",
      "subtitle_event": "Please fill in your contact details and event order information"
    },
    "contact": {
      "first_name": "First Name",
      "last_name": "Last Name",
      "phone": "Phone Number",
      "email": "Email",
      "special_request": "Special Request",
      "first_name_placeholder": "Enter first name",
      "last_name_placeholder": "Enter last name",
      "phone_placeholder": "Enter phone number",
      "email_placeholder": "Enter email (optional)",
      "special_request_placeholder": "If you have any special requests (optional)",
      "terms": {
        "label": "I have read and agree to the terms and rules",
        "read_terms": "Read terms and rules",
        "title": "Terms and Rules",
        "close": "Close",
        "booking_info": {
          "title": "Booking Information",
          "items": [
            "Please arrive at least 10 minutes before your scheduled time",
            "Reservations are confirmed upon payment",
            "Changes or cancellations must be made at least 24 hours in advance",
            "Late arrivals may result in reduced play time"
          ]
        },
        "rules": {
          "title": "Rules and Regulations",
          "items": [
            "Follow all safety instructions provided by staff",
            "Respect other players and maintain a friendly environment",
            "No food or drinks inside the game rooms",
            "Smoking is strictly prohibited",
            "Children under 12 must be accompanied by an adult",
            "Any damage to equipment will result in additional charges"
          ]
        },
        "payment": {
          "title": "Payment Details",
          "items": [
            "Payment is required at the time of booking",
            "Accepted payment methods: Cash, Credit Card, Bank Transfer",
            "Refunds are available only for cancellations made 24+ hours in advance"
          ]
        },
        "contact": {
          "title": "Contact Information",
          "description": "For questions or special requests, please contact us:",
          "items": [
            "Phone: 03-551-2277",
            "Email: contact@activegames.co.il"
          ]
        },
        "acknowledgment": "By checking the box, you acknowledge that you have read, understood, and agree to all terms and conditions."
      },
      "event": {
        "booking_info": {
          "title": "Event Booking Information",
          "items": [
            "Event reservations require a minimum of 15 participants",
            "Please arrive at least 15 minutes before your scheduled time",
            "Changes or cancellations must be made at least 48 hours in advance"
          ]
        },
        "rules": {
          "title": "Event Rules and Regulations",
          "items": [
            "Follow all safety instructions provided by staff",
            "Respect other participants and maintain a friendly environment",
            "No food or drinks inside the game rooms without authorization"
          ]
        },
        "payment": {
          "title": "Event Payment Details",
          "items": [
            "Payment is required at the time of booking",
            "Refunds are available only for cancellations made 48+ hours in advance"
          ]
        },
        "acknowledgment": "By checking the box, you acknowledge that you have read, understood, and agree to all event terms and conditions."
      }
    },
    "type": {
      "game": {
        "title": "Game",
        "description": "Unlimited games for one hour"
      },
      "event": {
        "title": "Event",
        "description": "Event package with private room",
        "min_players_note": "Minimum 15 players required for events"
      },
      "players": {
        "label": "Number of players",
        "placeholder": "Select or enter a number",
        "info_event": "Minimum 15 players required"
      }
    },
    "game_type": {
      "title": "Game Type",
      "subtitle": "Choose your activity",
      "active": "Active Games",
      "laser": "Laser City",
      "custom": "Custom Package",
      "custom_description": "Active Games + Laser City combination"
    },
    "game_duration": {
      "title": "Game Duration",
      "description": "Unlimited games for the chosen duration",
      "minutes": "minutes"
    },
    "game_count": {
      "title": "Number of Games",
      "game": "game",
      "games": "games"
    },
    "next": "Next",
    "previous": "Previous",
    "confirm": "Confirm booking",
    "loading": "Loading...",
    "confirmation": {
      "title": "Reservation Confirmed!",
      "subtitle": "Thank you for your reservation",
      "reservation_number": "Reservation Number",
      "back_to_site": "Back to Site",
      "finished": "Finished",
      "download_reservation": "Download Reservation",
      "download_order": "Download Order"
    },
    "arrival_note": "Please arrive at least 10 minutes before your scheduled time",
    "summary": {
      "title": "Booking Summary",
      "branch": "Branch:",
      "type": "Type:",
      "date": "Date:",
      "time": "Time:",
      "players": "Players:",
      "duration": "Duration:",
      "games": "Games:"
    }
  },
  "admin": {
    "common": {
      "loading": "Loading...",
      "saving": "Saving...",
      "save": "Save",
      "cancel": "Cancel",
      "delete": "Delete",
      "confirm": "Confirm",
      "yes": "Yes",
      "no": "No",
      "ok": "OK",
      "close": "Close",
      "edit": "Edit",
      "view": "View",
      "details": "Details",
      "error": "Error",
      "success": "Success",
      "warning": "Warning",
      "info": "Information",
      "search": "Search",
      "filter": "Filter",
      "refresh": "Refresh",
      "export": "Export",
      "add": "Add",
      "create": "Create",
      "update": "Update",
      "remove": "Remove",
      "action": "Action",
      "actions": "Actions",
      "no_permission": "You do not have permission to perform this action",
      "or": "or",
      "and": "and",
      "all": "All",
      "none": "None",
      "select": "Select",
      "required": "Required",
      "optional": "Optional",
      "players": "players",
      "player": "player",
      "minutes": "minutes",
      "hours": "hours",
      "days": "days",
      "of": "of",
      "total": "total",
      "first_name": "First name",
      "last_name": "Last name",
      "updated_at": "Updated",
      "at": "at",
      "page": "Page",
      "show": "Show",
      "rows": "rows"
    },
    "layout": {
      "loading": "Loading...",
      "redirecting": "Redirecting to login...",
      "logout": "Sign out",
      "language": "Language"
    },
    "login": {
      "title": "Sign in to access the dashboard",
      "subtitle": "Access to admin panel",
      "email": "Email",
      "email_label": "Email",
      "email_placeholder": "admin@example.com",
      "password": "Password",
      "password_label": "Password",
      "password_placeholder": "Your password",
      "submit": "Sign in",
      "submitting": "Signing in...",
      "logging_in": "Signing in...",
      "error_invalid": "Invalid email or password",
      "error_email_not_confirmed": "Please confirm your email before signing in",
      "error_generic": "An error occurred. Please try again.",
      "footer": "Active Games World",
      "remember_me": "Remember me"
    },
    "header": {
      "agenda": "Agenda",
      "clients": "Clients",
      "orders": "Orders",
      "users": "Users",
      "logs": "Logs",
      "permissions": "Permissions",
      "roles": "Role Management",
      "settings": "Settings",
      "data_management": "Data Management",
      "sign_out": "Sign out",
      "theme_light": "Light mode",
      "theme_dark": "Dark mode",
      "language": "Language",
      "pending_orders": "pending orders",
      "statistics": "Statistics"
    },
    "data_management": {
      "title": "Data Management",
      "subtitle": "Permanent data deletion by branch",
      "select_branches": "Select branches",
      "all_branches": "All branches",
      "deletion_zones": "Deletion zones",
      "logs_group": "Logs & Emails",
      "logs_description": "Activity logs and email history",
      "reservations_group": "Reservations",
      "reservations_description": "Orders, bookings, sessions and slots",
      "contacts_group": "Contacts",
      "contacts_description": "Clients and contacts (requires deleting reservations first)",
      "delete_button": "Delete",
      "confirm_title": "Delete Confirmation",
      "confirm_message": "You are about to permanently delete the following data. This action is IRREVERSIBLE.",
      "enter_password": "Enter your password to confirm",
      "password_placeholder": "Password",
      "cancel": "Cancel",
      "confirm_delete": "Confirm deletion",
      "deleting": "Deleting...",
      "success": "Deletion successful",
      "error": "Error during deletion",
      "no_branch_selected": "Please select at least one branch",
      "items": "items",
      "activity_logs": "Activity logs",
      "email_logs": "Email logs",
      "orders": "Orders",
      "bookings": "Bookings",
      "game_sessions": "Game sessions",
      "booking_slots": "Booking slots",
      "contacts": "Contacts"
    },
    "roles": {
      "super_admin": "Super Admin",
      "branch_admin": "Branch Admin",
      "agent": "Agent",
      "manager": "Manager",
      "employee": "Employee",
      "website": "Website",
      "system": "System",
      "title": "Role Management",
      "subtitle": "Manage roles and their hierarchy levels",
      "create": "Create Role",
      "create_title": "Create New Role",
      "edit_title": "Edit Role",
      "access_denied": "Access Denied",
      "access_denied_message": "You do not have the required permissions to manage roles.",
      "no_roles": "No roles defined",
      "system": "System",
      "custom": "Custom",
      "cannot_edit": "This role cannot be edited",
      "cannot_delete": "This role cannot be deleted",
      "display_name": "Display Name",
      "name": "Identifier (slug)",
      "name_help": "Unique role identifier, lowercase without spaces",
      "description": "Description",
      "level": "Hierarchy Level",
      "level_help": "1 = highest authority, 10 = lowest. You can only create roles with a lower level than yours.",
      "color": "Badge Color",
      "icon": "Icon",
      "preview": "Preview",
      "table": {
        "role": "Role",
        "slug": "Identifier",
        "level": "Level",
        "description": "Description",
        "type": "Type",
        "actions": "Actions"
      },
      "delete_title": "Delete Role",
      "delete_warning": "Warning",
      "users_will_lose_access": "user(s) will lose access to the system. They will be set to 'no role' until reassigned.",
      "confirm_delete": "Delete anyway"
    },
    "agenda": {
      "title": "Agenda",
      "no_branch": "No branch selected",
      "add_booking": "Add booking",
      "today": "Today",
      "today_button": "Today",
      "view": {
        "day": "Day",
        "week": "Week",
        "month": "Month"
      },
      "week": "Week",
      "month": "Month",
      "delete_all_title": "WARNING",
      "delete_all_message": "This action will delete ALL bookings for this branch. This action is irreversible.\n\nAre you sure you want to continue?",
      "delete_all_success": "All bookings have been deleted.",
      "delete_all_error": "Error deleting bookings.",
      "grids": {
        "active_games": "Active Games",
        "laser_city": "Laser City",
        "birthday_rooms": "Birthday Rooms"
      },
      "time_slot": "Time slot",
      "available": "Available",
      "occupied": "Occupied",
      "partial": "Partial",
      "search_placeholder": "Search appointment (customer name, date, time, reference)...",
      "results_found": "result(s) found",
      "no_results": "No appointments found",
      "ref": "Ref",
      "stats": {
        "with_room": "With room",
        "without_room": "Without room",
        "total_people": "Total people"
      },
      "settings": {
        "branch_title": "Branch settings",
        "grid_title": "Grid display settings",
        "refresh": "Refresh agenda",
        "open_calendar": "Open calendar",
        "previous_year": "Previous year",
        "next_year": "Next year",
        "previous_month": "Previous month",
        "next_month": "Next month",
        "previous_week": "Previous week",
        "next_week": "Next week",
        "settings_title": "Settings",
        "active_width": "ACTIVE width",
        "laser_width": "LASER width",
        "rooms_width": "ROOMS width",
        "row_height": "Row height",
        "normal": "normal",
        "reset": "Reset",
        "visible_hours": "Visible hours",
        "visible_hours_hint": "Auto-extends if booking outside range"
      },
      "grid_headers": {
        "hour": "Hour",
        "room": "Room"
      },
      "booking": {
        "no_name": "No name",
        "people": "ppl"
      },
      "months": {
        "january": "January",
        "february": "February",
        "march": "March",
        "april": "April",
        "may": "May",
        "june": "June",
        "july": "July",
        "august": "August",
        "september": "September",
        "october": "October",
        "november": "November",
        "december": "December"
      },
      "days_short": ["M", "T", "W", "T", "F", "S", "S"]
    },
    "orders": {
      "title": "Orders",
      "emails_button": "Emails",
      "search_placeholder": "Search order (name, phone, email, reference)...",
      "stats": {
        "total": "Total",
        "pending": "Pending",
        "auto_confirmed": "Auto confirmed",
        "manually_confirmed": "Manually confirmed",
        "cancelled": "Cancelled",
        "conversion_rate": "Conversion rate"
      },
      "filter": {
        "label": "Filter:",
        "all": "All",
        "pending": "Pending",
        "auto_confirmed": "Auto confirmed",
        "manually_confirmed": "Manually confirmed",
        "cancelled": "Cancelled",
        "closed": "Closed"
      },
      "status": {
        "pending": "Pending",
        "auto_confirmed": "Auto confirmed",
        "manually_confirmed": "Manually confirmed",
        "cancelled": "Cancelled",
        "closed": "Closed"
      },
      "type": {
        "game": "Game",
        "event": "Event"
      },
      "table": {
        "reference": "Reference",
        "date": "Date",
        "time": "Time",
        "customer": "Customer",
        "type": "Type",
        "players": "Players",
        "status": "Status",
        "actions": "Actions",
        "branch": "Branch",
        "created": "Created",
        "notes": "Notes",
        "zone": "Zone",
        "source": "Source"
      },
      "cgv": {
        "title": "Terms & Conditions",
        "pending": "Pending validation",
        "pending_desc": "Customer has not yet accepted the T&C",
        "validated": "T&C Accepted"
      },
      "resend_confirmation_email": "Resend confirmation email",
      "resend_confirmation_desc": "Includes the T&C validation link",
      "resend_cgv_reminder": "Send T&C reminder",
      "resend_cgv_desc": "Remind customer to accept T&C",
      "resend_cgv_success": "T&C reminder sent",
      "resend_cgv_error": "Error sending reminder",
      "actions": {
        "view": "View",
        "confirm": "Confirm",
        "cancel": "Cancel",
        "reactivate": "Reactivate",
        "delete": "Delete",
        "close": "Close"
      },
      "close_order": "Close order",
      "close_order_confirm": "Are you sure you want to close this order? This will create the invoice/receipt in iCount and cancel the quote.",
      "close_order_success": "Order closed successfully. Invoice/receipt has been created.",
      "modal": {
        "cancel_title": "Cancel order",
        "cancel_message": "Are you sure you want to cancel this order? This action is reversible.",
        "reactivate_title": "Reactivate booking",
        "reactivate_message": "You will be redirected to the agenda to check availability and confirm reactivation.",
        "delete_title": "Delete order",
        "delete_message": "Are you sure you want to delete this order? This action is irreversible.",
        "close_title": "Close order",
        "close_message": "Are you sure you want to close this order? This will create the invoice/receipt in iCount and cancel the quote.",
        "close_success": "Order closed successfully. Invoice/receipt has been created."
      },
      "no_orders": "No orders found",
      "loading_error": "Error loading orders",
      "games_plural": "games",
      "game_singular": "game",
      "order_ref": "Order",
      "reason": "Reason",
      "quick_access": "Quick access",
      "view_in_agenda": "View in agenda",
      "booking_cancelled_or_deleted": "Booking cancelled or deleted",
      "reactivate_booking": "Reactivate booking",
      "reactivate_description": "Set back to confirmed (same reference)",
      "open_booking": "Open booking",
      "client_card": "Client card",
      "view_in_crm": "View in CRM",
      "view_offer": "iCount Quote",
      "open_icount_offer": "Open quote",
      "resend_email": "Resend confirmation email",
      "resend_email_desc": "Send email again",
      "resend_email_success": "Email sent successfully",
      "resend_email_error": "Error sending email",
      "no_email_address": "No email address",
      "informations": "Information",
      "created_on": "Created on",
      "source_website": "Website",
      "branch": "Branch",
      "results": "result(s)",
      "orders_count": "order(s)",
      "no_matching_orders": "No orders match the filters"
    },
    "accounting": {
      "title": "Accounting Sheet",
      "payment_status": "Payment Status",
      "price_breakdown": "Price Breakdown",
      "description": "Description",
      "qty": "Qty",
      "unit_price": "Unit Price",
      "discount": "Discount",
      "room": "Room",
      "subtotal": "Subtotal",
      "amount_due": "Amount Due",
      "documents": "Documents",
      "not_generated": "Not generated",
      "no_price_data": "Price data not available",
      "icount_documents": "iCount Documents",
      "invoice": "Invoice",
      "status": {
        "unpaid": "Unpaid",
        "partial": "Partial Payment",
        "paid": "Paid",
        "guaranteed": "Card Guarantee"
      }
    },
    "invoice": {
      "send_invoice": "Send Invoice",
      "success_title": "Invoice Sent",
      "success": "The invoice has been sent successfully to the customer.",
      "errors": {
        "no_email": "No email address for this order",
        "not_closed": "Order must be closed to send invoice",
        "no_invoice": "No invoice available for this order",
        "send_failed": "Failed to send invoice"
      }
    },
    "payment": {
      "title": "Record Payment",
      "order_ref": "Order",
      "total": "Total",
      "already_paid": "Already Paid",
      "remaining": "Remaining",
      "method": "Payment Method",
      "method_card": "Card",
      "method_cash": "Cash",
      "method_transfer": "Transfer",
      "method_check": "Check",
      "amount": "Amount",
      "pay_full": "Full",
      "use_stored_card": "Use stored card",
      "card_number": "Card Number",
      "card_validity": "Expiry",
      "card_holder_id": "ID Number",
      "card_holder_name": "Cardholder Name",
      "check_number": "Check Number",
      "check_bank": "Bank",
      "check_date": "Check Date",
      "transfer_reference": "Transfer Reference",
      "notes": "Notes",
      "pay": "Pay",
      "processing": "Processing...",
      "success": "Payment Successful",
      "paid_successfully": "paid successfully",
      "error_generic": "Payment error",
      "add_payment": "Add Payment",
      "save_card": "Save card",
      "save_card_description": "Store this card for future payments (card imprint)",
      "mode_payment": "Pay now",
      "mode_payment_desc": "Charge immediately",
      "mode_preauth": "Card imprint",
      "mode_preauth_desc": "Pre-authorization (deposit)",
      "authorize": "Authorize",
      "use_preauth": "Use pre-authorization",
      "preauth_available": "Authorized amount",
      "preauth_available_title": "Pre-authorization available",
      "preauth_will_be_captured": "This pre-authorization will be used for payment",
      "preauth_card_only": "Pre-authorization is only available with credit card",
      "preauth_info_title": "Pre-authorization (J5)",
      "preauth_info_desc": "The client will receive an SMS validation. The amount will be reserved without being charged. You can charge it later."
    },
    "users": {
      "title": "User Management",
      "subtitle": "Manage user access and permissions",
      "create": "Create user",
      "access_denied": "Access denied",
      "access_denied_message": "You do not have the required permissions.",
      "search_placeholder": "Search by name or phone...",
      "no_branch": "No branch",
      "cannot_delete_self": "You cannot delete yourself",
      "created_by": "Created by",
      "filter": {
        "all_roles": "All roles",
        "by_role": "Filter by role",
        "all_branches": "All branches",
        "by_branch": "Filter by branch"
      },
      "table": {
        "user": "User",
        "name": "Name",
        "email": "Email",
        "phone": "Phone",
        "role": "Role",
        "branches": "Branches",
        "created": "Created",
        "created_by": "Created by",
        "actions": "Actions"
      },
      "actions": {
        "edit": "Edit",
        "delete": "Delete",
        "reset_password": "Reset password"
      },
      "modal": {
        "create_title": "Create user",
        "edit_title": "Edit user",
        "delete_title": "Delete user?",
        "delete_warning": "Irreversible action",
        "delete_message": "The user account and all access will be permanently deleted.",
        "delete_confirm": "Delete permanently",
        "first_name": "First name",
        "last_name": "Last name",
        "email": "Email",
        "phone": "Phone",
        "password": "Password",
        "password_placeholder": "Leave empty to auto-generate",
        "role": "Role",
        "branches": "Branches",
        "select_branches": "Select branches",
        "temp_password": "Temporary password",
        "copy_password": "Copy"
      },
      "no_users": "No users found",
      "loading_error": "Error loading users"
    },
    "clients": {
      "title": "Client Management",
      "search_placeholder": "Search by name, phone, email...",
      "include_archived": "Include archived",
      "advanced_filters": "Advanced filters",
      "detect_duplicates": "Detect duplicates",
      "export_csv": "Export CSV",
      "new_contact": "New contact",
      "no_contacts": "No contacts found",
      "table": {
        "name": "Name",
        "phone": "Phone",
        "email": "Email",
        "notes": "Notes",
        "source": "Source",
        "status": "Status",
        "created": "Created",
        "actions": "Actions"
      },
      "actions": {
        "view": "View details",
        "edit": "Edit",
        "archive": "Archive",
        "unarchive": "Restore"
      },
      "status": {
        "all": "All",
        "active": "Active",
        "archived": "Archived"
      },
      "source": {
        "all": "All",
        "admin_agenda": "Admin Agenda",
        "public_booking": "Public booking",
        "agenda": "Agenda",
        "public": "Public"
      },
      "reset_filters": "Reset filters",
      "pagination": "Page {{page}} of {{totalPages}} ({{total}} contact{{plural}})",
      "duplicate_not_found": "No duplicates",
      "duplicate_not_found_message": "No duplicates found in displayed contacts.",
      "archive_title": "Archive contact",
      "archive_message": "Are you sure you want to archive this contact?",
      "csv_filename": "clients_{{branch}}_{{date}}.csv",
      "contact_no_name": "Contact without name",
      "contact_details": "Contact details",
      "full_name": "Full name",
      "statistics": "Statistics",
      "stats": {
        "total_bookings": "Total bookings",
        "upcoming": "Upcoming",
        "total_participants": "Total participants",
        "games_events": "Games / Events",
        "last_activity": "Last activity"
      },
      "linked_bookings": "Linked bookings",
      "no_linked_bookings": "No bookings linked to this contact"
    },
    "booking_modal": {
      "title_new": "New booking",
      "title_edit": "Edit booking",
      "title_view": "Booking details",
      "order_number": "Order number",
      "order_number_help_edit": "Unique booking number",
      "order_number_help_new": "Will be generated automatically upon creation",
      "creating": "Creating...",
      "type_label": "Booking type",
      "branch": "Branch",
      "edit_branch": "Edit branch",
      "type": {
        "game": "Game",
        "event": "Event"
      },
      "game_area": {
        "active": "Active Games",
        "laser": "Laser",
        "custom": "Custom"
      },
      "game_area_label": "Game area",
      "game_time": "Game time",
      "start": "Start",
      "end": "End",
      "fields": {
        "date": "Date",
        "time": "Time",
        "end_time": "End time",
        "duration": "Duration",
        "duration_min": "Duration (min)",
        "players": "Number of players",
        "participants": "Participants",
        "games": "Number of games",
        "games_count": "Number of games",
        "game_number": "Game",
        "first_name": "First name",
        "last_name": "Last name",
        "phone": "Phone",
        "email": "Email",
        "notes": "Notes",
        "notes_additional": "Additional notes...",
        "color": "Color",
        "room": "Room",
        "laser_room": "Laser room",
        "alias": "Alias",
        "alias_placeholder": "E.g.: Marie, Lucas"
      },
      "event": {
        "room_title": "Event room",
        "room_start": "Room start",
        "room_end": "Room end",
        "event_notes": "Event notes",
        "event_notes_placeholder": "Notes about the event and room...",
        "game_plan": "Game plan",
        "predefined_plan": "Predefined plan",
        "custom_plan": "Custom",
        "games_2": "2 games",
        "first_game_start": "First game start time",
        "game_type": "Game area",
        "pause_after": "Pause after (min)",
        "modify_event": "Edit event"
      },
      "game": {
        "config_title": "Game configuration",
        "game_n": "Game {{n}}",
        "game_n_zone": "Game {{n}} - Game area",
        "slots_info": "{{slots}} slot(s) will be reserved ({{places}} max places)",
        "max_capacity": "Max capacity"
      },
      "laser": {
        "allocation_title": "Labyrinth allocation",
        "auto": "Auto",
        "auto_desc": "Automatic allocation",
        "petit": "Small laby",
        "petit_desc": "Small only",
        "grand": "Large laby",
        "grand_desc": "Large only",
        "maxi": "Maxi",
        "maxi_desc": "Both labyrinths",
        "single_room_notice": "Only one room available. Auto mode only.",
        "room_allocation": "Laser room (automatic allocation based on participants)",
        "default_l1": "Default: L1",
        "default_l2": "Default: L2",
        "needs_both": "Requires: L1 + L2"
      },
      "custom": {
        "config_title": "Custom configuration"
      },
      "contact": {
        "modify_client": "Edit client",
        "change_contact": "Change contact",
        "first_name_required": "First name *",
        "first_name_placeholder": "First name",
        "last_name_optional": "Last name (optional)",
        "phone_required": "Phone *",
        "phone_placeholder": "05X XXX XXXX",
        "email_placeholder": "email@example.com",
        "preferred_language": "Email language"
      },
      "colors": {
        "blue": "Blue",
        "green": "Green",
        "red": "Red",
        "orange": "Orange",
        "purple": "Purple",
        "pink": "Pink",
        "cyan": "Cyan",
        "yellow": "Yellow",
        "indigo": "Indigo",
        "emerald": "Emerald"
      },
      "actions": {
        "delete": "Delete",
        "cancel": "Cancel",
        "create": "Create booking",
        "modify": "Modify",
        "creating": "Creating...",
        "modifying": "Modifying...",
        "deleting": "Deleting...",
        "processing": "Processing...",
        "close": "Close",
        "view_order": "View order"
      },
      "modals": {
        "insufficient_capacity": "Insufficient capacity",
        "no_room_for_participants": "No room available for {{count}} participants.",
        "capacity_insufficient": "The maximum capacity of available rooms is insufficient.",
        "continue_anyway": "Do you want to continue anyway with the current room (if it exists)?",
        "continue_button": "Continue anyway",
        "no_room_available": "No room available",
        "no_room_at_period": "No room available for {{count}} participants at this time.",
        "reduce_participants": "Please reduce the number of participants or choose another time slot.",
        "lower_capacity": "Lower capacity available",
        "requested_vs_available": "You requested {{requested}} participants, but the largest available room has a capacity of {{available}} participants.",
        "exceeds_by": "This room exceeds its maximum capacity by {{count}} participants.",
        "use_this_room": "Do you want to use this room anyway?",
        "use_room_button": "Use this room",
        "duplicate_detected": "Duplicate detected",
        "duplicate_exists": "One or more contacts already exist with:",
        "create_anyway_question": "Do you want to create a new contact anyway? This contact will be created even if similar data already exists.",
        "create_anyway_button": "Create anyway",
        "overbooking_warning": "Warning: Overbooking detected",
        "destination_branch": "Destination branch",
        "unknown_branch": "Unknown branch",
        "will_create_overbooking": "This booking will create an overbooking in the destination branch:",
        "maximum": "Maximum",
        "persons_surplus": "persons in surplus",
        "slots": "slots",
        "affected_slots": "Affected time slots",
        "and_more": "... and {{count}} other slot(s)",
        "manual_auth_required": "Manual authorization required to continue.",
        "authorize_continue": "Authorize and continue",
        "confirm_delete": "Confirm deletion",
        "delete_irreversible": "Are you sure you want to permanently delete this booking? This action is irreversible.",
        "vests_limit": "Vest limit reached",
        "vests_limit_reached": "The main limit of {{max}} vests has been reached.",
        "spare_vests_available": "Are the {{spare}} spare vests available?",
        "no_cancel": "No - Cancel",
        "yes_authorize": "Yes - Authorize"
      },
      "calendar": {
        "previous_year": "Previous year",
        "next_year": "Next year",
        "previous_month": "Previous month",
        "next_month": "Next month"
      },
      "delete_title": "Delete booking",
      "delete_message": "Are you sure you want to delete this booking?",
      "save_error": "Error saving booking",
      "delete_error": "Error deleting booking",
      "conflict_error": "This time slot is no longer available",
      "validation": {
        "required_fields": "Please fill in all required fields",
        "invalid_phone": "Invalid phone number",
        "invalid_email": "Invalid email address",
        "email_required_for_event": "Email is required for events",
        "min_players": "Minimum {{min}} players required",
        "min_participants": "Number of participants must be at least 1",
        "min_duration": "Minimum duration is 15 minutes",
        "max_players": "Maximum {{max}} players allowed"
      },
      "errors": {
        "no_laser_room": "No laser room available for {{participants}} participants at {{time}}{{mode}}. Insufficient capacity. Please choose another time slot, reduce the number of participants{{modeHint}}.",
        "no_room_for_quantity": "No room available for this quantity. Please reduce the number of participants.",
        "vests_constraint": "Vest constraint violated: {{current}} > {{max}} (REJECTED). {{message}}",
        "booking_cancelled": "Booking cancelled. Please reduce the number of participants or choose another time slot.",
        "create_error": "Error creating booking",
        "generic_error": "An error occurred"
      }
    },
    "settings_modal": {
      "title": "Settings",
      "tabs": {
        "general": "General",
        "active": "Active Games",
        "laser": "Laser",
        "rooms": "Birthday Rooms",
        "pricing": "Pricing",
        "hours": "Opening Hours",
        "capacity": "Capacity",
        "notifications": "Notifications"
      },
      "general": {
        "branch_name": "Branch name",
        "phone": "Phone",
        "email": "Email",
        "address": "Address",
        "opening_hours": "Opening hours"
      },
      "active": {
        "title": "Active Games Settings",
        "players_per_slot": "Players per slot",
        "total_slots": "Total slots",
        "max_concurrent": "Max concurrent players",
        "game_duration": "Game duration (min)"
      },
      "laser": {
        "title": "Laser City Settings",
        "enabled": "Enable Laser City",
        "total_vests": "Total vests",
        "exclusive_threshold": "Exclusive room threshold",
        "rooms": "Laser Rooms",
        "add_room": "Add room",
        "room_name": "Room name",
        "room_capacity": "Capacity"
      },
      "rooms": {
        "title": "Birthday Rooms",
        "add_room": "Add room",
        "room_name": "Room name",
        "room_capacity": "Capacity"
      },
      "display": {
        "title": "Display",
        "text_size": "Text size",
        "text_weight": "Text weight",
        "size_xs": "Extra small",
        "size_sm": "Small",
        "size_base": "Normal",
        "size_lg": "Large",
        "weight_normal": "Normal",
        "weight_semibold": "Semi-bold",
        "weight_bold": "Bold"
      },
      "success": "Settings saved successfully",
      "error": "Error saving settings",
      "hours": {
        "title": "Opening Hours",
        "day": "Day",
        "open": "Open",
        "close": "Close",
        "closed": "Closed",
        "days": {
          "sunday": "Sunday",
          "monday": "Monday",
          "tuesday": "Tuesday",
          "wednesday": "Wednesday",
          "thursday": "Thursday",
          "friday": "Friday",
          "saturday": "Saturday"
        }
      },
      "capacity": {
        "title": "Capacity Settings",
        "max_concurrent_players": "Max concurrent players",
        "slot_duration": "Slot duration (minutes)",
        "game_duration": "Game duration (minutes)",
        "buffer_time": "Buffer time (minutes)"
      },
      "notifications": {
        "title": "Notification Settings",
        "email_notifications": "Email notifications",
        "sms_notifications": "SMS notifications",
        "booking_confirmation": "Booking confirmation",
        "booking_reminder": "Booking reminder",
        "booking_cancellation": "Booking cancellation"
      }
    },
    "contact_modal": {
      "title": "Contact details",
      "title_new": "New contact",
      "title_edit": "Edit contact",
      "title_view": "Contact details",
      "edit_title": "Edit contact",
      "create_title": "New contact",
      "full_name": "Full name",
      "phone": "Phone",
      "email": "Email",
      "notes": "Client notes",
      "fields": {
        "first_name": "First name",
        "last_name": "Last name",
        "phone": "Phone",
        "email": "Email",
        "notes": "Notes",
        "source": "Source"
      },
      "statistics": {
        "title": "Statistics",
        "total_bookings": "Total bookings",
        "upcoming_bookings": "Upcoming",
        "total_participants": "Total participants",
        "last_visit": "Last visit",
        "first_visit": "First visit"
      },
      "history": {
        "title": "Booking history",
        "no_bookings": "No bookings",
        "total_bookings": "Total bookings",
        "total_participants": "Total participants",
        "last_visit": "Last visit"
      },
      "validation": {
        "required_first_name": "First name is required",
        "required_phone": "Phone is required",
        "invalid_phone": "Invalid phone number",
        "invalid_email": "Invalid email",
        "phone_exists": "This phone number already exists"
      }
    },
    "confirmation_modal": {
      "confirm": "Confirm",
      "cancel": "Cancel"
    },
    "errors": {
      "loading": "Error loading data",
      "saving": "Error saving",
      "deleting": "Error deleting",
      "network": "A network error occurred",
      "unauthorized": "You must be logged in to perform this action",
      "noProfile": "User profile not found",
      "not_found": "Item not found",
      "generic": "An error occurred",
      "branchAccessDenied": "You don't have access to this branch",
      "orderNotFound": "Order not found",
      "contactNotFound": "Contact not found",
      "fetchFailed": "Failed to fetch data",
      "updateFailed": "Failed to update",
      "deleteFailed": "Failed to delete",
      "cancelFailed": "Failed to cancel",
      "archiveFailed": "Failed to archive",
      "reactivateFailed": "Failed to reactivate",
      "createBookingFailed": "Failed to create booking",
      "directConfirmDisabled": "Direct confirmation disabled. Please use the Reactivate button.",
      "orderNotCancelled": "This order is not cancelled",
      "invalidAction": "Invalid action",
      "cannotCancelClosedOrder": "Cannot cancel a closed order",
      "cannotCancelOrderWithInvoice": "Cannot cancel an order with an invoice. Please contact accounting.",
      "orderClosed": "Cannot modify a closed order",
      "internalError": "An internal error occurred",
      "permission": {
        "denied": "Permission denied",
        "view": {
          "orders": "You don't have permission to view orders",
          "clients": "You don't have permission to view contacts",
          "agenda": "You don't have permission to view the agenda",
          "users": "You don't have permission to view users",
          "logs": "You don't have permission to view logs",
          "settings": "You don't have permission to view settings",
          "permissions": "You don't have permission to view permissions"
        },
        "create": {
          "orders": "You don't have permission to create orders",
          "clients": "You don't have permission to create contacts",
          "agenda": "You don't have permission to create bookings",
          "users": "You don't have permission to create users"
        },
        "edit": {
          "orders": "You don't have permission to edit orders",
          "clients": "You don't have permission to edit contacts",
          "agenda": "You don't have permission to edit bookings",
          "users": "You don't have permission to edit users",
          "settings": "You don't have permission to edit settings"
        },
        "delete": {
          "orders": "You don't have permission to delete orders",
          "clients": "You don't have permission to delete contacts",
          "agenda": "You don't have permission to delete bookings",
          "users": "You don't have permission to delete users",
          "logs": "You don't have permission to delete logs"
        }
      }
    },
    "validation": {
      "required": "This field is required",
      "email": "Please enter a valid email address",
      "email_invalid": "Invalid email address",
      "phone": "Please enter a valid phone number",
      "phone_invalid": "Invalid phone number (format: 05XXXXXXXX)",
      "min_length": "Must be at least {{min}} characters",
      "max_length": "Must be at most {{max}} characters",
      "min_value": "Must be at least {{min}}",
      "max_value": "Must be at most {{max}}",
      "date_past": "Date must be in the future",
      "date_future": "Date must be in the past",
      "passwords_match": "Passwords must match"
    },
    "notifications": {
      "booking_created": "Booking created successfully",
      "booking_updated": "Booking updated successfully",
      "booking_deleted": "Booking deleted successfully",
      "booking_confirmed": "Booking confirmed successfully",
      "booking_cancelled": "Booking cancelled successfully",
      "contact_created": "Contact created successfully",
      "contact_updated": "Contact updated successfully",
      "contact_deleted": "Contact deleted successfully",
      "user_created": "User created successfully",
      "user_updated": "User updated successfully",
      "user_deleted": "User deleted successfully",
      "settings_saved": "Settings saved successfully",
      "order_confirmed": "Order confirmed",
      "order_rejected": "Order rejected"
    },
    "time": {
      "just_now": "Just now",
      "minutes_ago": "{{count}} minutes ago",
      "hours_ago": "{{count}} hours ago",
      "days_ago": "{{count}} days ago",
      "weeks_ago": "{{count}} weeks ago"
    },
    "pagination": {
      "page": "Page",
      "of": "of",
      "items_per_page": "Items per page",
      "showing": "Showing",
      "to": "to",
      "entries": "entries"
    },
    "logs": {
      "title": "Activity Logs",
      "subtitle": "Track all system activity and user actions",
      "access_denied": "Access denied",
      "access_denied_message": "You do not have permission to view activity logs.",
      "search_placeholder": "Search logs (user, action, target)...",
      "no_logs": "No activity logs found",
      "no_matching_logs": "No logs match the current filters",
      "results": "result(s)",
      "logs_count": "log(s)",
      "delete_confirm": "Are you sure you want to delete {{count}} log(s)? This action is irreversible.",
      "delete_selected": "Delete ({{count}})",
      "stats": {
        "today": "Today",
        "this_week": "This week",
        "total": "Total"
      },
      "table": {
        "timestamp": "Timestamp",
        "action": "Action",
        "user": "User",
        "role": "Role",
        "target": "Target",
        "details": "Details",
        "branch": "Branch"
      },
      "actions": {
        "booking_created": "Booking created",
        "booking_updated": "Booking updated",
        "booking_cancelled": "Booking cancelled",
        "booking_deleted": "Booking deleted",
        "order_created": "Order created",
        "order_confirmed": "Order confirmed",
        "order_cancelled": "Order cancelled",
        "order_deleted": "Order deleted",
        "contact_created": "Contact created",
        "contact_updated": "Contact updated",
        "contact_archived": "Contact archived",
        "contact_deleted": "Contact deleted",
        "user_created": "User created",
        "user_updated": "User updated",
        "user_deleted": "User deleted",
        "user_login": "User login",
        "user_logout": "User logout",
        "permission_changed": "Permission changed",
        "settings_updated": "Settings updated",
        "log_deleted": "Log deleted",
        "email_sent": "Email sent"
      },
      "targets": {
        "booking": "Booking",
        "order": "Order",
        "contact": "Contact",
        "email": "Email",
        "user": "User",
        "branch": "Branch",
        "settings": "Settings",
        "log": "Log"
      }
    },
    "emails": {
      "title": "Email History",
      "subtitle": "View and manage sent emails",
      "access_denied": "Access Denied",
      "access_denied_message": "Only super administrators can access this page.",
      "no_emails": "No emails sent",
      "search_placeholder": "Search by email, subject...",
      "resend": "Resend",
      "delete": "Delete",
      "delete_confirm": "Are you sure you want to delete this email?",
      "view_details": "View details",
      "details_title": "Email Details",
      "preview": "Preview",
      "error": "Error",
      "created_at": "Created at",
      "sent_at": "Sent at",
      "resend_success": "Email resent successfully",
      "resend_error": "Error resending email",
      "delete_success": "Email deleted successfully",
      "delete_error": "Error deleting email",
      "filter": {
        "all_status": "All statuses",
        "more": "More filters"
      },
      "stats": {
        "total": "Total",
        "sent": "Sent",
        "failed": "Failed",
        "pending": "Pending"
      },
      "status": {
        "sent": "Sent",
        "delivered": "Delivered",
        "failed": "Failed",
        "bounced": "Bounced",
        "pending": "Pending"
      },
      "table": {
        "status": "Status",
        "recipient": "Recipient",
        "subject": "Subject",
        "date": "Date",
        "actions": "Actions",
        "sent_at": "Sent at"
      },
      "pagination": {
        "showing": "Showing {{from}} to {{to}} of {{total}}"
      },
      "check_status": "Check Status",
      "checking": "Checking..."
    },
    "settings": {
      "title": "Settings",
      "subtitle": "Configure system settings",
      "access_denied": "Access Denied",
      "access_denied_message": "Only super administrators can access settings.",
      "sections": {
        "templates": "Templates",
        "templates_desc": "Emails & Terms",
        "credentials": "Payment Credentials",
        "credentials_desc": "iCount API settings per branch"
      },
      "templates_tabs": {
        "emails": "Email Templates",
        "terms": "Terms & Conditions"
      },
      "email_templates": {
        "title": "Email Templates",
        "subtitle": "Manage email templates for automatic notifications",
        "no_templates": "No templates",
        "create": "Create template",
        "create_title": "New template",
        "edit": "Edit",
        "edit_title": "Edit template",
        "delete": "Delete",
        "delete_confirm": "Are you sure you want to delete the template \"{{name}}\"?",
        "system": "System",
        "system_template": "System template",
        "system_template_info": "This template is used by the system and cannot be deleted",
        "cannot_delete_system": "System templates cannot be deleted",
        "active": "Active",
        "inactive": "Inactive",
        "activate": "Activate",
        "deactivate": "Deactivate",
        "preview": "Preview",
        "toggle_error": "Error changing status",
        "save_success": "Template saved successfully",
        "save_error": "Error saving template",
        "delete_success": "Template deleted successfully",
        "delete_error": "Error deleting template",
        "form": {
          "name": "Template name",
          "code": "Code (unique identifier)",
          "code_help": "Unique identifier for the template (lowercase letters, numbers and underscores)",
          "description": "Description",
          "subject": "Email subject",
          "body": "HTML content",
          "active": "Template active",
          "is_active": "Template active",
          "variables_help": "Available variables: {{booking_reference}}, {{booking_date}}, {{booking_time}}, {{participants}}, {{branch_name}}, {{branch_address}}, {{branch_phone}}, {{client_name}}, {{client_email}}"
        }
      },
      "terms": {
        "title": "Terms & Conditions",
        "subtitle": "Manage terms and conditions shown during online booking",
        "type_game": "Games",
        "type_event": "Events",
        "desc_game": "General conditions for game bookings: participation rules, safety, cancellation policy.",
        "desc_event": "Conditions for events: room rules, food service, allergies, cancellation policy.",
        "not_configured": "Not configured",
        "run_migration": "Run SQL migration",
        "edit_title": "Edit Terms",
        "content": "Content",
        "fetch_error": "Error loading terms templates",
        "save_error": "Error saving template",
        "toggle_error": "Error changing status",
        "usage_title": "How these templates are used",
        "usage_desc": "These terms are displayed when customers check the \"I accept the terms and conditions\" box during online booking, and are included at the bottom of confirmation emails."
      }
    },
    "permissions": {
      "title": "Permissions Management",
      "subtitle": "Configure access rights for each role",
      "access_denied": "Access denied",
      "access_denied_message": "Only super administrators can manage permissions.",
      "info_title": "Granular Permission Control",
      "info_description": "Super Admin permissions are locked and cannot be modified. Branch Admin and Agent permissions can be customized. Changes take effect immediately.",
      "no_roles": "No roles defined",
      "super_admin_locked": "Super Admin permissions cannot be modified",
      "locked": "Locked",
      "all_permissions_locked": "All permissions locked",
      "role_description_super_admin": "Full access to all features. Permissions cannot be modified.",
      "role_description_branch_admin": "Branch administration. Permissions can be customized.",
      "role_description_agent": "Agent with limited access. Permissions can be customized.",
      "table": {
        "resource": "Resource",
        "role": "Role",
        "can_view": "View",
        "can_create": "Create",
        "can_edit": "Edit",
        "can_delete": "Delete"
      },
      "save": "Save",
      "save_success": "Permissions saved successfully",
      "save_error": "Error saving permissions",
      "legend_title": "Role Legend",
      "legend_super_admin": "Full access (locked)",
      "legend_branch_admin": "Customizable",
      "legend_agent": "Customizable",
      "legend_locked": "Cannot be modified",
      "resources": {
        "agenda": "Agenda",
        "orders": "Orders",
        "clients": "Clients",
        "users": "Users",
        "logs": "Activity Logs",
        "settings": "Settings",
        "permissions": "Permissions"
      }
    },
    "icount_catalog": {
      "title": "iCount Catalog",
      "subtitle": "Products and formulas for {{branch}}",
      "tabs": {
        "products": "GAME Products",
        "rooms": "Rooms",
        "formulas": "EVENT Formulas"
      },
      "products": {
        "add": "Add product",
        "edit": "Edit product",
        "new": "New product",
        "code": "Code",
        "name_fr": "Name (FR)",
        "name_he": "Name (HE)",
        "name_en": "Name (EN)",
        "price_per_person": "Price/person",
        "order": "Order",
        "active": "Active",
        "status": "Status",
        "actions": "Actions",
        "none": "No products"
      },
      "rooms": {
        "add": "Add room",
        "edit": "Edit room",
        "new": "New room",
        "code": "Code",
        "name_fr": "Name (FR)",
        "name_he": "Name (HE)",
        "name_en": "Name (EN)",
        "price": "Price",
        "free": "Free",
        "order": "Order",
        "active": "Active",
        "status": "Status",
        "actions": "Actions",
        "none": "No rooms"
      },
      "formulas": {
        "add": "Add EVENT formula",
        "edit": "Edit formula",
        "new": "New EVENT formula",
        "name": "Name",
        "game_type": "Game type",
        "participants": "Participants",
        "min_participants": "Min participants",
        "max_participants": "Max participants",
        "price_per_person": "Price/person",
        "room": "Room",
        "no_room": "No room",
        "priority": "Priority",
        "active": "Active",
        "status": "Status",
        "actions": "Actions",
        "none": "No EVENT formulas",
        "calculation": "EVENT calculation: (Participants × Price/person) + Room price",
        "priority_info": "The formula with the highest priority matching the number of participants will be used."
      },
      "sync": {
        "button": "Sync with iCount",
        "syncing": "Syncing...",
        "success": "Sync: {{synced}} product(s) synced",
        "success_with_failures": "Sync: {{synced}} product(s) synced, {{failed}} failure(s)",
        "no_products": "No active products to sync"
      },
      "status": {
        "active": "Active",
        "inactive": "Inactive"
      },
      "game_types": {
        "laser": "Laser",
        "active": "Active",
        "both": "Laser + Active"
      },
      "save": "Save",
      "cancel": "Cancel",
      "delete_confirm": "Do you want to deactivate this item?",
      "element_deactivated": "Item deactivated",
      "error_loading": "Error loading data",
      "error_delete": "Error during deletion"
    }
  }
}
</file>

</files>
